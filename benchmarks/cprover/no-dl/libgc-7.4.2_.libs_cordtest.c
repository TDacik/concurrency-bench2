// #anon_enum$AO_BYTE_TS_clear=0$AO_BYTE_TS_set=255
// file /usr/include/atomic_ops/sysdeps/test_and_set_t_is_char.h line 30
enum anonymous$15 { AO_BYTE_TS_clear=0, AO_BYTE_TS_set=255 };

// #anon_enum$RT_CONSISTENT=0$RT_ADD=1$RT_DELETE=2
// file /usr/include/link.h line 54
enum anonymous$33 { RT_CONSISTENT=0, RT_ADD=1, RT_DELETE=2 };

// tag-#anon#ST[*{SYM#tag-#anon#ST[*{SYM#tag-_IO_FILE#}$SYM#tag-_IO_FILE#$'lf_file'|U64'lf_current'|ARR32{v*{SYM#tag-#anon#ST[U64'tag'|ARR512{S8}$S8$'data']#}$SYM#tag-#anon#ST[U64'tag'|ARR512{S8}$S8$'data']#$}$v*{SYM#tag-#anon#ST[U64'tag'|ARR512{S8}$S8$'data']#}$SYM#tag-#anon#ST[U64'tag'|ARR512{S8}$S8$'data']#$$'lf_cache']#}$SYM#tag-#anon#ST[*{SYM#tag-_IO_FILE#}$SYM#tag-_IO_FILE#$'lf_file'|U64'lf_current'|ARR32{v*{SYM#tag-#anon#ST[U64'tag'|ARR512{S8}$S8$'data']#}$SYM#tag-#anon#ST[U64'tag'|ARR512{S8}$S8$'data']#$}$v*{SYM#tag-#anon#ST[U64'tag'|ARR512{S8}$S8$'data']#}$SYM#tag-#anon#ST[U64'tag'|ARR512{S8}$S8$'data']#$$'lf_cache']#$'state'|U64'file_pos'|*{SYM#tag-#anon#ST[U64'tag'|ARR512{S8}$S8$'data']#}$SYM#tag-#anon#ST[U64'tag'|ARR512{S8}$S8$'data']#$'new_cache']
// file cord/cordxtra.c line 515
struct anonymous$4;

// tag-#anon#ST[*{SYM#tag-_IO_FILE#}$SYM#tag-_IO_FILE#$'lf_file'|U64'lf_current'|ARR32{v*{SYM#tag-#anon#ST[U64'tag'|ARR512{S8}$S8$'data']#}$SYM#tag-#anon#ST[U64'tag'|ARR512{S8}$S8$'data']#$}$v*{SYM#tag-#anon#ST[U64'tag'|ARR512{S8}$S8$'data']#}$SYM#tag-#anon#ST[U64'tag'|ARR512{S8}$S8$'data']#$$'lf_cache']
// file cord/cordxtra.c line 503
struct anonymous$2;

// tag-#anon#ST[*{V}$V$'_call_addr'|S32'_syscall'|U32'_arch']
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 126
struct anonymous$31;

// tag-#anon#ST[*{V}$V$'_lower'|*{V}$V$'_upper']
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 111
struct anonymous$32;

// tag-#anon#ST[*{V}$V$'si_addr'|S16'si_addr_lsb'|U48'$pad0'|SYM#tag-#anon#ST[*{V}$V$'_lower'|*{V}$V$'_upper']#'si_addr_bnd']
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 107
struct anonymous$16;

// tag-#anon#ST[*{cS8}$cS8$'c'|U64'len']
// file cord/cordbscs.c line 584
struct anonymous$0;

// tag-#anon#ST[*{cS8}$cS8$'oh_string'|U64'oh_int'|U64'oh_sz'|U64'oh_sf']
// file ./include/private/dbg_mlc.h line 57
struct anonymous$17;

// tag-#anon#ST[ARR16{U64}$U64$'__val']
// file /usr/include/x86_64-linux-gnu/bits/sigset.h line 27
struct anonymous$6;

// tag-#anon#ST[ARR16{U8}$U8$'e_ident'|U16'e_type'|U16'e_machine'|U32'e_version'|U64'e_entry'|U64'e_phoff'|U64'e_shoff'|U32'e_flags'|U16'e_ehsize'|U16'e_phentsize'|U16'e_phnum'|U16'e_shentsize'|U16'e_shnum'|U16'e_shstrndx']
// file /usr/include/elf.h line 85
struct anonymous$23;

// tag-#anon#ST[ARR1{SYM#tag-#anon#ST[ARR8{S64}$S64$'__cancel_jmp_buf'|S32'__mask_was_saved'|U32'$pad0']#}$SYM#tag-#anon#ST[ARR8{S64}$S64$'__cancel_jmp_buf'|S32'__mask_was_saved'|U32'$pad0']#$'__cancel_jmp_buf'|ARR4{*{V}$V$}$*{V}$V$$'__pad']
// file /usr/include/pthread.h line 523
struct anonymous$24;

// tag-#anon#ST[ARR23{S64}$S64$'gregs'|*{SYM#tag-_libc_fpstate#}$SYM#tag-_libc_fpstate#$'fpregs'|ARR8{U64}$U64$'__reserved1']
// file /usr/include/x86_64-linux-gnu/sys/ucontext.h line 124
struct anonymous$18;

// tag-#anon#ST[ARR8{S64}$S64$'__cancel_jmp_buf'|S32'__mask_was_saved'|U32'$pad0']
// file /usr/include/pthread.h line 525
struct anonymous$25;

// tag-#anon#ST[S32'__lock'|U32'__futex'|U64'__total_seq'|U64'__wakeup_seq'|U64'__woken_seq'|*{V}$V$'__mutex'|U32'__nwaiters'|U32'__broadcast_seq']
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 141
struct anonymous$9;

// tag-#anon#ST[S32'si_pid'|U32'si_uid']
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 74
struct anonymous$26;

// tag-#anon#ST[S32'si_pid'|U32'si_uid'|S32'si_status'|U32'$pad0'|S64'si_utime'|S64'si_stime']
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 97
struct anonymous$29;

// tag-#anon#ST[S32'si_pid'|U32'si_uid'|SYM#tag-sigval#'si_sigval']
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 89
struct anonymous$28;

// tag-#anon#ST[S32'si_signo'|S32'si_errno'|S32'si_code'|U32'$pad0'|SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid']#'_kill'|SYM#tag-#anon#ST[S32'si_tid'|S32'si_overrun'|SYM#tag-sigval#'si_sigval']#'_timer'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|SYM#tag-sigval#'si_sigval']#'_rt'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|S32'si_status'|U32'$pad0'|S64'si_utime'|S64'si_stime']#'_sigchld'|SYM#tag-#anon#ST[*{V}$V$'si_addr'|S16'si_addr_lsb'|U48'$pad0'|SYM#tag-#anon#ST[*{V}$V$'_lower'|*{V}$V$'_upper']#'si_addr_bnd']#'_sigfault'|SYM#tag-#anon#ST[S64'si_band'|S32'si_fd'|U32'$pad0']#'_sigpoll'|SYM#tag-#anon#ST[*{V}$V$'_call_addr'|S32'_syscall'|U32'_arch']#'_sigsys']#'_sifields']
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 62
struct anonymous$13;

// tag-#anon#ST[S32'si_tid'|S32'si_overrun'|SYM#tag-sigval#'si_sigval']
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 81
struct anonymous$27;

// tag-#anon#ST[S64'd_tag'|SYM#tag-#anon#UN[U64'd_val'|U64'd_ptr']#'d_un']
// file /usr/include/elf.h line 688
struct anonymous$21;

// tag-#anon#ST[S64'si_band'|S32'si_fd'|U32'$pad0']
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 119
struct anonymous$30;

// tag-#anon#ST[U32'p_type'|U32'p_flags'|U64'p_offset'|U64'p_vaddr'|U64'p_paddr'|U64'p_filesz'|U64'p_memsz'|U64'p_align']
// file /usr/include/elf.h line 579
struct anonymous$20;

// tag-#anon#ST[U64'ed_bitmap'|S32'ed_continued'|U32'$pad0']
// file typd_mlc.c line 57
struct anonymous$19;

// tag-#anon#ST[U64'len'|U64'count'|*{S8}$S8$'buf']
// file cord/cordxtra.c line 99
struct anonymous$5;

// tag-#anon#ST[U64'pos'|S8'target'|U56'$pad0']
// file cord/cordxtra.c line 302
struct anonymous$1;

// tag-#anon#ST[U64'tag'|ARR512{S8}$S8$'data']
// file cord/cordxtra.c line 497
struct anonymous$3;

// tag-#anon#UN[*{V(S32)->V}$V(S32)->V$'sa_handler'|*{V(S32|*{SYM#tag-#anon#ST[S32'si_signo'|S32'si_errno'|S32'si_code'|U32'$pad0'|SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid']#'_kill'|SYM#tag-#anon#ST[S32'si_tid'|S32'si_overrun'|SYM#tag-sigval#'si_sigval']#'_timer'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|SYM#tag-sigval#'si_sigval']#'_rt'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|S32'si_status'|U32'$pad0'|S64'si_utime'|S64'si_stime']#'_sigchld'|SYM#tag-#anon#ST[*{V}$V$'si_addr'|S16'si_addr_lsb'|U48'$pad0'|SYM#tag-#anon#ST[*{V}$V$'_lower'|*{V}$V$'_upper']#'si_addr_bnd']#'_sigfault'|SYM#tag-#anon#ST[S64'si_band'|S32'si_fd'|U32'$pad0']#'_sigpoll'|SYM#tag-#anon#ST[*{V}$V$'_call_addr'|S32'_syscall'|U32'_arch']#'_sigsys']#'_sifields']#}$SYM#tag-#anon#ST[S32'si_signo'|S32'si_errno'|S32'si_code'|U32'$pad0'|SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid']#'_kill'|SYM#tag-#anon#ST[S32'si_tid'|S32'si_overrun'|SYM#tag-sigval#'si_sigval']#'_timer'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|SYM#tag-sigval#'si_sigval']#'_rt'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|S32'si_status'|U32'$pad0'|S64'si_utime'|S64'si_stime']#'_sigchld'|SYM#tag-#anon#ST[*{V}$V$'si_addr'|S16'si_addr_lsb'|U48'$pad0'|SYM#tag-#anon#ST[*{V}$V$'_lower'|*{V}$V$'_upper']#'si_addr_bnd']#'_sigfault'|SYM#tag-#anon#ST[S64'si_band'|S32'si_fd'|U32'$pad0']#'_sigpoll'|SYM#tag-#anon#ST[*{V}$V$'_call_addr'|S32'_syscall'|U32'_arch']#'_sigsys']#'_sifields']#$|*{V}$V$)->V}$V(S32|*{SYM#tag-#anon#ST[S32'si_signo'|S32'si_errno'|S32'si_code'|U32'$pad0'|SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid']#'_kill'|SYM#tag-#anon#ST[S32'si_tid'|S32'si_overrun'|SYM#tag-sigval#'si_sigval']#'_timer'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|SYM#tag-sigval#'si_sigval']#'_rt'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|S32'si_status'|U32'$pad0'|S64'si_utime'|S64'si_stime']#'_sigchld'|SYM#tag-#anon#ST[*{V}$V$'si_addr'|S16'si_addr_lsb'|U48'$pad0'|SYM#tag-#anon#ST[*{V}$V$'_lower'|*{V}$V$'_upper']#'si_addr_bnd']#'_sigfault'|SYM#tag-#anon#ST[S64'si_band'|S32'si_fd'|U32'$pad0']#'_sigpoll'|SYM#tag-#anon#ST[*{V}$V$'_call_addr'|S32'_syscall'|U32'_arch']#'_sigsys']#'_sifields']#}$SYM#tag-#anon#ST[S32'si_signo'|S32'si_errno'|S32'si_code'|U32'$pad0'|SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid']#'_kill'|SYM#tag-#anon#ST[S32'si_tid'|S32'si_overrun'|SYM#tag-sigval#'si_sigval']#'_timer'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|SYM#tag-sigval#'si_sigval']#'_rt'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|S32'si_status'|U32'$pad0'|S64'si_utime'|S64'si_stime']#'_sigchld'|SYM#tag-#anon#ST[*{V}$V$'si_addr'|S16'si_addr_lsb'|U48'$pad0'|SYM#tag-#anon#ST[*{V}$V$'_lower'|*{V}$V$'_upper']#'si_addr_bnd']#'_sigfault'|SYM#tag-#anon#ST[S64'si_band'|S32'si_fd'|U32'$pad0']#'_sigpoll'|SYM#tag-#anon#ST[*{V}$V$'_call_addr'|S32'_syscall'|U32'_arch']#'_sigsys']#'_sifields']#$|*{V}$V$)->V$'sa_sigaction']
// file /usr/include/x86_64-linux-gnu/bits/sigaction.h line 28
union anonymous$11;

// tag-#anon#UN[ARR257{S8}$S8$'_hb_marks'|U64'dummy'|U2112'$pad']
// file ./include/private/gc_priv.h line 959
union anonymous$14;

// tag-#anon#UN[ARR28{S32}$S32$'_pad'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid']#'_kill'|SYM#tag-#anon#ST[S32'si_tid'|S32'si_overrun'|SYM#tag-sigval#'si_sigval']#'_timer'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|SYM#tag-sigval#'si_sigval']#'_rt'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|S32'si_status'|U32'$pad0'|S64'si_utime'|S64'si_stime']#'_sigchld'|SYM#tag-#anon#ST[*{V}$V$'si_addr'|S16'si_addr_lsb'|U48'$pad0'|SYM#tag-#anon#ST[*{V}$V$'_lower'|*{V}$V$'_upper']#'si_addr_bnd']#'_sigfault'|SYM#tag-#anon#ST[S64'si_band'|S32'si_fd'|U32'$pad0']#'_sigpoll'|SYM#tag-#anon#ST[*{V}$V$'_call_addr'|S32'_syscall'|U32'_arch']#'_sigsys']
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 69
union anonymous$12;

// tag-#anon#UN[ARR32{S8}$S8$'__size'|S64'__align']
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 239
union anonymous$8;

// tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'|U32'__futex'|U64'__total_seq'|U64'__wakeup_seq'|U64'__woken_seq'|*{V}$V$'__mutex'|U32'__nwaiters'|U32'__broadcast_seq']#'__data'|ARR48{S8}$S8$'__size'|S64'__align']
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 139
union anonymous$10;

// tag-#anon#UN[SYM#tag-Concatenation#'concatenation'|SYM#tag-Function#'function'|SYM#tag-Generic#'generic'|ARR1{S8}$S8$'string']
// file cord/cordbscs.c line 45
union anonymous;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'|ARR40{S8}$S8$'__size'|S64'__align']
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous$7;

// tag-#anon#UN[U64'd_val'|U64'd_ptr']
// file /usr/include/elf.h line 691
union anonymous$22;

// tag-CORD_Pos
// file ./include/cord_pos.h line 34
struct CORD_Pos;

// tag-CORD_ec_struct
// file ./include/ec.h line 37
struct CORD_ec_struct;

// tag-CORD_pe
// file ./include/cord_pos.h line 27
struct CORD_pe;

// tag-ComplexArrayDescriptor
// file typd_mlc.c line 76
struct ComplexArrayDescriptor;

// tag-ComplexDescriptor
// file typd_mlc.c line 66
union ComplexDescriptor;

// tag-Concatenation
// file cord/cordbscs.c line 46
struct Concatenation;

// tag-Function
// file cord/cordbscs.c line 58
struct Function;

// tag-GC_Thread_Rep
// file ./include/private/pthread_support.h line 42
struct GC_Thread_Rep;

// tag-GC_finalizer_closure
// file ./include/gc_disclaim.h line 42
struct GC_finalizer_closure;

// tag-GC_ms_entry
// file ./include/private/../gc_mark.h line 61
struct GC_ms_entry;

// tag-GC_prof_stats_s
// file ./include/private/../gc.h line 629
struct GC_prof_stats_s;

// tag-GC_stack_base
// file ./include/private/../gc.h line 1214
struct GC_stack_base;

// tag-GC_traced_stack_sect_s
// file ./include/private/gc_priv.h line 1454
struct GC_traced_stack_sect_s;

// tag-Generic
// file cord/cordbscs.c line 67
struct Generic;

// tag-HeapSect
// file ./include/private/gc_priv.h line 1238
struct HeapSect;

// tag-LeafDescriptor
// file typd_mlc.c line 67
struct LeafDescriptor;

// tag-Print_stats
// file reclaim.c line 464
struct Print_stats;

// tag-SequenceDescriptor
// file typd_mlc.c line 82
struct SequenceDescriptor;

// tag-_GC_arrays
// file ./include/private/gc_priv.h line 1092
struct _GC_arrays;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 156
struct _IO_marker;

// tag-__jmp_buf_tag
// file /usr/include/pthread.h line 742
struct __jmp_buf_tag;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-_libc_fpstate
// file /usr/include/x86_64-linux-gnu/sys/ucontext.h line 104
struct _libc_fpstate;

// tag-_libc_fpxreg
// file /usr/include/x86_64-linux-gnu/sys/ucontext.h line 92
struct _libc_fpxreg;

// tag-_libc_xmmreg
// file /usr/include/x86_64-linux-gnu/sys/ucontext.h line 99
struct _libc_xmmreg;

// tag-bi
// file ./include/private/gc_hdrs.h line 118
struct bi;

// tag-blocking_data
// file ./include/private/gc_priv.h line 1448
struct blocking_data;

// tag-closure
// file dbg_mlc.c line 1042
struct closure;

// tag-disappearing_link
// file finalize.c line 36
struct disappearing_link;

// tag-dl_hashtbl_s
// file finalize.c line 46
struct dl_hashtbl_s;

// tag-dl_phdr_info
// file /usr/include/link.h line 138
struct dl_phdr_info;

// tag-exclusion
// file ./include/private/gc_priv.h line 1021
struct exclusion;

// tag-finalizable_object
// file finalize.c line 58
struct finalizable_object;

// tag-hash_chain_entry
// file finalize.c line 31
struct hash_chain_entry;

// tag-hblk
// file ./include/private/gcconfig.h line 2922
struct hblk;

// tag-hblkhdr
// file ./include/private/gc_hdrs.h line 18
struct hblkhdr;

// tag-hce
// file ./include/private/gc_hdrs.h line 71
struct hce;

// tag-link_map
// file /usr/include/link.h line 46
struct link_map;

// tag-load_segment
// file dyn_load.c line 457
struct load_segment;

// tag-obj_kind
// file ./include/private/gc_priv.h line 1321
struct obj_kind;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-r_debug
// file /usr/include/link.h line 42
struct r_debug;

// tag-roots
// file ./include/private/gc_priv.h line 1030
struct roots;

// tag-sigaction
// file /usr/include/x86_64-linux-gnu/bits/sigaction.h line 24
struct sigaction;

// tag-sigaltstack
// file /usr/include/x86_64-linux-gnu/bits/sigstack.h line 49
struct sigaltstack;

// tag-sigval
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 32
union sigval;

// tag-start_info
// file pthread_support.c line 1592
struct start_info;

// tag-substr_args
// file cord/cordbscs.c line 324
struct substr_args;

// tag-thread_local_freelists
// file ./include/private/thread_local_alloc.h line 79
struct thread_local_freelists;

// tag-thread_stop_info
// file ./include/private/pthread_stop_world.h line 21
struct thread_stop_info;

// tag-ucontext
// file /usr/include/x86_64-linux-gnu/sys/ucontext.h line 133
struct ucontext;

// tag-word_ptr_ao_u
// file ./include/private/gc_priv.h line 865
union word_ptr_ao_u;

#include <assert.h>
#include <stdarg.h>

#ifndef NULL
#define NULL ((void*)0)
#endif

#ifndef FENCE
#define FENCE(x) ((void)0)
#endif

// AO_char_store
// file /usr/include/atomic_ops/sysdeps/loadstore/char_atomic_store.h line 28
static inline void AO_char_store(volatile unsigned char *addr, unsigned char new_val);
// AO_char_store$link1
// file /usr/include/atomic_ops/sysdeps/loadstore/char_atomic_store.h line 28
static inline void AO_char_store$link1(volatile unsigned char *addr$link1, unsigned char new_val$link1);
// AO_compare_and_swap_full
// file /usr/include/atomic_ops/sysdeps/gcc/x86.h line 139
static inline signed int AO_compare_and_swap_full(volatile unsigned long int *addr, unsigned long int old, unsigned long int new_val);
// AO_compare_and_swap_full$link1
// file /usr/include/atomic_ops/sysdeps/gcc/x86.h line 139
static inline signed int AO_compare_and_swap_full$link1(volatile unsigned long int *addr$link1, unsigned long int old$link1, unsigned long int new_val$link1);
// AO_compare_and_swap_full$link1$link1
// file /usr/include/atomic_ops/sysdeps/gcc/x86.h line 139
static inline signed int AO_compare_and_swap_full$link1$link1(volatile unsigned long int *addr$link1$link1, unsigned long int old$link1$link1, unsigned long int new_val$link1$link1);
// AO_compare_and_swap_full$link2
// file /usr/include/atomic_ops/sysdeps/gcc/x86.h line 139
static inline signed int AO_compare_and_swap_full$link2(volatile unsigned long int *addr$link2, unsigned long int old$link2, unsigned long int new_val$link2);
// AO_fetch_and_add
// file /usr/include/atomic_ops/generalize-arithm.h line 2726
static inline unsigned long int AO_fetch_and_add(volatile unsigned long int *addr, unsigned long int incr);
// AO_fetch_and_add$link1
// file /usr/include/atomic_ops/generalize-arithm.h line 2726
static inline unsigned long int AO_fetch_and_add$link1(volatile unsigned long int *addr$link1, unsigned long int incr$link1);
// AO_load
// file /usr/include/atomic_ops/sysdeps/loadstore/atomic_load.h line 28
static inline unsigned long int AO_load(const volatile unsigned long int *addr);
// AO_load$link1
// file /usr/include/atomic_ops/sysdeps/loadstore/atomic_load.h line 28
static inline unsigned long int AO_load$link1(const volatile unsigned long int *addr$link1);
// AO_load$link1$link1
// file /usr/include/atomic_ops/sysdeps/loadstore/atomic_load.h line 28
static inline unsigned long int AO_load$link1$link1(const volatile unsigned long int *addr$link1$link1);
// AO_load$link2
// file /usr/include/atomic_ops/sysdeps/loadstore/atomic_load.h line 28
static inline unsigned long int AO_load$link2(const volatile unsigned long int *addr$link2);
// AO_load$link2$link1
// file /usr/include/atomic_ops/sysdeps/loadstore/atomic_load.h line 28
static inline unsigned long int AO_load$link2$link1(const volatile unsigned long int *addr$link2$link1);
// AO_load$link3
// file /usr/include/atomic_ops/sysdeps/loadstore/atomic_load.h line 28
static inline unsigned long int AO_load$link3(const volatile unsigned long int *addr$link3);
// AO_load$link3$link1
// file /usr/include/atomic_ops/sysdeps/loadstore/atomic_load.h line 28
static inline unsigned long int AO_load$link3$link1(const volatile unsigned long int *addr$link3$link1);
// AO_load$link4
// file /usr/include/atomic_ops/sysdeps/loadstore/atomic_load.h line 28
static inline unsigned long int AO_load$link4(const volatile unsigned long int *addr$link4);
// AO_load_read
// file /usr/include/atomic_ops/generalize-small.h line 1856
static inline unsigned long int AO_load_read(const volatile unsigned long int *addr);
// AO_load_read$link1
// file /usr/include/atomic_ops/generalize-small.h line 1856
static inline unsigned long int AO_load_read$link1(const volatile unsigned long int *addr$link1);
// AO_load_read$link1$link1
// file /usr/include/atomic_ops/generalize-small.h line 1856
static inline unsigned long int AO_load_read$link1$link1(const volatile unsigned long int *addr$link1$link1);
// AO_load_read$link2
// file /usr/include/atomic_ops/generalize-small.h line 1856
static inline unsigned long int AO_load_read$link2(const volatile unsigned long int *addr$link2);
// AO_nop_read
// file /usr/include/atomic_ops/sysdeps/read_ordered.h line 31
static inline void AO_nop_read(void);
// AO_nop_read$link1
// file /usr/include/atomic_ops/sysdeps/read_ordered.h line 31
static inline void AO_nop_read$link1(void);
// AO_nop_read$link1$link1
// file /usr/include/atomic_ops/sysdeps/read_ordered.h line 31
static inline void AO_nop_read$link1$link1(void);
// AO_nop_read$link2
// file /usr/include/atomic_ops/sysdeps/read_ordered.h line 31
static inline void AO_nop_read$link2(void);
// AO_nop_write
// file /usr/include/atomic_ops/sysdeps/ordered_except_wr.h line 33
static inline void AO_nop_write(void);
// AO_nop_write$link1
// file /usr/include/atomic_ops/sysdeps/ordered_except_wr.h line 33
static inline void AO_nop_write$link1(void);
// AO_nop_write$link1$link1
// file /usr/include/atomic_ops/sysdeps/ordered_except_wr.h line 33
static inline void AO_nop_write$link1$link1(void);
// AO_nop_write$link2
// file /usr/include/atomic_ops/sysdeps/ordered_except_wr.h line 33
static inline void AO_nop_write$link2(void);
// AO_nop_write$link2$link1
// file /usr/include/atomic_ops/sysdeps/ordered_except_wr.h line 33
static inline void AO_nop_write$link2$link1(void);
// AO_nop_write$link3
// file /usr/include/atomic_ops/sysdeps/ordered_except_wr.h line 33
static inline void AO_nop_write$link3(void);
// AO_store
// file /usr/include/atomic_ops/sysdeps/loadstore/atomic_store.h line 28
static inline void AO_store(volatile unsigned long int *addr, unsigned long int new_val);
// AO_store$link1
// file /usr/include/atomic_ops/sysdeps/loadstore/atomic_store.h line 28
static inline void AO_store$link1(volatile unsigned long int *addr$link1, unsigned long int new_val$link1);
// AO_store$link1$link1
// file /usr/include/atomic_ops/sysdeps/loadstore/atomic_store.h line 28
static inline void AO_store$link1$link1(volatile unsigned long int *addr$link1$link1, unsigned long int new_val$link1$link1);
// AO_store$link2
// file /usr/include/atomic_ops/sysdeps/loadstore/atomic_store.h line 28
static inline void AO_store$link2(volatile unsigned long int *addr$link2, unsigned long int new_val$link2);
// AO_store$link2$link1
// file /usr/include/atomic_ops/sysdeps/loadstore/atomic_store.h line 28
static inline void AO_store$link2$link1(volatile unsigned long int *addr$link2$link1, unsigned long int new_val$link2$link1);
// AO_store$link3
// file /usr/include/atomic_ops/sysdeps/loadstore/atomic_store.h line 28
static inline void AO_store$link3(volatile unsigned long int *addr$link3, unsigned long int new_val$link3);
// AO_test_and_set_full
// file /usr/include/atomic_ops/sysdeps/gcc/x86.h line 124
static inline enum anonymous$15 AO_test_and_set_full(volatile unsigned char *addr);
// AO_test_and_set_full$link1
// file /usr/include/atomic_ops/sysdeps/gcc/x86.h line 124
static inline enum anonymous$15 AO_test_and_set_full$link1(volatile unsigned char *addr$link1);
// CORD__extend_path
// file cord/cordbscs.c line 734
void CORD__extend_path(struct CORD_Pos *p);
// CORD__next
// file ./include/cord_pos.h line 84
extern void CORD__next(struct CORD_Pos *p);
// CORD__next::1::1::1::fn$object
//
char fn$object(unsigned long int, void *);
// CORD__pos_fetch
// file ./include/cord_pos.h line 83
extern char CORD__pos_fetch(struct CORD_Pos *p);
// CORD__prev
// file cord/cordbscs.c line 835
extern void CORD__prev(struct CORD_Pos *p);
// CORD_add_forest
// file cord/cordbscs.c line 636
void CORD_add_forest(struct anonymous$0 *forest, const char *x, unsigned long int len);
// CORD_apply_access_fn
// file cord/cordbscs.c line 336
char CORD_apply_access_fn(unsigned long int i, void *client_data);
// CORD_balance
// file ./include/cord.h line 134
extern const char * CORD_balance(const char *x);
// CORD_balance_insert
// file cord/cordbscs.c line 691
void CORD_balance_insert(const char *x, unsigned long int len, struct anonymous$0 *forest);
// CORD_batched_chr_proc
// file cord/cordxtra.c line 325
signed int CORD_batched_chr_proc(const char *s, void *client_data);
// CORD_batched_fill_proc
// file cord/cordxtra.c line 119
signed int CORD_batched_fill_proc(const char *s, void *client_data);
// CORD_batched_put_proc
// file cord/cordxtra.c line 285
signed int CORD_batched_put_proc(const char *s, void *client_data);
// CORD_cat
// file ./include/cord.h line 104
extern const char * CORD_cat(const char *x, const char *y);
// CORD_cat_char
// file cord/cordxtra.c line 72
extern const char * CORD_cat_char(const char *x, char c);
// CORD_cat_char_star
// file cord/cordbscs.c line 152
extern const char * CORD_cat_char_star(const char *x, const char *y, unsigned long int leny);
// CORD_catn
// file ./include/cord.h line 234
extern const char * CORD_catn(signed int nargs, ...);
// CORD_chars
// file ./include/cord.h line 255
extern const char * CORD_chars(char c, unsigned long int i);
// CORD_chr
// file ./include/cord.h line 308
extern unsigned long int CORD_chr(const char *x, unsigned long int i, signed int c);
// CORD_chr_proc
// file cord/cordxtra.c line 307
signed int CORD_chr_proc(char c, void *client_data);
// CORD_cmp
// file ./include/cord.h line 240
extern signed int CORD_cmp(const char *x, const char *y);
// CORD_concat_forest
// file cord/cordbscs.c line 672
const char * CORD_concat_forest(struct anonymous$0 *forest, unsigned long int expected_len);
// CORD_dump
// file cord/cordbscs.c line 146
extern void CORD_dump(const char *x);
// CORD_dump_inner
// file cord/cordbscs.c line 109
void CORD_dump_inner(const char *x, unsigned int n);
// CORD_ec_append_cord
// file ./include/ec.h line 66
void CORD_ec_append_cord(struct CORD_ec_struct *x, const char *s);
// CORD_ec_flush_buf
// file ./include/ec.h line 49
void CORD_ec_flush_buf(struct CORD_ec_struct *x);
// CORD_fetch
// file cord/cordxtra.c line 268
extern char CORD_fetch(const char *x, unsigned long int i);
// CORD_fill_buf
// file cord/cordxtra.c line 140
void CORD_fill_buf(const char *x, unsigned long int i, unsigned long int len, char *buf);
// CORD_fill_proc
// file cord/cordxtra.c line 105
signed int CORD_fill_proc(char c, void *client_data);
// CORD_fprintf
// file ./include/cord.h line 347
extern signed int CORD_fprintf(struct _IO_FILE *f, const char *format, ...);
// CORD_from_char_star
// file ./include/cord.h line 291
extern const char * CORD_from_char_star(const char *s);
// CORD_from_file
// file ./include/cord.h line 274
extern const char * CORD_from_file(struct _IO_FILE *f);
// CORD_from_file_eager
// file cord/cordxtra.c line 454
extern const char * CORD_from_file_eager(struct _IO_FILE *f);
// CORD_from_file_lazy
// file ./include/cord.h line 283
extern const char * CORD_from_file_lazy(struct _IO_FILE *f);
// CORD_from_file_lazy_inner
// file cord/cordxtra.c line 574
const char * CORD_from_file_lazy_inner(struct _IO_FILE *f, unsigned long int len);
// CORD_from_fn
// file ./include/cord.h line 120
extern const char * CORD_from_fn(char (*fn)(unsigned long int, void *), void *client_data, unsigned long int len);
// CORD_from_fn::fn$object
//
char fn$object(unsigned long int, void *);
// CORD_index_access_fn
// file cord/cordbscs.c line 329
char CORD_index_access_fn(unsigned long int i, void *client_data);
// CORD_init_forest
// file cord/cordbscs.c line 620
void CORD_init_forest(struct anonymous$0 *forest, unsigned long int max_len);
// CORD_init_min_len
// file cord/cordbscs.c line 601
void CORD_init_min_len();
// CORD_iter
// file cord/cordbscs.c line 514
extern signed int CORD_iter(const char *x, signed int (*f1)(char, void *), void *client_data);
// CORD_iter5
// file ./include/cord.h line 158
extern signed int CORD_iter5(const char *x, unsigned long int i, signed int (*f1)(char, void *), signed int (*f2)(const char *, void *), void *client_data);
// CORD_iter5::f1$object
//
signed int f1$object(char, void *);
// CORD_iter5::f2$object
//
signed int f2$object(const char *, void *);
// CORD_iter::f1$object
//
signed int f1$object(char, void *);
// CORD_len
// file ./include/cord.h line 114
extern unsigned long int CORD_len(const char *x);
// CORD_lf_close_proc
// file cord/cordxtra.c line 567
void CORD_lf_close_proc(void *obj, void *client_data);
// CORD_lf_func
// file cord/cordxtra.c line 546
char CORD_lf_func(unsigned long int i, void *client_data);
// CORD_ncmp
// file cord/cordxtra.c line 193
extern signed int CORD_ncmp(const char *x, unsigned long int x_start, const char *y, unsigned long int y_start, unsigned long int len);
// CORD_next
// file cord/cordbscs.c line 879
extern void CORD_next(struct CORD_Pos *p);
// CORD_nul_func
// file cord/cordxtra.c line 443
char CORD_nul_func(unsigned long int i, void *client_data);
// CORD_oom_fn$object
//
void CORD_oom_fn$object(void);
// CORD_pos_fetch
// file cord/cordbscs.c line 870
extern char CORD_pos_fetch(struct CORD_Pos *p);
// CORD_pos_to_cord
// file cord/cordbscs.c line 902
extern const char * CORD_pos_to_cord(struct CORD_Pos *p);
// CORD_pos_to_index
// file cord/cordbscs.c line 897
extern unsigned long int CORD_pos_to_index(struct CORD_Pos *p);
// CORD_pos_valid
// file cord/cordbscs.c line 907
extern signed int CORD_pos_valid(struct CORD_Pos *p);
// CORD_prev
// file cord/cordbscs.c line 888
extern void CORD_prev(struct CORD_Pos *p);
// CORD_printf
// file cord/cordprnt.c line 389
extern signed int CORD_printf(const char *format, ...);
// CORD_put
// file ./include/cord.h line 300
extern signed int CORD_put(const char *x, struct _IO_FILE *f);
// CORD_put_proc
// file cord/cordxtra.c line 278
signed int CORD_put_proc(char c, void *client_data);
// CORD_rchr
// file ./include/cord.h line 313
extern unsigned long int CORD_rchr(const char *x, unsigned long int i, signed int c);
// CORD_rchr_proc
// file cord/cordxtra.c line 316
signed int CORD_rchr_proc(char c, void *client_data);
// CORD_riter
// file cord/cordbscs.c line 562
extern signed int CORD_riter(const char *x, signed int (*f1)(char, void *), void *client_data);
// CORD_riter4
// file cord/cordbscs.c line 519
extern signed int CORD_riter4(const char *x, unsigned long int i, signed int (*f1)(char, void *), void *client_data);
// CORD_riter4::f1$object
//
signed int f1$object(char, void *);
// CORD_riter::f1$object
//
signed int f1$object(char, void *);
// CORD_set_pos
// file ./include/cord_pos.h line 68
extern void CORD_set_pos(struct CORD_Pos *p, const char *x, unsigned long int i);
// CORD_sprintf
// file ./include/cord.h line 345
extern signed int CORD_sprintf(const char **out, const char *format, ...);
// CORD_str
// file ./include/cord.h line 250
extern unsigned long int CORD_str(const char *x, unsigned long int start, const char *s);
// CORD_substr
// file ./include/cord.h line 124
extern const char * CORD_substr(const char *x, unsigned long int i, unsigned long int n);
// CORD_substr_checked
// file cord/cordbscs.c line 368
const char * CORD_substr_checked(const char *x, unsigned long int i, unsigned long int n);
// CORD_substr_closure
// file cord/cordbscs.c line 348
const char * CORD_substr_closure(const char *x, unsigned long int i, unsigned long int n, char (*f)(unsigned long int, void *));
// CORD_substr_closure::f$object
//
char f$object(unsigned long int, void *);
// CORD_to_char_star
// file ./include/cord.h line 287
extern char * CORD_to_char_star(const char *x);
// CORD_to_const_char_star
// file cord/cordxtra.c line 261
extern const char * CORD_to_const_char_star(const char *x);
// CORD_vfprintf
// file cord/cordprnt.c line 379
extern signed int CORD_vfprintf(struct _IO_FILE *f, const char *format, void **args);
// CORD_vprintf
// file cord/cordprnt.c line 402
extern signed int CORD_vprintf(const char *format, void **args);
// CORD_vsprintf
// file cord/cordprnt.c line 167
extern signed int CORD_vsprintf(const char **out, const char *format, __builtin_va_list args);
// GC_FirstDLOpenedLinkMap
// file dyn_load.c line 678
struct link_map * GC_FirstDLOpenedLinkMap(void);
// GC_acquire_mark_lock
// file ./include/private/gc_priv.h line 2371
void GC_acquire_mark_lock(void);
// GC_add_ext_descriptor
// file typd_mlc.c line 113
signed long int GC_add_ext_descriptor(const unsigned long int *bm, unsigned long int nbits);
// GC_add_leaked
// file reclaim.c line 52
static inline void GC_add_leaked(char *leaked);
// GC_add_leaked$link1
// file reclaim.c line 52
static inline void GC_add_leaked$link1(char *leaked$link1);
// GC_add_map_entry
// file ./include/private/gc_priv.h line 1734
signed int GC_add_map_entry(unsigned long int granules);
// GC_add_roots
// file mark_rts.c line 151
extern void GC_add_roots(void *b, void *e);
// GC_add_roots_inner
// file ./include/private/gc_priv.h line 1660
void GC_add_roots_inner(char *b, char *e, signed int tmp);
// GC_add_smashed
// file dbg_mlc.c line 945
void GC_add_smashed(char *smashed);
// GC_add_to_black_list_normal
// file blacklst.c line 183
void GC_add_to_black_list_normal(unsigned long int p);
// GC_add_to_black_list_stack
// file blacklst.c line 205
void GC_add_to_black_list_stack(unsigned long int p);
// GC_add_to_fl
// file allchblk.c line 352
void GC_add_to_fl(struct hblk *h, struct hblkhdr *hhdr);
// GC_add_to_heap
// file alloc.c line 1045
void GC_add_to_heap(struct hblk *p, unsigned long int bytes);
// GC_adj_bytes_allocd
// file alloc.c line 244
unsigned long int GC_adj_bytes_allocd(void);
// GC_alloc_large
// file malloc.c line 42
char * GC_alloc_large(unsigned long int lb, signed int k, unsigned int flags);
// GC_alloc_large_and_clear
// file malloc.c line 85
char * GC_alloc_large_and_clear(unsigned long int lb, signed int k, unsigned int flags);
// GC_alloc_reclaim_list
// file malloc.c line 23
signed int GC_alloc_reclaim_list(struct obj_kind *kind);
// GC_allochblk
// file allchblk.c line 576
struct hblk * GC_allochblk(unsigned long int sz, signed int kind, unsigned int flags);
// GC_allochblk_nth
// file allchblk.c line 640
struct hblk * GC_allochblk_nth(unsigned long int sz, signed int kind, unsigned int flags, signed int n, signed int may_split);
// GC_allocobj
// file alloc.c line 1330
char * GC_allocobj(unsigned long int gran, signed int kind);
// GC_allow_register_threads
// file pthread_support.c line 1542
extern void GC_allow_register_threads(void);
// GC_apply_to_all_blocks
// file ./include/private/gc_priv.h line 1542
void GC_apply_to_all_blocks(void (*fn)(struct hblk *, unsigned long int), unsigned long int client_data);
// GC_apply_to_all_blocks::fn$link1$object
//
void fn$link1$object(struct hblk *, unsigned long int);
// GC_apply_to_all_blocks::fn$object
//
void fn$object(struct hblk *, unsigned long int);
// GC_approx_sp
// file ./include/private/gc_priv.h line 1538
char * GC_approx_sp(void);
// GC_array_mark_proc
// file typd_mlc.c line 495
struct GC_ms_entry * GC_array_mark_proc(unsigned long int *addr, struct GC_ms_entry *mark_stack_ptr, struct GC_ms_entry *mark_stack_limit, unsigned long int env);
// GC_atfork_child
// file pthread_support.c line 1019
extern void GC_atfork_child(void);
// GC_atfork_parent
// file pthread_support.c line 1013
extern void GC_atfork_parent(void);
// GC_atfork_prepare
// file pthread_support.c line 1001
extern void GC_atfork_prepare(void);
// GC_base
// file ./include/private/../gc.h line 464
extern void * GC_base(void *p);
// GC_bl_init
// file blacklst.c line 107
void GC_bl_init(void);
// GC_bl_init_no_interiors
// file blacklst.c line 92
void GC_bl_init_no_interiors(void);
// GC_block_empty
// file ./include/private/gc_priv.h line 1801
signed int GC_block_empty(struct hblkhdr *hhdr);
// GC_block_nearly_full
// file reclaim.c line 133
signed int GC_block_nearly_full(struct hblkhdr *hhdr);
// GC_block_was_dirty
// file mark.c line 1816
signed int GC_block_was_dirty(struct hblk *h, struct hblkhdr *hhdr);
// GC_build_fl
// file ./include/private/gc_priv.h line 1747
char * GC_build_fl(struct hblk *h, unsigned long int sz, signed int clear, char *list);
// GC_build_fl2
// file new_hblk.c line 70
char * GC_build_fl2(struct hblk *h, char *ofl);
// GC_build_fl4
// file new_hblk.c line 86
char * GC_build_fl4(struct hblk *h, char *ofl);
// GC_build_fl_clear2
// file new_hblk.c line 30
char * GC_build_fl_clear2(struct hblk *h, char *ofl);
// GC_build_fl_clear4
// file new_hblk.c line 50
char * GC_build_fl_clear4(struct hblk *h, char *ofl);
// GC_call_with_alloc_lock
// file misc.c line 1814
extern void * GC_call_with_alloc_lock(void * (*fn)(void *), void *client_data);
// GC_call_with_alloc_lock::fn$link1$object
//
void * fn$link1$object(void *);
// GC_call_with_alloc_lock::fn$object
//
void * fn$object(void *);
// GC_call_with_gc_active
// file pthread_support.c line 1244
extern void * GC_call_with_gc_active(void * (*fn)(void *), void *client_data);
// GC_call_with_gc_active::fn$link1$object
//
void * fn$link1$object(void *);
// GC_call_with_gc_active::fn$object
//
void * fn$object(void *);
// GC_call_with_stack_base
// file misc.c line 1829
extern void * GC_call_with_stack_base(void * (*fn)(struct GC_stack_base *, void *), void *arg);
// GC_call_with_stack_base::fn$link1$object
//
void * fn$link1$object(struct GC_stack_base *, void *);
// GC_call_with_stack_base::fn$object
//
void * fn$object(struct GC_stack_base *, void *);
// GC_calloc_explicitly_typed
// file typd_mlc.c line 658
extern void * GC_calloc_explicitly_typed(unsigned long int n, unsigned long int lb, unsigned long int d);
// GC_change_stubborn
// file stubborn.c line 52
extern void GC_change_stubborn(const void *p);
// GC_check_annotated_obj
// file dbg_mlc.c line 295
char * GC_check_annotated_obj(struct anonymous$17 *ohdr);
// GC_check_finalizer_nested
// file ./include/private/gc_priv.h line 2270
unsigned char * GC_check_finalizer_nested(void);
// GC_check_heap$object
//
void GC_check_heap$object(void);
// GC_check_heap_block
// file dbg_mlc.c line 979
void GC_check_heap_block(struct hblk *hbp, unsigned long int dummy);
// GC_check_heap_proc
// file dbg_mlc.c line 1005
void GC_check_heap_proc(void);
// GC_check_leaked
// file dbg_mlc.c line 1012
signed int GC_check_leaked(char *base);
// GC_clear_a_few_frames
// file alloc.c line 285
void GC_clear_a_few_frames(void);
// GC_clear_bl
// file blacklst.c line 122
void GC_clear_bl(unsigned long int *doomed);
// GC_clear_fl_links
// file reclaim.c line 591
void GC_clear_fl_links(void **flp);
// GC_clear_fl_marks
// file alloc.c line 765
void GC_clear_fl_marks(char *q);
// GC_clear_hdr_marks
// file ./include/private/gc_priv.h line 1647
void GC_clear_hdr_marks(struct hblkhdr *hhdr);
// GC_clear_mark_bit
// file ./include/private/../gc_mark.h line 246
extern void GC_clear_mark_bit(const void *p);
// GC_clear_marks
// file ./include/private/gc_priv.h line 1553
void GC_clear_marks(void);
// GC_clear_roots
// file mark_rts.c line 265
extern void GC_clear_roots(void);
// GC_clear_stack
// file ./include/private/../gc_mark.h line 229
extern void * GC_clear_stack(void *arg);
// GC_clear_stack_inner
// file misc.c line 328
void * GC_clear_stack_inner(void *arg, char *limit);
// GC_collect_a_little
// file alloc.c line 546
extern signed int GC_collect_a_little(void);
// GC_collect_a_little_inner
// file alloc.c line 499
void GC_collect_a_little_inner(signed int n);
// GC_collect_or_expand
// file alloc.c line 1249
signed int GC_collect_or_expand(unsigned long int needed_blocks, signed int ignore_off_page, signed int retry);
// GC_collection_in_progress
// file ./include/private/gc_priv.h line 1571
signed int GC_collection_in_progress(void);
// GC_compute_heap_usage_percent
// file alloc.c line 815
static inline signed int GC_compute_heap_usage_percent(void);
// GC_compute_heap_usage_percent$link1
// file alloc.c line 815
static inline signed int GC_compute_heap_usage_percent$link1(void);
// GC_compute_large_free_bytes
// file allchblk.c line 104
unsigned long int GC_compute_large_free_bytes(void);
// GC_compute_root_size
// file mark_rts.c line 44
unsigned long int GC_compute_root_size(void);
// GC_cond_register_dynamic_libraries
// file ./include/private/gc_priv.h line 1667
void GC_cond_register_dynamic_libraries(void);
// GC_continue_reclaim
// file ./include/private/gc_priv.h line 1784
void GC_continue_reclaim(unsigned long int sz, signed int kind);
// GC_copy_bl
// file blacklst.c line 127
void GC_copy_bl(unsigned long int *old, unsigned long int *new);
// GC_core_finalized_malloc
// file fnlz_mlc.c line 85
void * GC_core_finalized_malloc(unsigned long int lb, struct GC_finalizer_closure *fclos);
// GC_core_gcj_malloc
// file gcj_mlc.c line 159
void * GC_core_gcj_malloc(unsigned long int lb, void *ptr_to_struct_containing_descr);
// GC_core_gcj_malloc::1::1::2::1::oom_fn$link1$object
//
void * oom_fn$link1$object(unsigned long int);
// GC_core_gcj_malloc::1::1::2::1::oom_fn$object
//
void * oom_fn$object(unsigned long int);
// GC_core_gcj_malloc::1::2::2::oom_fn$link1$object
//
void * oom_fn$link1$object(unsigned long int);
// GC_core_gcj_malloc::1::2::2::oom_fn$object
//
void * oom_fn$object(unsigned long int);
// GC_core_malloc
// file malloc.c line 257
void * GC_core_malloc(unsigned long int lb);
// GC_core_malloc_atomic
// file malloc.c line 227
void * GC_core_malloc_atomic(unsigned long int lb);
// GC_current_warn_proc$object
//
void GC_current_warn_proc$object(char *, unsigned long int);
// GC_debug_change_stubborn
// file dbg_mlc.c line 667
extern void GC_debug_change_stubborn(const void *p);
// GC_debug_end_stubborn_change
// file dbg_mlc.c line 670
extern void GC_debug_end_stubborn_change(const void *p);
// GC_debug_free
// file dbg_mlc.c line 797
extern void GC_debug_free(void *p);
// GC_debug_gcj_malloc
// file gcj_mlc.c line 209
extern void * GC_debug_gcj_malloc(unsigned long int lb, void *ptr_to_struct_containing_descr, const char *s, signed int i);
// GC_debug_gcj_malloc::1::2::oom_fn$link1$object
//
void * oom_fn$link1$object(unsigned long int);
// GC_debug_gcj_malloc::1::2::oom_fn$object
//
void * oom_fn$object(unsigned long int);
// GC_debug_invoke_finalizer
// file dbg_mlc.c line 1065
void GC_debug_invoke_finalizer(void *obj, void *data);
// GC_debug_malloc
// file dbg_mlc.c line 509
extern void * GC_debug_malloc(unsigned long int lb, const char *s, signed int i);
// GC_debug_malloc_atomic
// file dbg_mlc.c line 674
extern void * GC_debug_malloc_atomic(unsigned long int lb, const char *s, signed int i);
// GC_debug_malloc_atomic_ignore_off_page
// file dbg_mlc.c line 553
extern void * GC_debug_malloc_atomic_ignore_off_page(unsigned long int lb, const char *s, signed int i);
// GC_debug_malloc_atomic_uncollectable
// file dbg_mlc.c line 771
extern void * GC_debug_malloc_atomic_uncollectable(unsigned long int lb, const char *s, signed int i);
// GC_debug_malloc_ignore_off_page
// file dbg_mlc.c line 536
extern void * GC_debug_malloc_ignore_off_page(unsigned long int lb, const char *s, signed int i);
// GC_debug_malloc_replacement
// file dbg_mlc.c line 1216
extern void * GC_debug_malloc_replacement(unsigned long int lb);
// GC_debug_malloc_stubborn
// file dbg_mlc.c line 661
extern void * GC_debug_malloc_stubborn(unsigned long int lb, const char *s, signed int i);
// GC_debug_malloc_uncollectable
// file dbg_mlc.c line 752
extern void * GC_debug_malloc_uncollectable(unsigned long int lb, const char *s, signed int i);
// GC_debug_print_heap_obj_proc
// file dbg_mlc.c line 404
void GC_debug_print_heap_obj_proc(char *p);
// GC_debug_realloc
// file dbg_mlc.c line 871
extern void * GC_debug_realloc(void *p, unsigned long int lb, const char *s, signed int i);
// GC_debug_realloc_replacement
// file dbg_mlc.c line 1221
extern void * GC_debug_realloc_replacement(void *p, unsigned long int lb);
// GC_debug_register_displacement
// file dbg_mlc.c line 478
extern void GC_debug_register_displacement(unsigned long int offset);
// GC_debug_register_finalizer
// file dbg_mlc.c line 1098
extern void GC_debug_register_finalizer(void *obj, void (*fn)(void *, void *), void *cd, void (**ofn)(void *, void *), void **ocd);
// GC_debug_register_finalizer::1::my_old_fn$link1$object
//
void my_old_fn$link1$object(void *, void *);
// GC_debug_register_finalizer::1::my_old_fn$object
//
void my_old_fn$object(void *, void *);
// GC_debug_register_finalizer::fn$link1$object
//
void fn$link1$object(void *, void *);
// GC_debug_register_finalizer::fn$object
//
void fn$object(void *, void *);
// GC_debug_register_finalizer::ofn$link1$object$object
//
void ofn$link1$object$object(void *, void *);
// GC_debug_register_finalizer::ofn$object$object
//
void ofn$object$object(void *, void *);
// GC_debug_register_finalizer_ignore_self
// file dbg_mlc.c line 1185
extern void GC_debug_register_finalizer_ignore_self(void *obj, void (*fn)(void *, void *), void *cd, void (**ofn)(void *, void *), void **ocd);
// GC_debug_register_finalizer_ignore_self::1::my_old_fn$link1$object
//
void my_old_fn$link1$object(void *, void *);
// GC_debug_register_finalizer_ignore_self::1::my_old_fn$object
//
void my_old_fn$object(void *, void *);
// GC_debug_register_finalizer_ignore_self::fn$link1$object
//
void fn$link1$object(void *, void *);
// GC_debug_register_finalizer_ignore_self::fn$object
//
void fn$object(void *, void *);
// GC_debug_register_finalizer_ignore_self::ofn$link1$object$object
//
void ofn$link1$object$object(void *, void *);
// GC_debug_register_finalizer_ignore_self::ofn$object$object
//
void ofn$object$object(void *, void *);
// GC_debug_register_finalizer_no_order
// file dbg_mlc.c line 1127
extern void GC_debug_register_finalizer_no_order(void *obj, void (*fn)(void *, void *), void *cd, void (**ofn)(void *, void *), void **ocd);
// GC_debug_register_finalizer_no_order::1::my_old_fn$link1$object
//
void my_old_fn$link1$object(void *, void *);
// GC_debug_register_finalizer_no_order::1::my_old_fn$object
//
void my_old_fn$object(void *, void *);
// GC_debug_register_finalizer_no_order::fn$link1$object
//
void fn$link1$object(void *, void *);
// GC_debug_register_finalizer_no_order::fn$object
//
void fn$object(void *, void *);
// GC_debug_register_finalizer_no_order::ofn$link1$object$object
//
void ofn$link1$object$object(void *, void *);
// GC_debug_register_finalizer_no_order::ofn$object$object
//
void ofn$object$object(void *, void *);
// GC_debug_register_finalizer_unreachable
// file dbg_mlc.c line 1156
extern void GC_debug_register_finalizer_unreachable(void *obj, void (*fn)(void *, void *), void *cd, void (**ofn)(void *, void *), void **ocd);
// GC_debug_register_finalizer_unreachable::1::my_old_fn$link1$object
//
void my_old_fn$link1$object(void *, void *);
// GC_debug_register_finalizer_unreachable::1::my_old_fn$object
//
void my_old_fn$object(void *, void *);
// GC_debug_register_finalizer_unreachable::fn$link1$object
//
void fn$link1$object(void *, void *);
// GC_debug_register_finalizer_unreachable::fn$object
//
void fn$object(void *, void *);
// GC_debug_register_finalizer_unreachable::ofn$link1$object$object
//
void ofn$link1$object$object(void *, void *);
// GC_debug_register_finalizer_unreachable::ofn$object$object
//
void ofn$object$object(void *, void *);
// GC_debug_strdup
// file dbg_mlc.c line 691
extern char * GC_debug_strdup(const char *str, const char *s, signed int i);
// GC_debug_strndup
// file dbg_mlc.c line 714
extern char * GC_debug_strndup(const char *str, unsigned long int size, const char *s, signed int i);
// GC_default_is_valid_displacement_print_proc
// file ptr_chck.c line 103
void GC_default_is_valid_displacement_print_proc(void *p);
// GC_default_is_visible_print_proc
// file ptr_chck.c line 152
void GC_default_is_visible_print_proc(void *p);
// GC_default_on_abort
// file misc.c line 1638
void GC_default_on_abort(const char *msg);
// GC_default_oom_fn
// file misc.c line 164
void * GC_default_oom_fn(unsigned long int bytes_requested);
// GC_default_print_heap_obj_proc
// file blacklst.c line 57
void GC_default_print_heap_obj_proc(char *p);
// GC_default_push_other_roots
// file os_dep.c line 2589
void GC_default_push_other_roots(void);
// GC_default_same_obj_print_proc
// file ptr_chck.c line 21
void GC_default_same_obj_print_proc(void *p, void *q);
// GC_default_stop_func$object
//
signed int GC_default_stop_func$object(void);
// GC_default_warn_proc
// file misc.c line 1590
void GC_default_warn_proc(char *msg, unsigned long int arg);
// GC_delete_gc_thread
// file pthread_support.c line 562
void GC_delete_gc_thread(struct GC_Thread_Rep *t);
// GC_delete_thread
// file pthread_support.c line 524
void GC_delete_thread(unsigned long int id);
// GC_descr_obj_size
// file typd_mlc.c line 421
unsigned long int GC_descr_obj_size(union ComplexDescriptor *d);
// GC_destroy_thread_local
// file thread_local_alloc.c line 127
void GC_destroy_thread_local(struct thread_local_freelists *p);
// GC_dirty_init
// file ./include/private/gc_priv.h line 2039
void GC_dirty_init(void);
// GC_disable
// file misc.c line 1725
extern void GC_disable(void);
// GC_disclaim_and_reclaim
// file reclaim.c line 222
char * GC_disclaim_and_reclaim(struct hblk *hbp, struct hblkhdr *hhdr, unsigned long int sz, char *list, signed long int *count);
// GC_disclaim_and_reclaim::1::disclaim$link1$object
//
signed int disclaim$link1$object(void *);
// GC_disclaim_and_reclaim::1::disclaim$object
//
signed int disclaim$object(void *);
// GC_disclaim_and_reclaim_or_free_small_block
// file reclaim.c line 346
void GC_disclaim_and_reclaim_or_free_small_block(struct hblk *hbp);
// GC_dlopen
// file gc_dlopen.c line 70
extern void * GC_dlopen(const char *path, signed int mode);
// GC_do_blocking
// file misc.c line 1940
extern void * GC_do_blocking(void * (*fn)(void *), void *client_data);
// GC_do_blocking::fn$link1$object
//
void * fn$link1$object(void *);
// GC_do_blocking::fn$object
//
void * fn$object(void *);
// GC_do_blocking_inner
// file ./include/private/gc_priv.h line 2271
void GC_do_blocking_inner(char *data, void *context);
// GC_do_local_mark
// file mark.c line 964
void GC_do_local_mark(struct GC_ms_entry *local_mark_stack, struct GC_ms_entry *local_top);
// GC_do_parallel_mark
// file mark.c line 1119
void GC_do_parallel_mark(void);
// GC_double_descr
// file typd_mlc.c line 175
unsigned long int GC_double_descr(unsigned long int descriptor, unsigned long int nwords);
// GC_dump
// file ./include/private/../gc.h line 1395
extern void GC_dump(void);
// GC_dump_finalization
// file finalize.c line 612
void GC_dump_finalization(void);
// GC_dump_finalization_links
// file finalize.c line 593
void GC_dump_finalization_links(struct dl_hashtbl_s *dl_hashtbl);
// GC_dump_regions
// file allchblk.c line 170
void GC_dump_regions(void);
// GC_enable
// file ./include/private/../gc.h line 693
extern void GC_enable(void);
// GC_enable_incremental
// file misc.c line 1228
extern void GC_enable_incremental(void);
// GC_end_stubborn_change
// file stubborn.c line 48
extern void GC_end_stubborn_change(const void *p);
// GC_enough_large_bytes_left
// file allchblk.c line 70
static inline signed int GC_enough_large_bytes_left(void);
// GC_enough_large_bytes_left$link1
// file allchblk.c line 70
static inline signed int GC_enough_large_bytes_left$link1(void);
// GC_enqueue_all_finalizers
// file finalize.c line 881
void GC_enqueue_all_finalizers(void);
// GC_err_printf
// file ./include/private/gc_priv.h line 2096
extern void GC_err_printf(const char *format, ...);
// GC_err_puts
// file misc.c line 1585
void GC_err_puts(const char *s);
// GC_exclude_static_roots
// file mark_rts.c line 474
extern void GC_exclude_static_roots(void *b, void *e);
// GC_exclude_static_roots_inner
// file ./include/private/gc_priv.h line 1661
void GC_exclude_static_roots_inner(void *start, void *finish);
// GC_exit_check
// file misc.c line 744
void GC_exit_check(void);
// GC_expand_hp
// file alloc.c line 1223
extern signed int GC_expand_hp(unsigned long int bytes);
// GC_expand_hp_inner
// file alloc.c line 1155
signed int GC_expand_hp_inner(unsigned long int n);
// GC_extend_size_map
// file ./include/private/gc_priv.h line 2220
void GC_extend_size_map(unsigned long int i);
// GC_fault_handler
// file os_dep.c line 922
void GC_fault_handler(signed int sig);
// GC_finalize
// file ./include/private/gc_priv.h line 262
void GC_finalize(void);
// GC_finalize_all
// file finalize.c line 936
extern void GC_finalize_all(void);
// GC_finalized_disclaim
// file fnlz_mlc.c line 29
signed int GC_finalized_disclaim(void *obj);
// GC_finalized_malloc
// file fnlz_mlc.c line 130
extern void * GC_finalized_malloc(unsigned long int client_lb, struct GC_finalizer_closure *fclos);
// GC_finalized_malloc::$tmp::return_value_GC_get_oom_fn$3$link1$object
//
void * return_value_GC_get_oom_fn$3$link1$object(unsigned long int);
// GC_finalized_malloc::$tmp::return_value_GC_get_oom_fn$3$object
//
void * return_value_GC_get_oom_fn$3$object(unsigned long int);
// GC_finalizer_notifier$object
//
void GC_finalizer_notifier$object(void);
// GC_find_header
// file ./include/private/gc_priv.h line 1895
struct hblkhdr * GC_find_header(char *h);
// GC_find_limit
// file os_dep.c line 998
char * GC_find_limit(char *p, signed int up);
// GC_find_limit_with_bound
// file os_dep.c line 956
char * GC_find_limit_with_bound(char *p, signed int up, char *bound);
// GC_finish_collection
// file alloc.c line 825
void GC_finish_collection(void);
// GC_free
// file ./include/private/../gc.h line 435
extern void GC_free(void *p);
// GC_free_block_ending_at
// file allchblk.c line 323
struct hblk * GC_free_block_ending_at(struct hblk *h);
// GC_free_inner
// file malloc.c line 542
void GC_free_inner(void *p);
// GC_freehblk
// file allchblk.c line 825
void GC_freehblk(struct hblk *hbp);
// GC_gcj_fake_mark_proc
// file gcj_mlc.c line 59
struct GC_ms_entry * GC_gcj_fake_mark_proc(unsigned long int *addr, struct GC_ms_entry *mark_stack_ptr, struct GC_ms_entry *mark_stack_limit, unsigned long int env);
// GC_gcj_malloc
// file thread_local_alloc.c line 240
extern void * GC_gcj_malloc(unsigned long int bytes, void *ptr_to_struct_containing_descr);
// GC_gcj_malloc::$tmp::return_value_GC_get_oom_fn$2$link1$object
//
void * return_value_GC_get_oom_fn$2$link1$object(unsigned long int);
// GC_gcj_malloc::$tmp::return_value_GC_get_oom_fn$2$object
//
void * return_value_GC_get_oom_fn$2$object(unsigned long int);
// GC_gcj_malloc_ignore_off_page
// file gcj_mlc.c line 237
extern void * GC_gcj_malloc_ignore_off_page(unsigned long int lb, void *ptr_to_struct_containing_descr);
// GC_gcj_malloc_ignore_off_page::1::1::2::1::oom_fn$link1$object
//
void * oom_fn$link1$object(unsigned long int);
// GC_gcj_malloc_ignore_off_page::1::1::2::1::oom_fn$object
//
void * oom_fn$object(unsigned long int);
// GC_gcj_malloc_ignore_off_page::1::2::2::oom_fn$link1$object
//
void * oom_fn$link1$object(unsigned long int);
// GC_gcj_malloc_ignore_off_page::1::2::2::oom_fn$object
//
void * oom_fn$object(unsigned long int);
// GC_gcollect
// file ./include/gc.h line 542
extern void GC_gcollect(void);
// GC_gcollect_and_unmap
// file alloc.c line 1014
extern void GC_gcollect_and_unmap(void);
// GC_general_register_disappearing_link
// file finalize.c line 211
extern signed int GC_general_register_disappearing_link(void **link, const void *obj);
// GC_generic_lock
// file pthread_support.c line 1826
void GC_generic_lock(union anonymous$7 *lock);
// GC_generic_malloc
// file malloc.c line 171
extern void * GC_generic_malloc(unsigned long int lb, signed int k);
// GC_generic_malloc::$tmp::return_value_GC_get_oom_fn$2$link1$object
//
void * return_value_GC_get_oom_fn$2$link1$object(unsigned long int);
// GC_generic_malloc::$tmp::return_value_GC_get_oom_fn$2$object
//
void * return_value_GC_get_oom_fn$2$object(unsigned long int);
// GC_generic_malloc::$tmp::return_value_GC_get_oom_fn$5$link1$object
//
void * return_value_GC_get_oom_fn$5$link1$object(unsigned long int);
// GC_generic_malloc::$tmp::return_value_GC_get_oom_fn$5$object
//
void * return_value_GC_get_oom_fn$5$object(unsigned long int);
// GC_generic_malloc_ignore_off_page
// file mallocx.c line 170
extern void * GC_generic_malloc_ignore_off_page(unsigned long int lb, signed int k);
// GC_generic_malloc_ignore_off_page::$tmp::return_value_GC_get_oom_fn$2$link1$object
//
void * return_value_GC_get_oom_fn$2$link1$object(unsigned long int);
// GC_generic_malloc_ignore_off_page::$tmp::return_value_GC_get_oom_fn$2$object
//
void * return_value_GC_get_oom_fn$2$object(unsigned long int);
// GC_generic_malloc_ignore_off_page::1::3::oom_fn$link1$object
//
void * oom_fn$link1$object(unsigned long int);
// GC_generic_malloc_ignore_off_page::1::3::oom_fn$object
//
void * oom_fn$object(unsigned long int);
// GC_generic_malloc_inner
// file ./include/private/gc_priv.h line 1828
void * GC_generic_malloc_inner(unsigned long int lb, signed int k);
// GC_generic_malloc_inner_ignore_off_page
// file ./include/private/gc_priv.h line 1831
void * GC_generic_malloc_inner_ignore_off_page(unsigned long int lb, signed int k);
// GC_generic_malloc_many
// file mallocx.c line 272
extern void GC_generic_malloc_many(unsigned long int lb, signed int k, void **result);
// GC_generic_or_special_malloc
// file mallocx.c line 50
void * GC_generic_or_special_malloc(unsigned long int lb, signed int knd);
// GC_get_abort_func
// file misc.c line 1704
extern void (*GC_get_abort_func(void))(const char *);
// GC_get_abort_func::1::fn$link1$object
//
void fn$link1$object(const char *);
// GC_get_abort_func::1::fn$object
//
void fn$object(const char *);
// GC_get_all_interior_pointers
// file misc.c line 2078
extern signed int GC_get_all_interior_pointers(void);
// GC_get_bytes_since_gc
// file misc.c line 503
extern unsigned long int GC_get_bytes_since_gc(void);
// GC_get_dont_expand
// file misc.c line 2114
extern signed int GC_get_dont_expand(void);
// GC_get_dont_precollect
// file misc.c line 2170
extern signed int GC_get_dont_precollect(void);
// GC_get_file_len
// file os_dep.c line 164
unsigned long int GC_get_file_len(signed int f);
// GC_get_finalize_on_demand
// file misc.c line 2090
extern signed int GC_get_finalize_on_demand(void);
// GC_get_finalizer_notifier
// file misc.c line 2033
extern void (*GC_get_finalizer_notifier(void))(void);
// GC_get_finalizer_notifier::1::fn$link1$object
//
void fn$link1$object(void);
// GC_get_finalizer_notifier::1::fn$object
//
void fn$object(void);
// GC_get_find_leak
// file misc.c line 2056
extern signed int GC_get_find_leak(void);
// GC_get_first_part
// file allchblk.c line 489
struct hblk * GC_get_first_part(struct hblk *h, struct hblkhdr *hhdr, unsigned long int bytes, signed int index);
// GC_get_force_unmap_on_gcollect
// file misc.c line 2202
extern signed int GC_get_force_unmap_on_gcollect(void);
// GC_get_free_bytes
// file misc.c line 492
extern unsigned long int GC_get_free_bytes(void);
// GC_get_free_space_divisor
// file misc.c line 2147
extern unsigned long int GC_get_free_space_divisor(void);
// GC_get_full_freq
// file misc.c line 2181
extern signed int GC_get_full_freq(void);
// GC_get_gc_no
// file misc.c line 1969
extern unsigned long int GC_get_gc_no(void);
// GC_get_heap_size
// file misc.c line 485
extern unsigned long int GC_get_heap_size(void);
// GC_get_heap_usage_safe
// file misc.c line 518
extern void GC_get_heap_usage_safe(unsigned long int *pheap_size, unsigned long int *pfree_bytes, unsigned long int *punmapped_bytes, unsigned long int *pbytes_since_gc, unsigned long int *ptotal_bytes);
// GC_get_java_finalization
// file misc.c line 2102
extern signed int GC_get_java_finalization(void);
// GC_get_main_stack_base
// file ./include/private/gc_priv.h line 1672
char * GC_get_main_stack_base(void);
// GC_get_maps
// file os_dep.c line 194
char * GC_get_maps(void);
// GC_get_maps_len
// file os_dep.c line 179
unsigned long int GC_get_maps_len(void);
// GC_get_max_retries
// file misc.c line 2158
extern unsigned long int GC_get_max_retries(void);
// GC_get_no_dls
// file misc.c line 2126
extern signed int GC_get_no_dls(void);
// GC_get_non_gc_bytes
// file misc.c line 2136
extern unsigned long int GC_get_non_gc_bytes(void);
// GC_get_nprocs
// file pthread_support.c line 804
signed int GC_get_nprocs(void);
// GC_get_on_heap_resize
// file misc.c line 2014
extern void (*GC_get_on_heap_resize(void))(unsigned long int);
// GC_get_on_heap_resize::1::fn$link1$object
//
void fn$link1$object(unsigned long int);
// GC_get_on_heap_resize::1::fn$object
//
void fn$object(unsigned long int);
// GC_get_oom_fn
// file ./include/private/../gc.h line 120
extern void * (*GC_get_oom_fn(void))(unsigned long int);
// GC_get_oom_fn::1::fn$link1$object
//
void * fn$link1$object(unsigned long int);
// GC_get_oom_fn::1::fn$object
//
void * fn$object(unsigned long int);
// GC_get_pages_executable
// file os_dep.c line 4446
extern signed int GC_get_pages_executable(void);
// GC_get_parallel
// file misc.c line 1975
extern signed int GC_get_parallel(void);
// GC_get_prof_stats
// file misc.c line 562
extern unsigned long int GC_get_prof_stats(struct GC_prof_stats_s *pstats, unsigned long int stats_sz);
// GC_get_prof_stats_unsafe
// file misc.c line 586
extern unsigned long int GC_get_prof_stats_unsafe(struct GC_prof_stats_s *pstats, unsigned long int stats_sz);
// GC_get_push_other_roots
// file os_dep.c line 2615
extern void (*GC_get_push_other_roots(void))(void);
// GC_get_stack_base
// file os_dep.c line 1273
extern signed int GC_get_stack_base(struct GC_stack_base *b);
// GC_get_start_callback
// file alloc.c line 324
extern void (*GC_get_start_callback(void))(void);
// GC_get_start_callback::1::fn$link1$object
//
void fn$link1$object(void);
// GC_get_start_callback::1::fn$object
//
void fn$object(void);
// GC_get_stop_func
// file alloc.c line 158
extern signed int (*GC_get_stop_func(void))(void);
// GC_get_stop_func::1::stop_func$link1$object
//
signed int stop_func$link1$object(void);
// GC_get_stop_func::1::stop_func$object
//
signed int stop_func$object(void);
// GC_get_suspend_signal
// file ./include/private/../gc.h line 1259
extern signed int GC_get_suspend_signal(void);
// GC_get_thr_restart_signal
// file pthread_stop_world.c line 172
extern signed int GC_get_thr_restart_signal(void);
// GC_get_time_limit
// file misc.c line 2192
extern unsigned long int GC_get_time_limit(void);
// GC_get_total_bytes
// file misc.c line 508
extern unsigned long int GC_get_total_bytes(void);
// GC_get_unmapped_bytes
// file misc.c line 498
extern unsigned long int GC_get_unmapped_bytes(void);
// GC_get_version
// file alloc.c line 105
extern unsigned int GC_get_version(void);
// GC_get_warn_proc
// file misc.c line 1624
extern void (*GC_get_warn_proc(void))(char *, unsigned long int);
// GC_get_warn_proc::1::result$link1$object
//
void result$link1$object(char *, unsigned long int);
// GC_get_warn_proc::1::result$object
//
void result$object(char *, unsigned long int);
// GC_grow_table
// file finalize.c line 100
void GC_grow_table(struct hash_chain_entry ***table, signed long int *log_size_ptr);
// GC_has_other_debug_info
// file dbg_mlc.c line 36
signed int GC_has_other_debug_info(char *p);
// GC_has_static_roots$object
//
signed int GC_has_static_roots$object(const char *, void *, unsigned long int);
// GC_hblk_fl_from_blocks
// file allchblk.c line 84
signed int GC_hblk_fl_from_blocks(unsigned long int blocks_needed);
// GC_header_cache_miss
// file headers.c line 58
struct hblkhdr * GC_header_cache_miss(char *p, struct hce *hce);
// GC_help_marker
// file mark.c line 1157
void GC_help_marker(unsigned long int my_mark_no);
// GC_ignore_self_finalize_mark_proc
// file finalize.c line 391
void GC_ignore_self_finalize_mark_proc(char *p);
// GC_ignore_warn_proc
// file misc.c line 1599
extern void GC_ignore_warn_proc(char *msg, unsigned long int arg);
// GC_incr_bytes_allocd
// file mallocx.c line 234
extern void GC_incr_bytes_allocd(unsigned long int n);
// GC_incr_bytes_freed
// file mallocx.c line 240
extern void GC_incr_bytes_freed(unsigned long int n);
// GC_incremental_protection_needs
// file os_dep.c line 3379
extern signed int GC_incremental_protection_needs(void);
// GC_init
// file ./include/gc.h line 396
extern void GC_init(void);
// GC_init_explicit_typing
// file typd_mlc.c line 348
void GC_init_explicit_typing(void);
// GC_init_finalized_malloc
// file fnlz_mlc.c line 50
extern void GC_init_finalized_malloc(void);
// GC_init_gcj_malloc
// file gcj_mlc.c line 69
extern void GC_init_gcj_malloc(signed int mp_index, void *mp);
// GC_init_headers
// file headers.c line 189
void GC_init_headers(void);
// GC_init_linux_data_start
// file ./include/private/gc_priv.h line 2289
void GC_init_linux_data_start(void);
// GC_init_parallel
// file ./include/private/gc_priv.h line 1681
void GC_init_parallel(void);
// GC_init_size_map
// file misc.c line 227
void GC_init_size_map(void);
// GC_init_thread_local
// file thread_local_alloc.c line 87
void GC_init_thread_local(struct thread_local_freelists *p);
// GC_initialize_offsets
// file ./include/private/gc_priv.h line 2224
void GC_initialize_offsets(void);
// GC_initiate_gc
// file ./include/private/gc_priv.h line 1565
void GC_initiate_gc(void);
// GC_inner_start_routine
// file pthread_start.c line 45
void * GC_inner_start_routine(struct GC_stack_base *sb, void *arg);
// GC_inner_start_routine::1::1::__cancel_routine$link1$object
//
void __cancel_routine$link1$object(void *);
// GC_inner_start_routine::1::1::__cancel_routine$object
//
void __cancel_routine$object(void *);
// GC_inner_start_routine::1::start$link1$object
//
void * start$link1$object(void *);
// GC_inner_start_routine::1::start$object
//
void * start$object(void *);
// GC_install_counts
// file ./include/private/gc_priv.h line 1887
signed int GC_install_counts(struct hblk *h, unsigned long int sz);
// GC_install_header
// file ./include/private/gc_priv.h line 1883
struct hblkhdr * GC_install_header(struct hblk *h);
// GC_invalidate_mark_state
// file ./include/private/gc_priv.h line 1555
void GC_invalidate_mark_state(void);
// GC_invoke_finalizers
// file ./include/gc.h line 1126
extern signed int GC_invoke_finalizers(void);
// GC_is_black_listed
// file ./include/private/gc_priv.h line 1713
struct hblk * GC_is_black_listed(struct hblk *h, unsigned long int len);
// GC_is_disabled
// file misc.c line 1733
extern signed int GC_is_disabled(void);
// GC_is_heap_ptr
// file misc.c line 462
extern signed int GC_is_heap_ptr(const void *p);
// GC_is_marked
// file ./include/private/../gc_mark.h line 245
extern signed int GC_is_marked(const void *p);
// GC_is_valid_displacement
// file ptr_chck.c line 117
extern void * GC_is_valid_displacement(void *p);
// GC_is_valid_displacement_print_proc$object
//
void GC_is_valid_displacement_print_proc$object(void *);
// GC_is_visible
// file ptr_chck.c line 187
extern void * GC_is_visible(void *p);
// GC_is_visible_print_proc$object
//
void GC_is_visible_print_proc$object(void *);
// GC_linux_main_stack_base
// file os_dep.c line 1071
char * GC_linux_main_stack_base(void);
// GC_lock
// file ./include/private/gc_locks.h line 182
void GC_lock(void);
// GC_log_printf
// file ./include/private/gc_priv.h line 2104
extern void GC_log_printf(const char *format, ...);
// GC_lookup_thread
// file pthread_support.c line 596
struct GC_Thread_Rep * GC_lookup_thread(unsigned long int id);
// GC_make_array_descriptor
// file typd_mlc.c line 207
signed int GC_make_array_descriptor(unsigned long int nelements, unsigned long int size, unsigned long int descriptor, unsigned long int *simple_d, union ComplexDescriptor **complex_d, struct LeafDescriptor *leaf);
// GC_make_closure
// file dbg_mlc.c line 1047
void * GC_make_closure(void (*fn)(void *, void *), void *data);
// GC_make_closure::fn$link1$object
//
void fn$link1$object(void *, void *);
// GC_make_closure::fn$object
//
void fn$object(void *, void *);
// GC_make_descriptor
// file typd_mlc.c line 534
extern unsigned long int GC_make_descriptor(const unsigned long int *bm, unsigned long int len);
// GC_make_disappearing_links_disappear
// file finalize.c line 702
static inline void GC_make_disappearing_links_disappear(struct dl_hashtbl_s *dl_hashtbl);
// GC_make_disappearing_links_disappear$link1
// file finalize.c line 702
static inline void GC_make_disappearing_links_disappear$link1(struct dl_hashtbl_s *dl_hashtbl$link1);
// GC_make_sequence_descriptor
// file typd_mlc.c line 303
union ComplexDescriptor * GC_make_sequence_descriptor(union ComplexDescriptor *first, union ComplexDescriptor *second);
// GC_malloc
// file ./include/private/../gc.h line 412
extern void * GC_malloc(unsigned long int bytes);
// GC_malloc::$tmp::return_value_GC_get_oom_fn$2$link1$object
//
void * return_value_GC_get_oom_fn$2$link1$object(unsigned long int);
// GC_malloc::$tmp::return_value_GC_get_oom_fn$2$object
//
void * return_value_GC_get_oom_fn$2$object(unsigned long int);
// GC_malloc_atomic
// file ./include/private/../gc.h line 414
extern void * GC_malloc_atomic(unsigned long int bytes);
// GC_malloc_atomic::$tmp::return_value_GC_get_oom_fn$2$link1$object
//
void * return_value_GC_get_oom_fn$2$link1$object(unsigned long int);
// GC_malloc_atomic::$tmp::return_value_GC_get_oom_fn$2$object
//
void * return_value_GC_get_oom_fn$2$object(unsigned long int);
// GC_malloc_atomic_ignore_off_page
// file ./include/private/../gc.h line 745
extern void * GC_malloc_atomic_ignore_off_page(unsigned long int lb);
// GC_malloc_atomic_uncollectable
// file ./include/private/../gc.h line 758
extern void * GC_malloc_atomic_uncollectable(unsigned long int lb);
// GC_malloc_explicitly_typed
// file typd_mlc.c line 584
extern void * GC_malloc_explicitly_typed(unsigned long int lb, unsigned long int d);
// GC_malloc_explicitly_typed_ignore_off_page
// file typd_mlc.c line 622
extern void * GC_malloc_explicitly_typed_ignore_off_page(unsigned long int lb, unsigned long int d);
// GC_malloc_ignore_off_page
// file ./include/private/../gc.h line 743
extern void * GC_malloc_ignore_off_page(unsigned long int lb);
// GC_malloc_many
// file mallocx.c line 438
extern void * GC_malloc_many(unsigned long int lb);
// GC_malloc_stubborn
// file stubborn.c line 43
extern void * GC_malloc_stubborn(unsigned long int lb);
// GC_malloc_uncollectable
// file ./include/private/../gc.h line 419
extern void * GC_malloc_uncollectable(unsigned long int lb);
// GC_mark_and_push
// file ./include/private/../gc_mark.h line 145
extern struct GC_ms_entry * GC_mark_and_push(void *obj, struct GC_ms_entry *mark_stack_ptr, struct GC_ms_entry *mark_stack_limit, void **src);
// GC_mark_and_push_stack
// file mark.c line 1393
void GC_mark_and_push_stack(char *p);
// GC_mark_from
// file ./include/private/gc_pmark.h line 400
struct GC_ms_entry * GC_mark_from(struct GC_ms_entry *mark_stack_top, struct GC_ms_entry *mark_stack, struct GC_ms_entry *mark_stack_limit);
// GC_mark_init
// file mark.c line 1238
void GC_mark_init(void);
// GC_mark_local
// file mark.c line 1014
void GC_mark_local(struct GC_ms_entry *local_mark_stack, signed int id);
// GC_mark_some
// file ./include/private/gc_priv.h line 1560
signed int GC_mark_some(char *cold_gc_frame);
// GC_mark_thread
// file pthread_support.c line 356
void * GC_mark_thread(void *id);
// GC_mark_thread_local_fls_for
// file thread_local_alloc.c line 285
void GC_mark_thread_local_fls_for(struct thread_local_freelists *p);
// GC_mark_thread_local_free_lists
// file ./include/private/gc_priv.h line 2197
void GC_mark_thread_local_free_lists(void);
// GC_max
// file alloc.c line 1132
static inline unsigned long int GC_max(unsigned long int x, unsigned long int y);
// GC_max$link1
// file alloc.c line 1132
static inline unsigned long int GC_max$link1(unsigned long int x$link1, unsigned long int y$link1);
// GC_maybe_gc
// file alloc.c line 351
void GC_maybe_gc(void);
// GC_memalign
// file mallocx.c line 451
extern void * GC_memalign(unsigned long int align, unsigned long int lb);
// GC_memalign::$tmp::return_value_GC_get_oom_fn$2$link1$object
//
void * return_value_GC_get_oom_fn$2$link1$object(unsigned long int);
// GC_memalign::$tmp::return_value_GC_get_oom_fn$2$object
//
void * return_value_GC_get_oom_fn$2$object(unsigned long int);
// GC_min
// file alloc.c line 1137
static inline unsigned long int GC_min(unsigned long int x, unsigned long int y);
// GC_min$link1
// file alloc.c line 1137
static inline unsigned long int GC_min$link1(unsigned long int x$link1, unsigned long int y$link1);
// GC_move_disappearing_link
// file finalize.c line 343
extern signed int GC_move_disappearing_link(void **link, void **new_link);
// GC_move_disappearing_link_inner
// file finalize.c line 292
signed int GC_move_disappearing_link_inner(struct dl_hashtbl_s *dl_hashtbl, void **link, void **new_link);
// GC_move_long_link
// file finalize.c line 360
extern signed int GC_move_long_link(void **link, void **new_link);
// GC_n_set_marks
// file reclaim.c line 474
signed int GC_n_set_marks(struct hblkhdr *hhdr);
// GC_never_stop_func
// file alloc.c line 125
signed int GC_never_stop_func(void);
// GC_new_free_list
// file misc.c line 1748
extern void ** GC_new_free_list(void);
// GC_new_free_list_inner
// file ./include/private/../gc_mark.h line 168
extern void ** GC_new_free_list_inner(void);
// GC_new_hblk
// file ./include/private/gc_priv.h line 1743
void GC_new_hblk(unsigned long int gran, signed int kind);
// GC_new_kind
// file misc.c line 1780
extern unsigned int GC_new_kind(void **fl, unsigned long int descr, signed int adjust, signed int clear);
// GC_new_kind_inner
// file ./include/private/../gc_mark.h line 176
extern unsigned int GC_new_kind_inner(void **fl, unsigned long int descr, signed int adjust, signed int clear);
// GC_new_proc
// file misc.c line 1804
extern unsigned int GC_new_proc(struct GC_ms_entry * (*proc)(unsigned long int *, struct GC_ms_entry *, struct GC_ms_entry *, unsigned long int));
// GC_new_proc::proc$link1$object
//
struct GC_ms_entry * proc$link1$object(unsigned long int *, struct GC_ms_entry *, struct GC_ms_entry *, unsigned long int);
// GC_new_proc::proc$object
//
struct GC_ms_entry * proc$object(unsigned long int *, struct GC_ms_entry *, struct GC_ms_entry *, unsigned long int);
// GC_new_proc_inner
// file misc.c line 1791
extern unsigned int GC_new_proc_inner(struct GC_ms_entry * (*proc)(unsigned long int *, struct GC_ms_entry *, struct GC_ms_entry *, unsigned long int));
// GC_new_proc_inner::proc$link1$object
//
struct GC_ms_entry * proc$link1$object(unsigned long int *, struct GC_ms_entry *, struct GC_ms_entry *, unsigned long int);
// GC_new_proc_inner::proc$object
//
struct GC_ms_entry * proc$object(unsigned long int *, struct GC_ms_entry *, struct GC_ms_entry *, unsigned long int);
// GC_new_thread
// file pthread_support.c line 489
struct GC_Thread_Rep * GC_new_thread(unsigned long int id);
// GC_next_exclusion
// file mark_rts.c line 417
struct exclusion * GC_next_exclusion(char *start_addr);
// GC_next_used_block
// file headers.c line 337
struct hblk * GC_next_used_block(struct hblk *h);
// GC_noop1
// file ./include/private/gc_priv.h line 2075
extern void GC_noop1(unsigned long int x);
// GC_noop6
// file ./include/private/gc_priv.h line 2073
void GC_noop6(unsigned long int arg1, unsigned long int arg2, unsigned long int arg3, unsigned long int arg4, unsigned long int arg5, unsigned long int arg6);
// GC_normal_finalize_mark_proc
// file finalize.c line 380
void GC_normal_finalize_mark_proc(char *p);
// GC_notify_all_builder
// file ./include/private/gc_priv.h line 2373
void GC_notify_all_builder(void);
// GC_notify_all_marker
// file ./include/private/gc_priv.h line 2378
void GC_notify_all_marker(void);
// GC_notify_full_gc
// file alloc.c line 334
static inline void GC_notify_full_gc(void);
// GC_notify_full_gc$link1
// file alloc.c line 334
static inline void GC_notify_full_gc$link1(void);
// GC_notify_or_invoke_finalizers
// file ./include/private/gc_priv.h line 254
void GC_notify_or_invoke_finalizers(void);
// GC_notify_or_invoke_finalizers::1::notifier_fn$link1$object
//
void notifier_fn$link1$object(void);
// GC_notify_or_invoke_finalizers::1::notifier_fn$object
//
void notifier_fn$object(void);
// GC_null_finalize_mark_proc
// file finalize.c line 413
void GC_null_finalize_mark_proc(char *p);
// GC_number_stack_black_listed
// file blacklst.c line 262
unsigned long int GC_number_stack_black_listed(struct hblk *start, struct hblk *endp1);
// GC_old_bus_handler$object
//
void GC_old_bus_handler$object(signed int, struct anonymous$13 *, void *);
// GC_old_segv_handler$object
//
void GC_old_segv_handler$object(signed int, struct anonymous$13 *, void *);
// GC_on_abort$object
//
void GC_on_abort$object(const char *);
// GC_on_heap_resize$object
//
void GC_on_heap_resize$object(unsigned long int);
// GC_oom_fn$object
//
void * GC_oom_fn$object(unsigned long int);
// GC_page_was_dirty
// file ./include/private/gc_priv.h line 2031
signed int GC_page_was_dirty(struct hblk *h);
// GC_parse_mem_size_arg
// file misc.c line 787
unsigned long int GC_parse_mem_size_arg(const char *str);
// GC_pause
// file pthread_support.c line 1774
void GC_pause(void);
// GC_posix_memalign
// file mallocx.c line 485
extern signed int GC_posix_memalign(void **memptr, unsigned long int align, unsigned long int lb);
// GC_post_incr
// file ptr_chck.c line 268
extern void * GC_post_incr(void **p, signed long int how_much);
// GC_pre_incr
// file ptr_chck.c line 257
extern void * GC_pre_incr(void **p, signed long int how_much);
// GC_prev_block
// file ./include/private/gc_priv.h line 1548
struct hblk * GC_prev_block(struct hblk *h);
// GC_print_address_map
// file ./include/private/gc_priv.h line 1925
void GC_print_address_map(void);
// GC_print_all_errors
// file ./include/private/gc_priv.h line 1908
void GC_print_all_errors(void);
// GC_print_all_smashed$object
//
void GC_print_all_smashed$object(void);
// GC_print_all_smashed_proc
// file dbg_mlc.c line 957
void GC_print_all_smashed_proc(void);
// GC_print_block_descr
// file reclaim.c line 531
void GC_print_block_descr(struct hblk *h, unsigned long int raw_ps);
// GC_print_block_list
// file ./include/private/gc_priv.h line 2054
void GC_print_block_list(void);
// GC_print_finalization_stats
// file ./include/private/gc_priv.h line 270
void GC_print_finalization_stats(void);
// GC_print_free_list
// file reclaim.c line 568
void GC_print_free_list(signed int kind, unsigned long int sz_in_granules);
// GC_print_hblkfreelist
// file allchblk.c line 122
void GC_print_hblkfreelist(void);
// GC_print_heap_obj$object
//
void GC_print_heap_obj$object(char *);
// GC_print_heap_sects
// file alloc.c line 1105
void GC_print_heap_sects(void);
// GC_print_obj
// file dbg_mlc.c line 336
void GC_print_obj(char *p);
// GC_print_smashed_obj
// file dbg_mlc.c line 418
void GC_print_smashed_obj(const char *msg, char *p, char *clobbered_addr);
// GC_print_static_roots
// file mark_rts.c line 58
void GC_print_static_roots(void);
// GC_printf
// file ./include/private/gc_priv.h line 2090
extern void GC_printf(const char *format, ...);
// GC_promote_black_lists
// file ./include/private/gc_priv.h line 1721
void GC_promote_black_lists(void);
// GC_protect_heap
// file os_dep.c line 3394
void GC_protect_heap(void);
// GC_pthread_cancel
// file pthread_support.c line 1451
extern signed int GC_pthread_cancel(unsigned long int thread);
// GC_pthread_create
// file pthread_support.c line 1661
extern signed int GC_pthread_create(unsigned long int *new_thread, const union pthread_attr_t *attr, void * (*start_routine)(void *), void *arg);
// GC_pthread_create::$tmp::return_value_GC_get_oom_fn$3$link1$object
//
void * return_value_GC_get_oom_fn$3$link1$object(unsigned long int);
// GC_pthread_create::$tmp::return_value_GC_get_oom_fn$3$object
//
void * return_value_GC_get_oom_fn$3$object(unsigned long int);
// GC_pthread_create::start_routine$link1$object
//
void * start_routine$link1$object(void *);
// GC_pthread_create::start_routine$object
//
void * start_routine$object(void *);
// GC_pthread_detach
// file pthread_support.c line 1418
extern signed int GC_pthread_detach(unsigned long int thread);
// GC_pthread_exit
// file pthread_support.c line 1476
extern void GC_pthread_exit(void *retval);
// GC_pthread_join
// file pthread_support.c line 1384
extern signed int GC_pthread_join(unsigned long int thread, void **retval);
// GC_pthread_sigmask
// file pthread_support.c line 1174
extern signed int GC_pthread_sigmask(signed int how, const struct anonymous$6 *set, struct anonymous$6 *oset);
// GC_push_all
// file ./include/private/../gc_mark.h line 252
extern void GC_push_all(char *bottom, char *top);
// GC_push_all_eager
// file mark.c line 1491
void GC_push_all_eager(char *bottom, char *top);
// GC_push_all_stack
// file mark.c line 1516
void GC_push_all_stack(char *bottom, char *top);
// GC_push_all_stack_sections
// file mark_rts.c line 536
void GC_push_all_stack_sections(char *lo, char *hi, struct GC_traced_stack_sect_s *traced_stack_sect);
// GC_push_all_stacks
// file ./include/private/gc_priv.h line 2272
void GC_push_all_stacks(void);
// GC_push_complex_descriptor
// file typd_mlc.c line 440
struct GC_ms_entry * GC_push_complex_descriptor(unsigned long int *addr, union ComplexDescriptor *d, struct GC_ms_entry *msp, struct GC_ms_entry *msl);
// GC_push_conditional
// file mark.c line 1323
extern void GC_push_conditional(char *bottom, char *top, signed int all);
// GC_push_conditional_with_exclusions
// file mark_rts.c line 491
void GC_push_conditional_with_exclusions(char *bottom, char *top, signed int all);
// GC_push_current_stack
// file mark_rts.c line 658
void GC_push_current_stack(char *cold_gc_frame, void *context);
// GC_push_finalizer_structures
// file finalize.c line 77
void GC_push_finalizer_structures(void);
// GC_push_gc_structures
// file mark_rts.c line 716
void GC_push_gc_structures(void);
// GC_push_marked
// file mark.c line 1727
void GC_push_marked(struct hblk *h, struct hblkhdr *hhdr);
// GC_push_next_marked
// file mark.c line 1835
struct hblk * GC_push_next_marked(struct hblk *h);
// GC_push_next_marked_dirty
// file mark.c line 1850
struct hblk * GC_push_next_marked_dirty(struct hblk *h);
// GC_push_next_marked_uncollectable
// file mark.c line 1883
struct hblk * GC_push_next_marked_uncollectable(struct hblk *h);
// GC_push_one
// file mark.c line 1350
void GC_push_one(unsigned long int p);
// GC_push_other_roots$object
//
void GC_push_other_roots$object(void);
// GC_push_regs_and_stack
// file mark_rts.c line 739
void GC_push_regs_and_stack(char *cold_gc_frame);
// GC_push_roots
// file ./include/private/gc_priv.h line 1598
void GC_push_roots(signed int all, char *cold_gc_frame);
// GC_push_selected
// file mark.c line 1281
void GC_push_selected(char *bottom, char *top, signed int (*dirty_fn)(struct hblk *));
// GC_push_selected::dirty_fn$link1$object
//
signed int dirty_fn$link1$object(struct hblk *);
// GC_push_selected::dirty_fn$object
//
signed int dirty_fn$object(struct hblk *);
// GC_push_thread_structures
// file ./include/private/gc_priv.h line 1612
void GC_push_thread_structures(void);
// GC_push_typed_structures$object
//
void GC_push_typed_structures$object(void);
// GC_push_typed_structures_proc
// file typd_mlc.c line 103
void GC_push_typed_structures_proc(void);
// GC_push_unconditionally
// file mark.c line 1787
void GC_push_unconditionally(struct hblk *h, struct hblkhdr *hhdr);
// GC_read_dirty
// file ./include/private/gc_priv.h line 2029
void GC_read_dirty(void);
// GC_realloc
// file ./include/private/../gc.h line 485
extern void * GC_realloc(void *p, unsigned long int lb);
// GC_rebuild_root_index
// file mark_rts.c line 299
void GC_rebuild_root_index(void);
// GC_reclaim_all
// file ./include/private/gc_priv.h line 1790
signed int GC_reclaim_all(signed int (*stop_func)(void), signed int ignore_old);
// GC_reclaim_all::stop_func$link1$object
//
signed int stop_func$link1$object(void);
// GC_reclaim_all::stop_func$object
//
signed int stop_func$object(void);
// GC_reclaim_block
// file reclaim.c line 374
void GC_reclaim_block(struct hblk *hbp, unsigned long int report_if_found);
// GC_reclaim_check
// file reclaim.c line 274
void GC_reclaim_check(struct hblk *hbp, struct hblkhdr *hhdr, unsigned long int sz);
// GC_reclaim_clear
// file reclaim.c line 146
char * GC_reclaim_clear(struct hblk *hbp, struct hblkhdr *hhdr, unsigned long int sz, char *list, signed long int *count);
// GC_reclaim_generic
// file ./include/private/gc_priv.h line 1793
char * GC_reclaim_generic(struct hblk *hbp, struct hblkhdr *hhdr, unsigned long int sz, signed int init, char *list, signed long int *count);
// GC_reclaim_small_nonempty_block
// file reclaim.c line 327
void GC_reclaim_small_nonempty_block(struct hblk *hbp, signed int report_if_found);
// GC_reclaim_unconditionally_marked
// file reclaim.c line 747
void GC_reclaim_unconditionally_marked(void);
// GC_reclaim_uninit
// file reclaim.c line 193
char * GC_reclaim_uninit(struct hblk *hbp, struct hblkhdr *hhdr, unsigned long int sz, char *list, signed long int *count);
// GC_record_stack_base
// file pthread_support.c line 1506
static inline void GC_record_stack_base(struct GC_Thread_Rep *me, struct GC_stack_base *sb);
// GC_record_stack_base$link1
// file pthread_support.c line 1506
static inline void GC_record_stack_base$link1(struct GC_Thread_Rep *me$link1, struct GC_stack_base *sb$link1);
// GC_register_data_segments
// file ./include/private/gc_priv.h line 1677
void GC_register_data_segments(void);
// GC_register_describe_type_fn
// file dbg_mlc.c line 318
extern void GC_register_describe_type_fn(signed int kind, void (*fn)(void *, char *));
// GC_register_describe_type_fn::fn$link1$object
//
void fn$link1$object(void *, char *);
// GC_register_describe_type_fn::fn$object
//
void fn$object(void *, char *);
// GC_register_disappearing_link
// file finalize.c line 137
extern signed int GC_register_disappearing_link(void **link);
// GC_register_disappearing_link_inner
// file finalize.c line 147
signed int GC_register_disappearing_link_inner(struct dl_hashtbl_s *dl_hashtbl, void **link, const void *obj);
// GC_register_disappearing_link_inner::1::4::oom_fn$link1$object
//
void * oom_fn$link1$object(unsigned long int);
// GC_register_disappearing_link_inner::1::4::oom_fn$object
//
void * oom_fn$object(unsigned long int);
// GC_register_disclaim_proc
// file fnlz_mlc.c line 76
extern void GC_register_disclaim_proc(signed int kind, signed int (*proc)(void *), signed int mark_unconditionally);
// GC_register_disclaim_proc::proc$link1$object
//
signed int proc$link1$object(void *);
// GC_register_disclaim_proc::proc$object
//
signed int proc$object(void *);
// GC_register_displacement
// file ./include/private/../gc.h line 535
extern void GC_register_displacement(unsigned long int offset);
// GC_register_displacement_inner
// file ./include/private/gc_priv.h line 1738
void GC_register_displacement_inner(unsigned long int offset);
// GC_register_dynamic_libraries
// file dyn_load.c line 707
void GC_register_dynamic_libraries(void);
// GC_register_dynamic_libraries_dl_iterate_phdr
// file dyn_load.c line 568
signed int GC_register_dynamic_libraries_dl_iterate_phdr(void);
// GC_register_dynlib_callback
// file dyn_load.c line 469
signed int GC_register_dynlib_callback(struct dl_phdr_info *info, unsigned long int size, void *ptr);
// GC_register_dynlib_callback::1::1::1::1::2::callback$link1$object
//
signed int callback$link1$object(const char *, void *, unsigned long int);
// GC_register_dynlib_callback::1::1::1::1::2::callback$object
//
signed int callback$object(const char *, void *, unsigned long int);
// GC_register_finalizer
// file ./include/private/../gc.h line 914
extern void GC_register_finalizer(void *obj, void (*fn)(void *, void *), void *cd, void (**ofn)(void *, void *), void **ocd);
// GC_register_finalizer::fn$link1$object
//
void fn$link1$object(void *, void *);
// GC_register_finalizer::fn$object
//
void fn$object(void *, void *);
// GC_register_finalizer::ofn$link1$object$object
//
void ofn$link1$object$object(void *, void *);
// GC_register_finalizer::ofn$object$object
//
void ofn$object$object(void *, void *);
// GC_register_finalizer_ignore_self
// file ./include/private/../gc.h line 970
extern void GC_register_finalizer_ignore_self(void *obj, void (*fn)(void *, void *), void *cd, void (**ofn)(void *, void *), void **ocd);
// GC_register_finalizer_ignore_self::fn$link1$object
//
void fn$link1$object(void *, void *);
// GC_register_finalizer_ignore_self::fn$object
//
void fn$object(void *, void *);
// GC_register_finalizer_ignore_self::ofn$link1$object$object
//
void ofn$link1$object$object(void *, void *);
// GC_register_finalizer_ignore_self::ofn$object$object
//
void ofn$object$object(void *, void *);
// GC_register_finalizer_inner
// file finalize.c line 433
void GC_register_finalizer_inner(void *obj, void (*fn)(void *, void *), void *cd, void (**ofn)(void *, void *), void **ocd, void (*mp)(char *));
// GC_register_finalizer_inner::1::oom_fn$link1$object
//
void * oom_fn$link1$object(unsigned long int);
// GC_register_finalizer_inner::1::oom_fn$object
//
void * oom_fn$object(unsigned long int);
// GC_register_finalizer_inner::fn$link1$object
//
void fn$link1$object(void *, void *);
// GC_register_finalizer_inner::fn$object
//
void fn$object(void *, void *);
// GC_register_finalizer_inner::mp$link1$object
//
void mp$link1$object(char *);
// GC_register_finalizer_inner::mp$object
//
void mp$object(char *);
// GC_register_finalizer_inner::ofn$link1$object$object
//
void ofn$link1$object$object(void *, void *);
// GC_register_finalizer_inner::ofn$object$object
//
void ofn$object$object(void *, void *);
// GC_register_finalizer_no_order
// file ./include/private/../gc.h line 983
extern void GC_register_finalizer_no_order(void *obj, void (*fn)(void *, void *), void *cd, void (**ofn)(void *, void *), void **ocd);
// GC_register_finalizer_no_order::fn$link1$object
//
void fn$link1$object(void *, void *);
// GC_register_finalizer_no_order::fn$object
//
void fn$object(void *, void *);
// GC_register_finalizer_no_order::ofn$link1$object$object
//
void ofn$link1$object$object(void *, void *);
// GC_register_finalizer_no_order::ofn$object$object
//
void ofn$object$object(void *, void *);
// GC_register_finalizer_unreachable
// file ./include/private/../gc.h line 1008
extern void GC_register_finalizer_unreachable(void *obj, void (*fn)(void *, void *), void *cd, void (**ofn)(void *, void *), void **ocd);
// GC_register_finalizer_unreachable::fn$link1$object
//
void fn$link1$object(void *, void *);
// GC_register_finalizer_unreachable::fn$object
//
void fn$object(void *, void *);
// GC_register_finalizer_unreachable::ofn$link1$object$object
//
void ofn$link1$object$object(void *, void *);
// GC_register_finalizer_unreachable::ofn$object$object
//
void ofn$object$object(void *, void *);
// GC_register_has_static_roots_callback
// file dyn_load.c line 1503
extern void GC_register_has_static_roots_callback(signed int (*callback)(const char *, void *, unsigned long int));
// GC_register_has_static_roots_callback::callback$link1$object
//
signed int callback$link1$object(const char *, void *, unsigned long int);
// GC_register_has_static_roots_callback::callback$object
//
signed int callback$object(const char *, void *, unsigned long int);
// GC_register_long_link
// file finalize.c line 267
extern signed int GC_register_long_link(void **link, const void *obj);
// GC_register_main_static_data
// file dyn_load.c line 556
signed int GC_register_main_static_data(void);
// GC_register_my_thread
// file pthread_support.c line 1550
extern signed int GC_register_my_thread(struct GC_stack_base *sb);
// GC_register_my_thread_inner
// file pthread_support.c line 1520
struct GC_Thread_Rep * GC_register_my_thread_inner(struct GC_stack_base *sb, unsigned long int my_pthread);
// GC_release_mark_lock
// file ./include/private/gc_priv.h line 2372
void GC_release_mark_lock(void);
// GC_remove_all_threads_but_me
// file pthread_support.c line 664
void GC_remove_all_threads_but_me(void);
// GC_remove_allowed_signals
// file pthread_stop_world.c line 82
void GC_remove_allowed_signals(struct anonymous$6 *set);
// GC_remove_counts
// file ./include/private/gc_priv.h line 1893
void GC_remove_counts(struct hblk *h, unsigned long int sz);
// GC_remove_dangling_disappearing_links
// file finalize.c line 719
static inline void GC_remove_dangling_disappearing_links(struct dl_hashtbl_s *dl_hashtbl);
// GC_remove_dangling_disappearing_links$link1
// file finalize.c line 719
static inline void GC_remove_dangling_disappearing_links$link1(struct dl_hashtbl_s *dl_hashtbl$link1);
// GC_remove_from_fl
// file allchblk.c line 317
static inline void GC_remove_from_fl(struct hblkhdr *hhdr);
// GC_remove_from_fl$link1
// file allchblk.c line 317
static inline void GC_remove_from_fl$link1(struct hblkhdr *hhdr$link1);
// GC_remove_from_fl_at
// file allchblk.c line 293
void GC_remove_from_fl_at(struct hblkhdr *hhdr, signed int index);
// GC_remove_header
// file ./include/private/gc_priv.h line 1891
void GC_remove_header(struct hblk *h);
// GC_remove_protection
// file ./include/private/gc_priv.h line 2033
void GC_remove_protection(struct hblk *h, unsigned long int nblocks, signed int is_ptrfree);
// GC_remove_root_at_pos
// file mark_rts.c line 284
void GC_remove_root_at_pos(signed int i);
// GC_remove_roots
// file mark_rts.c line 331
extern void GC_remove_roots(void *b, void *e);
// GC_remove_roots_inner
// file mark_rts.c line 346
void GC_remove_roots_inner(char *b, char *e);
// GC_remove_tmp_roots
// file mark_rts.c line 311
void GC_remove_tmp_roots(void);
// GC_repeat_read
// file os_dep.c line 145
signed long int GC_repeat_read(signed int fd, char *buf, unsigned long int count);
// GC_reset_fault_handler
// file os_dep.c line 935
void GC_reset_fault_handler(void);
// GC_reset_finalizer_nested
// file ./include/private/gc_priv.h line 2269
void GC_reset_finalizer_nested(void);
// GC_restart_handler
// file pthread_stop_world.c line 311
void GC_restart_handler(signed int sig);
// GC_return_mark_stack
// file mark.c line 931
void GC_return_mark_stack(struct GC_ms_entry *low, struct GC_ms_entry *high);
// GC_roots_present
// file mark_rts.c line 127
void * GC_roots_present(char *b);
// GC_same_obj
// file ptr_chck.c line 39
extern void * GC_same_obj(void *p, void *q);
// GC_same_obj_print_proc$object
//
void GC_same_obj_print_proc$object(void *, void *);
// GC_scratch_alloc
// file ./include/private/gc_priv.h line 1728
char * GC_scratch_alloc(unsigned long int bytes);
// GC_set_abort_func
// file misc.c line 1695
extern void GC_set_abort_func(void (*fn)(const char *));
// GC_set_abort_func::fn$link1$object
//
void fn$link1$object(const char *);
// GC_set_abort_func::fn$object
//
void fn$object(const char *);
// GC_set_all_interior_pointers
// file misc.c line 2061
extern void GC_set_all_interior_pointers(signed int value);
// GC_set_and_save_fault_handler
// file ./include/private/gc_priv.h line 2297
void GC_set_and_save_fault_handler(void (*h)(signed int));
// GC_set_and_save_fault_handler::h$link1$object
//
void h$link1$object(signed int);
// GC_set_and_save_fault_handler::h$object
//
void h$object(signed int);
// GC_set_dont_expand
// file misc.c line 2107
extern void GC_set_dont_expand(signed int value);
// GC_set_dont_precollect
// file misc.c line 2163
extern void GC_set_dont_precollect(signed int value);
// GC_set_finalize_on_demand
// file misc.c line 2083
extern void GC_set_finalize_on_demand(signed int value);
// GC_set_finalizer_notifier
// file misc.c line 2024
extern void GC_set_finalizer_notifier(void (*fn)(void));
// GC_set_finalizer_notifier::fn$link1$object
//
void fn$link1$object(void);
// GC_set_finalizer_notifier::fn$object
//
void fn$object(void);
// GC_set_find_leak
// file misc.c line 2050
extern void GC_set_find_leak(signed int value);
// GC_set_fl_marks
// file alloc.c line 687
void GC_set_fl_marks(char *q);
// GC_set_force_unmap_on_gcollect
// file misc.c line 2197
extern void GC_set_force_unmap_on_gcollect(signed int value);
// GC_set_free_space_divisor
// file misc.c line 2141
extern void GC_set_free_space_divisor(unsigned long int value);
// GC_set_full_freq
// file misc.c line 2175
extern void GC_set_full_freq(signed int value);
// GC_set_handle_fork
// file misc.c line 204
extern void GC_set_handle_fork(signed int value);
// GC_set_hdr_marks
// file ./include/private/gc_priv.h line 1649
void GC_set_hdr_marks(struct hblkhdr *hhdr);
// GC_set_java_finalization
// file misc.c line 2095
extern void GC_set_java_finalization(signed int value);
// GC_set_mark_bit
// file ./include/private/../gc_mark.h line 247
extern void GC_set_mark_bit(const void *p);
// GC_set_max_heap_size
// file alloc.c line 1144
extern void GC_set_max_heap_size(unsigned long int n);
// GC_set_max_retries
// file misc.c line 2152
extern void GC_set_max_retries(unsigned long int value);
// GC_set_no_dls
// file misc.c line 2119
extern void GC_set_no_dls(signed int value);
// GC_set_non_gc_bytes
// file misc.c line 2131
extern void GC_set_non_gc_bytes(unsigned long int value);
// GC_set_on_heap_resize
// file misc.c line 2005
extern void GC_set_on_heap_resize(void (*fn)(unsigned long int));
// GC_set_on_heap_resize::fn$link1$object
//
void fn$link1$object(unsigned long int);
// GC_set_on_heap_resize::fn$object
//
void fn$object(unsigned long int);
// GC_set_oom_fn
// file misc.c line 1986
extern void GC_set_oom_fn(void * (*fn)(unsigned long int));
// GC_set_oom_fn::fn$link1$object
//
void * fn$link1$object(unsigned long int);
// GC_set_oom_fn::fn$object
//
void * fn$object(unsigned long int);
// GC_set_pages_executable
// file os_dep.c line 4435
extern void GC_set_pages_executable(signed int value);
// GC_set_push_other_roots
// file os_dep.c line 2610
extern void GC_set_push_other_roots(void (*fn)(void));
// GC_set_push_other_roots::fn$link1$object
//
void fn$link1$object(void);
// GC_set_push_other_roots::fn$object
//
void fn$object(void);
// GC_set_start_callback
// file alloc.c line 316
extern void GC_set_start_callback(void (*fn)(void));
// GC_set_start_callback::fn$link1$object
//
void fn$link1$object(void);
// GC_set_start_callback::fn$object
//
void fn$object(void);
// GC_set_stop_func
// file alloc.c line 149
extern void GC_set_stop_func(signed int (*stop_func)(void));
// GC_set_stop_func::stop_func$link1$object
//
signed int stop_func$link1$object(void);
// GC_set_stop_func::stop_func$object
//
signed int stop_func$object(void);
// GC_set_suspend_signal
// file pthread_stop_world.c line 153
extern void GC_set_suspend_signal(signed int sig);
// GC_set_thr_restart_signal
// file pthread_stop_world.c line 160
extern void GC_set_thr_restart_signal(signed int sig);
// GC_set_time_limit
// file misc.c line 2186
extern void GC_set_time_limit(unsigned long int value);
// GC_set_warn_proc
// file misc.c line 1607
extern void GC_set_warn_proc(void (*p)(char *, unsigned long int));
// GC_set_warn_proc::p$link1$object
//
void p$link1$object(char *, unsigned long int);
// GC_set_warn_proc::p$object
//
void p$object(char *, unsigned long int);
// GC_setpagesize
// file ./include/private/gc_priv.h line 2222
void GC_setpagesize(void);
// GC_setup_temporary_fault_handler
// file os_dep.c line 927
void GC_setup_temporary_fault_handler(void);
// GC_should_collect
// file ./include/private/gc_priv.h line 1540
signed int GC_should_collect(void);
// GC_should_invoke_finalizers
// file finalize.c line 959
extern signed int GC_should_invoke_finalizers(void);
// GC_signal_mark_stack_overflow
// file ./include/private/gc_pmark.h line 113
struct GC_ms_entry * GC_signal_mark_stack_overflow(struct GC_ms_entry *msp);
// GC_size
// file ./include/private/../gc.h line 475
extern unsigned long int GC_size(const void *p);
// GC_split_block
// file allchblk.c line 530
void GC_split_block(struct hblk *h, struct hblkhdr *hhdr, struct hblk *n, struct hblkhdr *nhdr, signed int index);
// GC_start_call_back$object
//
void GC_start_call_back$object(void);
// GC_start_debugging
// file dbg_mlc.c line 467
void GC_start_debugging(void);
// GC_start_debugging_inner
// file dbg_mlc.c line 452
void GC_start_debugging_inner(void);
// GC_start_mark_threads
// file pthread_support.c line 403
extern void GC_start_mark_threads(void);
// GC_start_reclaim
// file ./include/private/gc_priv.h line 1778
void GC_start_reclaim(signed int report_if_found);
// GC_start_routine
// file pthread_support.c line 1638
void * GC_start_routine(void *arg);
// GC_start_rtn_prepare_thread
// file ./include/private/pthread_support.h line 145
struct GC_Thread_Rep * GC_start_rtn_prepare_thread(void * (**pstart)(void *), void **pstart_arg, struct GC_stack_base *sb, void *arg);
// GC_start_rtn_prepare_thread::pstart$link1$object$object
//
void * pstart$link1$object$object(void *);
// GC_start_rtn_prepare_thread::pstart$object$object
//
void * pstart$object$object(void *);
// GC_start_world
// file ./include/private/gc_priv.h line 448
void GC_start_world(void);
// GC_steal_mark_stack
// file mark.c line 897
struct GC_ms_entry * GC_steal_mark_stack(struct GC_ms_entry *low, struct GC_ms_entry *high, struct GC_ms_entry *local, unsigned int max, struct GC_ms_entry **next);
// GC_stop_init
// file ./include/private/pthread_stop_world.h line 42
void GC_stop_init(void);
// GC_stop_world
// file ./include/private/gc_priv.h line 447
void GC_stop_world(void);
// GC_stopped_mark
// file alloc.c line 586
signed int GC_stopped_mark(signed int (*stop_func)(void));
// GC_stopped_mark::stop_func$link1$object
//
signed int stop_func$link1$object(void);
// GC_stopped_mark::stop_func$object
//
signed int stop_func$object(void);
// GC_store_debug_info
// file dbg_mlc.c line 279
char * GC_store_debug_info(char *p, unsigned long int sz, const char *string, signed int linenum);
// GC_store_debug_info_inner
// file dbg_mlc.c line 255
char * GC_store_debug_info_inner(char *p, unsigned long int sz, const char *string, signed int linenum);
// GC_strdup
// file mallocx.c line 563
extern char * GC_strdup(const char *s);
// GC_strndup
// file mallocx.c line 579
extern char * GC_strndup(const char *str, unsigned long int size);
// GC_suspend_all
// file pthread_stop_world.c line 465
signed int GC_suspend_all(void);
// GC_suspend_handler
// file pthread_stop_world.c line 206
void GC_suspend_handler(signed int sig, struct anonymous$13 *info, void *context);
// GC_suspend_handler_inner
// file pthread_stop_world.c line 227
void GC_suspend_handler_inner(char *sig_arg, void *context);
// GC_thr_init
// file ./include/private/gc_priv.h line 1680
void GC_thr_init(void);
// GC_thread_exit_proc
// file ./include/private/pthread_support.h line 149
void GC_thread_exit_proc(void *arg);
// GC_thread_is_registered
// file pthread_support.c line 647
extern signed int GC_thread_is_registered(void);
// GC_timeout_stop_func
// file alloc.c line 171
signed int GC_timeout_stop_func(void);
// GC_try_to_collect
// file alloc.c line 1000
extern signed int GC_try_to_collect(signed int (*stop_func)(void));
// GC_try_to_collect::stop_func$link1$object
//
signed int stop_func$link1$object(void);
// GC_try_to_collect::stop_func$object
//
signed int stop_func$object(void);
// GC_try_to_collect_general
// file alloc.c line 964
signed int GC_try_to_collect_general(signed int (*stop_func)(void), signed int force_unmap);
// GC_try_to_collect_general::stop_func$link1$object
//
signed int stop_func$link1$object(void);
// GC_try_to_collect_general::stop_func$object
//
signed int stop_func$object(void);
// GC_try_to_collect_inner
// file alloc.c line 411
signed int GC_try_to_collect_inner(signed int (*stop_func)(void));
// GC_try_to_collect_inner::stop_func$link1$object
//
signed int stop_func$link1$object(void);
// GC_try_to_collect_inner::stop_func$object
//
signed int stop_func$object(void);
// GC_typed_mark_proc
// file typd_mlc.c line 381
struct GC_ms_entry * GC_typed_mark_proc(unsigned long int *addr, struct GC_ms_entry *mark_stack_ptr, struct GC_ms_entry *mark_stack_limit, unsigned long int env);
// GC_unix_get_mem
// file ./include/private/gcconfig.h line 2963
char * GC_unix_get_mem(unsigned long int bytes);
// GC_unix_mmap_get_mem
// file os_dep.c line 2040
char * GC_unix_mmap_get_mem(unsigned long int bytes);
// GC_unix_sbrk_get_mem
// file os_dep.c line 2100
char * GC_unix_sbrk_get_mem(unsigned long int bytes);
// GC_unpromote_black_lists
// file ./include/private/gc_priv.h line 1723
void GC_unpromote_black_lists(void);
// GC_unreachable_finalize_mark_proc
// file finalize.c line 423
void GC_unreachable_finalize_mark_proc(char *p);
// GC_unregister_disappearing_link
// file finalize.c line 251
extern signed int GC_unregister_disappearing_link(void **link);
// GC_unregister_disappearing_link_inner
// file finalize.c line 227
static inline struct disappearing_link * GC_unregister_disappearing_link_inner(struct dl_hashtbl_s *dl_hashtbl, void **link);
// GC_unregister_disappearing_link_inner$link1
// file finalize.c line 227
static inline struct disappearing_link * GC_unregister_disappearing_link_inner$link1(struct dl_hashtbl_s *dl_hashtbl$link1, void **link$link1);
// GC_unregister_long_link
// file finalize.c line 274
extern signed int GC_unregister_long_link(void **link);
// GC_unregister_my_thread
// file pthread_support.c line 1337
extern signed int GC_unregister_my_thread(void);
// GC_unregister_my_thread_inner
// file pthread_support.c line 1307
void GC_unregister_my_thread_inner(struct GC_Thread_Rep *me);
// GC_wait_builder
// file pthread_support.c line 2002
void GC_wait_builder(void);
// GC_wait_for_gc_completion
// file pthread_support.c line 911
void GC_wait_for_gc_completion(signed int wait_for_all);
// GC_wait_for_reclaim
// file ./include/private/gc_priv.h line 2374
void GC_wait_for_reclaim(void);
// GC_wait_marker
// file ./include/private/gc_priv.h line 2379
void GC_wait_marker(void);
// GC_with_callee_saves_pushed
// file mach_dep.c line 213
void GC_with_callee_saves_pushed(void (*fn)(char *, void *), char *arg);
// GC_with_callee_saves_pushed::fn$link1$object
//
void fn$link1$object(char *, void *);
// GC_with_callee_saves_pushed::fn$object
//
void fn$object(char *, void *);
// GC_write
// file misc.c line 1456
signed int GC_write(signed int fd, const char *buf, unsigned long int len);
// GC_write_fault_handler
// file os_dep.c line 3124
void GC_write_fault_handler(signed int sig, struct anonymous$13 *si, void *raw_sc);
// GC_write_fault_handler::1::1::1::old_handler$link1$object
//
void old_handler$link1$object(signed int, struct anonymous$13 *, void *);
// GC_write_fault_handler::1::1::1::old_handler$object
//
void old_handler$object(signed int, struct anonymous$13 *, void *);
// _IO_getc
// file /usr/include/libio.h line 430
extern signed int _IO_getc(struct _IO_FILE *);
// _IO_putc
// file /usr/include/libio.h line 431
extern signed int _IO_putc(signed int, struct _IO_FILE *);
// __assert_fail
// file /usr/include/assert.h line 69
extern void __assert_fail(const char *, const char *, unsigned int, const char *);
// __ctype_b_loc
// file /usr/include/ctype.h line 79
extern const unsigned short int ** __ctype_b_loc(void);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// __pthread_register_cancel
// file /usr/include/pthread.h line 680
extern void __pthread_register_cancel(struct anonymous$24 *);
// __pthread_unregister_cancel
// file /usr/include/pthread.h line 692
extern void __pthread_unregister_cancel(struct anonymous$24 *);
// __pthread_unwind_next
// file /usr/include/pthread.h line 733
extern void __pthread_unwind_next(struct anonymous$24 *);
// __pthread_unwind_next$link1
// file /usr/include/pthread.h line 733
extern void __pthread_unwind_next$link1(struct anonymous$24 *);
// __rawmemchr
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 393
extern void * __rawmemchr(const void *, signed int);
// __sigsetjmp
// file /usr/include/pthread.h line 743
extern signed int __sigsetjmp(struct __jmp_buf_tag *, signed int);
// __sync_bool_compare_and_swap
// file gcc_builtin_headers_generic.h line 105
_Bool __sync_bool_compare_and_swap();
// abort
// file /usr/include/stdlib.h line 515
extern void abort(void);
// add_roots_to_index
// file mark_rts.c line 140
static inline void add_roots_to_index(struct roots *p);
// add_roots_to_index$link1
// file mark_rts.c line 140
static inline void add_roots_to_index$link1(struct roots *p$link1);
// alloc_hdr
// file headers.c line 164
static struct hblkhdr * alloc_hdr(void);
// alloc_hdr$link1
// file headers.c line 164
static struct hblkhdr * alloc_hdr$link1(void);
// alloc_mark_stack
// file mark.c line 1187
static void alloc_mark_stack(unsigned long int n);
// alloc_mark_stack$link1
// file mark.c line 1187
static void alloc_mark_stack$link1(unsigned long int n$link1);
// async_set_pht_entry_from_index
// file os_dep.c line 3028
static void async_set_pht_entry_from_index(unsigned long int * volatile db, unsigned long int index);
// async_set_pht_entry_from_index$link1
// file os_dep.c line 3028
static void async_set_pht_entry_from_index$link1(unsigned long int * volatile db$link1, unsigned long int index$link1);
// atexit
// file /usr/include/stdlib.h line 519
extern signed int atexit(void (*)(void));
// atoi
// file /usr/include/stdlib.h line 278
static inline signed int atoi(const char *__nptr);
// atoi$link1
// file /usr/include/stdlib.h line 278
static inline signed int atoi$link1(const char *__nptr$link1);
// atoi$link1$link1
// file /usr/include/stdlib.h line 278
static inline signed int atoi$link1$link1(const char *__nptr$link1$link1);
// atoi$link2
// file /usr/include/stdlib.h line 278
static inline signed int atoi$link2(const char *__nptr$link2);
// atol
// file /usr/include/stdlib.h line 283
static inline signed long int atol(const char *__nptr);
// atol$link1
// file /usr/include/stdlib.h line 283
static inline signed long int atol$link1(const char *__nptr$link1);
// clear_marks_for_block
// file mark.c line 166
static void clear_marks_for_block(struct hblk *h, unsigned long int dummy);
// clear_marks_for_block$link1
// file mark.c line 166
static void clear_marks_for_block$link1(struct hblk *h$link1, unsigned long int dummy$link1);
// clock
// file /usr/include/time.h line 189
extern signed long int clock(void);
// close
// file /usr/include/unistd.h line 356
extern signed int close(signed int);
// disable_gc_for_dlopen
// file gc_dlopen.c line 44
static void disable_gc_for_dlopen(void);
// disable_gc_for_dlopen$link1
// file gc_dlopen.c line 44
static void disable_gc_for_dlopen$link1(void);
// dl_iterate_phdr
// file /usr/include/link.h line 167
extern signed int dl_iterate_phdr(signed int (*)(struct dl_phdr_info *, unsigned long int, void *), void *);
// dlopen
// file /usr/include/dlfcn.h line 56
extern void * dlopen(const char *, signed int);
// ec_len
// file cord/cordprnt.c line 45
static signed int ec_len(struct CORD_ec_struct *x);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// extract_conv_spec
// file cord/cordprnt.c line 62
static signed int extract_conv_spec(struct CORD_Pos *source, char *buf, signed int *width, signed int *prec, signed int *left, signed int *long_arg);
// fclose
// file /usr/include/stdio.h line 237
extern signed int fclose(struct _IO_FILE *);
// fcntl
// file /usr/include/fcntl.h line 146
extern signed int fcntl(signed int, signed int, ...);
// fflush
// file /usr/include/stdio.h line 242
extern signed int fflush(struct _IO_FILE *);
// fill_prof_stats
// file misc.c line 541
static void fill_prof_stats(struct GC_prof_stats_s *pstats);
// fill_prof_stats$link1
// file misc.c line 541
static void fill_prof_stats$link1(struct GC_prof_stats_s *pstats$link1);
// fopen
// file /usr/include/stdio.h line 272
extern struct _IO_FILE * fopen(const char *, const char *);
// fork_child_proc
// file pthread_support.c line 983
static void fork_child_proc(void);
// fork_child_proc$link1
// file pthread_support.c line 983
static void fork_child_proc$link1(void);
// fork_parent_proc
// file pthread_support.c line 972
static void fork_parent_proc(void);
// fork_parent_proc$link1
// file pthread_support.c line 972
static void fork_parent_proc$link1(void);
// fork_prepare_proc
// file pthread_support.c line 948
static void fork_prepare_proc(void);
// fork_prepare_proc$link1
// file pthread_support.c line 948
static void fork_prepare_proc$link1(void);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// fputs
// file /usr/include/stdio.h line 689
extern signed int fputs(const char *, struct _IO_FILE *);
// fread
// file /usr/include/stdio.h line 709
extern unsigned long int fread(void *, unsigned long int, unsigned long int, struct _IO_FILE *);
// free_hdr
// file headers.c line 177
static inline void free_hdr(struct hblkhdr *hhdr);
// free_hdr$link1
// file headers.c line 177
static inline void free_hdr$link1(struct hblkhdr *hhdr$link1);
// free_list_index_of
// file allchblk.c line 153
static signed int free_list_index_of(struct hblkhdr *wanted);
// free_list_index_of$link1
// file allchblk.c line 153
static signed int free_list_index_of$link1(struct hblkhdr *wanted$link1);
// fseek
// file /usr/include/stdio.h line 749
extern signed int fseek(struct _IO_FILE *, signed long int, signed int);
// ftell
// file /usr/include/stdio.h line 754
extern signed long int ftell(struct _IO_FILE *);
// get_index
// file headers.c line 206
static signed int get_index(unsigned long int addr);
// get_index$link1
// file headers.c line 206
static signed int get_index$link1(unsigned long int addr$link1);
// getcontext
// file /usr/include/ucontext.h line 31
extern signed int getcontext(struct ucontext *);
// getenv
// file /usr/include/stdlib.h line 564
extern char * getenv(const char *);
// getpagesize
// file /usr/include/unistd.h line 981
extern signed int getpagesize(void);
// id_cord_fn
// file cord/tests/cordtest.c line 46
char id_cord_fn(unsigned long int i, void *client_data);
// looping_handler
// file misc.c line 753
static void looping_handler(signed int sig);
// looping_handler$link1
// file misc.c line 753
static void looping_handler$link1(signed int sig$link1);
// maybe_finalize
// file gcj_mlc.c line 142
static void maybe_finalize(void);
// maybe_finalize$link1
// file gcj_mlc.c line 142
static void maybe_finalize$link1(void);
// maybe_install_looping_handler
// file misc.c line 763
static void maybe_install_looping_handler(void);
// maybe_install_looping_handler$link1
// file misc.c line 763
static void maybe_install_looping_handler$link1(void);
// memcpy
// file /usr/include/string.h line 42
extern void * memcpy(void *, const void *, unsigned long int);
// memmove
// file /usr/include/string.h line 46
extern void * memmove(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 62
extern void * memset(void *, signed int, unsigned long int);
// min_bytes_allocd
// file alloc.c line 199
static unsigned long int min_bytes_allocd(void);
// min_bytes_allocd$link1
// file alloc.c line 199
static unsigned long int min_bytes_allocd$link1(void);
// mmap
// file /usr/include/x86_64-linux-gnu/sys/mman.h line 57
extern void * mmap(void *, unsigned long int, signed int, signed int, signed int, signed long int);
// mprotect
// file /usr/include/x86_64-linux-gnu/sys/mman.h line 81
extern signed int mprotect(void *, unsigned long int, signed int);
// old_bus_handler$link1$object
//
void old_bus_handler$link1$object(signed int);
// old_bus_handler$object
//
void old_bus_handler$object(signed int);
// old_segv_handler$link1$object
//
void old_segv_handler$link1$object(signed int);
// old_segv_handler$object
//
void old_segv_handler$object(signed int);
// open
// file /usr/include/fcntl.h line 156
extern signed int open(const char *, signed int, ...);
// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// pthread_atfork
// file /usr/include/pthread.h line 1145
extern signed int pthread_atfork(void (*)(void), void (*)(void), void (*)(void));
// pthread_attr_destroy
// file /usr/include/pthread.h line 290
extern signed int pthread_attr_destroy(union pthread_attr_t *);
// pthread_attr_getdetachstate
// file /usr/include/pthread.h line 294
extern signed int pthread_attr_getdetachstate(const union pthread_attr_t *, signed int *);
// pthread_attr_getstack
// file /usr/include/pthread.h line 381
extern signed int pthread_attr_getstack(const union pthread_attr_t *, void ** restrict , unsigned long int *);
// pthread_attr_init
// file /usr/include/pthread.h line 287
extern signed int pthread_attr_init(union pthread_attr_t *);
// pthread_attr_setdetachstate
// file /usr/include/pthread.h line 299
extern signed int pthread_attr_setdetachstate(union pthread_attr_t *, signed int);
// pthread_cancel
// file /usr/include/pthread.h line 513
extern signed int pthread_cancel(unsigned long int);
// pthread_cond_broadcast
// file /usr/include/pthread.h line 981
extern signed int pthread_cond_broadcast(union anonymous$10 *);
// pthread_cond_wait
// file /usr/include/pthread.h line 989
extern signed int pthread_cond_wait(union anonymous$10 *, union anonymous$7 *);
// pthread_create
// file /usr/include/pthread.h line 233
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_detach
// file /usr/include/pthread.h line 271
extern signed int pthread_detach(unsigned long int);
// pthread_exit
// file /usr/include/pthread.h line 242
extern void pthread_exit(void *);
// pthread_getattr_np
// file /usr/include/pthread.h line 420
extern signed int pthread_getattr_np(unsigned long int, union pthread_attr_t *);
// pthread_join
// file /usr/include/pthread.h line 250
extern signed int pthread_join(unsigned long int, void **);
// pthread_kill
// file /usr/include/x86_64-linux-gnu/bits/sigthread.h line 35
extern signed int pthread_kill(unsigned long int, signed int);
// pthread_mutex_lock
// file /usr/include/pthread.h line 762
extern signed int pthread_mutex_lock(union anonymous$7 *);
// pthread_mutex_trylock
// file /usr/include/pthread.h line 758
extern signed int pthread_mutex_trylock(union anonymous$7 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 773
extern signed int pthread_mutex_unlock(union anonymous$7 *);
// pthread_self
// file /usr/include/pthread.h line 275
extern unsigned long int pthread_self(void);
// pthread_setcancelstate
// file /usr/include/pthread.h line 506
extern signed int pthread_setcancelstate(signed int, signed int *);
// pthread_sigmask
// file /usr/include/x86_64-linux-gnu/bits/sigthread.h line 30
extern signed int pthread_sigmask(signed int, const struct anonymous$6 *, struct anonymous$6 *);
// putchar
// file /usr/include/x86_64-linux-gnu/bits/stdio.h line 79
static inline signed int putchar(signed int __c);
// read
// file /usr/include/unistd.h line 363
extern signed long int read(signed int, void *, unsigned long int);
// refill_cache
// file cord/cordxtra.c line 522
static char refill_cache(struct anonymous$4 *client_data);
// remove
// file /usr/include/stdio.h line 178
extern signed int remove(const char *);
// return_freelists
// file thread_local_alloc.c line 64
static void return_freelists(void **fl, void **gfl);
// return_freelists$link1
// file thread_local_alloc.c line 64
static void return_freelists$link1(void **fl$link1, void **gfl$link1);
// return_single_freelist
// file thread_local_alloc.c line 44
static void return_single_freelist(void *fl, void **gfl);
// return_single_freelist$link1
// file thread_local_alloc.c line 44
static void return_single_freelist$link1(void *fl$link1, void **gfl$link1);
// rewind
// file /usr/include/stdio.h line 759
extern void rewind(struct _IO_FILE *);
// rt_hash
// file mark_rts.c line 110
static inline signed int rt_hash(char *addr);
// rt_hash$link1
// file mark_rts.c line 110
static inline signed int rt_hash$link1(char *addr$link1);
// sbrk
// file /usr/include/unistd.h line 1046
extern void * sbrk(signed long int);
// sched_yield
// file /usr/include/sched.h line 65
extern signed int sched_yield(void);
// sem_destroy
// file /usr/include/semaphore.h line 39
extern signed int sem_destroy(union anonymous$8 *);
// sem_getvalue
// file /usr/include/semaphore.h line 72
extern signed int sem_getvalue(union anonymous$8 *, signed int *);
// sem_init
// file /usr/include/semaphore.h line 36
extern signed int sem_init(union anonymous$8 *, signed int, unsigned int);
// sem_post
// file /usr/include/semaphore.h line 69
extern signed int sem_post(union anonymous$8 *);
// sem_wait
// file /usr/include/semaphore.h line 54
extern signed int sem_wait(union anonymous$8 *);
// setup_header
// file allchblk.c line 225
static signed int setup_header(struct hblkhdr *hhdr, struct hblk *block, unsigned long int byte_sz, signed int kind, unsigned int flags);
// setup_header$link1
// file allchblk.c line 225
static signed int setup_header$link1(struct hblkhdr *hhdr$link1, struct hblk *block$link1, unsigned long int byte_sz$link1, signed int kind$link1, unsigned int flags$link1);
// sigaction
// file /usr/include/signal.h line 257
extern signed int sigaction(signed int, struct sigaction *, struct sigaction *);
// sigaddset
// file /usr/include/signal.h line 219
extern signed int sigaddset(struct anonymous$6 *, signed int);
// sigdelset
// file /usr/include/signal.h line 222
extern signed int sigdelset(struct anonymous$6 *, signed int);
// sigemptyset
// file /usr/include/signal.h line 213
extern signed int sigemptyset(struct anonymous$6 *);
// sigfillset
// file /usr/include/signal.h line 216
extern signed int sigfillset(struct anonymous$6 *);
// siglongjmp
// file /usr/include/setjmp.h line 102
extern void siglongjmp(struct __jmp_buf_tag *, signed int);
// signal
// file /usr/include/signal.h line 102
extern void (*signal(signed int, void (*)(signed int)))(signed int);
// sigsuspend
// file /usr/include/signal.h line 254
extern signed int sigsuspend(const struct anonymous$6 *);
// snprintf
// file /usr/include/stdio.h line 386
extern signed int snprintf(char *, unsigned long int, const char *, ...);
// store_old
// file dbg_mlc.c line 1075
static void store_old(void *obj, void (*my_old_fn)(void *, void *), struct closure *my_old_cd, void (**ofn)(void *, void *), void **ocd);
// store_old$link1
// file dbg_mlc.c line 1075
static void store_old$link1(void *obj$link1, void (*my_old_fn$link1)(void *, void *), struct closure *my_old_cd$link1, void (**ofn$link1)(void *, void *), void **ocd$link1);
// store_old::my_old_fn$link1$object
//
void my_old_fn$link1$object(void *, void *);
// store_old::my_old_fn$object
//
void my_old_fn$object(void *, void *);
// store_old::ofn$link1$object$object
//
void ofn$link1$object$object(void *, void *);
// store_old::ofn$object$object
//
void ofn$object$object(void *, void *);
// strlen
// file /usr/include/string.h line 394
extern unsigned long int strlen(const char *);
// strncmp
// file /usr/include/string.h line 143
extern signed int strncmp(const char *, const char *, unsigned long int);
// strtol
// file /usr/include/stdlib.h line 183
extern signed long int strtol(const char *, char ** restrict , signed int);
// strtoul
// file /usr/include/stdlib.h line 187
extern unsigned long int strtoul(const char *, char ** restrict , signed int);
// test_basics
// file cord/tests/cordtest.c line 52
void test_basics(void);
// test_extras
// file cord/tests/cordtest.c line 124
void test_extras(void);
// test_fn
// file cord/tests/cordtest.c line 28
signed int test_fn(char c, void *client_data);
// test_printf
// file cord/tests/cordtest.c line 207
void test_printf(void);
// total_stack_black_listed
// file blacklst.c line 277
static unsigned long int total_stack_black_listed(void);
// total_stack_black_listed$link1
// file blacklst.c line 277
static unsigned long int total_stack_black_listed$link1(void);
// usleep
// file /usr/include/unistd.h line 463
extern signed int usleep(unsigned int);
// vsnprintf
// file /usr/include/stdio.h line 390
extern signed int vsnprintf(char *, unsigned long int, const char *, void **);
// vsprintf
// file /usr/include/stdio.h line 379
extern signed int vsprintf(char *, const char *, void **);
// write
// file /usr/include/unistd.h line 369
extern signed long int write(signed int, const void *, unsigned long int);

struct anonymous$4
{
  // state
  struct anonymous$2 *state;
  // file_pos
  unsigned long int file_pos;
  // new_cache
  struct anonymous$3 *new_cache;
};

struct anonymous$3
{
  // tag
  unsigned long int tag;
  // data
  char data[512l];
};

struct anonymous$2
{
  // lf_file
  struct _IO_FILE *lf_file;
  // lf_current
  unsigned long int lf_current;
  // lf_cache
  struct anonymous$3 * volatile lf_cache[32l];
};

struct anonymous$31
{
  // _call_addr
  void *_call_addr;
  // _syscall
  signed int _syscall;
  // _arch
  unsigned int _arch;
};

struct anonymous$32
{
  // _lower
  void *_lower;
  // _upper
  void *_upper;
};

struct anonymous$16
{
  // si_addr
  void *si_addr;
  // si_addr_lsb
  signed short int si_addr_lsb;
  // si_addr_bnd
  struct anonymous$32 si_addr_bnd;
};

struct anonymous$0
{
  // c
  const char *c;
  // len
  unsigned long int len;
};

struct anonymous$17
{
  // oh_string
  const char *oh_string;
  // oh_int
  unsigned long int oh_int;
  // oh_sz
  unsigned long int oh_sz;
  // oh_sf
  unsigned long int oh_sf;
};

struct anonymous$6
{
  // __val
  unsigned long int __val[16l];
};

struct anonymous$23
{
  // e_ident
  unsigned char e_ident[16l];
  // e_type
  unsigned short int e_type;
  // e_machine
  unsigned short int e_machine;
  // e_version
  unsigned int e_version;
  // e_entry
  unsigned long int e_entry;
  // e_phoff
  unsigned long int e_phoff;
  // e_shoff
  unsigned long int e_shoff;
  // e_flags
  unsigned int e_flags;
  // e_ehsize
  unsigned short int e_ehsize;
  // e_phentsize
  unsigned short int e_phentsize;
  // e_phnum
  unsigned short int e_phnum;
  // e_shentsize
  unsigned short int e_shentsize;
  // e_shnum
  unsigned short int e_shnum;
  // e_shstrndx
  unsigned short int e_shstrndx;
};

struct anonymous$25
{
  // __cancel_jmp_buf
  signed long int __cancel_jmp_buf[8l];
  // __mask_was_saved
  signed int __mask_was_saved;
};

struct anonymous$24
{
  // __cancel_jmp_buf
  struct anonymous$25 __cancel_jmp_buf[1l];
  // __pad
  void *__pad[4l];
};

struct anonymous$18
{
  // gregs
  signed long long int gregs[23l];
  // fpregs
  struct _libc_fpstate *fpregs;
  // __reserved1
  unsigned long long int __reserved1[8l];
};

struct anonymous$9
{
  // __lock
  signed int __lock;
  // __futex
  unsigned int __futex;
  // __total_seq
  unsigned long long int __total_seq;
  // __wakeup_seq
  unsigned long long int __wakeup_seq;
  // __woken_seq
  unsigned long long int __woken_seq;
  // __mutex
  void *__mutex;
  // __nwaiters
  unsigned int __nwaiters;
  // __broadcast_seq
  unsigned int __broadcast_seq;
};

struct anonymous$26
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
};

struct anonymous$29
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
  // si_status
  signed int si_status;
  // si_utime
  signed long int si_utime;
  // si_stime
  signed long int si_stime;
};

union sigval
{
  // sival_int
  signed int sival_int;
  // sival_ptr
  void *sival_ptr;
};

struct anonymous$28
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
  // si_sigval
  union sigval si_sigval;
};

struct anonymous$27
{
  // si_tid
  signed int si_tid;
  // si_overrun
  signed int si_overrun;
  // si_sigval
  union sigval si_sigval;
};

struct anonymous$30
{
  // si_band
  signed long int si_band;
  // si_fd
  signed int si_fd;
};

union anonymous$12
{
  // _pad
  signed int _pad[28l];
  // _kill
  struct anonymous$26 _kill;
  // _timer
  struct anonymous$27 _timer;
  // _rt
  struct anonymous$28 _rt;
  // _sigchld
  struct anonymous$29 _sigchld;
  // _sigfault
  struct anonymous$16 _sigfault;
  // _sigpoll
  struct anonymous$30 _sigpoll;
  // _sigsys
  struct anonymous$31 _sigsys;
};

struct anonymous$13
{
  // si_signo
  signed int si_signo;
  // si_errno
  signed int si_errno;
  // si_code
  signed int si_code;
  // _sifields
  union anonymous$12 _sifields;
};

union anonymous$22
{
  // d_val
  unsigned long int d_val;
  // d_ptr
  unsigned long int d_ptr;
};

struct anonymous$21
{
  // d_tag
  signed long int d_tag;
  // d_un
  union anonymous$22 d_un;
};

struct anonymous$20
{
  // p_type
  unsigned int p_type;
  // p_flags
  unsigned int p_flags;
  // p_offset
  unsigned long int p_offset;
  // p_vaddr
  unsigned long int p_vaddr;
  // p_paddr
  unsigned long int p_paddr;
  // p_filesz
  unsigned long int p_filesz;
  // p_memsz
  unsigned long int p_memsz;
  // p_align
  unsigned long int p_align;
};

struct anonymous$19
{
  // ed_bitmap
  unsigned long int ed_bitmap;
  // ed_continued
  signed int ed_continued;
};

struct anonymous$5
{
  // len
  unsigned long int len;
  // count
  unsigned long int count;
  // buf
  char *buf;
};

struct anonymous$1
{
  // pos
  unsigned long int pos;
  // target
  char target;
};

union anonymous$11
{
  // sa_handler
  void (*sa_handler)(signed int);
  // sa_sigaction
  void (*sa_sigaction)(signed int, struct anonymous$13 *, void *);
};

union anonymous$14
{
  // _hb_marks
  char _hb_marks[257l];
  // dummy
  unsigned long int dummy;
};

union anonymous$8
{
  // __size
  char __size[32l];
  // __align
  signed long int __align;
};

union anonymous$10
{
  // __data
  struct anonymous$9 __data;
  // __size
  char __size[48l];
  // __align
  signed long long int __align;
};

struct Concatenation
{
  // null
  char null;
  // header
  char header;
  // depth
  char depth;
  // left_len
  unsigned char left_len;
  // len
  unsigned long int len;
  // left
  const char *left;
  // right
  const char *right;
};

struct Function
{
  // null
  char null;
  // header
  char header;
  // depth
  char depth;
  // left_len
  char left_len;
  // len
  unsigned long int len;
  // fn
  char (*fn)(unsigned long int, void *);
  // client_data
  void *client_data;
};

struct Generic
{
  // null
  char null;
  // header
  char header;
  // depth
  char depth;
  // left_len
  char left_len;
  // len
  unsigned long int len;
};

union anonymous
{
  // concatenation
  struct Concatenation concatenation;
  // function
  struct Function function;
  // generic
  struct Generic generic;
  // string
  char string[1l];
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous$7
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct CORD_pe
{
  // pe_cord
  const char *pe_cord;
  // pe_start_pos
  unsigned long int pe_start_pos;
};

struct CORD_Pos
{
  // cur_pos
  unsigned long int cur_pos;
  // path_len
  signed int path_len;
  // cur_leaf
  const char *cur_leaf;
  // cur_start
  unsigned long int cur_start;
  // cur_end
  unsigned long int cur_end;
  // path
  struct CORD_pe path[49l];
  // function_buf
  char function_buf[8l];
};

struct CORD_ec_struct
{
  // ec_cord
  const char *ec_cord;
  // ec_bufptr
  char *ec_bufptr;
  // ec_buf
  char ec_buf[129l];
};

struct ComplexArrayDescriptor
{
  // ad_tag
  unsigned long int ad_tag;
  // ad_nelements
  unsigned long int ad_nelements;
  // ad_element_descr
  union ComplexDescriptor *ad_element_descr;
};

struct LeafDescriptor
{
  // ld_tag
  unsigned long int ld_tag;
  // ld_size
  unsigned long int ld_size;
  // ld_nelements
  unsigned long int ld_nelements;
  // ld_descriptor
  unsigned long int ld_descriptor;
};

struct SequenceDescriptor
{
  // sd_tag
  unsigned long int sd_tag;
  // sd_first
  union ComplexDescriptor *sd_first;
  // sd_second
  union ComplexDescriptor *sd_second;
};

union ComplexDescriptor
{
  // ld
  struct LeafDescriptor ld;
  // ad
  struct ComplexArrayDescriptor ad;
  // sd
  struct SequenceDescriptor sd;
};

struct thread_stop_info
{
  // last_stop_count
  unsigned long int last_stop_count;
  // stack_ptr
  char *stack_ptr;
};

struct thread_local_freelists
{
  // ptrfree_freelists
  void *ptrfree_freelists[25l];
  // normal_freelists
  void *normal_freelists[25l];
  // gcj_freelists
  void *gcj_freelists[25l];
  // finalized_freelists
  void *finalized_freelists[25l];
};

struct GC_Thread_Rep
{
  // next
  struct GC_Thread_Rep *next;
  // id
  unsigned long int id;
  // stop_info
  struct thread_stop_info stop_info;
  // flags
  unsigned char flags;
  // thread_blocked
  unsigned char thread_blocked;
  // finalizer_skipped
  unsigned short int finalizer_skipped;
  // finalizer_nested
  unsigned char finalizer_nested;
  // stack_end
  char *stack_end;
  // traced_stack_sect
  struct GC_traced_stack_sect_s *traced_stack_sect;
  // status
  void *status;
  // tlfs
  struct thread_local_freelists tlfs;
};

struct GC_finalizer_closure
{
  // proc
  void (*proc)(void *, void *);
  // cd
  void *cd;
};

union word_ptr_ao_u
{
  // w
  unsigned long int w;
  // sw
  signed long int sw;
  // vp
  void *vp;
  // ao
  volatile unsigned long int ao;
};

struct GC_ms_entry
{
  // mse_start
  char *mse_start;
  // mse_descr
  union word_ptr_ao_u mse_descr;
};

struct GC_prof_stats_s
{
  // heapsize_full
  unsigned long int heapsize_full;
  // free_bytes_full
  unsigned long int free_bytes_full;
  // unmapped_bytes
  unsigned long int unmapped_bytes;
  // bytes_allocd_since_gc
  unsigned long int bytes_allocd_since_gc;
  // allocd_bytes_before_gc
  unsigned long int allocd_bytes_before_gc;
  // non_gc_bytes
  unsigned long int non_gc_bytes;
  // gc_no
  unsigned long int gc_no;
  // markers_m1
  unsigned long int markers_m1;
  // bytes_reclaimed_since_gc
  unsigned long int bytes_reclaimed_since_gc;
  // reclaimed_bytes_before_gc
  unsigned long int reclaimed_bytes_before_gc;
};

struct GC_stack_base
{
  // mem_base
  void *mem_base;
};

struct GC_traced_stack_sect_s
{
  // saved_stack_ptr
  char *saved_stack_ptr;
  // prev
  struct GC_traced_stack_sect_s *prev;
};

struct HeapSect
{
  // hs_start
  char *hs_start;
  // hs_bytes
  unsigned long int hs_bytes;
};

struct Print_stats
{
  // number_of_blocks
  unsigned long int number_of_blocks;
  // total_bytes
  unsigned long int total_bytes;
};

struct roots
{
  // r_start
  char *r_start;
  // r_end
  char *r_end;
  // r_next
  struct roots *r_next;
  // r_tmp
  signed int r_tmp;
};

struct exclusion
{
  // e_start
  char *e_start;
  // e_end
  char *e_end;
};

struct hblkhdr
{
  // hb_next
  struct hblk *hb_next;
  // hb_prev
  struct hblk *hb_prev;
  // hb_block
  struct hblk *hb_block;
  // hb_obj_kind
  unsigned char hb_obj_kind;
  // hb_flags
  unsigned char hb_flags;
  // hb_last_reclaimed
  unsigned short int hb_last_reclaimed;
  // hb_sz
  unsigned long int hb_sz;
  // hb_descr
  unsigned long int hb_descr;
  // hb_large_block
  unsigned char hb_large_block;
  // hb_map
  signed short int *hb_map;
  // hb_n_marks
  volatile unsigned long int hb_n_marks;
  // _mark_byte_union
  union anonymous$14 _mark_byte_union;
};

struct bi
{
  // index
  struct hblkhdr *index[1024l];
  // asc_link
  struct bi *asc_link;
  // desc_link
  struct bi *desc_link;
  // key
  unsigned long int key;
  // hash_link
  struct bi *hash_link;
};

struct _GC_arrays
{
  // _heapsize
  unsigned long int _heapsize;
  // _requested_heapsize
  unsigned long int _requested_heapsize;
  // _last_heap_addr
  char *_last_heap_addr;
  // _prev_heap_addr
  char *_prev_heap_addr;
  // _large_free_bytes
  unsigned long int _large_free_bytes;
  // _large_allocd_bytes
  unsigned long int _large_allocd_bytes;
  // _max_large_allocd_bytes
  unsigned long int _max_large_allocd_bytes;
  // _bytes_allocd_before_gc
  unsigned long int _bytes_allocd_before_gc;
  // _bytes_allocd
  unsigned long int _bytes_allocd;
  // _bytes_dropped
  unsigned long int _bytes_dropped;
  // _bytes_finalized
  unsigned long int _bytes_finalized;
  // _bytes_freed
  unsigned long int _bytes_freed;
  // _finalizer_bytes_freed
  unsigned long int _finalizer_bytes_freed;
  // _scratch_end_ptr
  char *_scratch_end_ptr;
  // _scratch_last_end_ptr
  char *_scratch_last_end_ptr;
  // _mark_stack
  struct GC_ms_entry *_mark_stack;
  // _mark_stack_limit
  struct GC_ms_entry *_mark_stack_limit;
  // _mark_stack_top
  struct GC_ms_entry * volatile _mark_stack_top;
  // _mark_procs
  struct GC_ms_entry * (*_mark_procs[64l])(unsigned long int *, struct GC_ms_entry *, struct GC_ms_entry *, unsigned long int);
  // _objfreelist
  void *_objfreelist[129l];
  // _aobjfreelist
  void *_aobjfreelist[129l];
  // _uobjfreelist
  void *_uobjfreelist[129l];
  // _auobjfreelist
  void *_auobjfreelist[129l];
  // _composite_in_use
  unsigned long int _composite_in_use;
  // _atomic_in_use
  unsigned long int _atomic_in_use;
  // _size_map
  unsigned long int _size_map[2049l];
  // _obj_map
  signed short int *_obj_map[129l];
  // _valid_offsets
  char _valid_offsets[4096l];
  // _modws_valid_offsets
  char _modws_valid_offsets[(signed long int)sizeof(unsigned long int) /*8l*/ ];
  // _grungy_pages
  unsigned long int _grungy_pages[4096l];
  // _dirty_pages
  unsigned long int _dirty_pages[4096l];
  // _heap_sects
  struct HeapSect _heap_sects[1024l];
  // _static_roots
  struct roots _static_roots[2048l];
  // _root_index
  struct roots *_root_index[64l];
  // _excl_table
  struct exclusion _excl_table[512l];
  // _all_nils
  struct bi *_all_nils;
  // _top_index
  struct bi *_top_index[2048l];
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct __jmp_buf_tag
{
  // __jmpbuf
  signed long int __jmpbuf[8l];
  // __mask_was_saved
  signed int __mask_was_saved;
  // __saved_mask
  struct anonymous$6 __saved_mask;
};

struct _libc_fpxreg
{
  // significand
  unsigned short int significand[4l];
  // exponent
  unsigned short int exponent;
  // padding
  unsigned short int padding[3l];
};

struct _libc_xmmreg
{
  // element
  unsigned int element[4l];
};

struct _libc_fpstate
{
  // cwd
  unsigned short int cwd;
  // swd
  unsigned short int swd;
  // ftw
  unsigned short int ftw;
  // fop
  unsigned short int fop;
  // rip
  unsigned long int rip;
  // rdp
  unsigned long int rdp;
  // mxcsr
  unsigned int mxcsr;
  // mxcr_mask
  unsigned int mxcr_mask;
  // _st
  struct _libc_fpxreg _st[8l];
  // _xmm
  struct _libc_xmmreg _xmm[16l];
  // padding
  unsigned int padding[24l];
};

struct blocking_data
{
  // fn
  void * (*fn)(void *);
  // client_data
  void *client_data;
};

struct closure
{
  // cl_fn
  void (*cl_fn)(void *, void *);
  // cl_data
  void *cl_data;
};

struct hash_chain_entry
{
  // hidden_key
  unsigned long int hidden_key;
  // next
  struct hash_chain_entry *next;
};

struct disappearing_link
{
  // prolog
  struct hash_chain_entry prolog;
  // dl_hidden_obj
  unsigned long int dl_hidden_obj;
};

struct dl_hashtbl_s
{
  // head
  struct disappearing_link **head;
  // log_size
  signed long int log_size;
  // entries
  unsigned long int entries;
};

struct dl_phdr_info
{
  // dlpi_addr
  unsigned long int dlpi_addr;
  // dlpi_name
  const char *dlpi_name;
  // dlpi_phdr
  const struct anonymous$20 *dlpi_phdr;
  // dlpi_phnum
  unsigned short int dlpi_phnum;
  // dlpi_adds
  unsigned long long int dlpi_adds;
  // dlpi_subs
  unsigned long long int dlpi_subs;
  // dlpi_tls_modid
  unsigned long int dlpi_tls_modid;
  // dlpi_tls_data
  void *dlpi_tls_data;
};

struct finalizable_object
{
  // prolog
  struct hash_chain_entry prolog;
  // fo_fn
  void (*fo_fn)(void *, void *);
  // fo_client_data
  char *fo_client_data;
  // fo_object_size
  unsigned long int fo_object_size;
  // fo_mark_proc
  void (*fo_mark_proc)(char *);
};

struct hblk
{
  // hb_body
  char hb_body[4096l];
};

struct hce
{
  // block_addr
  unsigned long int block_addr;
  // hce_hdr
  struct hblkhdr *hce_hdr;
};

struct link_map
{
  // l_addr
  unsigned long int l_addr;
  // l_name
  char *l_name;
  // l_ld
  struct anonymous$21 *l_ld;
  // l_next
  struct link_map *l_next;
  // l_prev
  struct link_map *l_prev;
};

struct load_segment
{
  // start
  char *start;
  // end
  char *end;
  // start2
  char *start2;
  // end2
  char *end2;
};

struct obj_kind
{
  // ok_freelist
  void **ok_freelist;
  // ok_reclaim_list
  struct hblk **ok_reclaim_list;
  // ok_descriptor
  unsigned long int ok_descriptor;
  // ok_relocate_descr
  signed int ok_relocate_descr;
  // ok_init
  signed int ok_init;
  // ok_mark_unconditionally
  signed int ok_mark_unconditionally;
  // ok_disclaim_proc
  signed int (*ok_disclaim_proc)(void *);
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct r_debug
{
  // r_version
  signed int r_version;
  // r_map
  struct link_map *r_map;
  // r_brk
  unsigned long int r_brk;
  // r_state
  enum anonymous$33 r_state;
  // r_ldbase
  unsigned long int r_ldbase;
};

struct sigaction
{
  // __sigaction_handler
  union anonymous$11 __sigaction_handler;
  // sa_mask
  struct anonymous$6 sa_mask;
  // sa_flags
  signed int sa_flags;
  // sa_restorer
  void (*sa_restorer)(void);
};

struct sigaltstack
{
  // ss_sp
  void *ss_sp;
  // ss_flags
  signed int ss_flags;
  // ss_size
  unsigned long int ss_size;
};

struct start_info
{
  // start_routine
  void * (*start_routine)(void *);
  // arg
  void *arg;
  // flags
  unsigned long int flags;
  // registered
  union anonymous$8 registered;
};

struct substr_args
{
  // sa_cord
  union anonymous *sa_cord;
  // sa_index
  unsigned long int sa_index;
};

struct ucontext
{
  // uc_flags
  unsigned long int uc_flags;
  // uc_link
  struct ucontext *uc_link;
  // uc_stack
  struct sigaltstack uc_stack;
  // uc_mcontext
  struct anonymous$18 uc_mcontext;
  // uc_sigmask
  struct anonymous$6 uc_sigmask;
  // __fpregs_mem
  struct _libc_fpstate __fpregs_mem;
};


// CORD_max_len
// file cord/cordbscs.c line 593
signed int CORD_max_len;
// CORD_oom_fn
// file cord/cordbscs.c line 37
void (*CORD_oom_fn)(void) = (void (*)(void))0;
// GC_active_count
// file mark.c line 877
unsigned int GC_active_count = (unsigned int)0;
// GC_all_bottom_indices
// file headers.c line 27
struct bi *GC_all_bottom_indices = ((struct bi *)NULL);
// GC_all_bottom_indices_end
// file headers.c line 31
struct bi *GC_all_bottom_indices_end = ((struct bi *)NULL);
// GC_all_interior_pointers
// file misc.c line 129
signed int GC_all_interior_pointers = 1;
// GC_allocate_ml
// file pthread_support.c line 83
union anonymous$7 GC_allocate_ml = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// GC_aobjfreelist_ptr
// file mallocx.c line 43
void ** const GC_aobjfreelist_ptr;
// GC_arrays
// file misc.c line 77
struct _GC_arrays GC_arrays;
// GC_aobjfreelist_ptr
// file mallocx.c line 43
void ** const GC_aobjfreelist_ptr = GC_arrays._aobjfreelist;
// GC_arobjfreelist
// file typd_mlc.c line 339
char **GC_arobjfreelist = (char **)(void *)0;
// GC_array_kind
// file typd_mlc.c line 50
signed int GC_array_kind = 0;
// GC_array_mark_proc_index
// file typd_mlc.c line 101
signed int GC_array_mark_proc_index = 0;
// GC_auobjfreelist_ptr
// file mallocx.c line 46
void ** const GC_auobjfreelist_ptr;
// GC_auobjfreelist_ptr
// file mallocx.c line 46
void ** const GC_auobjfreelist_ptr = GC_arrays._auobjfreelist;
// GC_avail_descr
// file typd_mlc.c line 98
unsigned long int GC_avail_descr = (unsigned long int)0;
// GC_black_list_spacing
// file blacklst.c line 52
unsigned long int GC_black_list_spacing = (unsigned long int)16 * (unsigned long int)(1 << 12);
// GC_bm_table
// file typd_mlc.c line 168
unsigned long int GC_bm_table[32l];
// GC_bytes_allocd_tmp
// file mallocx.c line 246
volatile unsigned long int GC_bytes_allocd_tmp = (volatile unsigned long int)0;
// GC_bytes_found
// file reclaim.c line 25
signed long int GC_bytes_found = (signed long int)0;
// GC_check_heap
// file alloc.c line 543
void (*GC_check_heap)(void) = ((void (*)(void))NULL);
// GC_collect_at_heapsize
// file alloc.c line 296
unsigned long int GC_collect_at_heapsize = (unsigned long int)-1;
// GC_collecting
// file pthread_support.c line 1795
volatile signed int GC_collecting = 0;
// GC_copyright
// file alloc.c line 89
char * const GC_copyright[7l] = { "Copyright 1988,1989 Hans-J. Boehm and Alan J. Demers ",
    "Copyright (c) 1991-1995 by Xerox Corporation.  All rights reserved. ",
    "Copyright (c) 1996-1998 by Silicon Graphics.  All rights reserved. ",
    "Copyright (c) 1999-2009 by Hewlett-Packard Company.  All rights reserved. ",
    "THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY",
    " EXPRESSED OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.",
    "See source code for details." };
// GC_current_warn_proc
// file misc.c line 1596
void (*GC_current_warn_proc)(char *, unsigned long int);
// GC_current_warn_proc
// file misc.c line 1596
void (*GC_current_warn_proc)(char *, unsigned long int) = GC_default_warn_proc;
// GC_data_start
// file os_dep.c line 451
char *GC_data_start = (char *)(void *)0;
// GC_debug_header_size
// file dbg_mlc.c line 476
unsigned long int GC_debug_header_size = sizeof(struct anonymous$17) /*32ul*/ ;
// GC_debugging_started
// file misc.c line 79
signed int GC_debugging_started = 0;
// GC_default_stop_func
// file alloc.c line 146
signed int (*GC_default_stop_func)(void);
// GC_default_stop_func
// file alloc.c line 146
signed int (*GC_default_stop_func)(void) = GC_never_stop_func;
// GC_deficit
// file alloc.c line 496
signed int GC_deficit = 0;
// GC_describe_type_fns
// file dbg_mlc.c line 316
void (*GC_describe_type_fns[16l])(void *, char *) = { ((void (*)(void *, char *))NULL), ((void (*)(void *, char *))NULL), ((void (*)(void *, char *))NULL), ((void (*)(void *, char *))NULL), ((void (*)(void *, char *))NULL), ((void (*)(void *, char *))NULL), ((void (*)(void *, char *))NULL), ((void (*)(void *, char *))NULL), ((void (*)(void *, char *))NULL), ((void (*)(void *, char *))NULL), ((void (*)(void *, char *))NULL), ((void (*)(void *, char *))NULL), ((void (*)(void *, char *))NULL), ((void (*)(void *, char *))NULL), ((void (*)(void *, char *))NULL), ((void (*)(void *, char *))NULL) };
// GC_dirty_maintained
// file os_dep.c line 2660
signed int GC_dirty_maintained = 0;
// GC_dl_hashtbl
// file finalize.c line 52
struct dl_hashtbl_s GC_dl_hashtbl = { .head=(struct disappearing_link **)(void *)0, .log_size=(signed long int)-1,
    .entries=(unsigned long int)0 };
// GC_dont_expand
// file alloc.c line 116
signed int GC_dont_expand = 0;
// GC_dont_gc
// file misc.c line 88
signed int GC_dont_gc = 0;
// GC_dont_precollect
// file misc.c line 90
signed int GC_dont_precollect = 0;
// GC_dump_regularly
// file misc.c line 105
signed int GC_dump_regularly = 0;
// GC_ed_size
// file typd_mlc.c line 95
unsigned long int GC_ed_size = (unsigned long int)0;
// GC_eobjfreelist
// file typd_mlc.c line 337
char **GC_eobjfreelist = (char **)(void *)0;
// GC_excl_table_entries
// file mark_rts.c line 412
unsigned long int GC_excl_table_entries = (unsigned long int)0;
// GC_explicit_kind
// file typd_mlc.c line 46
signed int GC_explicit_kind = 0;
// GC_explicit_typing_initialized
// file typd_mlc.c line 44
signed int GC_explicit_typing_initialized = 0;
// GC_ext_descriptors
// file typd_mlc.c line 91
struct anonymous$19 *GC_ext_descriptors = (struct anonymous$19 *)(void *)0;
// GC_fail_count
// file alloc.c line 1238
unsigned int GC_fail_count = (unsigned int)0;
// GC_fault_handler_lock
// file os_dep.c line 3027
volatile unsigned char GC_fault_handler_lock = (volatile unsigned char)(unsigned long int)AO_BYTE_TS_clear;
// GC_finalize_now
// file finalize.c line 72
struct finalizable_object *GC_finalize_now = ((struct finalizable_object *)NULL);
// GC_finalize_on_demand
// file misc.c line 137
signed int GC_finalize_on_demand = 0;
// GC_finalized_kind
// file fnlz_mlc.c line 27
signed int GC_finalized_kind = 0;
// GC_finalized_objfreelist
// file thread_local_alloc.c line 36
char **GC_finalized_objfreelist = (char **)(void *)0;
// GC_finalizer_notifier
// file misc.c line 147
void (*GC_finalizer_notifier)(void) = (void (*)(void))0;
// GC_find_leak
// file misc.c line 117
signed int GC_find_leak = 0;
// GC_findleak_delay_free
// file misc.c line 124
signed int GC_findleak_delay_free = 0;
// GC_first_nonempty
// file mark.c line 107
volatile unsigned long int GC_first_nonempty = (volatile unsigned long int)0;
// GC_fl_builder_count
// file reclaim.c line 31
unsigned long int GC_fl_builder_count = (unsigned long int)0;
// GC_fo_entries
// file alloc.c line 1236
unsigned long int GC_fo_entries = (unsigned long int)0;
// GC_fo_head
// file finalize.c line 70
struct finalizable_object **GC_fo_head = ((struct finalizable_object **)NULL);
// GC_force_unmap_on_gcollect
// file misc.c line 155
signed int GC_force_unmap_on_gcollect = 0;
// GC_free_bytes
// file allchblk.c line 64
unsigned long int GC_free_bytes[61l] = { (unsigned long int)0, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul };
// GC_free_space_divisor
// file alloc.c line 123
unsigned long int GC_free_space_divisor = (unsigned long int)3;
// GC_full_freq
// file alloc.c line 77
signed int GC_full_freq = 19;
// GC_gc_no
// file alloc.c line 61
unsigned long int GC_gc_no = (unsigned long int)0;
// GC_gcj_debug_kind
// file gcj_mlc.c line 51
signed int GC_gcj_debug_kind = 0;
// GC_gcj_kind
// file gcj_mlc.c line 49
signed int GC_gcj_kind = 0;
// GC_gcj_malloc_initialized
// file gcj_mlc.c line 47
signed int GC_gcj_malloc_initialized = 0;
// GC_gcjdebugobjfreelist
// file gcj_mlc.c line 57
char **GC_gcjdebugobjfreelist = (char **)(void *)0;
// GC_gcjobjfreelist
// file gcj_mlc.c line 55
char **GC_gcjobjfreelist = (char **)(void *)0;
// GC_greatest_plausible_heap_addr
// file alloc.c line 1130
void *GC_greatest_plausible_heap_addr = NULL;
// GC_handle_fork
// file misc.c line 178
signed int GC_handle_fork = 0;
// GC_has_static_roots
// file dyn_load.c line 50
signed int (*GC_has_static_roots)(const char *, void *, unsigned long int) = ((signed int (*)(const char *, void *, unsigned long int))NULL);
// GC_have_errors
// file reclaim.c line 46
signed int GC_have_errors = 0;
// GC_hblkfreelist
// file allchblk.c line 54
struct hblk *GC_hblkfreelist[61l] = { ((struct hblk *)NULL), ((struct hblk *)NULL), ((struct hblk *)NULL), ((struct hblk *)NULL), ((struct hblk *)NULL), ((struct hblk *)NULL), ((struct hblk *)NULL), ((struct hblk *)NULL), ((struct hblk *)NULL), ((struct hblk *)NULL), ((struct hblk *)NULL), ((struct hblk *)NULL), ((struct hblk *)NULL), ((struct hblk *)NULL), ((struct hblk *)NULL), ((struct hblk *)NULL), ((struct hblk *)NULL), ((struct hblk *)NULL), ((struct hblk *)NULL), ((struct hblk *)NULL), ((struct hblk *)NULL), ((struct hblk *)NULL), ((struct hblk *)NULL), ((struct hblk *)NULL), ((struct hblk *)NULL), ((struct hblk *)NULL), ((struct hblk *)NULL), ((struct hblk *)NULL), ((struct hblk *)NULL), ((struct hblk *)NULL), ((struct hblk *)NULL), ((struct hblk *)NULL), ((struct hblk *)NULL), ((struct hblk *)NULL), ((struct hblk *)NULL), ((struct hblk *)NULL), ((struct hblk *)NULL), ((struct hblk *)NULL), ((struct hblk *)NULL), ((struct hblk *)NULL), ((struct hblk *)NULL), ((struct hblk *)NULL), ((struct hblk *)NULL), ((struct hblk *)NULL), ((struct hblk *)NULL), ((struct hblk *)NULL), ((struct hblk *)NULL), ((struct hblk *)NULL), ((struct hblk *)NULL), ((struct hblk *)NULL), ((struct hblk *)NULL), ((struct hblk *)NULL), ((struct hblk *)NULL), ((struct hblk *)NULL), ((struct hblk *)NULL), ((struct hblk *)NULL), ((struct hblk *)NULL), ((struct hblk *)NULL), ((struct hblk *)NULL), ((struct hblk *)NULL), ((struct hblk *)NULL) };
// GC_help_wanted
// file mark.c line 874
signed int GC_help_wanted = 0;
// GC_helper_count
// file mark.c line 875
unsigned int GC_helper_count = (unsigned int)0;
// GC_in_thread_creation
// file pthread_support.c line 1503
signed int GC_in_thread_creation = 0;
// GC_incomplete_normal_bl
// file blacklst.c line 43
unsigned long int *GC_incomplete_normal_bl = (unsigned long int *)(void *)0;
// GC_incomplete_stack_bl
// file blacklst.c line 47
unsigned long int *GC_incomplete_stack_bl = (unsigned long int *)(void *)0;
// GC_incremental
// file alloc.c line 64
signed int GC_incremental = 0;
// GC_is_full_gc
// file alloc.c line 341
signed int GC_is_full_gc = 0;
// GC_is_initialized
// file misc.c line 737
signed int GC_is_initialized = 0;
// GC_is_valid_displacement_print_proc
// file ptr_chck.c line 108
void (*GC_is_valid_displacement_print_proc)(void *);
// GC_is_valid_displacement_print_proc
// file ptr_chck.c line 108
void (*GC_is_valid_displacement_print_proc)(void *) = GC_default_is_valid_displacement_print_proc;
// GC_is_visible_print_proc
// file ptr_chck.c line 157
void (*GC_is_visible_print_proc)(void *);
// GC_is_visible_print_proc
// file ptr_chck.c line 157
void (*GC_is_visible_print_proc)(void *) = GC_default_is_visible_print_proc;
// GC_java_finalization
// file misc.c line 141
signed int GC_java_finalization = 1;
// GC_jmp_buf
// file ./include/private/gc_priv.h line 2484
struct __jmp_buf_tag GC_jmp_buf[1l];
// GC_large_alloc_warn_interval
// file misc.c line 161
signed long int GC_large_alloc_warn_interval = (signed long int)5;
// GC_large_alloc_warn_suppressed
// file allchblk.c line 631
signed long int GC_large_alloc_warn_suppressed = (signed long int)0;
// GC_leaked
// file reclaim.c line 43
char *GC_leaked[40l] = { (char *)(void *)0, ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL) };
// GC_least_plausible_heap_addr
// file alloc.c line 1129
void *GC_least_plausible_heap_addr = (void *)(unsigned long int)(signed long int)-1;
// GC_ll_hashtbl
// file finalize.c line 55
struct dl_hashtbl_s GC_ll_hashtbl = { .head=(struct disappearing_link **)(void *)0, .log_size=(signed long int)-1,
    .entries=(unsigned long int)0 };
// GC_log
// file misc.c line 784
signed int GC_log = 2;
// GC_mark_no
// file mark.c line 884
unsigned long int GC_mark_no = (unsigned long int)0;
// GC_mark_stack_size
// file mark.c line 104
unsigned long int GC_mark_stack_size = (unsigned long int)0;
// GC_mark_stack_too_small
// file mark.c line 116
signed int GC_mark_stack_too_small = 0;
// GC_mark_state
// file mark.c line 114
signed int GC_mark_state = 0;
// GC_mark_threads
// file pthread_support.c line 393
unsigned long int GC_mark_threads[16l];
// GC_max_heapsize
// file alloc.c line 1142
unsigned long int GC_max_heapsize = (unsigned long int)0;
// GC_max_retries
// file alloc.c line 1149
unsigned long int GC_max_retries = (unsigned long int)0;
// GC_n_attempts
// file alloc.c line 143
signed int GC_n_attempts = 0;
// GC_n_heap_sects
// file alloc.c line 1019
unsigned long int GC_n_heap_sects = (unsigned long int)0;
// GC_n_kinds
// file mark.c line 88
unsigned int GC_n_kinds = (unsigned int)4;
// GC_n_leaked
// file reclaim.c line 44
unsigned int GC_n_leaked = (unsigned int)0;
// GC_n_mark_procs
// file mark.c line 43
unsigned int GC_n_mark_procs = (unsigned int)8;
// GC_n_rescuing_pages
// file mark.c line 100
unsigned long int GC_n_rescuing_pages = (unsigned long int)0;
// GC_n_smashed
// file dbg_mlc.c line 943
unsigned int GC_n_smashed = (unsigned int)0;
// GC_need_full_gc
// file alloc.c line 79
signed int GC_need_full_gc = 0;
// GC_need_to_lock
// file pthread_support.c line 277
signed int GC_need_to_lock = 0;
// GC_no_dls
// file mark_rts.c line 37
signed int GC_no_dls = 0;
// GC_non_gc_bytes
// file alloc.c line 59
unsigned long int GC_non_gc_bytes = (unsigned long int)0;
// GC_non_gc_bytes_at_gc
// file alloc.c line 237
unsigned long int GC_non_gc_bytes_at_gc = (unsigned long int)0;
// GC_noop_sink
// file mark.c line 35
volatile unsigned long int GC_noop_sink;
// GC_nprocs
// file pthread_support.c line 279
signed int GC_nprocs = 1;
// GC_obj_kinds
// file mark.c line 49
struct obj_kind GC_obj_kinds[16l];
// GC_obj_kinds
// file mark.c line 49
struct obj_kind GC_obj_kinds[16l] = { { .ok_freelist=&GC_arrays._aobjfreelist[(signed long int)0], .ok_reclaim_list=((struct hblk **)NULL),
    .ok_descriptor=(unsigned long int)(0 | 0),
    .ok_relocate_descr=0,
    .ok_init=0, .ok_mark_unconditionally=0, .ok_disclaim_proc=((signed int (*)(void *))NULL) },
    { .ok_freelist=&GC_arrays._objfreelist[(signed long int)0], .ok_reclaim_list=((struct hblk **)NULL),
    .ok_descriptor=(unsigned long int)(0 | 0),
    .ok_relocate_descr=1,
    .ok_init=1, .ok_mark_unconditionally=0, .ok_disclaim_proc=((signed int (*)(void *))NULL) },
    { .ok_freelist=&GC_arrays._uobjfreelist[(signed long int)0], .ok_reclaim_list=((struct hblk **)NULL),
    .ok_descriptor=(unsigned long int)(0 | 0),
    .ok_relocate_descr=1,
    .ok_init=1, .ok_mark_unconditionally=0, .ok_disclaim_proc=((signed int (*)(void *))NULL) },
    { .ok_freelist=&GC_arrays._auobjfreelist[(signed long int)0], .ok_reclaim_list=((struct hblk **)NULL),
    .ok_descriptor=(unsigned long int)(0 | 0),
    .ok_relocate_descr=0,
    .ok_init=0, .ok_mark_unconditionally=0, .ok_disclaim_proc=((signed int (*)(void *))NULL) },
    { .ok_freelist=((void **)NULL), .ok_reclaim_list=((struct hblk **)NULL), .ok_descriptor=0ul,
    .ok_relocate_descr=0, .ok_init=0,
    .ok_mark_unconditionally=0, .ok_disclaim_proc=((signed int (*)(void *))NULL) },
    { .ok_freelist=((void **)NULL), .ok_reclaim_list=((struct hblk **)NULL), .ok_descriptor=0ul,
    .ok_relocate_descr=0, .ok_init=0,
    .ok_mark_unconditionally=0, .ok_disclaim_proc=((signed int (*)(void *))NULL) },
    { .ok_freelist=((void **)NULL), .ok_reclaim_list=((struct hblk **)NULL), .ok_descriptor=0ul,
    .ok_relocate_descr=0, .ok_init=0,
    .ok_mark_unconditionally=0, .ok_disclaim_proc=((signed int (*)(void *))NULL) },
    { .ok_freelist=((void **)NULL), .ok_reclaim_list=((struct hblk **)NULL), .ok_descriptor=0ul,
    .ok_relocate_descr=0, .ok_init=0,
    .ok_mark_unconditionally=0, .ok_disclaim_proc=((signed int (*)(void *))NULL) },
    { .ok_freelist=((void **)NULL), .ok_reclaim_list=((struct hblk **)NULL), .ok_descriptor=0ul,
    .ok_relocate_descr=0, .ok_init=0,
    .ok_mark_unconditionally=0, .ok_disclaim_proc=((signed int (*)(void *))NULL) },
    { .ok_freelist=((void **)NULL), .ok_reclaim_list=((struct hblk **)NULL), .ok_descriptor=0ul,
    .ok_relocate_descr=0, .ok_init=0,
    .ok_mark_unconditionally=0, .ok_disclaim_proc=((signed int (*)(void *))NULL) },
    { .ok_freelist=((void **)NULL), .ok_reclaim_list=((struct hblk **)NULL), .ok_descriptor=0ul,
    .ok_relocate_descr=0, .ok_init=0,
    .ok_mark_unconditionally=0, .ok_disclaim_proc=((signed int (*)(void *))NULL) },
    { .ok_freelist=((void **)NULL), .ok_reclaim_list=((struct hblk **)NULL), .ok_descriptor=0ul,
    .ok_relocate_descr=0, .ok_init=0,
    .ok_mark_unconditionally=0, .ok_disclaim_proc=((signed int (*)(void *))NULL) },
    { .ok_freelist=((void **)NULL), .ok_reclaim_list=((struct hblk **)NULL), .ok_descriptor=0ul,
    .ok_relocate_descr=0, .ok_init=0,
    .ok_mark_unconditionally=0, .ok_disclaim_proc=((signed int (*)(void *))NULL) },
    { .ok_freelist=((void **)NULL), .ok_reclaim_list=((struct hblk **)NULL), .ok_descriptor=0ul,
    .ok_relocate_descr=0, .ok_init=0,
    .ok_mark_unconditionally=0, .ok_disclaim_proc=((signed int (*)(void *))NULL) },
    { .ok_freelist=((void **)NULL), .ok_reclaim_list=((struct hblk **)NULL), .ok_descriptor=0ul,
    .ok_relocate_descr=0, .ok_init=0,
    .ok_mark_unconditionally=0, .ok_disclaim_proc=((signed int (*)(void *))NULL) },
    { .ok_freelist=((void **)NULL), .ok_reclaim_list=((struct hblk **)NULL), .ok_descriptor=0ul,
    .ok_relocate_descr=0, .ok_init=0,
    .ok_mark_unconditionally=0, .ok_disclaim_proc=((signed int (*)(void *))NULL) } };
// GC_objects_are_marked
// file mark.c line 120
signed int GC_objects_are_marked = 0;
// GC_objfreelist_ptr
// file mallocx.c line 42
void ** const GC_objfreelist_ptr;
// GC_objfreelist_ptr
// file mallocx.c line 42
void ** const GC_objfreelist_ptr = GC_arrays._objfreelist;
// GC_old_bus_handler
// file os_dep.c line 3010
void (*GC_old_bus_handler)(signed int, struct anonymous$13 *, void *) = ((void (*)(signed int, struct anonymous$13 *, void *))NULL);
// GC_old_dl_entries
// file finalize.c line 637
unsigned long int GC_old_dl_entries = (unsigned long int)0;
// GC_old_ll_entries
// file finalize.c line 639
unsigned long int GC_old_ll_entries = (unsigned long int)0;
// GC_old_normal_bl
// file blacklst.c line 40
unsigned long int *GC_old_normal_bl = (unsigned long int *)(void *)0;
// GC_old_segv_handler
// file os_dep.c line 3007
void (*GC_old_segv_handler)(signed int, struct anonymous$13 *, void *) = ((void (*)(signed int, struct anonymous$13 *, void *))NULL);
// GC_old_segv_handler_used_si
// file os_dep.c line 3014
signed int GC_old_segv_handler_used_si = 0;
// GC_old_stack_bl
// file blacklst.c line 46
unsigned long int *GC_old_stack_bl = (unsigned long int *)(void *)0;
// GC_on_abort
// file misc.c line 1693
void (*GC_on_abort)(const char *);
// GC_on_abort
// file misc.c line 1693
void (*GC_on_abort)(const char *) = GC_default_on_abort;
// GC_on_heap_resize
// file alloc.c line 812
void (*GC_on_heap_resize)(unsigned long int) = ((void (*)(unsigned long int))NULL);
// GC_oom_fn
// file misc.c line 171
void * (*GC_oom_fn)(unsigned long int);
// GC_oom_fn
// file misc.c line 171
void * (*GC_oom_fn)(unsigned long int) = GC_default_oom_fn;
// GC_page_size
// file os_dep.c line 716
unsigned long int GC_page_size = (unsigned long int)0;
// GC_pages_executable
// file os_dep.c line 131
signed int GC_pages_executable = 0;
// GC_parallel
// file alloc.c line 68
signed int GC_parallel = 0;
// GC_print_all_smashed
// file alloc.c line 544
void (*GC_print_all_smashed)(void) = ((void (*)(void))NULL);
// GC_print_back_height
// file misc.c line 101
signed int GC_print_back_height = 0;
// GC_print_heap_obj
// file blacklst.c line 68
void (*GC_print_heap_obj)(char *);
// GC_print_heap_obj
// file blacklst.c line 68
void (*GC_print_heap_obj)(char *) = GC_default_print_heap_obj_proc;
// GC_print_stats
// file misc.c line 95
signed int GC_print_stats = 0;
// GC_push_other_roots
// file os_dep.c line 2607
void (*GC_push_other_roots)(void);
// GC_push_other_roots
// file os_dep.c line 2607
void (*GC_push_other_roots)(void) = GC_default_push_other_roots;
// GC_push_typed_structures
// file mark_rts.c line 705
void (*GC_push_typed_structures)(void) = ((void (*)(void))NULL);
// GC_quiet
// file misc.c line 92
signed int GC_quiet = 0;
// GC_reclaimed_bytes_before_gc
// file misc.c line 538
unsigned long int GC_reclaimed_bytes_before_gc = (unsigned long int)0;
// GC_retry_signals
// file pthread_stop_world.c line 118
signed int GC_retry_signals = 0;
// GC_root_size
// file mark_rts.c line 149
unsigned long int GC_root_size = (unsigned long int)0;
// GC_same_obj_print_proc
// file ptr_chck.c line 27
void (*GC_same_obj_print_proc)(void *, void *);
// GC_same_obj_print_proc
// file ptr_chck.c line 27
void (*GC_same_obj_print_proc)(void *, void *) = GC_default_same_obj_print_proc;
// GC_sig_suspend
// file pthread_stop_world.c line 150
signed int GC_sig_suspend = -1;
// GC_sig_thr_restart
// file pthread_stop_world.c line 151
signed int GC_sig_thr_restart = -1;
// GC_smashed
// file dbg_mlc.c line 942
char *GC_smashed[20l] = { ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL) };
// GC_stackbottom
// file misc.c line 82
char *GC_stackbottom = ((char *)NULL);
// GC_start_call_back
// file alloc.c line 311
void (*GC_start_call_back)(void) = ((void (*)(void))NULL);
// GC_start_time
// file alloc.c line 138
signed long int GC_start_time = (signed long int)0;
// GC_stderr
// file misc.c line 783
signed int GC_stderr = 2;
// GC_stdout
// file misc.c line 782
signed int GC_stdout = 1;
// GC_stop_count
// file pthread_stop_world.c line 106
volatile unsigned long int GC_stop_count = (volatile unsigned long int)0;
// GC_suspend_ack_sem
// file pthread_stop_world.c line 194
union anonymous$8 GC_suspend_ack_sem;
// GC_thr_initialized
// file pthread_support.c line 452
signed int GC_thr_initialized = 0;
// GC_thread_key
// file thread_local_alloc.c line 31
void *GC_thread_key;
// GC_threads
// file pthread_support.c line 454
struct GC_Thread_Rep * volatile GC_threads[256l] = { ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL), ((struct GC_Thread_Rep *)NULL) };
// GC_time_limit
// file alloc.c line 135
unsigned long int GC_time_limit = (unsigned long int)50;
// GC_total_stack_black_listed
// file blacklst.c line 49
unsigned long int GC_total_stack_black_listed = (unsigned long int)0;
// GC_total_stacksize
// file alloc.c line 194
unsigned long int GC_total_stacksize = (unsigned long int)0;
// GC_typed_mark_proc_index
// file typd_mlc.c line 100
signed int GC_typed_mark_proc_index = 0;
// GC_uobjfreelist_ptr
// file mallocx.c line 44
void ** const GC_uobjfreelist_ptr;
// GC_uobjfreelist_ptr
// file mallocx.c line 44
void ** const GC_uobjfreelist_ptr = GC_arrays._uobjfreelist;
// GC_use_entire_heap
// file allchblk.c line 24
signed int GC_use_entire_heap = 0;
// GC_used_heap_size_after_full
// file alloc.c line 86
unsigned long int GC_used_heap_size_after_full = (unsigned long int)0;
// GC_version
// file alloc.c line 101
const unsigned int GC_version = (const unsigned int)(7 << 16 | 4 << 8 | 2);
// GC_world_is_stopped
// file pthread_stop_world.c line 109
volatile unsigned long int GC_world_is_stopped = (volatile unsigned long int)0;
// GC_world_stopped
// file alloc.c line 83
signed int GC_world_stopped = 0;
// _DYNAMIC
// file /usr/include/link.h line 76
extern struct anonymous$21 _DYNAMIC[];
// __data_start
// file os_dep.c line 442
extern signed int __data_start[];
// __libc_stack_end
// file os_dep.c line 1037
extern char *__libc_stack_end;
// _end
// file ./include/private/gcconfig.h line 2247
extern signed int _end[];
// available_markers_m1
// file pthread_support.c line 396
static signed int available_markers_m1 = 0;
// available_markers_m1$link1
// file pthread_support.c line 396
static signed int available_markers_m1$link1 = 0;
// builder_cv
// file pthread_support.c line 1980
static union anonymous$10 builder_cv = { .__data={ .__lock=0, .__futex=(unsigned int)0, .__total_seq=(unsigned long long int)0, .__wakeup_seq=(unsigned long long int)0,
    .__woken_seq=(unsigned long long int)0,
    .__mutex=(void *)0,
    .__nwaiters=(unsigned int)0, .__broadcast_seq=(unsigned int)0 } };
// builder_cv$link1
// file pthread_support.c line 1980
static union anonymous$10 builder_cv$link1 = { .__data={ .__lock=0, .__futex=(unsigned int)0, .__total_seq=(unsigned long long int)0, .__wakeup_seq=(unsigned long long int)0,
    .__woken_seq=(unsigned long long int)0,
    .__mutex=(void *)0,
    .__nwaiters=(unsigned int)0, .__broadcast_seq=(unsigned int)0 } };
// count
// file cord/tests/cordtest.c line 26
signed int count;
// data_start
// file os_dep.c line 442
extern signed int data_start[];
// done_init
// file fnlz_mlc.c line 48
static signed int done_init = 0;
// done_init$link1
// file fnlz_mlc.c line 48
static signed int done_init$link1 = 0;
// first_thread
// file pthread_support.c line 485
static struct GC_Thread_Rep first_thread;
// first_thread$link1
// file pthread_support.c line 485
static struct GC_Thread_Rep first_thread$link1;
// fork_cancel_state
// file pthread_support.c line 944
static signed int fork_cancel_state;
// fork_cancel_state$link1
// file pthread_support.c line 944
static signed int fork_cancel_state$link1;
// hdr_free_list
// file headers.c line 161
static struct hblkhdr *hdr_free_list = ((struct hblkhdr *)NULL);
// hdr_free_list$link1
// file headers.c line 161
static struct hblkhdr *hdr_free_list$link1 = ((struct hblkhdr *)NULL);
// installed_looping_handler
// file misc.c line 761
static signed int installed_looping_handler = 0;
// installed_looping_handler$link1
// file misc.c line 761
static signed int installed_looping_handler$link1 = 0;
// keys_initialized
// file thread_local_alloc.c line 33
static signed int keys_initialized;
// keys_initialized$link1
// file thread_local_alloc.c line 33
static signed int keys_initialized$link1;
// last_bytes_finalized
// file alloc.c line 1243
static unsigned long int last_bytes_finalized = (unsigned long int)0;
// last_bytes_finalized$link1
// file alloc.c line 1243
static unsigned long int last_bytes_finalized$link1 = (unsigned long int)0;
// last_finalizer_notification
// file finalize.c line 1010
static unsigned long int last_finalizer_notification = (unsigned long int)0;
// last_finalizer_notification$link1
// file finalize.c line 1010
static unsigned long int last_finalizer_notification$link1 = (unsigned long int)0;
// last_fo_entries
// file alloc.c line 1242
static unsigned long int last_fo_entries = (unsigned long int)0;
// last_fo_entries$link1
// file alloc.c line 1242
static unsigned long int last_fo_entries$link1 = (unsigned long int)0;
// load_segs
// file dyn_load.c line 464
static struct load_segment load_segs[2048l];
// load_segs$link1
// file dyn_load.c line 464
static struct load_segment load_segs$link1[2048l];
// log_fo_table_size
// file finalize.c line 75
static signed long int log_fo_table_size = (signed long int)-1;
// log_fo_table_size$link1
// file finalize.c line 75
static signed long int log_fo_table_size$link1 = (signed long int)-1;
// mark_cv
// file pthread_support.c line 2030
static union anonymous$10 mark_cv = { .__data={ .__lock=0, .__futex=(unsigned int)0, .__total_seq=(unsigned long long int)0, .__wakeup_seq=(unsigned long long int)0,
    .__woken_seq=(unsigned long long int)0,
    .__mutex=(void *)0,
    .__nwaiters=(unsigned int)0, .__broadcast_seq=(unsigned int)0 } };
// mark_cv$link1
// file pthread_support.c line 2030
static union anonymous$10 mark_cv$link1 = { .__data={ .__lock=0, .__futex=(unsigned int)0, .__total_seq=(unsigned long long int)0, .__wakeup_seq=(unsigned long long int)0,
    .__woken_seq=(unsigned long long int)0,
    .__mutex=(void *)0,
    .__nwaiters=(unsigned int)0, .__broadcast_seq=(unsigned int)0 } };
// mark_mutex
// file pthread_support.c line 1977
static union anonymous$7 mark_mutex = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// mark_mutex$link1
// file pthread_support.c line 1977
static union anonymous$7 mark_mutex$link1 = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// marker_sp
// file pthread_support.c line 336
static char *marker_sp[15l] = { ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL) };
// marker_sp$link1
// file pthread_support.c line 336
static char *marker_sp$link1[15l] = { ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL) };
// min_len
// file cord/cordbscs.c line 589
static unsigned long int min_len[48l];
// min_len_init
// file cord/cordbscs.c line 591
static signed int min_len_init = 0;
// n_load_segs
// file dyn_load.c line 466
static signed int n_load_segs;
// n_load_segs$link1
// file dyn_load.c line 466
static signed int n_load_segs$link1;
// n_root_sets
// file mark_rts.c line 39
static signed int n_root_sets = 0;
// n_root_sets$link1
// file mark_rts.c line 39
static signed int n_root_sets$link1 = 0;
// need_unreachable_finalization
// file finalize.c line 579
static signed int need_unreachable_finalization = 0;
// need_unreachable_finalization$link1
// file finalize.c line 579
static signed int need_unreachable_finalization$link1 = 0;
// old_bus_handler
// file os_dep.c line 872
static void (*old_bus_handler)(signed int);
// old_bus_handler$link1
// file os_dep.c line 872
static void (*old_bus_handler$link1)(signed int);
// old_segv_handler
// file os_dep.c line 870
static void (*old_segv_handler)(signed int);
// old_segv_handler$link1
// file os_dep.c line 870
static void (*old_segv_handler$link1)(signed int);
// parallel_initialized
// file pthread_support.c line 275
static signed int parallel_initialized = 0;
// parallel_initialized$link1
// file pthread_support.c line 275
static signed int parallel_initialized$link1 = 0;
// roots_were_cleared
// file mark_rts.c line 263
static signed int roots_were_cleared = 0;
// roots_were_cleared$link1
// file mark_rts.c line 263
static signed int roots_were_cleared$link1 = 0;
// scan_ptr
// file mark.c line 118
static struct hblk *scan_ptr;
// scan_ptr$link1
// file mark.c line 118
static struct hblk *scan_ptr$link1;
// scratch_free_ptr
// file headers.c line 113
static char *scratch_free_ptr = ((char *)NULL);
// scratch_free_ptr$link1
// file headers.c line 113
static char *scratch_free_ptr$link1 = ((char *)NULL);
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// stdout
// file /usr/include/stdio.h line 169
extern struct _IO_FILE *stdout;
// suspend_handler_mask
// file pthread_stop_world.c line 104
static struct anonymous$6 suspend_handler_mask;
// suspend_handler_mask$link1
// file pthread_stop_world.c line 104
static struct anonymous$6 suspend_handler_mask$link1;
// world_stopped_total_divisor
// file alloc.c line 564
static unsigned int world_stopped_total_divisor = (unsigned int)0;
// world_stopped_total_divisor$link1
// file alloc.c line 564
static unsigned int world_stopped_total_divisor$link1 = (unsigned int)0;
// world_stopped_total_time
// file alloc.c line 563
static unsigned int world_stopped_total_time = (unsigned int)0;
// world_stopped_total_time$link1
// file alloc.c line 563
static unsigned int world_stopped_total_time$link1 = (unsigned int)0;
// zero_fd
// file os_dep.c line 2028
static signed int zero_fd;
// zero_fd$link1
// file os_dep.c line 2028
static signed int zero_fd$link1;

// AO_char_store
// file /usr/include/atomic_ops/sysdeps/loadstore/char_atomic_store.h line 28
static inline void AO_char_store(volatile unsigned char *addr, unsigned char new_val)
{
  *((unsigned char *)addr) = new_val;
}

// AO_char_store$link1
// file /usr/include/atomic_ops/sysdeps/loadstore/char_atomic_store.h line 28
static inline void AO_char_store$link1(volatile unsigned char *addr$link1, unsigned char new_val$link1)
{
  *((unsigned char *)addr$link1) = new_val$link1;
}

// AO_compare_and_swap_full
// file /usr/include/atomic_ops/sysdeps/gcc/x86.h line 139
static inline signed int AO_compare_and_swap_full(volatile unsigned long int *addr, unsigned long int old, unsigned long int new_val)
{
  _Bool return_value___sync_bool_compare_and_swap$1;
  __CPROVER_atomic_begin();
  return_value___sync_bool_compare_and_swap$1 = *addr == old;
  *addr = *addr == old ? new_val : *addr;
  FENCE(WRfence);
  __CPROVER_atomic_end();
  return (signed int)return_value___sync_bool_compare_and_swap$1;
}

// AO_compare_and_swap_full$link1
// file /usr/include/atomic_ops/sysdeps/gcc/x86.h line 139
static inline signed int AO_compare_and_swap_full$link1(volatile unsigned long int *addr$link1, unsigned long int old$link1, unsigned long int new_val$link1)
{
  _Bool return_value___sync_bool_compare_and_swap$1$link1;
  __CPROVER_atomic_begin();
  return_value___sync_bool_compare_and_swap$1$link1 = *addr$link1 == old$link1;
  *addr$link1 = *addr$link1 == old$link1 ? new_val$link1 : *addr$link1;
  FENCE(WRfence);
  __CPROVER_atomic_end();
  return (signed int)return_value___sync_bool_compare_and_swap$1$link1;
}

// AO_compare_and_swap_full$link1$link1
// file /usr/include/atomic_ops/sysdeps/gcc/x86.h line 139
static inline signed int AO_compare_and_swap_full$link1$link1(volatile unsigned long int *addr$link1$link1, unsigned long int old$link1$link1, unsigned long int new_val$link1$link1)
{
  _Bool return_value___sync_bool_compare_and_swap$1$link1$link1;
  __CPROVER_atomic_begin();
  return_value___sync_bool_compare_and_swap$1$link1$link1 = *addr$link1$link1 == old$link1$link1;
  *addr$link1$link1 = *addr$link1$link1 == old$link1$link1 ? new_val$link1$link1 : *addr$link1$link1;
  FENCE(WRfence);
  __CPROVER_atomic_end();
  return (signed int)return_value___sync_bool_compare_and_swap$1$link1$link1;
}

// AO_compare_and_swap_full$link2
// file /usr/include/atomic_ops/sysdeps/gcc/x86.h line 139
static inline signed int AO_compare_and_swap_full$link2(volatile unsigned long int *addr$link2, unsigned long int old$link2, unsigned long int new_val$link2)
{
  _Bool return_value___sync_bool_compare_and_swap$1$link2;
  __CPROVER_atomic_begin();
  return_value___sync_bool_compare_and_swap$1$link2 = *addr$link2 == old$link2;
  *addr$link2 = *addr$link2 == old$link2 ? new_val$link2 : *addr$link2;
  FENCE(WRfence);
  __CPROVER_atomic_end();
  return (signed int)return_value___sync_bool_compare_and_swap$1$link2;
}

// AO_fetch_and_add
// file /usr/include/atomic_ops/generalize-arithm.h line 2726
static inline unsigned long int AO_fetch_and_add(volatile unsigned long int *addr, unsigned long int incr)
{
  unsigned long int old;
  signed int return_value_AO_compare_and_swap_full$1;
  do
  {
    old = *((unsigned long int *)addr);
    return_value_AO_compare_and_swap_full$1=AO_compare_and_swap_full(addr, old, old + incr);
  }
  while(return_value_AO_compare_and_swap_full$1 == 0);
  return old;
}

// AO_fetch_and_add$link1
// file /usr/include/atomic_ops/generalize-arithm.h line 2726
static inline unsigned long int AO_fetch_and_add$link1(volatile unsigned long int *addr$link1, unsigned long int incr$link1)
{
  unsigned long int old$link1;
  signed int return_value_AO_compare_and_swap_full$1$link1;
  do
  {
    old$link1 = *((unsigned long int *)addr$link1);
    return_value_AO_compare_and_swap_full$1$link1=AO_compare_and_swap_full$link2(addr$link1, old$link1, old$link1 + incr$link1);
  }
  while(return_value_AO_compare_and_swap_full$1$link1 == 0);
  return old$link1;
}

// AO_load
// file /usr/include/atomic_ops/sysdeps/loadstore/atomic_load.h line 28
static inline unsigned long int AO_load(const volatile unsigned long int *addr)
{
  /* assertion ((size_t)addr & (sizeof(*addr) - 1)) == 0 */
  assert(((unsigned long int)addr & sizeof(const volatile unsigned long int) /*8ul*/  - (unsigned long int)1) == (unsigned long int)0);
  return *((const unsigned long int *)addr);
}

// AO_load$link1
// file /usr/include/atomic_ops/sysdeps/loadstore/atomic_load.h line 28
static inline unsigned long int AO_load$link1(const volatile unsigned long int *addr$link1)
{
  /* assertion ((size_t)addr & (sizeof(*addr) - 1)) == 0 */
  assert(((unsigned long int)addr$link1 & sizeof(const volatile unsigned long int) /*8ul*/  - (unsigned long int)1) == (unsigned long int)0);
  return *((const unsigned long int *)addr$link1);
}

// AO_load$link1$link1
// file /usr/include/atomic_ops/sysdeps/loadstore/atomic_load.h line 28
static inline unsigned long int AO_load$link1$link1(const volatile unsigned long int *addr$link1$link1)
{
  /* assertion ((size_t)addr & (sizeof(*addr) - 1)) == 0 */
  assert(((unsigned long int)addr$link1$link1 & sizeof(const volatile unsigned long int) /*8ul*/  - (unsigned long int)1) == (unsigned long int)0);
  return *((const unsigned long int *)addr$link1$link1);
}

// AO_load$link2
// file /usr/include/atomic_ops/sysdeps/loadstore/atomic_load.h line 28
static inline unsigned long int AO_load$link2(const volatile unsigned long int *addr$link2)
{
  /* assertion ((size_t)addr & (sizeof(*addr) - 1)) == 0 */
  assert(((unsigned long int)addr$link2 & sizeof(const volatile unsigned long int) /*8ul*/  - (unsigned long int)1) == (unsigned long int)0);
  return *((const unsigned long int *)addr$link2);
}

// AO_load$link2$link1
// file /usr/include/atomic_ops/sysdeps/loadstore/atomic_load.h line 28
static inline unsigned long int AO_load$link2$link1(const volatile unsigned long int *addr$link2$link1)
{
  /* assertion ((size_t)addr & (sizeof(*addr) - 1)) == 0 */
  assert(((unsigned long int)addr$link2$link1 & sizeof(const volatile unsigned long int) /*8ul*/  - (unsigned long int)1) == (unsigned long int)0);
  return *((const unsigned long int *)addr$link2$link1);
}

// AO_load$link3
// file /usr/include/atomic_ops/sysdeps/loadstore/atomic_load.h line 28
static inline unsigned long int AO_load$link3(const volatile unsigned long int *addr$link3)
{
  /* assertion ((size_t)addr & (sizeof(*addr) - 1)) == 0 */
  assert(((unsigned long int)addr$link3 & sizeof(const volatile unsigned long int) /*8ul*/  - (unsigned long int)1) == (unsigned long int)0);
  return *((const unsigned long int *)addr$link3);
}

// AO_load$link3$link1
// file /usr/include/atomic_ops/sysdeps/loadstore/atomic_load.h line 28
static inline unsigned long int AO_load$link3$link1(const volatile unsigned long int *addr$link3$link1)
{
  /* assertion ((size_t)addr & (sizeof(*addr) - 1)) == 0 */
  assert(((unsigned long int)addr$link3$link1 & sizeof(const volatile unsigned long int) /*8ul*/  - (unsigned long int)1) == (unsigned long int)0);
  return *((const unsigned long int *)addr$link3$link1);
}

// AO_load$link4
// file /usr/include/atomic_ops/sysdeps/loadstore/atomic_load.h line 28
static inline unsigned long int AO_load$link4(const volatile unsigned long int *addr$link4)
{
  /* assertion ((size_t)addr & (sizeof(*addr) - 1)) == 0 */
  assert(((unsigned long int)addr$link4 & sizeof(const volatile unsigned long int) /*8ul*/  - (unsigned long int)1) == (unsigned long int)0);
  return *((const unsigned long int *)addr$link4);
}

// AO_load_read
// file /usr/include/atomic_ops/generalize-small.h line 1856
static inline unsigned long int AO_load_read(const volatile unsigned long int *addr)
{
  unsigned long int result;
  result=AO_load$link1(addr);
  AO_nop_read();
  return result;
}

// AO_load_read$link1
// file /usr/include/atomic_ops/generalize-small.h line 1856
static inline unsigned long int AO_load_read$link1(const volatile unsigned long int *addr$link1)
{
  unsigned long int result$link1;
  result$link1=AO_load$link3(addr$link1);
  AO_nop_read$link1();
  return result$link1;
}

// AO_load_read$link1$link1
// file /usr/include/atomic_ops/generalize-small.h line 1856
static inline unsigned long int AO_load_read$link1$link1(const volatile unsigned long int *addr$link1$link1)
{
  unsigned long int result$link1$link1;
  result$link1$link1=AO_load$link3$link1(addr$link1$link1);
  AO_nop_read$link1$link1();
  return result$link1$link1;
}

// AO_load_read$link2
// file /usr/include/atomic_ops/generalize-small.h line 1856
static inline unsigned long int AO_load_read$link2(const volatile unsigned long int *addr$link2)
{
  unsigned long int result$link2;
  result$link2=AO_load$link1$link1(addr$link2);
  AO_nop_read$link2();
  return result$link2;
}

// AO_nop_read
// file /usr/include/atomic_ops/sysdeps/read_ordered.h line 31
static inline void AO_nop_read(void)
{
  asm("" :  :  : "memory");
}

// AO_nop_read$link1
// file /usr/include/atomic_ops/sysdeps/read_ordered.h line 31
static inline void AO_nop_read$link1(void)
{
  asm("" :  :  : "memory");
}

// AO_nop_read$link1$link1
// file /usr/include/atomic_ops/sysdeps/read_ordered.h line 31
static inline void AO_nop_read$link1$link1(void)
{
  asm("" :  :  : "memory");
}

// AO_nop_read$link2
// file /usr/include/atomic_ops/sysdeps/read_ordered.h line 31
static inline void AO_nop_read$link2(void)
{
  asm("" :  :  : "memory");
}

// AO_nop_write
// file /usr/include/atomic_ops/sysdeps/ordered_except_wr.h line 33
static inline void AO_nop_write(void)
{
  asm("" :  :  : "memory");
}

// AO_nop_write$link1
// file /usr/include/atomic_ops/sysdeps/ordered_except_wr.h line 33
static inline void AO_nop_write$link1(void)
{
  asm("" :  :  : "memory");
}

// AO_nop_write$link1$link1
// file /usr/include/atomic_ops/sysdeps/ordered_except_wr.h line 33
static inline void AO_nop_write$link1$link1(void)
{
  asm("" :  :  : "memory");
}

// AO_nop_write$link2
// file /usr/include/atomic_ops/sysdeps/ordered_except_wr.h line 33
static inline void AO_nop_write$link2(void)
{
  asm("" :  :  : "memory");
}

// AO_nop_write$link2$link1
// file /usr/include/atomic_ops/sysdeps/ordered_except_wr.h line 33
static inline void AO_nop_write$link2$link1(void)
{
  asm("" :  :  : "memory");
}

// AO_nop_write$link3
// file /usr/include/atomic_ops/sysdeps/ordered_except_wr.h line 33
static inline void AO_nop_write$link3(void)
{
  asm("" :  :  : "memory");
}

// AO_store
// file /usr/include/atomic_ops/sysdeps/loadstore/atomic_store.h line 28
static inline void AO_store(volatile unsigned long int *addr, unsigned long int new_val)
{
  /* assertion ((size_t)addr & (sizeof(*addr) - 1)) == 0 */
  assert(((unsigned long int)addr & sizeof(volatile unsigned long int) /*8ul*/  - (unsigned long int)1) == (unsigned long int)0);
  *((unsigned long int *)addr) = new_val;
}

// AO_store$link1
// file /usr/include/atomic_ops/sysdeps/loadstore/atomic_store.h line 28
static inline void AO_store$link1(volatile unsigned long int *addr$link1, unsigned long int new_val$link1)
{
  /* assertion ((size_t)addr & (sizeof(*addr) - 1)) == 0 */
  assert(((unsigned long int)addr$link1 & sizeof(volatile unsigned long int) /*8ul*/  - (unsigned long int)1) == (unsigned long int)0);
  *((unsigned long int *)addr$link1) = new_val$link1;
}

// AO_store$link1$link1
// file /usr/include/atomic_ops/sysdeps/loadstore/atomic_store.h line 28
static inline void AO_store$link1$link1(volatile unsigned long int *addr$link1$link1, unsigned long int new_val$link1$link1)
{
  /* assertion ((size_t)addr & (sizeof(*addr) - 1)) == 0 */
  assert(((unsigned long int)addr$link1$link1 & sizeof(volatile unsigned long int) /*8ul*/  - (unsigned long int)1) == (unsigned long int)0);
  *((unsigned long int *)addr$link1$link1) = new_val$link1$link1;
}

// AO_store$link2
// file /usr/include/atomic_ops/sysdeps/loadstore/atomic_store.h line 28
static inline void AO_store$link2(volatile unsigned long int *addr$link2, unsigned long int new_val$link2)
{
  /* assertion ((size_t)addr & (sizeof(*addr) - 1)) == 0 */
  assert(((unsigned long int)addr$link2 & sizeof(volatile unsigned long int) /*8ul*/  - (unsigned long int)1) == (unsigned long int)0);
  *((unsigned long int *)addr$link2) = new_val$link2;
}

// AO_store$link2$link1
// file /usr/include/atomic_ops/sysdeps/loadstore/atomic_store.h line 28
static inline void AO_store$link2$link1(volatile unsigned long int *addr$link2$link1, unsigned long int new_val$link2$link1)
{
  /* assertion ((size_t)addr & (sizeof(*addr) - 1)) == 0 */
  assert(((unsigned long int)addr$link2$link1 & sizeof(volatile unsigned long int) /*8ul*/  - (unsigned long int)1) == (unsigned long int)0);
  *((unsigned long int *)addr$link2$link1) = new_val$link2$link1;
}

// AO_store$link3
// file /usr/include/atomic_ops/sysdeps/loadstore/atomic_store.h line 28
static inline void AO_store$link3(volatile unsigned long int *addr$link3, unsigned long int new_val$link3)
{
  /* assertion ((size_t)addr & (sizeof(*addr) - 1)) == 0 */
  assert(((unsigned long int)addr$link3 & sizeof(volatile unsigned long int) /*8ul*/  - (unsigned long int)1) == (unsigned long int)0);
  *((unsigned long int *)addr$link3) = new_val$link3;
}

// AO_test_and_set_full
// file /usr/include/atomic_ops/sysdeps/gcc/x86.h line 124
static inline enum anonymous$15 AO_test_and_set_full(volatile unsigned char *addr)
{
  unsigned char oldval;
  asm("xchgb %0, %1" : "=q"(oldval), "=m"(*addr) : "0"((unsigned char)0xff), "m"(*addr) : "memory");
  return (enum anonymous$15)oldval;
}

// AO_test_and_set_full$link1
// file /usr/include/atomic_ops/sysdeps/gcc/x86.h line 124
static inline enum anonymous$15 AO_test_and_set_full$link1(volatile unsigned char *addr$link1)
{
  unsigned char oldval$link1;
  asm("xchgb %0, %1" : "=q"(oldval$link1), "=m"(*addr$link1) : "0"((unsigned char)0xff), "m"(*addr$link1) : "memory");
  return (enum anonymous$15)oldval$link1;
}

// CORD__extend_path
// file cord/cordbscs.c line 734
void CORD__extend_path(struct CORD_Pos *p)
{
  struct CORD_pe *current_pe = &(p + (signed long int)0)->path[(signed long int)(p + (signed long int)0)->path_len];
  const char *top = current_pe->pe_cord;
  unsigned long int pos = (p + (signed long int)0)->cur_pos;
  unsigned long int top_pos = current_pe->pe_start_pos;
  unsigned long int top_len;
  unsigned long int tmp_if_expr$2;
  unsigned long int return_value_strlen$1;
  if(!((signed int)*top == 0))
  {
    return_value_strlen$1=strlen(top);
    tmp_if_expr$2 = return_value_strlen$1;
  }

  else
    tmp_if_expr$2 = ((union anonymous *)top)->generic.len;
  top_len = tmp_if_expr$2;
  unsigned long int tmp_if_expr$5;
  unsigned long int tmp_if_expr$4;
  unsigned long int return_value_strlen$3;
  while((signed int)*top == 0)
  {
    if(!((signed int)((union anonymous *)top)->generic.header == 1))
      break;

    struct Concatenation *conc = &((union anonymous *)top)->concatenation;
    unsigned long int left_len;
    unsigned long int tmp_if_expr$6;
    if(!((signed int)conc->left_len == 0))
      tmp_if_expr$6 = (unsigned long int)conc->left_len;

    else
    {
      if(!((signed int)*conc->left == 0))
      {
        if(!((signed int)*conc->right == 0))
        {
          return_value_strlen$3=strlen(conc->right);
          tmp_if_expr$4 = return_value_strlen$3;
        }

        else
          tmp_if_expr$4 = ((union anonymous *)conc->right)->generic.len;
        tmp_if_expr$5 = conc->len - tmp_if_expr$4;
      }

      else
        tmp_if_expr$5 = ((union anonymous *)conc->left)->generic.len;
      tmp_if_expr$6 = tmp_if_expr$5;
    }
    left_len = tmp_if_expr$6;
    current_pe = current_pe + 1l;
    if(pos >= left_len + top_pos)
    {
      top = conc->right;
      current_pe->pe_cord = top;
      top_pos = top_pos + left_len;
      current_pe->pe_start_pos = top_pos;
      top_len = top_len - left_len;
    }

    else
    {
      top = conc->left;
      current_pe->pe_cord = top;
      current_pe->pe_start_pos = top_pos;
      top_len = left_len;
    }
    (p + (signed long int)0)->path_len = (p + (signed long int)0)->path_len + 1;
  }
  if(!((signed int)*top == 0))
  {
    (p + (signed long int)0)->cur_leaf = top;
    (p + (signed long int)0)->cur_start = top_pos;
    (p + (signed long int)0)->cur_end = top_pos + top_len;
  }

  else
    (p + (signed long int)0)->cur_end = (unsigned long int)0;
  if(pos >= top_len + top_pos)
    (p + (signed long int)0)->path_len = 0x55555555;

}

// CORD__next
// file ./include/cord_pos.h line 84
extern void CORD__next(struct CORD_Pos *p)
{
  unsigned long int cur_pos = (p + (signed long int)0)->cur_pos + (unsigned long int)1;
  struct CORD_pe *current_pe = &(p + (signed long int)0)->path[(signed long int)(p + (signed long int)0)->path_len];
  const char *leaf = current_pe->pe_cord;
  (p + (signed long int)0)->cur_pos = cur_pos;
  if((signed int)*leaf == 0)
  {
    struct Function *f = &((union anonymous *)leaf)->function;
    unsigned long int start_pos = current_pe->pe_start_pos;
    unsigned long int end_pos = start_pos + f->len;
    if(!(cur_pos >= end_pos))
    {
      unsigned long int i;
      unsigned long int limit = cur_pos + (unsigned long int)8;
      char (*fn)(unsigned long int, void *) = f->fn;
      void *client_data = f->client_data;
      if(!(end_pos >= limit))
        limit = end_pos;

      i = cur_pos;
      if(!(i >= limit))
      {
        (p + (signed long int)0)->function_buf[(signed long int)(i - cur_pos)]=fn(i - start_pos, client_data);
        i = i + 1ul;
      }

      (p + (signed long int)0)->cur_start = cur_pos;
      (p + (signed long int)0)->cur_leaf = (p + (signed long int)0)->function_buf;
      (p + (signed long int)0)->cur_end = limit;
      goto __CPROVER_DUMP_L8;
    }

  }

  for( ; p->path_len >= 1; current_pe = current_pe - 1l)
  {
    if(current_pe->pe_start_pos == (current_pe + -1l)->pe_start_pos)
      break;

    (p + (signed long int)0)->path_len = (p + (signed long int)0)->path_len - 1;
  }
  if(p->path_len == 0)
    (p + (signed long int)0)->path_len = 0x55555555;

  else
  {
    (p + (signed long int)0)->path_len = (p + (signed long int)0)->path_len - 1;
    CORD__extend_path(p);
  }

__CPROVER_DUMP_L8:
  ;
}

// CORD__pos_fetch
// file ./include/cord_pos.h line 83
extern char CORD__pos_fetch(struct CORD_Pos *p)
{
  struct CORD_pe *pe = &(p + (signed long int)0)->path[(signed long int)(p + (signed long int)0)->path_len];
  const char *leaf = pe->pe_cord;
  struct Function *f = &((union anonymous *)leaf)->function;
  if((4 & (signed int)((union anonymous *)leaf)->generic.header) == 0)
  {
    fprintf(stderr, "%s\n", (const void *)"CORD_pos_fetch: bad leaf");
    abort();
  }

  char return_value;
  return_value=f->fn((p + (signed long int)0)->cur_pos - pe->pe_start_pos, f->client_data);
  return return_value;
}

// CORD__prev
// file cord/cordbscs.c line 835
extern void CORD__prev(struct CORD_Pos *p)
{
  struct CORD_pe *pe = &(p + (signed long int)0)->path[(signed long int)(p + (signed long int)0)->path_len];
  if(p->cur_pos == 0ul)
    (p + (signed long int)0)->path_len = 0x55555555;

  else
  {
    (p + (signed long int)0)->cur_pos = (p + (signed long int)0)->cur_pos - 1ul;
    if(!(p->cur_pos >= pe->pe_start_pos))
    {
      struct CORD_pe *current_pe = &(p + (signed long int)0)->path[(signed long int)(p + (signed long int)0)->path_len];
      for( ; p->path_len >= 1; current_pe = current_pe - 1l)
      {
        if(!(current_pe->pe_start_pos == (current_pe + -1l)->pe_start_pos))
          break;

        (p + (signed long int)0)->path_len = (p + (signed long int)0)->path_len - 1;
      }
      (p + (signed long int)0)->path_len = (p + (signed long int)0)->path_len - 1;
      CORD__extend_path(p);
    }

  }
}

// CORD_add_forest
// file cord/cordbscs.c line 636
void CORD_add_forest(struct anonymous$0 *forest, const char *x, unsigned long int len)
{
  signed int i = 0;
  const char *sum = ((const char *)NULL);
  unsigned long int sum_len = (unsigned long int)0;
  for( ; !(min_len[(signed long int)(1 + i)] >= len); i = i + 1)
    if(!((forest + (signed long int)i)->c == ((const char *)NULL)))
    {
      sum=CORD_cat((forest + (signed long int)i)->c, sum);
      sum_len = sum_len + (forest + (signed long int)i)->len;
      (forest + (signed long int)i)->c = ((const char *)NULL);
    }

  sum=CORD_cat(sum, x);
  sum_len = sum_len + len;
  for( ; sum_len >= min_len[(signed long int)i]; i = i + 1)
    if(!((forest + (signed long int)i)->c == ((const char *)NULL)))
    {
      sum=CORD_cat((forest + (signed long int)i)->c, sum);
      sum_len = sum_len + (forest + (signed long int)i)->len;
      (forest + (signed long int)i)->c = ((const char *)NULL);
    }

  i = i - 1;
  (forest + (signed long int)i)->c = sum;
  (forest + (signed long int)i)->len = sum_len;
}

// CORD_apply_access_fn
// file cord/cordbscs.c line 336
char CORD_apply_access_fn(unsigned long int i, void *client_data)
{
  struct substr_args *descr = (struct substr_args *)client_data;
  struct Function *fn_cord = &descr->sa_cord->function;
  char return_value;
  return_value=fn_cord->fn(i + descr->sa_index, fn_cord->client_data);
  return return_value;
}

// CORD_balance
// file ./include/cord.h line 134
extern const char * CORD_balance(const char *x)
{
  struct anonymous$0 forest[48l];
  unsigned long int len;
  if(x == ((const char *)NULL))
    return ((const char *)NULL);

  else
    if(!((signed int)*x == 0))
      return x;

    else
    {
      if(min_len_init == 0)
        CORD_init_min_len();

      len = ((union anonymous *)x)->generic.len;
      CORD_init_forest(forest, len);
      CORD_balance_insert(x, len, forest);
      const char *return_value_CORD_concat_forest$1;
      return_value_CORD_concat_forest$1=CORD_concat_forest(forest, len);
      return return_value_CORD_concat_forest$1;
    }
}

// CORD_balance_insert
// file cord/cordbscs.c line 691
void CORD_balance_insert(const char *x, unsigned long int len, struct anonymous$0 *forest)
{
  signed int depth;
  _Bool tmp_if_expr$5;
  unsigned long int tmp_if_expr$3;
  unsigned long int tmp_if_expr$2;
  unsigned long int return_value_strlen$1;
  if(!((signed int)*x == 0))
    CORD_add_forest(forest, x, len);

  else
  {
    _Bool tmp_if_expr$6;
    if((signed int)((union anonymous *)x)->generic.header == 1)
    {
      depth = (signed int)((union anonymous *)x)->generic.depth;
      if(depth >= 48)
        tmp_if_expr$5 = (_Bool)1;

      else
        tmp_if_expr$5 = len < min_len[(signed long int)depth] ? (_Bool)1 : (_Bool)0;
      tmp_if_expr$6 = tmp_if_expr$5 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$6 = (_Bool)0;
    if(tmp_if_expr$6)
    {
      struct Concatenation *conc = &((union anonymous *)x)->concatenation;
      unsigned long int left_len;
      unsigned long int tmp_if_expr$4;
      if(!((signed int)conc->left_len == 0))
        tmp_if_expr$4 = (unsigned long int)conc->left_len;

      else
      {
        if(!((signed int)*conc->left == 0))
        {
          if(!((signed int)*conc->right == 0))
          {
            return_value_strlen$1=strlen(conc->right);
            tmp_if_expr$2 = return_value_strlen$1;
          }

          else
            tmp_if_expr$2 = ((union anonymous *)conc->right)->generic.len;
          tmp_if_expr$3 = conc->len - tmp_if_expr$2;
        }

        else
          tmp_if_expr$3 = ((union anonymous *)conc->left)->generic.len;
        tmp_if_expr$4 = tmp_if_expr$3;
      }
      left_len = tmp_if_expr$4;
      CORD_balance_insert(conc->left, left_len, forest);
      CORD_balance_insert(conc->right, len - left_len, forest);
    }

    else
      CORD_add_forest(forest, x, len);
  }
}

// CORD_batched_chr_proc
// file cord/cordxtra.c line 325
signed int CORD_batched_chr_proc(const char *s, void *client_data)
{
  struct anonymous$1 *d = (struct anonymous$1 *)client_data;
  char *occ;
  char *return_value___builtin_strchr$1;
  return_value___builtin_strchr$1=__builtin_strchr(s, (signed int)d->target);
  occ = return_value___builtin_strchr$1;
  if(occ == ((char *)NULL))
  {
    unsigned long int return_value_strlen$2;
    return_value_strlen$2=strlen(s);
    d->pos = d->pos + return_value_strlen$2;
    return 0;
  }

  else
  {
    d->pos = d->pos + (unsigned long int)(occ - s);
    return 1;
  }
}

// CORD_batched_fill_proc
// file cord/cordxtra.c line 119
signed int CORD_batched_fill_proc(const char *s, void *client_data)
{
  struct anonymous$5 *d = (struct anonymous$5 *)client_data;
  unsigned long int CORD_batched_fill_proc$$1$$count = d->count;
  unsigned long int max = d->len;
  char *buf = d->buf;
  const char *t = s;
  const char *tmp_post$1;
  do
  {
    tmp_post$1 = t;
    t = t + 1l;
    buf[(signed long int)CORD_batched_fill_proc$$1$$count] = *tmp_post$1;
    if((signed int)buf[(signed long int)CORD_batched_fill_proc$$1$$count] == 0)
      break;

    CORD_batched_fill_proc$$1$$count = CORD_batched_fill_proc$$1$$count + 1ul;
    if(CORD_batched_fill_proc$$1$$count >= max)
    {
      d->count = CORD_batched_fill_proc$$1$$count;
      return 1;
    }

  }
  while((_Bool)1);
  d->count = CORD_batched_fill_proc$$1$$count;
  return 0;
}

// CORD_batched_put_proc
// file cord/cordxtra.c line 285
signed int CORD_batched_put_proc(const char *s, void *client_data)
{
  struct _IO_FILE *f = (struct _IO_FILE *)client_data;
  signed int return_value_fputs$1;
  return_value_fputs$1=fputs(s, f);
  return (signed int)(return_value_fputs$1 == -1);
}

// CORD_cat
// file ./include/cord.h line 104
extern const char * CORD_cat(const char *x, const char *y)
{
  unsigned long int result_len;
  signed int depth;
  unsigned long int lenx;
  if(x == ((const char *)NULL))
    return y;

  else
    if(y == ((const char *)NULL))
      return x;

    else
    {
      if(!((signed int)*y == 0))
      {
        unsigned long int return_value_strlen$1;
        return_value_strlen$1=strlen(y);
        const char *return_value_CORD_cat_char_star$2;
        return_value_CORD_cat_char_star$2=CORD_cat_char_star(x, y, return_value_strlen$1);
        return return_value_CORD_cat_char_star$2;
      }

      else
        if(!((signed int)*x == 0))
        {
          lenx=strlen(x);
          depth = (signed int)((union anonymous *)y)->generic.depth + 1;
        }

        else
        {
          signed int depthy = (signed int)((union anonymous *)y)->generic.depth;
          lenx = ((union anonymous *)x)->generic.len;
          depth = (signed int)((union anonymous *)x)->generic.depth + 1;
          if(depthy >= depth)
            depth = depthy + 1;

        }
      result_len = lenx + ((union anonymous *)y)->generic.len;
      struct Concatenation *result;
      void *return_value_GC_malloc$3;
      return_value_GC_malloc$3=GC_malloc(sizeof(struct Concatenation) /*32ul*/ );
      result = (struct Concatenation *)return_value_GC_malloc$3;
      if(result == ((struct Concatenation *)NULL))
      {
        if(!(CORD_oom_fn == ((void (*)(void))NULL)))
          CORD_oom_fn();

        fprintf(stderr, "%s\n", (const void *)"Out of memory\n");
        abort();
      }

      result->header = (char)1;
      result->depth = (char)depth;
      if(!(lenx >= 256ul))
        result->left_len = (unsigned char)lenx;

      result->len = result_len;
      result->left = x;
      result->right = y;
      if(depth >= 48)
      {
        const char *return_value_CORD_balance$4;
        return_value_CORD_balance$4=CORD_balance((const char *)result);
        return return_value_CORD_balance$4;
      }

      else
        return (const char *)result;
    }
}

// CORD_cat_char
// file cord/cordxtra.c line 72
extern const char * CORD_cat_char(const char *x, char c)
{
  char *string;
  const char *return_value_CORD_chars$1;
  const char *return_value_CORD_cat$2;
  if((signed int)c == 0)
  {
    return_value_CORD_chars$1=CORD_chars((char)0, (unsigned long int)1);
    return_value_CORD_cat$2=CORD_cat(x, return_value_CORD_chars$1);
    return return_value_CORD_cat$2;
  }

  void *return_value_GC_malloc_atomic$3;
  return_value_GC_malloc_atomic$3=GC_malloc_atomic((unsigned long int)2);
  string = (char *)return_value_GC_malloc_atomic$3;
  if(string == ((char *)NULL))
  {
    if(!(CORD_oom_fn == ((void (*)(void))NULL)))
      CORD_oom_fn();

    fprintf(stderr, "%s\n", (const void *)"Out of memory\n");
    abort();
  }

  string[(signed long int)0] = c;
  string[(signed long int)1] = (char)0;
  const char *return_value_CORD_cat_char_star$4;
  return_value_CORD_cat_char_star$4=CORD_cat_char_star(x, string, (unsigned long int)1);
  return return_value_CORD_cat_char_star$4;
}

// CORD_cat_char_star
// file cord/cordbscs.c line 152
extern const char * CORD_cat_char_star(const char *x, const char *y, unsigned long int leny)
{
  unsigned long int result_len;
  unsigned long int lenx;
  signed int depth;
  if(x == ((const char *)NULL))
    return y;

  else
    if(leny == 0ul)
      return x;

    else
    {
      if(!((signed int)*x == 0))
      {
        lenx=strlen(x);
        result_len = lenx + leny;
        if(!(result_len >= 32ul))
        {
          char *CORD_cat_char_star$$1$$1$$1$$result;
          void *return_value_GC_malloc_atomic$1;
          return_value_GC_malloc_atomic$1=GC_malloc_atomic(result_len + (unsigned long int)1);
          CORD_cat_char_star$$1$$1$$1$$result = (char *)return_value_GC_malloc_atomic$1;
          if(CORD_cat_char_star$$1$$1$$1$$result == ((char *)NULL))
          {
            if(!(CORD_oom_fn == ((void (*)(void))NULL)))
              CORD_oom_fn();

            fprintf(stderr, "%s\n", (const void *)"Out of memory\n");
            abort();
          }

          memcpy((void *)CORD_cat_char_star$$1$$1$$1$$result, (const void *)x, lenx);
          memcpy((void *)(CORD_cat_char_star$$1$$1$$1$$result + (signed long int)lenx), (const void *)y, leny);
          CORD_cat_char_star$$1$$1$$1$$result[(signed long int)result_len] = (char)0;
          return (const char *)CORD_cat_char_star$$1$$1$$1$$result;
        }

        else
          depth = 1;
      }

      else
      {
        const char *right;
        const char *left;
        char *new_right;
        unsigned long int right_len;
        lenx = ((union anonymous *)x)->generic.len;
        _Bool tmp_if_expr$3;
        if(!(leny >= 16ul))
          tmp_if_expr$3 = (signed int)((union anonymous *)x)->generic.header == 1 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$3 = (_Bool)0;
        _Bool tmp_if_expr$4;
        if(tmp_if_expr$3)
        {
          right = ((union anonymous *)x)->concatenation.right;
          tmp_if_expr$4 = (signed int)*right != 0 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr$4 = (_Bool)0;
        if(tmp_if_expr$4)
        {
          left = ((union anonymous *)x)->concatenation.left;
          if((signed int)*left == 0)
            right_len = lenx - ((union anonymous *)left)->generic.len;

          else
            if(!((signed int)((union anonymous *)x)->concatenation.left_len == 0))
              right_len = lenx - (unsigned long int)((union anonymous *)x)->concatenation.left_len;

            else
              right_len=strlen(right);
          result_len = right_len + leny;
          if(!(result_len >= 32ul))
          {
            void *return_value_GC_malloc_atomic$2;
            return_value_GC_malloc_atomic$2=GC_malloc_atomic(result_len + (unsigned long int)1);
            new_right = (char *)return_value_GC_malloc_atomic$2;
            if(new_right == ((char *)NULL))
            {
              if(!(CORD_oom_fn == ((void (*)(void))NULL)))
                CORD_oom_fn();

              fprintf(stderr, "%s\n", (const void *)"Out of memory\n");
              abort();
            }

            memcpy((void *)new_right, (const void *)right, right_len);
            memcpy((void *)(new_right + (signed long int)right_len), (const void *)y, leny);
            new_right[(signed long int)result_len] = (char)0;
            y = new_right;
            leny = result_len;
            x = left;
            lenx = lenx - right_len;
          }

          if(!((signed int)*x == 0))
            depth = 1;

          else
            depth = (signed int)((union anonymous *)x)->generic.depth + 1;
        }

        else
          depth = (signed int)((union anonymous *)x)->generic.depth + 1;
        result_len = lenx + leny;
      }
      struct Concatenation *result;
      void *return_value_GC_malloc$5;
      return_value_GC_malloc$5=GC_malloc(sizeof(struct Concatenation) /*32ul*/ );
      result = (struct Concatenation *)return_value_GC_malloc$5;
      if(result == ((struct Concatenation *)NULL))
      {
        if(!(CORD_oom_fn == ((void (*)(void))NULL)))
          CORD_oom_fn();

        fprintf(stderr, "%s\n", (const void *)"Out of memory\n");
        abort();
      }

      result->header = (char)1;
      result->depth = (char)depth;
      if(!(lenx >= 256ul))
        result->left_len = (unsigned char)lenx;

      result->len = result_len;
      result->left = x;
      result->right = y;
      if(depth >= 48)
      {
        const char *return_value_CORD_balance$6;
        return_value_CORD_balance$6=CORD_balance((const char *)result);
        return return_value_CORD_balance$6;
      }

      else
        return (const char *)result;
    }
}

// CORD_catn
// file ./include/cord.h line 234
extern const char * CORD_catn(signed int nargs, ...)
{
  const char *result = ((const char *)NULL);
  __builtin_va_list args;
  signed int i;
  va_start(args, nargs);
  i = 0;
  for( ; !(i >= nargs); i = i + 1)
  {
    const char *next;
    next=va_arg(args, __typeof__(next));
    result=CORD_cat(result, next);
  }
  va_end(args);
  return result;
}

// CORD_chars
// file ./include/cord.h line 255
extern const char * CORD_chars(char c, unsigned long int i)
{
  const char *return_value_CORD_from_fn$1;
  return_value_CORD_from_fn$1=CORD_from_fn(CORD_nul_func, (void *)(unsigned long int)c, i);
  return return_value_CORD_from_fn$1;
}

// CORD_chr
// file ./include/cord.h line 308
extern unsigned long int CORD_chr(const char *x, unsigned long int i, signed int c)
{
  struct anonymous$1 d;
  d.pos = i;
  d.target = (char)c;
  signed int return_value_CORD_iter5$1;
  return_value_CORD_iter5$1=CORD_iter5(x, i, CORD_chr_proc, CORD_batched_chr_proc, (void *)&d);
  if(!(return_value_CORD_iter5$1 == 0))
    return d.pos;

  else
    return (unsigned long int)-1;
}

// CORD_chr_proc
// file cord/cordxtra.c line 307
signed int CORD_chr_proc(char c, void *client_data)
{
  struct anonymous$1 *d = (struct anonymous$1 *)client_data;
  if(c == d->target)
    return 1;

  else
  {
    d->pos = d->pos + 1ul;
    return 0;
  }
}

// CORD_cmp
// file ./include/cord.h line 240
extern signed int CORD_cmp(const char *x, const char *y)
{
  struct CORD_Pos xpos[1l];
  struct CORD_Pos ypos[1l];
  unsigned long int avail;
  unsigned long int yavail;
  char return_value_CORD__pos_fetch$3;
  char return_value_CORD__pos_fetch$5;
  if(y == ((const char *)NULL))
    return (signed int)(x != ((const char *)NULL));

  else
    if(x == ((const char *)NULL))
      return -1;

    else
    {
      if(!((signed int)*y == 0))
      {
        if(!((signed int)*x == 0))
        {
          signed int tmp_statement_expression$1;
          unsigned long int __s1_len;
          unsigned long int __s2_len;
          signed int return_value___builtin_strcmp$2;
          return_value___builtin_strcmp$2=__builtin_strcmp(x, y);
          tmp_statement_expression$1 = return_value___builtin_strcmp$2;
          return tmp_statement_expression$1;
        }

      }

      CORD_set_pos(xpos, x, (unsigned long int)0);
      CORD_set_pos(ypos, y, (unsigned long int)0);
      while((_Bool)1)
      {
        if(xpos[0l].path_len == 0x55555555)
        {
          if(!(ypos[0l].path_len == 0x55555555))
            return -1;

          else
            return 0;
        }

        if(ypos[0l].path_len == 0x55555555)
          return 1;

        avail = (unsigned long int)((signed long int)xpos[(signed long int)0].cur_end - (signed long int)xpos[(signed long int)0].cur_pos);
        _Bool tmp_if_expr$8;
        if(!(avail >= 1ul))
          tmp_if_expr$8 = (_Bool)1;

        else
        {
          yavail = (unsigned long int)((signed long int)ypos[(signed long int)0].cur_end - (signed long int)ypos[(signed long int)0].cur_pos);
          tmp_if_expr$8 = yavail <= (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$8)
        {
          char xcurrent;
          signed int tmp_if_expr$4;
          if(!(xpos[0l].cur_end == 0ul))
            tmp_if_expr$4 = (signed int)xpos[(signed long int)0].cur_leaf[(signed long int)(xpos[(signed long int)0].cur_pos - xpos[(signed long int)0].cur_start)];

          else
          {
            return_value_CORD__pos_fetch$3=CORD__pos_fetch(xpos);
            tmp_if_expr$4 = (signed int)return_value_CORD__pos_fetch$3;
          }
          xcurrent = (char)tmp_if_expr$4;
          char ycurrent;
          signed int tmp_if_expr$6;
          if(!(ypos[0l].cur_end == 0ul))
            tmp_if_expr$6 = (signed int)ypos[(signed long int)0].cur_leaf[(signed long int)(ypos[(signed long int)0].cur_pos - ypos[(signed long int)0].cur_start)];

          else
          {
            return_value_CORD__pos_fetch$5=CORD__pos_fetch(ypos);
            tmp_if_expr$6 = (signed int)return_value_CORD__pos_fetch$5;
          }
          ycurrent = (char)tmp_if_expr$6;
          if(!(xcurrent == ycurrent))
            return (signed int)xcurrent - (signed int)ycurrent;

          if(!(1ul + xpos[0l].cur_pos >= xpos[0l].cur_end))
            xpos[(signed long int)0].cur_pos = xpos[(signed long int)0].cur_pos + 1ul;

          else
          {
            CORD__next(xpos);
            0;
          }
          if(!(1ul + ypos[0l].cur_pos >= ypos[0l].cur_end))
            ypos[(signed long int)0].cur_pos = ypos[(signed long int)0].cur_pos + 1ul;

          else
          {
            CORD__next(ypos);
            0;
          }
        }

        else
        {
          signed int result;
          if(!(yavail >= avail))
            avail = yavail;

          signed int return_value_strncmp$7;
          return_value_strncmp$7=strncmp(xpos[(signed long int)0].cur_leaf + (signed long int)(xpos[(signed long int)0].cur_pos - xpos[(signed long int)0].cur_start), ypos[(signed long int)0].cur_leaf + (signed long int)(ypos[(signed long int)0].cur_pos - ypos[(signed long int)0].cur_start), avail);
          result = return_value_strncmp$7;
          if(!(result == 0))
            return result;

          xpos[(signed long int)0].cur_pos = xpos[(signed long int)0].cur_pos + (avail - (unsigned long int)1);
          if(!(1ul + xpos[0l].cur_pos >= xpos[0l].cur_end))
            xpos[(signed long int)0].cur_pos = xpos[(signed long int)0].cur_pos + 1ul;

          else
          {
            CORD__next(xpos);
            0;
          }
          ypos[(signed long int)0].cur_pos = ypos[(signed long int)0].cur_pos + (avail - (unsigned long int)1);
          if(!(1ul + ypos[0l].cur_pos >= ypos[0l].cur_end))
            ypos[(signed long int)0].cur_pos = ypos[(signed long int)0].cur_pos + 1ul;

          else
          {
            CORD__next(ypos);
            0;
          }
        }
      }
    }
}

// CORD_concat_forest
// file cord/cordbscs.c line 672
const char * CORD_concat_forest(struct anonymous$0 *forest, unsigned long int expected_len)
{
  signed int i = 0;
  const char *sum = ((const char *)NULL);
  unsigned long int sum_len = (unsigned long int)0;
  for( ; !(sum_len == expected_len); i = i + 1)
    if(!((forest + (signed long int)i)->c == ((const char *)NULL)))
    {
      sum=CORD_cat((forest + (signed long int)i)->c, sum);
      sum_len = sum_len + (forest + (signed long int)i)->len;
    }

  return sum;
}

// CORD_dump
// file cord/cordbscs.c line 146
extern void CORD_dump(const char *x)
{
  CORD_dump_inner(x, (unsigned int)0);
  fflush(stdout);
}

// CORD_dump_inner
// file cord/cordbscs.c line 109
void CORD_dump_inner(const char *x, unsigned int n)
{
  unsigned long int i = (unsigned long int)0;
  for( ; !(i >= (unsigned long int)n); i = i + 1ul)
    fputs("  ", stdout);
  if(x == ((const char *)NULL))
    fputs("NIL\n", stdout);

  else
    if(!((signed int)*x == 0))
    {
      i = (unsigned long int)0;
      for( ; !(i >= 32ul); i = i + 1ul)
      {
        if((signed int)x[(signed long int)i] == 0)
          break;

        putchar((signed int)x[(signed long int)i]);
      }
      if(!((signed int)x[(signed long int)i] == 0))
        fputs("...", stdout);

      putchar(10);
    }

    else
      if((signed int)((union anonymous *)x)->generic.header == 1)
      {
        struct Concatenation *conc = &((union anonymous *)x)->concatenation;
        printf("Concatenation: %p (len: %d, depth: %d)\n", x, (signed int)conc->len, (signed int)conc->depth);
        CORD_dump_inner(conc->left, n + (unsigned int)1);
        CORD_dump_inner(conc->right, n + (unsigned int)1);
      }

      else
      {
        struct Function *func = &((union anonymous *)x)->function;
        if((signed int)((union anonymous *)x)->generic.header == 6)
          printf("(Substring) ");

        printf("Function: %p (len: %d): ", x, (signed int)func->len);
        i = (unsigned long int)0;
        _Bool tmp_if_expr$1;
        if(!(i >= 20ul))
          tmp_if_expr$1 = i < func->len ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$1 = (_Bool)0;
        if(tmp_if_expr$1)
        {
          char return_value;
          return_value=func->fn(i, func->client_data);
          putchar((signed int)return_value);
          i = i + 1ul;
        }

        if(!(i >= func->len))
          fputs("...", stdout);

        putchar(10);
      }
}

// CORD_ec_append_cord
// file ./include/ec.h line 66
void CORD_ec_append_cord(struct CORD_ec_struct *x, const char *s)
{
  CORD_ec_flush_buf(x);
  (x + (signed long int)0)->ec_cord=CORD_cat((x + (signed long int)0)->ec_cord, s);
}

// CORD_ec_flush_buf
// file ./include/ec.h line 49
void CORD_ec_flush_buf(struct CORD_ec_struct *x)
{
  unsigned long int len = (unsigned long int)((x + (signed long int)0)->ec_bufptr - (x + (signed long int)0)->ec_buf);
  char *s;
  if(!(len == 0ul))
  {
    void *return_value_GC_malloc_atomic$1;
    return_value_GC_malloc_atomic$1=GC_malloc_atomic(len + (unsigned long int)1);
    s = (char *)return_value_GC_malloc_atomic$1;
    memcpy((void *)s, (const void *)(x + (signed long int)0)->ec_buf, len);
    s[(signed long int)len] = (char)0;
    (x + (signed long int)0)->ec_cord=CORD_cat_char_star((x + (signed long int)0)->ec_cord, s, len);
    (x + (signed long int)0)->ec_bufptr = (x + (signed long int)0)->ec_buf;
  }

}

// CORD_fetch
// file cord/cordxtra.c line 268
extern char CORD_fetch(const char *x, unsigned long int i)
{
  struct CORD_Pos xpos[1l];
  CORD_set_pos(xpos, x, i);
  if(xpos[0l].path_len == 0x55555555)
  {
    fprintf(stderr, "%s\n", (const void *)"bad index?");
    abort();
  }

  signed int tmp_if_expr$2;
  char return_value_CORD__pos_fetch$1;
  if(!(xpos[0l].cur_end == 0ul))
    tmp_if_expr$2 = (signed int)xpos[(signed long int)0].cur_leaf[(signed long int)(xpos[(signed long int)0].cur_pos - xpos[(signed long int)0].cur_start)];

  else
  {
    return_value_CORD__pos_fetch$1=CORD__pos_fetch(xpos);
    tmp_if_expr$2 = (signed int)return_value_CORD__pos_fetch$1;
  }
  return (char)tmp_if_expr$2;
}

// CORD_fill_buf
// file cord/cordxtra.c line 140
void CORD_fill_buf(const char *x, unsigned long int i, unsigned long int len, char *buf)
{
  struct anonymous$5 fd;
  fd.len = len;
  fd.buf = buf;
  fd.count = (unsigned long int)0;
  CORD_iter5(x, i, CORD_fill_proc, CORD_batched_fill_proc, (void *)&fd);
}

// CORD_fill_proc
// file cord/cordxtra.c line 105
signed int CORD_fill_proc(char c, void *client_data)
{
  struct anonymous$5 *d = (struct anonymous$5 *)client_data;
  unsigned long int CORD_fill_proc$$1$$count = d->count;
  d->buf[(signed long int)CORD_fill_proc$$1$$count] = c;
  CORD_fill_proc$$1$$count = CORD_fill_proc$$1$$count + 1ul;
  d->count = CORD_fill_proc$$1$$count;
  if(CORD_fill_proc$$1$$count >= d->len)
    return 1;

  else
    return 0;
}

// CORD_fprintf
// file ./include/cord.h line 347
extern signed int CORD_fprintf(struct _IO_FILE *f, const char *format, ...)
{
  void **args;
  signed int result;
  const char *out = ((const char *)NULL);
  args = (void **)&format;
  result=CORD_vsprintf(&out, format, args);
  args = ((void **)NULL);
  if(result >= 1)
    CORD_put(out, f);

  return result;
}

// CORD_from_char_star
// file ./include/cord.h line 291
extern const char * CORD_from_char_star(const char *s)
{
  char *result;
  unsigned long int len;
  len=strlen(s);
  if(len == 0ul)
    return ((const char *)NULL);

  else
  {
    void *return_value_GC_malloc_atomic$1;
    return_value_GC_malloc_atomic$1=GC_malloc_atomic(len + (unsigned long int)1);
    result = (char *)return_value_GC_malloc_atomic$1;
    if(result == ((char *)NULL))
    {
      if(!(CORD_oom_fn == ((void (*)(void))NULL)))
        CORD_oom_fn();

      fprintf(stderr, "%s\n", (const void *)"Out of memory\n");
      abort();
    }

    memcpy((void *)result, (const void *)s, len + (unsigned long int)1);
    return result;
  }
}

// CORD_from_file
// file ./include/cord.h line 274
extern const char * CORD_from_file(struct _IO_FILE *f)
{
  signed long int len;
  signed int return_value_fseek$1;
  return_value_fseek$1=fseek(f, 0l, 2);
  if(!(return_value_fseek$1 == 0))
  {
    fprintf(stderr, "%s\n", (const void *)"Bad fd argument - fseek failed");
    abort();
  }

  len=ftell(f);
  if(!(len >= 0l))
  {
    fprintf(stderr, "%s\n", (const void *)"Bad fd argument - ftell failed");
    abort();
  }

  rewind(f);
  if(!(len >= 131073l))
  {
    const char *return_value_CORD_from_file_eager$2;
    return_value_CORD_from_file_eager$2=CORD_from_file_eager(f);
    return return_value_CORD_from_file_eager$2;
  }

  else
  {
    const char *return_value_CORD_from_file_lazy_inner$3;
    return_value_CORD_from_file_lazy_inner$3=CORD_from_file_lazy_inner(f, (unsigned long int)len);
    return return_value_CORD_from_file_lazy_inner$3;
  }
}

// CORD_from_file_eager
// file cord/cordxtra.c line 454
extern const char * CORD_from_file_eager(struct _IO_FILE *f)
{
  signed int c;
  struct CORD_ec_struct ecord[1l];
  ecord[(signed long int)0].ec_cord = ((const char *)NULL);
  ecord[(signed long int)0].ec_bufptr = ecord[(signed long int)0].ec_buf;
  do
  {
    c=_IO_getc(f);
    if(c == 0)
    {
      unsigned long int CORD_from_file_eager$$1$$1$$1$$1$$count = (unsigned long int)1;
      CORD_ec_flush_buf(ecord);
      do
      {
        c=_IO_getc(f);
        if(!(c == 0))
          break;

        CORD_from_file_eager$$1$$1$$1$$1$$count = CORD_from_file_eager$$1$$1$$1$$1$$count + 1ul;
      }
      while((_Bool)1);
      const char *return_value_CORD_chars$1;
      return_value_CORD_chars$1=CORD_chars((char)0, CORD_from_file_eager$$1$$1$$1$$1$$count);
      ecord[(signed long int)0].ec_cord=CORD_cat(ecord[(signed long int)0].ec_cord, return_value_CORD_chars$1);
    }

    if(c == -1)
      break;

    if(ecord[0l].ec_bufptr == ecord[0l].ec_buf + 128l)
    {
      CORD_ec_flush_buf(ecord);
      0;
    }

    else
      0;
    char *tmp_post$2 = ecord[(signed long int)0].ec_bufptr;
    ecord[(signed long int)0].ec_bufptr = ecord[(signed long int)0].ec_bufptr + 1l;
    *tmp_post$2 = (char)c;
  }
  while((_Bool)1);
  fclose(f);
  CORD_ec_flush_buf(ecord);
  const char *return_value_CORD_balance$3;
  return_value_CORD_balance$3=CORD_balance(ecord[(signed long int)0].ec_cord);
  return return_value_CORD_balance$3;
}

// CORD_from_file_lazy
// file ./include/cord.h line 283
extern const char * CORD_from_file_lazy(struct _IO_FILE *f)
{
  signed long int len;
  signed int return_value_fseek$1;
  return_value_fseek$1=fseek(f, 0l, 2);
  if(!(return_value_fseek$1 == 0))
  {
    fprintf(stderr, "%s\n", (const void *)"Bad fd argument - fseek failed");
    abort();
  }

  len=ftell(f);
  if(!(len >= 0l))
  {
    fprintf(stderr, "%s\n", (const void *)"Bad fd argument - ftell failed");
    abort();
  }

  rewind(f);
  const char *return_value_CORD_from_file_lazy_inner$2;
  return_value_CORD_from_file_lazy_inner$2=CORD_from_file_lazy_inner(f, (unsigned long int)len);
  return return_value_CORD_from_file_lazy_inner$2;
}

// CORD_from_file_lazy_inner
// file cord/cordxtra.c line 574
const char * CORD_from_file_lazy_inner(struct _IO_FILE *f, unsigned long int len)
{
  struct anonymous$2 *state;
  void *return_value_GC_malloc$1;
  return_value_GC_malloc$1=GC_malloc(sizeof(struct anonymous$2) /*272ul*/ );
  state = (struct anonymous$2 *)return_value_GC_malloc$1;
  signed int i;
  if(state == ((struct anonymous$2 *)NULL))
  {
    if(!(CORD_oom_fn == ((void (*)(void))NULL)))
      CORD_oom_fn();

    fprintf(stderr, "%s\n", (const void *)"Out of memory\n");
    abort();
  }

  if(!(len == 0ul))
  {
    char buf[1l];
    unsigned long int return_value_fread$2;
    return_value_fread$2=fread((void *)buf, (unsigned long int)1, (unsigned long int)1, f);
    if(return_value_fread$2 >= 2ul)
    {
      fprintf(stderr, "%s\n", (const void *)"fread unexpected result");
      abort();
    }

    rewind(f);
  }

  state->lf_file = f;
  i = 0;
  for( ; !(i >= 32); i = i + 1)
    state->lf_cache[(signed long int)i] = ((struct anonymous$3 *)NULL);
  state->lf_current = (unsigned long int)0;
  GC_register_finalizer((void *)state, CORD_lf_close_proc, NULL, ((void (**)(void *, void *))NULL), ((void **)NULL));
  const char *return_value_CORD_from_fn$3;
  return_value_CORD_from_fn$3=CORD_from_fn(CORD_lf_func, (void *)state, len);
  return return_value_CORD_from_fn$3;
}

// CORD_from_fn
// file ./include/cord.h line 120
extern const char * CORD_from_fn(char (*fn)(unsigned long int, void *), void *client_data, unsigned long int len)
{
  if(!(len >= 1ul))
    return ((const char *)NULL);

  else
  {
    if(!(len >= 32ul))
    {
      char *CORD_from_fn$$1$$1$$result;
      unsigned long int i;
      char buf[32l];
      char c;
      i = (unsigned long int)0;
      if(!(i >= len))
      {
        c=fn(i, client_data);
        buf[(signed long int)i] = c;
        i = i + 1ul;
      }

      void *return_value_GC_malloc_atomic$1;
      return_value_GC_malloc_atomic$1=GC_malloc_atomic(len + (unsigned long int)1);
      CORD_from_fn$$1$$1$$result = (char *)return_value_GC_malloc_atomic$1;
      if(CORD_from_fn$$1$$1$$result == ((char *)NULL))
      {
        if(!(CORD_oom_fn == ((void (*)(void))NULL)))
          CORD_oom_fn();

        fprintf(stderr, "%s\n", (const void *)"Out of memory\n");
        abort();
      }

      memcpy((void *)CORD_from_fn$$1$$1$$result, (const void *)buf, len);
      CORD_from_fn$$1$$1$$result[(signed long int)len] = (char)0;
      return (const char *)CORD_from_fn$$1$$1$$result;
    }


  gen_case:
    ;
    struct Function *result;
    void *return_value_GC_malloc$2;
    return_value_GC_malloc$2=GC_malloc(sizeof(struct Function) /*32ul*/ );
    result = (struct Function *)return_value_GC_malloc$2;
    if(result == ((struct Function *)NULL))
    {
      if(!(CORD_oom_fn == ((void (*)(void))NULL)))
        CORD_oom_fn();

      fprintf(stderr, "%s\n", (const void *)"Out of memory\n");
      abort();
    }

    result->header = (char)4;
    result->len = len;
    result->fn = fn;
    result->client_data = client_data;
    return (const char *)result;
  }
}

// CORD_index_access_fn
// file cord/cordbscs.c line 329
char CORD_index_access_fn(unsigned long int i, void *client_data)
{
  struct substr_args *descr = (struct substr_args *)client_data;
  return ((char *)descr->sa_cord)[(signed long int)(i + descr->sa_index)];
}

// CORD_init_forest
// file cord/cordbscs.c line 620
void CORD_init_forest(struct anonymous$0 *forest, unsigned long int max_len)
{
  signed int i = 0;
  for( ; !(i >= 48); i = i + 1)
  {
    (forest + (signed long int)i)->c = ((const char *)NULL);
    if(!(max_len >= min_len[(signed long int)i]))
      goto __CPROVER_DUMP_L4;

  }
  fprintf(stderr, "%s\n", (const void *)"Cord too long");
  abort();

__CPROVER_DUMP_L4:
  ;
}

// CORD_init_min_len
// file cord/cordbscs.c line 601
void CORD_init_min_len()
{
  signed int i;
  unsigned long int last;
  unsigned long int previous;
  unsigned long int current;
  previous = (unsigned long int)1;
  min_len[(signed long int)0] = previous;
  last = (unsigned long int)2;
  min_len[(signed long int)1] = last;
  i = 2;
  for( ; !(i >= 48); i = i + 1)
  {
    current = last + previous;
    if(!(current >= last))
      current = last;

    min_len[(signed long int)i] = current;
    previous = last;
    last = current;
  }
  CORD_max_len = (signed int)(last - (unsigned long int)1);
  min_len_init = 1;
}

// CORD_iter
// file cord/cordbscs.c line 514
extern signed int CORD_iter(const char *x, signed int (*f1)(char, void *), void *client_data)
{
  signed int return_value_CORD_iter5$1;
  return_value_CORD_iter5$1=CORD_iter5(x, (unsigned long int)0, f1, (signed int (*)(const char *, void *))0, client_data);
  return return_value_CORD_iter5$1;
}

// CORD_iter5
// file ./include/cord.h line 158
extern signed int CORD_iter5(const char *x, unsigned long int i, signed int (*f1)(char, void *), signed int (*f2)(const char *, void *), void *client_data)
{
  unsigned long int tmp_if_expr$3;
  unsigned long int tmp_if_expr$2;
  unsigned long int return_value_strlen$1;
  if(x == ((const char *)NULL))
    return 0;

  else
    if(!((signed int)*x == 0))
    {
      const char *p = x + (signed long int)i;
      if((signed int)*p == 0)
      {
        fprintf(stderr, "%s\n", (const void *)"2nd arg to CORD_iter5 too big");
        abort();
      }

      if(!(f2 == ((signed int (*)(const char *, void *))NULL)))
      {
        signed int return_value;
        return_value=f2(p, client_data);
        return return_value;
      }

      else
      {
        if(!(*p == 0))
        {
          signed int return_value_1;
          return_value_1=f1(*p, client_data);
          if(!(return_value_1 == 0))
            return 1;

          p = p + 1l;
        }

        return 0;
      }
    }

    else
      if((signed int)((union anonymous *)x)->generic.header == 1)
      {
        struct Concatenation *conc = &((union anonymous *)x)->concatenation;
        if(i >= 1ul)
        {
          unsigned long int left_len;
          unsigned long int tmp_if_expr$4;
          if(!((signed int)conc->left_len == 0))
            tmp_if_expr$4 = (unsigned long int)conc->left_len;

          else
          {
            if(!((signed int)*conc->left == 0))
            {
              if(!((signed int)*conc->right == 0))
              {
                return_value_strlen$1=strlen(conc->right);
                tmp_if_expr$2 = return_value_strlen$1;
              }

              else
                tmp_if_expr$2 = ((union anonymous *)conc->right)->generic.len;
              tmp_if_expr$3 = conc->len - tmp_if_expr$2;
            }

            else
              tmp_if_expr$3 = ((union anonymous *)conc->left)->generic.len;
            tmp_if_expr$4 = tmp_if_expr$3;
          }
          left_len = tmp_if_expr$4;
          if(i >= left_len)
          {
            signed int return_value_CORD_iter5$5;
            return_value_CORD_iter5$5=CORD_iter5(conc->right, i - left_len, f1, f2, client_data);
            return return_value_CORD_iter5$5;
          }

        }

        signed int return_value_CORD_iter5$6;
        return_value_CORD_iter5$6=CORD_iter5(conc->left, i, f1, f2, client_data);
        if(!(return_value_CORD_iter5$6 == 0))
          return 1;

        signed int return_value_CORD_iter5$7;
        return_value_CORD_iter5$7=CORD_iter5(conc->right, (unsigned long int)0, f1, f2, client_data);
        return return_value_CORD_iter5$7;
      }

      else
      {
        struct Function *f = &((union anonymous *)x)->function;
        unsigned long int j;
        unsigned long int lim = f->len;
        j = i;
        if(!(j >= lim))
        {
          char return_value_2;
          return_value_2=f->fn(j, f->client_data);
          signed int return_value_3;
          return_value_3=f1(return_value_2, client_data);
          if(!(return_value_3 == 0))
            return 1;

          j = j + 1ul;
        }

        return 0;
      }
}

// CORD_len
// file ./include/cord.h line 114
extern unsigned long int CORD_len(const char *x)
{
  unsigned long int return_value_strlen$1;
  if(x == ((const char *)NULL))
    return (unsigned long int)0;

  else
  {
    unsigned long int tmp_if_expr$2;
    if(!((signed int)*x == 0))
    {
      return_value_strlen$1=strlen(x);
      tmp_if_expr$2 = return_value_strlen$1;
    }

    else
      tmp_if_expr$2 = ((union anonymous *)x)->generic.len;
    return tmp_if_expr$2;
  }
}

// CORD_lf_close_proc
// file cord/cordxtra.c line 567
void CORD_lf_close_proc(void *obj, void *client_data)
{
  signed int return_value_fclose$1;
  return_value_fclose$1=fclose(((struct anonymous$2 *)obj)->lf_file);
  if(!(return_value_fclose$1 == 0))
  {
    fprintf(stderr, "%s\n", (const void *)"CORD_lf_close_proc: fclose failed");
    abort();
  }

}

// CORD_lf_func
// file cord/cordxtra.c line 546
char CORD_lf_func(unsigned long int i, void *client_data)
{
  struct anonymous$2 *state = (struct anonymous$2 *)client_data;
  struct anonymous$3 * volatile *cl_addr = &state->lf_cache[(signed long int)((i & (unsigned long int)((1 << 14) - 1)) >> 9)];
  struct anonymous$3 *cl = (struct anonymous$3 *)*cl_addr;
  _Bool tmp_if_expr$3;
  if(cl == ((struct anonymous$3 *)NULL))
    tmp_if_expr$3 = (_Bool)1;

  else
    tmp_if_expr$3 = cl->tag != i >> 9 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$3)
  {
    struct anonymous$4 rd;
    rd.state = state;
    rd.file_pos = i;
    void *return_value_GC_malloc_atomic$1;
    return_value_GC_malloc_atomic$1=GC_malloc_atomic(sizeof(struct anonymous$3) /*520ul*/ );
    rd.new_cache = (struct anonymous$3 *)return_value_GC_malloc_atomic$1;
    if(rd.new_cache == ((struct anonymous$3 *)NULL))
    {
      if(!(CORD_oom_fn == ((void (*)(void))NULL)))
        CORD_oom_fn();

      fprintf(stderr, "%s\n", (const void *)"Out of memory\n");
      abort();
    }

    void *return_value_GC_call_with_alloc_lock$2;
    return_value_GC_call_with_alloc_lock$2=GC_call_with_alloc_lock((void * (*)(void *))refill_cache, (void *)&rd);
    return (char)(unsigned long int)return_value_GC_call_with_alloc_lock$2;
  }

  return cl->data[(signed long int)(i & (unsigned long int)((1 << 9) - 1))];
}

// CORD_ncmp
// file cord/cordxtra.c line 193
extern signed int CORD_ncmp(const char *x, unsigned long int x_start, const char *y, unsigned long int y_start, unsigned long int len)
{
  struct CORD_Pos xpos[1l];
  struct CORD_Pos ypos[1l];
  unsigned long int CORD_ncmp$$1$$count;
  signed long int avail;
  signed long int yavail;
  CORD_set_pos(xpos, x, x_start);
  CORD_set_pos(ypos, y, y_start);
  CORD_ncmp$$1$$count = (unsigned long int)0;
  char return_value_CORD__pos_fetch$1;
  char return_value_CORD__pos_fetch$3;
  while(!(CORD_ncmp$$1$$count >= len))
  {
    if(xpos[0l].path_len == 0x55555555)
    {
      if(!(ypos[0l].path_len == 0x55555555))
        return -1;

      else
        return 0;
    }

    if(ypos[0l].path_len == 0x55555555)
      return 1;

    avail = (signed long int)xpos[(signed long int)0].cur_end - (signed long int)xpos[(signed long int)0].cur_pos;
    _Bool tmp_if_expr$6;
    if(!(avail >= 1l))
      tmp_if_expr$6 = (_Bool)1;

    else
    {
      yavail = (signed long int)ypos[(signed long int)0].cur_end - (signed long int)ypos[(signed long int)0].cur_pos;
      tmp_if_expr$6 = yavail <= (signed long int)0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$6)
    {
      char xcurrent;
      signed int tmp_if_expr$2;
      if(!(xpos[0l].cur_end == 0ul))
        tmp_if_expr$2 = (signed int)xpos[(signed long int)0].cur_leaf[(signed long int)(xpos[(signed long int)0].cur_pos - xpos[(signed long int)0].cur_start)];

      else
      {
        return_value_CORD__pos_fetch$1=CORD__pos_fetch(xpos);
        tmp_if_expr$2 = (signed int)return_value_CORD__pos_fetch$1;
      }
      xcurrent = (char)tmp_if_expr$2;
      char ycurrent;
      signed int tmp_if_expr$4;
      if(!(ypos[0l].cur_end == 0ul))
        tmp_if_expr$4 = (signed int)ypos[(signed long int)0].cur_leaf[(signed long int)(ypos[(signed long int)0].cur_pos - ypos[(signed long int)0].cur_start)];

      else
      {
        return_value_CORD__pos_fetch$3=CORD__pos_fetch(ypos);
        tmp_if_expr$4 = (signed int)return_value_CORD__pos_fetch$3;
      }
      ycurrent = (char)tmp_if_expr$4;
      if(!(xcurrent == ycurrent))
        return (signed int)xcurrent - (signed int)ycurrent;

      if(!(1ul + xpos[0l].cur_pos >= xpos[0l].cur_end))
        xpos[(signed long int)0].cur_pos = xpos[(signed long int)0].cur_pos + 1ul;

      else
      {
        CORD__next(xpos);
        0;
      }
      if(!(1ul + ypos[0l].cur_pos >= ypos[0l].cur_end))
        ypos[(signed long int)0].cur_pos = ypos[(signed long int)0].cur_pos + 1ul;

      else
      {
        CORD__next(ypos);
        0;
      }
      CORD_ncmp$$1$$count = CORD_ncmp$$1$$count + 1ul;
    }

    else
    {
      signed int result;
      if(!(yavail >= avail))
        avail = yavail;

      CORD_ncmp$$1$$count = CORD_ncmp$$1$$count + (unsigned long int)avail;
      if(!(len >= CORD_ncmp$$1$$count))
        avail = avail - (signed long int)(CORD_ncmp$$1$$count - len);

      signed int return_value_strncmp$5;
      return_value_strncmp$5=strncmp(xpos[(signed long int)0].cur_leaf + (signed long int)(xpos[(signed long int)0].cur_pos - xpos[(signed long int)0].cur_start), ypos[(signed long int)0].cur_leaf + (signed long int)(ypos[(signed long int)0].cur_pos - ypos[(signed long int)0].cur_start), (unsigned long int)avail);
      result = return_value_strncmp$5;
      if(!(result == 0))
        return result;

      xpos[(signed long int)0].cur_pos = xpos[(signed long int)0].cur_pos + ((unsigned long int)avail - (unsigned long int)1);
      if(!(1ul + xpos[0l].cur_pos >= xpos[0l].cur_end))
        xpos[(signed long int)0].cur_pos = xpos[(signed long int)0].cur_pos + 1ul;

      else
      {
        CORD__next(xpos);
        0;
      }
      ypos[(signed long int)0].cur_pos = ypos[(signed long int)0].cur_pos + ((unsigned long int)avail - (unsigned long int)1);
      if(!(1ul + ypos[0l].cur_pos >= ypos[0l].cur_end))
        ypos[(signed long int)0].cur_pos = ypos[(signed long int)0].cur_pos + 1ul;

      else
      {
        CORD__next(ypos);
        0;
      }
    }
  }
  return 0;
}

// CORD_next
// file cord/cordbscs.c line 879
extern void CORD_next(struct CORD_Pos *p)
{
  if(!(p->cur_pos >= p->cur_end + 18446744073709551615ul))
    (p + (signed long int)0)->cur_pos = (p + (signed long int)0)->cur_pos + 1ul;

  else
    CORD__next(p);
}

// CORD_nul_func
// file cord/cordxtra.c line 443
char CORD_nul_func(unsigned long int i, void *client_data)
{
  return (char)(unsigned long int)client_data;
}

// CORD_pos_fetch
// file cord/cordbscs.c line 870
extern char CORD_pos_fetch(struct CORD_Pos *p)
{
  _Bool tmp_if_expr$2;
  if(p->cur_pos >= p->cur_start)
    tmp_if_expr$2 = (p + (signed long int)0)->cur_pos < (p + (signed long int)0)->cur_end ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$2 = (_Bool)0;
  if(tmp_if_expr$2)
    return (p + (signed long int)0)->cur_leaf[(signed long int)((p + (signed long int)0)->cur_pos - (p + (signed long int)0)->cur_start)];

  else
  {
    char return_value_CORD__pos_fetch$1;
    return_value_CORD__pos_fetch$1=CORD__pos_fetch(p);
    return return_value_CORD__pos_fetch$1;
  }
}

// CORD_pos_to_cord
// file cord/cordbscs.c line 902
extern const char * CORD_pos_to_cord(struct CORD_Pos *p)
{
  return (p + (signed long int)0)->path[(signed long int)0].pe_cord;
}

// CORD_pos_to_index
// file cord/cordbscs.c line 897
extern unsigned long int CORD_pos_to_index(struct CORD_Pos *p)
{
  return (p + (signed long int)0)->cur_pos;
}

// CORD_pos_valid
// file cord/cordbscs.c line 907
extern signed int CORD_pos_valid(struct CORD_Pos *p)
{
  return (signed int)((p + (signed long int)0)->path_len != 0x55555555);
}

// CORD_prev
// file cord/cordbscs.c line 888
extern void CORD_prev(struct CORD_Pos *p)
{
  _Bool tmp_if_expr$1;
  if(!(p->cur_end == 0ul))
    tmp_if_expr$1 = (p + (signed long int)0)->cur_pos > (p + (signed long int)0)->cur_start ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(tmp_if_expr$1)
    (p + (signed long int)0)->cur_pos = (p + (signed long int)0)->cur_pos - 1ul;

  else
    CORD__prev(p);
}

// CORD_printf
// file cord/cordprnt.c line 389
extern signed int CORD_printf(const char *format, ...)
{
  void **args;
  signed int result;
  const char *out = ((const char *)NULL);
  args = (void **)&format;
  result=CORD_vsprintf(&out, format, args);
  args = ((void **)NULL);
  if(result >= 1)
    CORD_put(out, stdout);

  return result;
}

// CORD_put
// file ./include/cord.h line 300
extern signed int CORD_put(const char *x, struct _IO_FILE *f)
{
  signed int return_value_CORD_iter5$1;
  return_value_CORD_iter5$1=CORD_iter5(x, (unsigned long int)0, CORD_put_proc, CORD_batched_put_proc, (void *)f);
  if(!(return_value_CORD_iter5$1 == 0))
    return -1;

  else
    return 1;
}

// CORD_put_proc
// file cord/cordxtra.c line 278
signed int CORD_put_proc(char c, void *client_data)
{
  struct _IO_FILE *f = (struct _IO_FILE *)client_data;
  signed int return_value__IO_putc$1;
  return_value__IO_putc$1=_IO_putc((signed int)c, f);
  return (signed int)(return_value__IO_putc$1 == -1);
}

// CORD_rchr
// file ./include/cord.h line 313
extern unsigned long int CORD_rchr(const char *x, unsigned long int i, signed int c)
{
  struct anonymous$1 d;
  d.pos = i;
  d.target = (char)c;
  signed int return_value_CORD_riter4$1;
  return_value_CORD_riter4$1=CORD_riter4(x, i, CORD_rchr_proc, (void *)&d);
  if(!(return_value_CORD_riter4$1 == 0))
    return d.pos;

  else
    return (unsigned long int)-1;
}

// CORD_rchr_proc
// file cord/cordxtra.c line 316
signed int CORD_rchr_proc(char c, void *client_data)
{
  struct anonymous$1 *d = (struct anonymous$1 *)client_data;
  if(c == d->target)
    return 1;

  else
  {
    d->pos = d->pos - 1ul;
    return 0;
  }
}

// CORD_riter
// file cord/cordbscs.c line 562
extern signed int CORD_riter(const char *x, signed int (*f1)(char, void *), void *client_data)
{
  unsigned long int len;
  len=CORD_len(x);
  if(len == 0ul)
    return 0;

  else
  {
    signed int return_value_CORD_riter4$1;
    return_value_CORD_riter4$1=CORD_riter4(x, len - (unsigned long int)1, f1, client_data);
    return return_value_CORD_riter4$1;
  }
}

// CORD_riter4
// file cord/cordbscs.c line 519
extern signed int CORD_riter4(const char *x, unsigned long int i, signed int (*f1)(char, void *), void *client_data)
{
  unsigned long int tmp_if_expr$3;
  unsigned long int tmp_if_expr$2;
  unsigned long int return_value_strlen$1;
  if(x == ((const char *)NULL))
    return 0;

  else
    if(!((signed int)*x == 0))
    {
      const char *p = x + (signed long int)i;
      char c;
      c = *p;
      if((signed int)c == 0)
      {
        fprintf(stderr, "%s\n", (const void *)"2nd arg to CORD_riter4 too big");
        abort();
      }

      signed int return_value;
      return_value=f1(c, client_data);
      if(!(return_value == 0))
        return 1;

      if(!(p == x))
        p = p - 1l;

      return 0;
    }

    else
      if((signed int)((union anonymous *)x)->generic.header == 1)
      {
        struct Concatenation *conc = &((union anonymous *)x)->concatenation;
        const char *left_part = conc->left;
        unsigned long int left_len;
        unsigned long int tmp_if_expr$4;
        if(!((signed int)conc->left_len == 0))
          tmp_if_expr$4 = (unsigned long int)conc->left_len;

        else
        {
          if(!((signed int)*conc->left == 0))
          {
            if(!((signed int)*conc->right == 0))
            {
              return_value_strlen$1=strlen(conc->right);
              tmp_if_expr$2 = return_value_strlen$1;
            }

            else
              tmp_if_expr$2 = ((union anonymous *)conc->right)->generic.len;
            tmp_if_expr$3 = conc->len - tmp_if_expr$2;
          }

          else
            tmp_if_expr$3 = ((union anonymous *)conc->left)->generic.len;
          tmp_if_expr$4 = tmp_if_expr$3;
        }
        left_len = tmp_if_expr$4;
        if(i >= left_len)
        {
          signed int return_value_CORD_riter4$5;
          return_value_CORD_riter4$5=CORD_riter4(conc->right, i - left_len, f1, client_data);
          if(!(return_value_CORD_riter4$5 == 0))
            return 1;

          signed int return_value_CORD_riter4$6;
          return_value_CORD_riter4$6=CORD_riter4(left_part, left_len - (unsigned long int)1, f1, client_data);
          return return_value_CORD_riter4$6;
        }

        else
        {
          signed int return_value_CORD_riter4$7;
          return_value_CORD_riter4$7=CORD_riter4(left_part, i, f1, client_data);
          return return_value_CORD_riter4$7;
        }
      }

      else
      {
        struct Function *f = &((union anonymous *)x)->function;
        unsigned long int j = i;
        char return_value_1;
        return_value_1=f->fn(j, f->client_data);
        signed int return_value_2;
        return_value_2=f1(return_value_1, client_data);
        if(!(return_value_2 == 0))
          return 1;

        if(j == 0ul)
          return 0;

        j = j - 1ul;
      }
}

// CORD_set_pos
// file ./include/cord_pos.h line 68
extern void CORD_set_pos(struct CORD_Pos *p, const char *x, unsigned long int i)
{
  if(x == ((const char *)NULL))
    (p + (signed long int)0)->path_len = 0x55555555;

  else
  {
    (p + (signed long int)0)->path[(signed long int)0].pe_cord = x;
    (p + (signed long int)0)->path[(signed long int)0].pe_start_pos = (unsigned long int)0;
    (p + (signed long int)0)->path_len = 0;
    (p + (signed long int)0)->cur_pos = i;
    CORD__extend_path(p);
  }
}

// CORD_sprintf
// file ./include/cord.h line 345
extern signed int CORD_sprintf(const char **out, const char *format, ...)
{
  void **args;
  signed int result;
  args = (void **)&format;
  result=CORD_vsprintf(out, format, args);
  args = ((void **)NULL);
  return result;
}

// CORD_str
// file ./include/cord.h line 250
extern unsigned long int CORD_str(const char *x, unsigned long int start, const char *s)
{
  struct CORD_Pos xpos[1l];
  unsigned long int xlen;
  xlen=CORD_len(x);
  unsigned long int slen;
  unsigned long int start_len;
  const char *s_start;
  unsigned long int s_buf = (unsigned long int)0;
  unsigned long int x_buf = (unsigned long int)0;
  unsigned long int mask = (unsigned long int)0;
  unsigned long int i;
  unsigned long int match_pos;
  char return_value_CORD__pos_fetch$2;
  signed int return_value_CORD_ncmp$4;
  char return_value_CORD__pos_fetch$6;
  if(s == ((const char *)NULL))
    return start;

  else
  {
    if(!((signed int)*s == 0))
    {
      s_start = s;
      slen=strlen(s);
    }

    else
    {
      const char *return_value_CORD_substr$1;
      return_value_CORD_substr$1=CORD_substr(s, (unsigned long int)0, sizeof(unsigned long int) /*8ul*/ );
      s_start=CORD_to_char_star(return_value_CORD_substr$1);
      slen=CORD_len(s);
    }
    if(!(xlen + -start >= slen) || !(xlen >= start))
      return (unsigned long int)-1;

    else
    {
      start_len = slen;
      if(start_len >= 9ul)
        start_len = sizeof(unsigned long int) /*8ul*/ ;

      CORD_set_pos(xpos, x, start);
      i = (unsigned long int)0;
      for( ; !(i >= start_len); i = i + 1ul)
      {
        mask = mask << 8;
        mask = mask | (unsigned long int)0xff;
        s_buf = s_buf << 8;
        s_buf = s_buf | (unsigned long int)(unsigned char)s_start[(signed long int)i];
        x_buf = x_buf << 8;
        signed int tmp_if_expr$3;
        if(!(xpos[0l].cur_end == 0ul))
          tmp_if_expr$3 = (signed int)xpos[(signed long int)0].cur_leaf[(signed long int)(xpos[(signed long int)0].cur_pos - xpos[(signed long int)0].cur_start)];

        else
        {
          return_value_CORD__pos_fetch$2=CORD__pos_fetch(xpos);
          tmp_if_expr$3 = (signed int)return_value_CORD__pos_fetch$2;
        }
        x_buf = x_buf | (unsigned long int)(unsigned char)tmp_if_expr$3;
        if(!(1ul + xpos[0l].cur_pos >= xpos[0l].cur_end))
          xpos[(signed long int)0].cur_pos = xpos[(signed long int)0].cur_pos + 1ul;

        else
        {
          CORD__next(xpos);
          0;
        }
      }
      match_pos = start;
      for( ; (_Bool)1; match_pos = match_pos + 1ul)
      {
        if((mask & x_buf) == s_buf)
        {
          _Bool tmp_if_expr$5;
          if(slen == start_len)
            tmp_if_expr$5 = (_Bool)1;

          else
          {
            return_value_CORD_ncmp$4=CORD_ncmp(x, match_pos + start_len, s, start_len, slen - start_len);
            tmp_if_expr$5 = return_value_CORD_ncmp$4 == 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$5)
            return match_pos;

        }

        if(match_pos == xlen + -slen)
          return (unsigned long int)-1;

        x_buf = x_buf << 8;
        signed int tmp_if_expr$7;
        if(!(xpos[0l].cur_end == 0ul))
          tmp_if_expr$7 = (signed int)xpos[(signed long int)0].cur_leaf[(signed long int)(xpos[(signed long int)0].cur_pos - xpos[(signed long int)0].cur_start)];

        else
        {
          return_value_CORD__pos_fetch$6=CORD__pos_fetch(xpos);
          tmp_if_expr$7 = (signed int)return_value_CORD__pos_fetch$6;
        }
        x_buf = x_buf | (unsigned long int)(unsigned char)tmp_if_expr$7;
        if(!(1ul + xpos[0l].cur_pos >= xpos[0l].cur_end))
          xpos[(signed long int)0].cur_pos = xpos[(signed long int)0].cur_pos + 1ul;

        else
        {
          CORD__next(xpos);
          0;
        }
      }
    }
  }
}

// CORD_substr
// file ./include/cord.h line 124
extern const char * CORD_substr(const char *x, unsigned long int i, unsigned long int n)
{
  unsigned long int len;
  len=CORD_len(x);
  if(i >= len || !(n >= 1ul))
    return ((const char *)NULL);

  else
  {
    if(!(len >= i + n))
      n = len - i;

    const char *return_value_CORD_substr_checked$1;
    return_value_CORD_substr_checked$1=CORD_substr_checked(x, i, n);
    return return_value_CORD_substr_checked$1;
  }
}

// CORD_substr_checked
// file cord/cordbscs.c line 368
const char * CORD_substr_checked(const char *x, unsigned long int i, unsigned long int n)
{
  unsigned long int tmp_if_expr$5;
  unsigned long int tmp_if_expr$4;
  unsigned long int return_value_strlen$3;
  if(!((signed int)*x == 0))
  {
    if(n >= 311ul)
    {
      const char *return_value_CORD_substr_closure$1;
      return_value_CORD_substr_closure$1=CORD_substr_closure(x, i, n, CORD_index_access_fn);
      return return_value_CORD_substr_closure$1;
    }

    else
    {
      char *result;
      void *return_value_GC_malloc_atomic$2;
      return_value_GC_malloc_atomic$2=GC_malloc_atomic(n + (unsigned long int)1);
      result = (char *)return_value_GC_malloc_atomic$2;
      if(result == ((char *)NULL))
      {
        if(!(CORD_oom_fn == ((void (*)(void))NULL)))
          CORD_oom_fn();

        fprintf(stderr, "%s\n", (const void *)"Out of memory\n");
        abort();
      }

      __builtin_strncpy(result, x + (signed long int)i, n);
      result[(signed long int)n] = (char)0;
      return result;
    }
  }

  else
    if((signed int)((union anonymous *)x)->generic.header == 1)
    {
      struct Concatenation *conc = &((union anonymous *)x)->concatenation;
      unsigned long int left_len;
      unsigned long int right_len;
      unsigned long int tmp_if_expr$6;
      if(!((signed int)conc->left_len == 0))
        tmp_if_expr$6 = (unsigned long int)conc->left_len;

      else
      {
        if(!((signed int)*conc->left == 0))
        {
          if(!((signed int)*conc->right == 0))
          {
            return_value_strlen$3=strlen(conc->right);
            tmp_if_expr$4 = return_value_strlen$3;
          }

          else
            tmp_if_expr$4 = ((union anonymous *)conc->right)->generic.len;
          tmp_if_expr$5 = conc->len - tmp_if_expr$4;
        }

        else
          tmp_if_expr$5 = ((union anonymous *)conc->left)->generic.len;
        tmp_if_expr$6 = tmp_if_expr$5;
      }
      left_len = tmp_if_expr$6;
      right_len = conc->len - left_len;
      if(i >= left_len)
      {
        if(n == right_len)
          return conc->right;

        const char *return_value_CORD_substr_checked$7;
        return_value_CORD_substr_checked$7=CORD_substr_checked(conc->right, i - left_len, n);
        return return_value_CORD_substr_checked$7;
      }

      else
        if(left_len >= i + n)
        {
          if(n == left_len)
            return conc->left;

          const char *return_value_CORD_substr_checked$8;
          return_value_CORD_substr_checked$8=CORD_substr_checked(conc->left, i, n);
          return return_value_CORD_substr_checked$8;
        }

        else
        {
          const char *left_part;
          const char *right_part;
          unsigned long int left_part_len = left_len - i;
          if(i == 0ul)
            left_part = conc->left;

          else
            left_part=CORD_substr_checked(conc->left, i, left_part_len);
          if(i + n == left_len + right_len)
            right_part = conc->right;

          else
            right_part=CORD_substr_checked(conc->right, (unsigned long int)0, n - left_part_len);
          const char *return_value_CORD_cat$9;
          return_value_CORD_cat$9=CORD_cat(left_part, right_part);
          return return_value_CORD_cat$9;
        }
    }

    else
      if(n >= 311ul)
      {
        if((signed int)((union anonymous *)x)->generic.header == 6)
        {
          struct Function *f = &((union anonymous *)x)->function;
          struct substr_args *descr = (struct substr_args *)f->client_data;
          const char *return_value_CORD_substr_closure$10;
          return_value_CORD_substr_closure$10=CORD_substr_closure((const char *)descr->sa_cord, i + descr->sa_index, n, f->fn);
          return return_value_CORD_substr_closure$10;
        }

        else
        {
          const char *return_value_CORD_substr_closure$11;
          return_value_CORD_substr_closure$11=CORD_substr_closure(x, i, n, CORD_apply_access_fn);
          return return_value_CORD_substr_closure$11;
        }
      }

      else
      {
        char *CORD_substr_checked$$1$$3$$2$$result;
        struct Function *CORD_substr_checked$$1$$3$$2$$f = &((union anonymous *)x)->function;
        char buf[311l];
        char *p = buf;
        char c;
        signed int j;
        signed int lim = (signed int)(i + n);
        j = (signed int)i;
        if(!(j >= lim))
        {
          c=CORD_substr_checked$$1$$3$$2$$f->fn((unsigned long int)j, CORD_substr_checked$$1$$3$$2$$f->client_data);
          if((signed int)c == 0)
          {
            const char *return_value_CORD_substr_closure$12;
            return_value_CORD_substr_closure$12=CORD_substr_closure(x, i, n, CORD_apply_access_fn);
            return return_value_CORD_substr_closure$12;
          }

          char *tmp_post$13 = p;
          p = p + 1l;
          *tmp_post$13 = c;
          j = j + 1;
        }

        void *return_value_GC_malloc_atomic$14;
        return_value_GC_malloc_atomic$14=GC_malloc_atomic(n + (unsigned long int)1);
        CORD_substr_checked$$1$$3$$2$$result = (char *)return_value_GC_malloc_atomic$14;
        if(CORD_substr_checked$$1$$3$$2$$result == ((char *)NULL))
        {
          if(!(CORD_oom_fn == ((void (*)(void))NULL)))
            CORD_oom_fn();

          fprintf(stderr, "%s\n", (const void *)"Out of memory\n");
          abort();
        }

        memcpy((void *)CORD_substr_checked$$1$$3$$2$$result, (const void *)buf, n);
        CORD_substr_checked$$1$$3$$2$$result[(signed long int)n] = (char)0;
        return CORD_substr_checked$$1$$3$$2$$result;
      }
}

// CORD_substr_closure
// file cord/cordbscs.c line 348
const char * CORD_substr_closure(const char *x, unsigned long int i, unsigned long int n, char (*f)(unsigned long int, void *))
{
  struct substr_args *sa;
  void *return_value_GC_malloc$1;
  return_value_GC_malloc$1=GC_malloc(sizeof(struct substr_args) /*16ul*/ );
  sa = (struct substr_args *)return_value_GC_malloc$1;
  const char *result;
  if(sa == ((struct substr_args *)NULL))
  {
    if(!(CORD_oom_fn == ((void (*)(void))NULL)))
      CORD_oom_fn();

    fprintf(stderr, "%s\n", (const void *)"Out of memory\n");
    abort();
  }

  sa->sa_cord = (union anonymous *)x;
  sa->sa_index = i;
  result=CORD_from_fn(f, (void *)sa, n);
  if(result == ((const char *)NULL))
    return ((const char *)NULL);

  else
  {
    ((union anonymous *)result)->function.header = (char)6;
    return result;
  }
}

// CORD_to_char_star
// file ./include/cord.h line 287
extern char * CORD_to_char_star(const char *x)
{
  unsigned long int len;
  len=CORD_len(x);
  char *result;
  void *return_value_GC_malloc_atomic$1;
  return_value_GC_malloc_atomic$1=GC_malloc_atomic(len + (unsigned long int)1);
  result = (char *)return_value_GC_malloc_atomic$1;
  if(result == ((char *)NULL))
  {
    if(!(CORD_oom_fn == ((void (*)(void))NULL)))
      CORD_oom_fn();

    fprintf(stderr, "%s\n", (const void *)"Out of memory\n");
    abort();
  }

  CORD_fill_buf(x, (unsigned long int)0, len, result);
  result[(signed long int)len] = (char)0;
  return result;
}

// CORD_to_const_char_star
// file cord/cordxtra.c line 261
extern const char * CORD_to_const_char_star(const char *x)
{
  if(x == ((const char *)NULL))
    return "";

  else
    if(!((signed int)*x == 0))
      return (const char *)x;

    else
    {
      char *return_value_CORD_to_char_star$1;
      return_value_CORD_to_char_star$1=CORD_to_char_star(x);
      return return_value_CORD_to_char_star$1;
    }
}

// CORD_vfprintf
// file cord/cordprnt.c line 379
extern signed int CORD_vfprintf(struct _IO_FILE *f, const char *format, void **args)
{
  signed int result;
  const char *out = ((const char *)NULL);
  result=CORD_vsprintf(&out, format, args);
  if(result >= 1)
    CORD_put(out, f);

  return result;
}

// CORD_vprintf
// file cord/cordprnt.c line 402
extern signed int CORD_vprintf(const char *format, void **args)
{
  signed int result;
  const char *out = ((const char *)NULL);
  result=CORD_vsprintf(&out, format, args);
  if(result >= 1)
    CORD_put(out, stdout);

  return result;
}

// CORD_vsprintf
// file cord/cordprnt.c line 167
extern signed int CORD_vsprintf(const char **out, const char *format, __builtin_va_list args)
{
  struct CORD_ec_struct result[1l];
  signed int CORD_vsprintf$$1$$count;
  char current;
  struct CORD_Pos pos[1l];
  char conv_spec[51l];
  result[(signed long int)0].ec_cord = ((const char *)NULL);
  result[(signed long int)0].ec_bufptr = result[(signed long int)0].ec_buf;
  CORD_set_pos(pos, format, (unsigned long int)0);
  char return_value_CORD__pos_fetch$1;
  char return_value_CORD__pos_fetch$3;
  char return_value_CORD__pos_fetch$7;
  char *str;
  char CORD_vsprintf$$1$$1$$1$$1$$2$$2$$7$$c;
  char *tmp_post$14;
  char *tmp_post$17;
  while(!(pos[0l].path_len == 0x55555555))
  {
    signed int tmp_if_expr$2;
    if(!(pos[0l].cur_end == 0ul))
      tmp_if_expr$2 = (signed int)pos[(signed long int)0].cur_leaf[(signed long int)(pos[(signed long int)0].cur_pos - pos[(signed long int)0].cur_start)];

    else
    {
      return_value_CORD__pos_fetch$1=CORD__pos_fetch(pos);
      tmp_if_expr$2 = (signed int)return_value_CORD__pos_fetch$1;
    }
    current = (char)tmp_if_expr$2;
    if((signed int)current == 37)
    {
      if(!(1ul + pos[0l].cur_pos >= pos[0l].cur_end))
        pos[(signed long int)0].cur_pos = pos[(signed long int)0].cur_pos + 1ul;

      else
      {
        CORD__next(pos);
        0;
      }
      if(pos[0l].path_len == 0x55555555)
        return -1;

      signed int tmp_if_expr$4;
      if(!(pos[0l].cur_end == 0ul))
        tmp_if_expr$4 = (signed int)pos[(signed long int)0].cur_leaf[(signed long int)(pos[(signed long int)0].cur_pos - pos[(signed long int)0].cur_start)];

      else
      {
        return_value_CORD__pos_fetch$3=CORD__pos_fetch(pos);
        tmp_if_expr$4 = (signed int)return_value_CORD__pos_fetch$3;
      }
      current = (char)tmp_if_expr$4;
      if((signed int)current == 37)
      {
        if(result[0l].ec_bufptr == result[0l].ec_buf + 128l)
        {
          CORD_ec_flush_buf(result);
          0;
        }

        else
          0;
        char *tmp_post$5 = result[(signed long int)0].ec_bufptr;
        result[(signed long int)0].ec_bufptr = result[(signed long int)0].ec_bufptr + 1l;
        *tmp_post$5 = current;
      }

      else
      {
        signed int width;
        signed int prec;
        signed int left_adj = 0;
        signed int long_arg = 0;
        const char *arg;
        unsigned long int len;
        signed int return_value_extract_conv_spec$6;
        return_value_extract_conv_spec$6=extract_conv_spec(pos, conv_spec, &width, &prec, &left_adj, &long_arg);
        if(!(return_value_extract_conv_spec$6 >= 0))
          return -1;

        signed int tmp_if_expr$8;
        if(!(pos[0l].cur_end == 0ul))
          tmp_if_expr$8 = (signed int)pos[(signed long int)0].cur_leaf[(signed long int)(pos[(signed long int)0].cur_pos - pos[(signed long int)0].cur_start)];

        else
        {
          return_value_CORD__pos_fetch$7=CORD__pos_fetch(pos);
          tmp_if_expr$8 = (signed int)return_value_CORD__pos_fetch$7;
        }
        current = (char)tmp_if_expr$8;
        switch((signed int)current)
        {
          case 110:
          {
            if(long_arg == 0)
            {
              signed int *pos_ptr;
              pos_ptr=va_arg(args, __typeof__(pos_ptr));
              *pos_ptr=ec_len(result);
            }

            else
              if(long_arg >= 1)
              {
                signed long int *CORD_vsprintf$$1$$1$$1$$1$$2$$2$$2$$pos_ptr;
                CORD_vsprintf$$1$$1$$1$$1$$2$$2$$2$$pos_ptr=va_arg(args, __typeof__(CORD_vsprintf$$1$$1$$1$$1$$2$$2$$2$$pos_ptr));
                signed int return_value_ec_len$9;
                return_value_ec_len$9=ec_len(result);
                *CORD_vsprintf$$1$$1$$1$$1$$2$$2$$2$$pos_ptr = (signed long int)return_value_ec_len$9;
              }

              else
              {
                signed short int *CORD_vsprintf$$1$$1$$1$$1$$2$$2$$3$$pos_ptr;
                CORD_vsprintf$$1$$1$$1$$1$$2$$2$$3$$pos_ptr=va_arg(args, __typeof__(CORD_vsprintf$$1$$1$$1$$1$$2$$2$$3$$pos_ptr));
                signed int return_value_ec_len$10;
                return_value_ec_len$10=ec_len(result);
                *CORD_vsprintf$$1$$1$$1$$1$$2$$2$$3$$pos_ptr = (signed short int)return_value_ec_len$10;
              }
            break;
          }
          case 114:
          {
            if(width == -2)
              width=va_arg(args, __typeof__(width));

            if(prec == -2)
              prec=va_arg(args, __typeof__(prec));

            arg=va_arg(args, __typeof__(arg));
            len=CORD_len(arg);
            if(!(prec == -1) && !((unsigned long int)prec >= len))
            {
              if(!(prec >= 0))
                return -1;

              arg=CORD_substr(arg, (unsigned long int)0, (unsigned long int)prec);
              len = (unsigned long int)prec;
            }

            if(!(width == -1) && !(len >= (unsigned long int)width))
            {
              char *blanks;
              void *return_value_GC_malloc_atomic$11;
              return_value_GC_malloc_atomic$11=GC_malloc_atomic(((unsigned long int)width - len) + (unsigned long int)1);
              blanks = (char *)return_value_GC_malloc_atomic$11;
              memset((void *)blanks, 32, (unsigned long int)width - len);
              blanks[(signed long int)((unsigned long int)width - len)] = (char)0;
              if(!(left_adj == 0))
                arg=CORD_cat(arg, blanks);

              else
                arg=CORD_cat(blanks, arg);
            }

            CORD_ec_append_cord(result, arg);
            break;
          }
          case 99:
          {
            if(prec == -1 && width == -1)
            {
              char c;
              signed int return_value_gcc_builtin_va_arg$12;
              return_value_gcc_builtin_va_arg$12=va_arg(args, __typeof__(return_value_gcc_builtin_va_arg$12));
              c = (char)return_value_gcc_builtin_va_arg$12;
              if(result[0l].ec_bufptr == result[0l].ec_buf + 128l)
              {
                CORD_ec_flush_buf(result);
                0;
              }

              else
                0;
              char *tmp_post$13 = result[(signed long int)0].ec_bufptr;
              result[(signed long int)0].ec_bufptr = result[(signed long int)0].ec_bufptr + 1l;
              *tmp_post$13 = c;
              break;
            }

            goto __CPROVER_DUMP_L36;
          }
          case 115:
          {
            if(!(prec == -1) || !(width == -1))
              goto __CPROVER_DUMP_L36;

            str=va_arg(args, __typeof__(str));
            do
            {
              tmp_post$14 = str;
              str = str + 1l;
              CORD_vsprintf$$1$$1$$1$$1$$2$$2$$7$$c = *tmp_post$14;
              if(CORD_vsprintf$$1$$1$$1$$1$$2$$2$$7$$c == 0)
                break;

              if(result[0l].ec_bufptr == result[0l].ec_buf + 128l)
              {
                CORD_ec_flush_buf(result);
                0;
              }

              else
                0;
              char *tmp_post$15 = result[(signed long int)0].ec_bufptr;
              result[(signed long int)0].ec_bufptr = result[(signed long int)0].ec_bufptr + 1l;
              *tmp_post$15 = CORD_vsprintf$$1$$1$$1$$1$$2$$2$$7$$c;
            }
            while((_Bool)1);
            break;
          }
          default:
          {

          __CPROVER_DUMP_L36:
            ;
            char *buf;
            void **vsprintf_args;
            signed int max_size = 0;
            signed int res;
            vsprintf_args = (void **)args;
            if(width == -2)
              width=va_arg(args, __typeof__(width));

            if(prec == -2)
              prec=va_arg(args, __typeof__(prec));

            if(!(width == -1))
              max_size = width;

            if(!(prec == -1) && !(max_size >= prec))
              max_size = prec;

            max_size = max_size + 50;
            if(max_size >= 128)
            {
              void *return_value_GC_malloc_atomic$16;
              return_value_GC_malloc_atomic$16=GC_malloc_atomic((unsigned long int)(max_size + 1));
              buf = (char *)return_value_GC_malloc_atomic$16;
            }

            else
            {
              if(!(128l + -(result[0l].ec_bufptr - result[0l].ec_buf) >= (signed long int)max_size))
                CORD_ec_flush_buf(result);

              buf = result[(signed long int)0].ec_bufptr;
            }
            switch((signed int)current)
            {
              case 100:

              case 105:

              case 111:

              case 117:

              case 120:

              case 88:

              case 99:
              {
                if(!(long_arg >= 1))
                  (void)va_arg(args, __typeof__(*((signed int *)0)));

                else
                  if(long_arg >= 1)
                    (void)va_arg(args, __typeof__(*((signed long int *)0)));

                break;
              }
              case 115:

              case 112:
              {
                (void)va_arg(args, __typeof__(*((char **)0)));
                break;
              }
              case 102:

              case 101:

              case 69:

              case 103:

              case 71:
              {
                (void)va_arg(args, __typeof__(*((double *)0)));
                break;
              }
              default:
              {
                vsprintf_args = ((void **)NULL);
                return -1;
              }
            }
            res=vsprintf(buf, conv_spec, vsprintf_args);
            vsprintf_args = ((void **)NULL);
            len = (unsigned long int)res;
            if((char *)res == buf)
              len=strlen(buf);

            else
              if(!(res >= 0))
                return -1;

            if(!(buf == result[0l].ec_bufptr))
            {
              char CORD_vsprintf$$1$$1$$1$$1$$2$$3$$6$$c;
              do
              {
                tmp_post$17 = buf;
                buf = buf + 1l;
                CORD_vsprintf$$1$$1$$1$$1$$2$$3$$6$$c = *tmp_post$17;
                if(CORD_vsprintf$$1$$1$$1$$1$$2$$3$$6$$c == 0)
                  break;

                if(result[0l].ec_bufptr == result[0l].ec_buf + 128l)
                {
                  CORD_ec_flush_buf(result);
                  0;
                }

                else
                  0;
                char *tmp_post$18 = result[(signed long int)0].ec_bufptr;
                result[(signed long int)0].ec_bufptr = result[(signed long int)0].ec_bufptr + 1l;
                *tmp_post$18 = CORD_vsprintf$$1$$1$$1$$1$$2$$3$$6$$c;
              }
              while((_Bool)1);
            }

            else
              result[(signed long int)0].ec_bufptr = buf + (signed long int)len;
          }
        }
      }
    }

    else
    {
      if(result[0l].ec_bufptr == result[0l].ec_buf + 128l)
      {
        CORD_ec_flush_buf(result);
        0;
      }

      else
        0;
      char *tmp_post$19 = result[(signed long int)0].ec_bufptr;
      result[(signed long int)0].ec_bufptr = result[(signed long int)0].ec_bufptr + 1l;
      *tmp_post$19 = current;
    }

  done:
    ;
    if(!(1ul + pos[0l].cur_pos >= pos[0l].cur_end))
      pos[(signed long int)0].cur_pos = pos[(signed long int)0].cur_pos + 1ul;

    else
    {
      CORD__next(pos);
      0;
    }
  }
  CORD_vsprintf$$1$$count=ec_len(result);
  CORD_ec_flush_buf(result);
  *out=CORD_balance(result[(signed long int)0].ec_cord);
  return CORD_vsprintf$$1$$count;
}

// GC_FirstDLOpenedLinkMap
// file dyn_load.c line 678
struct link_map * GC_FirstDLOpenedLinkMap(void)
{
  struct anonymous$21 *dp;
  static struct link_map *cachedResult = ((struct link_map *)NULL);
  if(cachedResult == ((struct link_map *)NULL))
  {
    signed int tag;
    dp = _DYNAMIC;
    do
    {
      tag = (signed int)dp->d_tag;
      if(tag == 0)
        break;

      if(tag == 21)
      {
        struct link_map *lm = ((struct r_debug *)dp->d_un.d_ptr)->r_map;
        if(!(lm == ((struct link_map *)NULL)))
          cachedResult = lm->l_next;

        break;
      }

      dp = dp + 1l;
    }
    while((_Bool)1);
  }

  return cachedResult;
}

// GC_acquire_mark_lock
// file ./include/private/gc_priv.h line 2371
void GC_acquire_mark_lock(void)
{
  GC_generic_lock(&mark_mutex);
}

// GC_add_ext_descriptor
// file typd_mlc.c line 113
signed long int GC_add_ext_descriptor(const unsigned long int *bm, unsigned long int nbits)
{
  unsigned long int nwords = (nbits + (unsigned long int)64) - (unsigned long int)1 >> (unsigned long int)6;
  signed long int result;
  unsigned long int i;
  unsigned long int last_part;
  unsigned long int extra_bits;
  do
    if(!(GC_need_to_lock == 0))
    {
      signed int return_value_pthread_mutex_trylock$1;
      return_value_pthread_mutex_trylock$1=pthread_mutex_trylock(&GC_allocate_ml);
      if(!(return_value_pthread_mutex_trylock$1 == 0))
        GC_lock();

    }

  while((_Bool)0);
  while(nwords + GC_avail_descr >= GC_ed_size)
  {
    struct anonymous$19 *new;
    unsigned long int new_size;
    unsigned long int ed_size = GC_ed_size;
    if(ed_size == 0ul)
    {
      GC_push_typed_structures = GC_push_typed_structures_proc;
      do
        if(!(GC_need_to_lock == 0))
          pthread_mutex_unlock(&GC_allocate_ml);

      while((_Bool)0);
      new_size = (unsigned long int)100;
    }

    else
    {
      do
        if(!(GC_need_to_lock == 0))
          pthread_mutex_unlock(&GC_allocate_ml);

      while((_Bool)0);
      new_size = (unsigned long int)2 * ed_size;
      if(new_size >= 72057594037927936ul)
        return (signed long int)-1;

    }
    void *return_value_GC_malloc_atomic$2;
    return_value_GC_malloc_atomic$2=GC_malloc_atomic(new_size * sizeof(struct anonymous$19) /*16ul*/ );
    new = (struct anonymous$19 *)return_value_GC_malloc_atomic$2;
    if(new == ((struct anonymous$19 *)NULL))
      return (signed long int)-1;

    do
      if(!(GC_need_to_lock == 0))
      {
        signed int return_value_pthread_mutex_trylock$3;
        return_value_pthread_mutex_trylock$3=pthread_mutex_trylock(&GC_allocate_ml);
        if(!(return_value_pthread_mutex_trylock$3 == 0))
          GC_lock();

      }

    while((_Bool)0);
    if(ed_size == GC_ed_size)
    {
      if(!(GC_avail_descr == 0ul))
        memcpy((void *)new, (const void *)GC_ext_descriptors, (unsigned long int)(GC_avail_descr * sizeof(struct anonymous$19) /*16ul*/ ));

      GC_ed_size = new_size;
      GC_ext_descriptors = new;
    }

  }
  result = (signed long int)GC_avail_descr;
  i = (unsigned long int)0;
  for( ; !(i >= nwords + 18446744073709551615ul); i = i + 1ul)
  {
    (GC_ext_descriptors + (signed long int)((unsigned long int)result + i))->ed_bitmap = bm[(signed long int)i];
    (GC_ext_descriptors + (signed long int)((unsigned long int)result + i))->ed_continued = 1;
  }
  last_part = bm[(signed long int)i];
  extra_bits = nwords * (unsigned long int)64 - nbits;
  last_part = last_part << extra_bits;
  last_part = last_part >> extra_bits;
  (GC_ext_descriptors + (signed long int)((unsigned long int)result + i))->ed_bitmap = last_part;
  (GC_ext_descriptors + (signed long int)((unsigned long int)result + i))->ed_continued = 0;
  GC_avail_descr = GC_avail_descr + nwords;
  do
    if(!(GC_need_to_lock == 0))
      pthread_mutex_unlock(&GC_allocate_ml);

  while((_Bool)0);
  return result;
}

// GC_add_leaked
// file reclaim.c line 52
static inline void GC_add_leaked(char *leaked)
{
  signed int return_value_GC_check_leaked$1;
  if(!(GC_findleak_delay_free == 0))
  {
    return_value_GC_check_leaked$1=GC_check_leaked(leaked);
    if(return_value_GC_check_leaked$1 == 0)
      goto __CPROVER_DUMP_L3;

  }

  GC_have_errors = 1;
  if(!(GC_n_leaked >= 40u))
  {
    unsigned int tmp_post$2 = GC_n_leaked;
    GC_n_leaked = GC_n_leaked + 1u;
    GC_leaked[(signed long int)tmp_post$2] = leaked;
    GC_set_mark_bit((const void *)leaked);
  }


__CPROVER_DUMP_L3:
  ;
}

// GC_add_leaked$link1
// file reclaim.c line 52
static inline void GC_add_leaked$link1(char *leaked$link1)
{
  signed int return_value_GC_check_leaked$1$link1;
  if(!(GC_findleak_delay_free == 0))
  {
    return_value_GC_check_leaked$1$link1=GC_check_leaked(leaked$link1);
    if(return_value_GC_check_leaked$1$link1 == 0)
      goto __CPROVER_DUMP_L3;

  }

  GC_have_errors = 1;
  if(!(GC_n_leaked >= 40u))
  {
    unsigned int tmp_post$2$link1 = GC_n_leaked;
    GC_n_leaked = GC_n_leaked + 1u;
    GC_leaked[(signed long int)tmp_post$2$link1] = leaked$link1;
    GC_set_mark_bit((const void *)leaked$link1);
  }


__CPROVER_DUMP_L3:
  ;
}

// GC_add_map_entry
// file ./include/private/gc_priv.h line 1734
signed int GC_add_map_entry(unsigned long int granules)
{
  unsigned int displ;
  signed short int *new_map;
  if(granules >= 129ul)
    granules = (unsigned long int)0;

  if(!(GC_arrays._obj_map[(signed long int)granules] == ((signed short int *)NULL)))
    return 1;

  else
  {
    char *return_value_GC_scratch_alloc$1;
    return_value_GC_scratch_alloc$1=GC_scratch_alloc(((unsigned long int)(1 << 12) >> 4) * sizeof(signed short int) /*2ul*/ );
    new_map = (signed short int *)return_value_GC_scratch_alloc$1;
    if(new_map == ((signed short int *)NULL))
      return 0;

    else
    {
      if(!(GC_print_stats == 0))
        GC_log_printf("Adding block map for size of %u granules (%u bytes)\n", (unsigned int)granules, (unsigned int)(granules << 4));

      if(granules == 0ul)
      {
        displ = (unsigned int)0;
        for( ; !((unsigned long int)displ >= 256ul); displ = displ + 1u)
          new_map[(signed long int)displ] = (signed short int)1;
      }

      else
      {
        displ = (unsigned int)0;
        for( ; !((unsigned long int)displ >= 256ul); displ = displ + 1u)
          new_map[(signed long int)displ] = (signed short int)((unsigned long int)displ % granules);
      }
      GC_arrays._obj_map[(signed long int)granules] = new_map;
      return 1;
    }
  }
}

// GC_add_roots
// file mark_rts.c line 151
extern void GC_add_roots(void *b, void *e)
{
  if((signed long int)GC_is_initialized == 0l)
    GC_init();

  do
    if(!(GC_need_to_lock == 0))
    {
      signed int return_value_pthread_mutex_trylock$1;
      return_value_pthread_mutex_trylock$1=pthread_mutex_trylock(&GC_allocate_ml);
      if(!(return_value_pthread_mutex_trylock$1 == 0))
        GC_lock();

    }

  while((_Bool)0);
  GC_add_roots_inner((char *)b, (char *)e, 0);
  do
    if(!(GC_need_to_lock == 0))
      pthread_mutex_unlock(&GC_allocate_ml);

  while((_Bool)0);
}

// GC_add_roots_inner
// file ./include/private/gc_priv.h line 1660
void GC_add_roots_inner(char *b, char *e, signed int tmp)
{
  struct roots *old;
  b = (char *)((unsigned long int)b + (sizeof(unsigned long int) /*8ul*/  - (unsigned long int)1) & ~(sizeof(unsigned long int) /*8ul*/  - (unsigned long int)1));
  e = (char *)((unsigned long int)e & ~(sizeof(unsigned long int) /*8ul*/  - (unsigned long int)1));
  if(!((unsigned long int)b >= (unsigned long int)e))
  {
    void *return_value_GC_roots_present$1;
    return_value_GC_roots_present$1=GC_roots_present(b);
    old = (struct roots *)return_value_GC_roots_present$1;
    if(!(old == ((struct roots *)NULL)))
    {
      if((unsigned long int)old->r_end >= (unsigned long int)e)
        goto __CPROVER_DUMP_L5;

      GC_root_size = GC_root_size + (unsigned long int)(e - old->r_end);
      old->r_end = e;
    }

    else
    {
      if(n_root_sets == 2048)
      {
        GC_on_abort("Too many root sets");
        abort();
      }

      GC_arrays._static_roots[(signed long int)n_root_sets].r_start = (char *)b;
      GC_arrays._static_roots[(signed long int)n_root_sets].r_end = (char *)e;
      GC_arrays._static_roots[(signed long int)n_root_sets].r_tmp = tmp;
      GC_arrays._static_roots[(signed long int)n_root_sets].r_next = ((struct roots *)NULL);
      add_roots_to_index(GC_arrays._static_roots + (signed long int)n_root_sets);
      GC_root_size = GC_root_size + (unsigned long int)(e - b);
      n_root_sets = n_root_sets + 1;
    }
  }


__CPROVER_DUMP_L5:
  ;
}

// GC_add_smashed
// file dbg_mlc.c line 945
void GC_add_smashed(char *smashed)
{
  GC_smashed[(signed long int)GC_n_smashed] = smashed;
  if(!(GC_n_smashed >= 19u))
    GC_n_smashed = GC_n_smashed + 1u;

  GC_have_errors = 1;
}

// GC_add_to_black_list_normal
// file blacklst.c line 183
void GC_add_to_black_list_normal(unsigned long int p)
{
  if(!(GC_arrays._modws_valid_offsets[7l & (signed long int)p] == 0))
  {
    unsigned long int index = (unsigned long int)p >> (unsigned long int)12 & ((unsigned long int)1 << 18) - (unsigned long int)1;
    struct hblkhdr *return_value_GC_find_header$1;
    return_value_GC_find_header$1=GC_find_header((char *)p);
    _Bool tmp_if_expr$2;
    if(return_value_GC_find_header$1 == ((struct hblkhdr *)NULL))
      tmp_if_expr$2 = (_Bool)1;

    else
      tmp_if_expr$2 = (GC_old_normal_bl[(signed long int)(index >> (unsigned long int)6)] >> (index & (unsigned long int)0x3f) & (unsigned long int)1) != 0ul ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$2)
      GC_incomplete_normal_bl[(signed long int)(index >> (unsigned long int)6)] = GC_incomplete_normal_bl[(signed long int)(index >> (unsigned long int)6)] | (unsigned long int)1 << (index & (unsigned long int)0x3f);

  }

}

// GC_add_to_black_list_stack
// file blacklst.c line 205
void GC_add_to_black_list_stack(unsigned long int p)
{
  unsigned long int index = (unsigned long int)p >> (unsigned long int)12 & ((unsigned long int)1 << 18) - (unsigned long int)1;
  struct hblkhdr *return_value_GC_find_header$1;
  return_value_GC_find_header$1=GC_find_header((char *)p);
  _Bool tmp_if_expr$2;
  if(return_value_GC_find_header$1 == ((struct hblkhdr *)NULL))
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = (GC_old_stack_bl[(signed long int)(index >> (unsigned long int)6)] >> (index & (unsigned long int)0x3f) & (unsigned long int)1) != 0ul ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$2)
    GC_incomplete_stack_bl[(signed long int)(index >> (unsigned long int)6)] = GC_incomplete_stack_bl[(signed long int)(index >> (unsigned long int)6)] | (unsigned long int)1 << (index & (unsigned long int)0x3f);

}

// GC_add_to_fl
// file allchblk.c line 352
void GC_add_to_fl(struct hblk *h, struct hblkhdr *hhdr)
{
  signed int index;
  index=GC_hblk_fl_from_blocks(hhdr->hb_sz >> (unsigned long int)12);
  struct hblk *second = GC_hblkfreelist[(signed long int)index];
  struct hblkhdr *second_hdr;
  GC_hblkfreelist[(signed long int)index] = h;
  GC_free_bytes[(signed long int)index] = GC_free_bytes[(signed long int)index] + hhdr->hb_sz;
  hhdr->hb_next = second;
  hhdr->hb_prev = ((struct hblk *)NULL);
  if(!(second == ((struct hblk *)NULL)))
  {
    do
    {
      struct hblkhdr **_ha;
      do
      {
        struct bi *bi;
        do
        {
          unsigned long int hi = (unsigned long int)second >> (unsigned long int)10 + (unsigned long int)12;
          struct bi *_bi = GC_arrays._top_index[(signed long int)(hi & (unsigned long int)((1 << 11) - 1))];
          for( ; !(_bi->key == hi); _bi = _bi->hash_link)
            if(_bi == GC_arrays._all_nils)
              break;

          bi = _bi;
        }
        while((_Bool)0);
        _ha = &bi->index[(signed long int)((unsigned long int)second >> (unsigned long int)12 & (unsigned long int)((1 << 10) - 1))];
      }
      while((_Bool)0);
      second_hdr = *_ha;
    }
    while((_Bool)0);
    second_hdr->hb_prev = h;
  }

  hhdr->hb_flags = hhdr->hb_flags | (unsigned char)4;
}

// GC_add_to_heap
// file alloc.c line 1045
void GC_add_to_heap(struct hblk *p, unsigned long int bytes)
{
  struct hblkhdr *phdr;
  unsigned long int endp;
  if(GC_n_heap_sects >= 1024ul)
  {
    GC_on_abort("Too many heap sections: Increase MAXHINCR or MAX_HEAP_SECTS");
    abort();
  }

  while(!((unsigned long int)p >= 4097ul))
  {
    p = p + 1l;
    bytes = bytes - (unsigned long int)(1 << 12);
    if(bytes == 0ul)
      goto __CPROVER_DUMP_L10;

  }
  endp = (unsigned long int)p + bytes;
  if((unsigned long int)p >= endp)
  {
    bytes = bytes - (unsigned long int)(1 << 12);
    if(bytes == 0ul)
      goto __CPROVER_DUMP_L10;

    endp = endp - (unsigned long int)(1 << 12);
  }

  phdr=GC_install_header(p);
  if(!(phdr == ((struct hblkhdr *)NULL)))
  {
    GC_arrays._heap_sects[(signed long int)GC_n_heap_sects].hs_start = (char *)p;
    GC_arrays._heap_sects[(signed long int)GC_n_heap_sects].hs_bytes = bytes;
    GC_n_heap_sects = GC_n_heap_sects + 1ul;
    phdr->hb_sz = bytes;
    phdr->hb_flags = (unsigned char)0;
    GC_freehblk(p);
    GC_arrays._heapsize = GC_arrays._heapsize + bytes;
    GC_collect_at_heapsize = GC_collect_at_heapsize + bytes;
    if(!(GC_collect_at_heapsize >= GC_arrays._heapsize))
      GC_collect_at_heapsize = (unsigned long int)-1;

    if(GC_least_plausible_heap_addr == NULL || (unsigned long int)GC_least_plausible_heap_addr >= (unsigned long int)p)
      GC_least_plausible_heap_addr = (void *)((char *)p - (signed long int)sizeof(unsigned long int) /*8ul*/ );

    if(bytes + (unsigned long int)p >= (unsigned long int)GC_greatest_plausible_heap_addr)
      GC_greatest_plausible_heap_addr = (void *)endp;

  }


__CPROVER_DUMP_L10:
  ;
}

// GC_adj_bytes_allocd
// file alloc.c line 244
unsigned long int GC_adj_bytes_allocd(void)
{
  signed long int result;
  signed long int expl_managed = (signed long int)GC_non_gc_bytes - (signed long int)GC_non_gc_bytes_at_gc;
  result = ((((signed long int)GC_arrays._bytes_allocd + (signed long int)GC_arrays._bytes_dropped) - (signed long int)GC_arrays._bytes_freed) + (signed long int)GC_arrays._finalizer_bytes_freed) - expl_managed;
  if(!((signed long int)GC_arrays._bytes_allocd >= result))
    result = (signed long int)GC_arrays._bytes_allocd;

  result = result + (signed long int)GC_arrays._bytes_finalized;
  if(!(result >= (signed long int)(GC_arrays._bytes_allocd >> 3)))
    return GC_arrays._bytes_allocd >> 3;

  else
    return (unsigned long int)result;
}

// GC_alloc_large
// file malloc.c line 42
char * GC_alloc_large(unsigned long int lb, signed int k, unsigned int flags)
{
  struct hblk *h;
  unsigned long int n_blocks;
  char *result;
  signed int retry = 0;
  lb = (lb + (unsigned long int)16) - (unsigned long int)1 & (unsigned long int)~(16 - 1);
  n_blocks = (lb + (unsigned long int)(1 << 12)) - (unsigned long int)1 >> (unsigned long int)12;
  if((signed long int)GC_is_initialized == 0l)
    GC_init();

  if(GC_dont_gc == 0 && !(GC_incremental == 0))
    GC_collect_a_little_inner((signed int)n_blocks);

  h=GC_allochblk(lb, k, flags);
  signed int return_value_GC_collect_or_expand$1;
  for( ; h == ((struct hblk *)NULL); retry = 1)
  {
    return_value_GC_collect_or_expand$1=GC_collect_or_expand(n_blocks, (signed int)(flags != (unsigned int)0), retry);
    if(return_value_GC_collect_or_expand$1 == 0)
      break;

    h=GC_allochblk(lb, k, flags);
  }
  if(h == ((struct hblk *)NULL))
    result = ((char *)NULL);

  else
  {
    unsigned long int total_bytes = n_blocks * (unsigned long int)(1 << 12);
    if(n_blocks >= 2ul)
    {
      GC_arrays._large_allocd_bytes = GC_arrays._large_allocd_bytes + total_bytes;
      if(!(GC_arrays._max_large_allocd_bytes >= GC_arrays._large_allocd_bytes))
        GC_arrays._max_large_allocd_bytes = GC_arrays._large_allocd_bytes;

    }

    result = h->hb_body;
  }
  return result;
}

// GC_alloc_large_and_clear
// file malloc.c line 85
char * GC_alloc_large_and_clear(unsigned long int lb, signed int k, unsigned int flags)
{
  char *result;
  result=GC_alloc_large(lb, k, flags);
  unsigned long int n_blocks = (lb + (unsigned long int)(1 << 12)) - (unsigned long int)1 >> (unsigned long int)12;
  if(result == ((char *)NULL))
    return ((char *)NULL);

  else
  {
    _Bool tmp_if_expr$1;
    if(!(GC_debugging_started == 0))
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = GC_obj_kinds[(signed long int)k].ok_init != 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$1)
      memset((void *)result, 0, (unsigned long int)(n_blocks * (unsigned long int)(1 << 12)));

    return result;
  }
}

// GC_alloc_reclaim_list
// file malloc.c line 23
signed int GC_alloc_reclaim_list(struct obj_kind *kind)
{
  struct hblk **result;
  char *return_value_GC_scratch_alloc$1;
  return_value_GC_scratch_alloc$1=GC_scratch_alloc(((unsigned long int)((1 << 12) / 2 >> 4) + (unsigned long int)1) * sizeof(struct hblk *) /*8ul*/ );
  result = (struct hblk **)return_value_GC_scratch_alloc$1;
  if(result == ((struct hblk **)NULL))
    return 0;

  else
  {
    memset((void *)result, 0, (unsigned long int)(((unsigned long int)((1 << 12) / 2 >> 4) + (unsigned long int)1) * sizeof(struct hblk *) /*8ul*/ ));
    kind->ok_reclaim_list = result;
    return 1;
  }
}

// GC_allochblk
// file allchblk.c line 576
struct hblk * GC_allochblk(unsigned long int sz, signed int kind, unsigned int flags)
{
  unsigned long int blocks;
  signed int start_list;
  struct hblk *result;
  signed int may_split;
  signed int split_limit;
  blocks = (sz + (unsigned long int)(1 << 12)) - (unsigned long int)1 >> (unsigned long int)12;
  signed int return_value_GC_should_collect$1;
  if(!(4096l * (signed long int)blocks >= 0l))
    return ((struct hblk *)NULL);

  else
  {
    start_list=GC_hblk_fl_from_blocks(blocks);
    result=GC_allochblk_nth(sz, kind, flags, start_list, 0);
    if(!(result == ((struct hblk *)NULL)))
      return result;

    else
    {
      may_split = 1;
      _Bool tmp_if_expr$2;
      if(!(GC_dont_gc == 0) || !(GC_incremental == 0) || !(GC_use_entire_heap == 0) || !(GC_arrays._heapsize + -GC_arrays._large_free_bytes >= GC_arrays._requested_heapsize))
        tmp_if_expr$2 = (_Bool)1;

      else
      {
        return_value_GC_should_collect$1=GC_should_collect();
        tmp_if_expr$2 = !(return_value_GC_should_collect$1 != 0) ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$2)
        split_limit = (256 - 32) / 8 + 32;

      else
        if(!(GC_arrays._heapsize >> 4 >= GC_arrays._finalizer_bytes_freed))
          split_limit = 0;

        else
          split_limit=GC_enough_large_bytes_left();
      if(!(start_list >= 32))
        start_list = start_list + 1;

      for( ; split_limit >= start_list; start_list = start_list + 1)
      {
        result=GC_allochblk_nth(sz, kind, flags, start_list, may_split);
        if(!(result == ((struct hblk *)NULL)))
          break;

      }
      return result;
    }
  }
}

// GC_allochblk_nth
// file allchblk.c line 640
struct hblk * GC_allochblk_nth(unsigned long int sz, signed int kind, unsigned int flags, signed int n, signed int may_split)
{
  struct hblk *hbp;
  struct hblkhdr *hhdr;
  struct hblk *thishbp;
  struct hblkhdr *thishdr;
  signed long int size_needed;
  signed long int size_avail;
  size_needed = (signed long int)((unsigned long int)(1 << 12) * ((sz + (unsigned long int)(1 << 12)) - (unsigned long int)1 >> (unsigned long int)12));
  hbp = GC_hblkfreelist[(signed long int)n];
  struct hblk *return_value_GC_is_black_listed$1;
  for( ; (_Bool)1; hbp = hhdr->hb_next)
  {
    if(hbp == ((struct hblk *)NULL))
      return (struct hblk *)(void *)0;

    do
    {
      struct hblkhdr **_ha;
      do
      {
        struct bi *bi;
        do
        {
          unsigned long int GC_allochblk_nth$$1$$1$$1$$1$$1$$1$$hi = (unsigned long int)hbp >> (unsigned long int)10 + (unsigned long int)12;
          struct bi *GC_allochblk_nth$$1$$1$$1$$1$$1$$1$$_bi = GC_arrays._top_index[(signed long int)(GC_allochblk_nth$$1$$1$$1$$1$$1$$1$$hi & (unsigned long int)((1 << 11) - 1))];
          for( ; !(GC_allochblk_nth$$1$$1$$1$$1$$1$$1$$_bi->key == GC_allochblk_nth$$1$$1$$1$$1$$1$$1$$hi); GC_allochblk_nth$$1$$1$$1$$1$$1$$1$$_bi = GC_allochblk_nth$$1$$1$$1$$1$$1$$1$$_bi->hash_link)
            if(GC_allochblk_nth$$1$$1$$1$$1$$1$$1$$_bi == GC_arrays._all_nils)
              break;

          bi = GC_allochblk_nth$$1$$1$$1$$1$$1$$1$$_bi;
        }
        while((_Bool)0);
        _ha = &bi->index[(signed long int)((unsigned long int)hbp >> (unsigned long int)12 & (unsigned long int)((1 << 10) - 1))];
      }
      while((_Bool)0);
      hhdr = *_ha;
    }
    while((_Bool)0);
    size_avail = (signed long int)hhdr->hb_sz;
    if(size_avail >= size_needed)
    {
      if(!(size_avail == size_needed))
      {
        signed long int next_size;
        if(may_split == 0)
          goto __CPROVER_DUMP_L28;

        thishbp = hhdr->hb_next;
        if(!(thishbp == ((struct hblk *)NULL)))
        {
          do
          {
            struct hblkhdr **GC_allochblk_nth$$1$$1$$1$$2$$1$$1$$_ha;
            do
            {
              struct bi *GC_allochblk_nth$$1$$1$$1$$2$$1$$1$$1$$bi;
              do
              {
                unsigned long int hi = (unsigned long int)thishbp >> (unsigned long int)10 + (unsigned long int)12;
                struct bi *_bi = GC_arrays._top_index[(signed long int)(hi & (unsigned long int)((1 << 11) - 1))];
                for( ; !(_bi->key == hi); _bi = _bi->hash_link)
                  if(_bi == GC_arrays._all_nils)
                    break;

                GC_allochblk_nth$$1$$1$$1$$2$$1$$1$$1$$bi = _bi;
              }
              while((_Bool)0);
              GC_allochblk_nth$$1$$1$$1$$2$$1$$1$$_ha = &GC_allochblk_nth$$1$$1$$1$$2$$1$$1$$1$$bi->index[(signed long int)((unsigned long int)thishbp >> (unsigned long int)12 & (unsigned long int)((1 << 10) - 1))];
            }
            while((_Bool)0);
            thishdr = *GC_allochblk_nth$$1$$1$$1$$2$$1$$1$$_ha;
          }
          while((_Bool)0);
          next_size = (signed long int)thishdr->hb_sz;
          if(next_size >= size_needed && !(next_size >= size_avail))
          {
            return_value_GC_is_black_listed$1=GC_is_black_listed(thishbp, (unsigned long int)size_needed);
            if(return_value_GC_is_black_listed$1 == ((struct hblk *)NULL))
              goto __CPROVER_DUMP_L28;

          }

        }

      }

      if(!((-2 & kind) == 2) && (size_needed >= 8193l || !(kind == 0)))
      {
        struct hblk *lasthbp = hbp;
        char *search_end = ((char *)hbp + size_avail) - size_needed;
        signed long int orig_avail = size_avail;
        signed long int eff_size_needed = (flags & (unsigned int)1) != (unsigned int)0 ? (signed long int)(unsigned long int)(1 << 12) : size_needed;
        for( ; (unsigned long int)search_end >= (unsigned long int)lasthbp; lasthbp = thishbp)
        {
          thishbp=GC_is_black_listed(lasthbp, (unsigned long int)eff_size_needed);
          if(thishbp == ((struct hblk *)NULL))
            break;

        }
        size_avail = size_avail - ((char *)lasthbp - (char *)hbp);
        thishbp = lasthbp;
        if(size_avail >= size_needed)
        {
          if(!(thishbp == hbp))
          {
            thishdr=GC_install_header(thishbp);
            if(!(thishdr == ((struct hblkhdr *)NULL)))
            {
              GC_split_block(hbp, hhdr, thishbp, thishdr, n);
              hbp = thishbp;
              hhdr = thishdr;
            }

          }

        }

        else
          if(!((signed long int)GC_black_list_spacing >= orig_avail + -size_needed) && !((signed long int)GC_black_list_spacing >= size_needed))
          {
            GC_large_alloc_warn_suppressed = GC_large_alloc_warn_suppressed + 1l;
            if(GC_large_alloc_warn_suppressed >= GC_large_alloc_warn_interval)
            {
              GC_current_warn_proc("GC Warning: Repeated allocation of very large block (appr. size %ld):\n\tMay lead to memory leak and poor performance.\n", (unsigned long int)size_needed);
              GC_large_alloc_warn_suppressed = (signed long int)0;
            }

            size_avail = orig_avail;
          }

          else
            if(size_avail == 0l && (unsigned long int)size_needed == 4096ul)
            {
              if(GC_find_leak == 0)
              {
                static unsigned int GC_allochblk_nth$$1$$1$$1$$3$$4$$1$$count = (unsigned int)0;
                GC_allochblk_nth$$1$$1$$1$$3$$4$$1$$count = GC_allochblk_nth$$1$$1$$1$$3$$4$$1$$count + 1u;
                if((3u & GC_allochblk_nth$$1$$1$$1$$3$$4$$1$$count) == 0u)
                {
                  unsigned long int total_size = hhdr->hb_sz;
                  struct hblk *limit = hbp + (signed long int)(total_size >> (unsigned long int)12);
                  struct hblk *h;
                  struct hblk *prev = hhdr->hb_prev;
                  GC_arrays._large_free_bytes = GC_arrays._large_free_bytes - total_size;
                  GC_arrays._bytes_dropped = GC_arrays._bytes_dropped + total_size;
                  GC_remove_from_fl_at(hhdr, n);
                  h = hbp;
                  for( ; !((unsigned long int)h >= (unsigned long int)limit); h = h + 1l)
                  {
                    if(!(h == hbp))
                      hhdr=GC_install_header(h);

                    if(!(hhdr == ((struct hblkhdr *)NULL)))
                    {
                      setup_header(hhdr, h, (unsigned long int)(1 << 12), 0, (unsigned int)0);
                      if(!(GC_debugging_started == 0))
                        memset((void *)h, 0, (unsigned long int)(1 << 12));

                    }

                  }
                  hbp = prev;
                  if(hbp == ((struct hblk *)NULL))
                  {
                    struct hblk *return_value_GC_allochblk_nth$2;
                    return_value_GC_allochblk_nth$2=GC_allochblk_nth(sz, kind, flags, n, may_split);
                    return return_value_GC_allochblk_nth$2;
                  }

                  hhdr=GC_find_header((char *)hbp);
                }

              }

            }

      }

      if(size_avail >= size_needed)
      {
        hbp=GC_get_first_part(hbp, hhdr, (unsigned long int)size_needed, n);
        break;
      }

    }


  __CPROVER_DUMP_L28:
    ;
  }
  if(hbp == ((struct hblk *)NULL))
    return ((struct hblk *)NULL);

  else
  {
    signed int return_value_GC_install_counts$3;
    return_value_GC_install_counts$3=GC_install_counts(hbp, (unsigned long int)size_needed);
    if(return_value_GC_install_counts$3 == 0)
      return ((struct hblk *)NULL);

    else
    {
      signed int return_value_setup_header$4;
      return_value_setup_header$4=setup_header(hhdr, hbp, sz, kind, flags);
      if(return_value_setup_header$4 == 0)
      {
        GC_remove_counts(hbp, (unsigned long int)size_needed);
        return ((struct hblk *)NULL);
      }

      else
      {
        GC_remove_protection(hbp, (unsigned long int)(size_needed >> (unsigned long int)12), (signed int)(hhdr->hb_descr == (unsigned long int)0));
        GC_fail_count = (unsigned int)0;
        GC_arrays._large_free_bytes = GC_arrays._large_free_bytes - (unsigned long int)size_needed;
        return hbp;
      }
    }
  }
}

// GC_allocobj
// file alloc.c line 1330
char * GC_allocobj(unsigned long int gran, signed int kind)
{
  void **flh = &GC_obj_kinds[(signed long int)kind].ok_freelist[(signed long int)gran];
  signed int tried_minor = 0;
  signed int retry = 0;
  if(gran == 0ul)
    return ((char *)NULL);

  else
  {
    while(*flh == NULL)
    {
      GC_collecting = 1;
      if(!(GC_incremental == 0) && !(GC_time_limit == 999999ul))
        GC_collect_a_little_inner(1);

      GC_continue_reclaim(gran, kind);
      GC_collecting = 0;
      if(*flh == NULL)
        GC_new_hblk(gran, kind);

      if(*flh == NULL)
      {
        GC_collecting = 1;
        if(tried_minor == 0 && GC_time_limit == 999999ul && !(GC_incremental == 0))
        {
          GC_collect_a_little_inner(1);
          tried_minor = 1;
        }

        else
        {
          signed int return_value_GC_collect_or_expand$1;
          return_value_GC_collect_or_expand$1=GC_collect_or_expand((unsigned long int)1, 0, retry);
          if(return_value_GC_collect_or_expand$1 == 0)
          {
            GC_collecting = 0;
            return ((char *)NULL);
          }

          retry = 1;
        }
        GC_collecting = 0;
      }

    }
    GC_fail_count = (unsigned int)0;
    return (char *)*flh;
  }
}

// GC_allow_register_threads
// file pthread_support.c line 1542
extern void GC_allow_register_threads(void)
{
  GC_need_to_lock = 1;
}

// GC_apply_to_all_blocks
// file ./include/private/gc_priv.h line 1542
void GC_apply_to_all_blocks(void (*fn)(struct hblk *, unsigned long int), unsigned long int client_data)
{
  signed long int j;
  struct bi *index_p = GC_all_bottom_indices;
  for( ; !(index_p == ((struct bi *)NULL)); index_p = index_p->asc_link)
  {
    j = (signed long int)((1 << 10) - 1);
    while(j >= 0l)
      if((unsigned long int)index_p->index[j] >= 4096ul)
      {
        if((4 & (signed int)index_p->index[j]->hb_flags) == 0)
          fn((struct hblk *)((index_p->key << 10) + (unsigned long int)j << (unsigned long int)12), client_data);

        j = j - 1l;
      }

      else
        if(index_p->index[j] == ((struct hblkhdr *)NULL))
          j = j - 1l;

        else
          j = j - (signed long int)index_p->index[j];
  }
}

// GC_approx_sp
// file ./include/private/gc_priv.h line 1538
char * GC_approx_sp(void)
{
  volatile unsigned long int sp = (unsigned long int)&sp;
  return (char *)sp;
}

// GC_array_mark_proc
// file typd_mlc.c line 495
struct GC_ms_entry * GC_array_mark_proc(unsigned long int *addr, struct GC_ms_entry *mark_stack_ptr, struct GC_ms_entry *mark_stack_limit, unsigned long int env)
{
  struct hblkhdr *hhdr;
  hhdr=GC_find_header((char *)addr);
  unsigned long int sz = hhdr->hb_sz;
  unsigned long int nwords = sz >> 3;
  union ComplexDescriptor *descr = (union ComplexDescriptor *)addr[(signed long int)(nwords - (unsigned long int)1)];
  struct GC_ms_entry *orig_mark_stack_ptr = mark_stack_ptr;
  struct GC_ms_entry *new_mark_stack_ptr;
  if(descr == ((union ComplexDescriptor *)NULL))
    return orig_mark_stack_ptr;

  else
  {
    new_mark_stack_ptr=GC_push_complex_descriptor(addr, descr, mark_stack_ptr, mark_stack_limit - (signed long int)1);
    if(new_mark_stack_ptr == ((struct GC_ms_entry *)NULL))
    {
      GC_mark_stack_too_small = 1;
      new_mark_stack_ptr = orig_mark_stack_ptr + (signed long int)1;
      new_mark_stack_ptr->mse_start = (char *)addr;
      new_mark_stack_ptr->mse_descr.w = sz | (unsigned long int)0;
    }

    else
    {
      new_mark_stack_ptr = new_mark_stack_ptr + 1l;
      new_mark_stack_ptr->mse_start = (char *)((addr + (signed long int)nwords) - (signed long int)1);
      new_mark_stack_ptr->mse_descr.w = sizeof(unsigned long int) /*8ul*/  | (unsigned long int)0;
    }
    return new_mark_stack_ptr;
  }
}

// GC_atfork_child
// file pthread_support.c line 1019
extern void GC_atfork_child(void)
{
  if(!(GC_handle_fork >= 1))
    fork_child_proc();

}

// GC_atfork_parent
// file pthread_support.c line 1013
extern void GC_atfork_parent(void)
{
  if(!(GC_handle_fork >= 1))
    fork_parent_proc();

}

// GC_atfork_prepare
// file pthread_support.c line 1001
extern void GC_atfork_prepare(void)
{
  if(!(GC_handle_fork >= 1))
    fork_prepare_proc();

}

// GC_base
// file ./include/private/../gc.h line 464
extern void * GC_base(void *p)
{
  char *r;
  struct hblk *h;
  struct bi *bi;
  struct hblkhdr *candidate_hdr;
  char *limit;
  r = (char *)p;
  if((signed long int)GC_is_initialized == 0l)
    return NULL;

  else
  {
    h = (struct hblk *)((unsigned long int)r & ~((unsigned long int)(1 << 12) - (unsigned long int)1));
    do
    {
      unsigned long int hi = (unsigned long int)r >> (unsigned long int)10 + (unsigned long int)12;
      struct bi *_bi = GC_arrays._top_index[(signed long int)(hi & (unsigned long int)((1 << 11) - 1))];
      for( ; !(_bi->key == hi); _bi = _bi->hash_link)
        if(_bi == GC_arrays._all_nils)
          break;

      bi = _bi;
    }
    while((_Bool)0);
    candidate_hdr = bi->index[(signed long int)((unsigned long int)r >> (unsigned long int)12 & (unsigned long int)((1 << 10) - 1))];
    if(candidate_hdr == ((struct hblkhdr *)NULL))
      return NULL;

    else
    {
      while(!((unsigned long int)candidate_hdr >= 4096ul))
      {
        h = (struct hblk *)h - (signed long int)(unsigned long int)candidate_hdr;
        r = (char *)h;
        candidate_hdr=GC_find_header((char *)h);
      }
      if(!((4 & (signed int)candidate_hdr->hb_flags) == 0))
        return NULL;

      else
      {
        r = (char *)((unsigned long int)r & (unsigned long int)~((1 << 3) - 1));
        unsigned long int offset = (unsigned long int)r & (unsigned long int)(1 << 12) - (unsigned long int)1;
        unsigned long int sz = candidate_hdr->hb_sz;
        unsigned long int obj_displ = offset % sz;
        r = r - (signed long int)obj_displ;
        limit = r + (signed long int)sz;
        if(!(sz >= 4097ul) && !((unsigned long int)(h + 1l) >= (unsigned long int)limit))
          return NULL;

        else
          if((unsigned long int)p >= (unsigned long int)limit)
            return NULL;

          else
            return (void *)r;
      }
    }
  }
}

// GC_bl_init
// file blacklst.c line 107
void GC_bl_init(void)
{
  if(GC_all_interior_pointers == 0)
    GC_bl_init_no_interiors();

  char *return_value_GC_scratch_alloc$1;
  return_value_GC_scratch_alloc$1=GC_scratch_alloc(sizeof(unsigned long int [4096l]) /*32768ul*/ );
  GC_old_stack_bl = (unsigned long int *)return_value_GC_scratch_alloc$1;
  char *return_value_GC_scratch_alloc$2;
  return_value_GC_scratch_alloc$2=GC_scratch_alloc(sizeof(unsigned long int [4096l]) /*32768ul*/ );
  GC_incomplete_stack_bl = (unsigned long int *)return_value_GC_scratch_alloc$2;
  if(GC_incomplete_stack_bl == ((unsigned long int *)NULL) || GC_old_stack_bl == ((unsigned long int *)NULL))
  {
    GC_err_printf("Insufficient memory for black list\n");
    GC_on_abort((const char *)(void *)0);
    exit(1);
  }

  GC_clear_bl(GC_old_stack_bl);
  GC_clear_bl(GC_incomplete_stack_bl);
}

// GC_bl_init_no_interiors
// file blacklst.c line 92
void GC_bl_init_no_interiors(void)
{
  if(GC_incomplete_normal_bl == ((unsigned long int *)NULL))
  {
    char *return_value_GC_scratch_alloc$1;
    return_value_GC_scratch_alloc$1=GC_scratch_alloc(sizeof(unsigned long int [4096l]) /*32768ul*/ );
    GC_old_normal_bl = (unsigned long int *)return_value_GC_scratch_alloc$1;
    char *return_value_GC_scratch_alloc$2;
    return_value_GC_scratch_alloc$2=GC_scratch_alloc(sizeof(unsigned long int [4096l]) /*32768ul*/ );
    GC_incomplete_normal_bl = (unsigned long int *)return_value_GC_scratch_alloc$2;
    if(GC_incomplete_normal_bl == ((unsigned long int *)NULL) || GC_old_normal_bl == ((unsigned long int *)NULL))
    {
      GC_err_printf("Insufficient memory for black list\n");
      GC_on_abort((const char *)(void *)0);
      exit(1);
    }

    GC_clear_bl(GC_old_normal_bl);
    GC_clear_bl(GC_incomplete_normal_bl);
  }

}

// GC_block_empty
// file ./include/private/gc_priv.h line 1801
signed int GC_block_empty(struct hblkhdr *hhdr)
{
  return (signed int)(hhdr->hb_n_marks == (unsigned long int)0);
}

// GC_block_nearly_full
// file reclaim.c line 133
signed int GC_block_nearly_full(struct hblkhdr *hhdr)
{
  return (signed int)(hhdr->hb_n_marks > ((unsigned long int)7 * ((unsigned long int)(1 << 12) / hhdr->hb_sz)) / (unsigned long int)8);
}

// GC_block_was_dirty
// file mark.c line 1816
signed int GC_block_was_dirty(struct hblk *h, struct hblkhdr *hhdr)
{
  unsigned long int sz = hhdr->hb_sz;
  if(!(sz >= 2049ul))
  {
    signed int return_value_GC_page_was_dirty$1;
    return_value_GC_page_was_dirty$1=GC_page_was_dirty(h);
    return return_value_GC_page_was_dirty$1;
  }

  else
  {
    char *p = (char *)h;
    while(!((unsigned long int)p >= sz + (unsigned long int)h))
    {
      signed int return_value_GC_page_was_dirty$2;
      return_value_GC_page_was_dirty$2=GC_page_was_dirty((struct hblk *)p);
      if(!(return_value_GC_page_was_dirty$2 == 0))
        return 1;

      p = p + (signed long int)(unsigned long int)(1 << 12);
    }
    return 0;
  }
}

// GC_build_fl
// file ./include/private/gc_priv.h line 1747
char * GC_build_fl(struct hblk *h, unsigned long int sz, signed int clear, char *list)
{
  unsigned long int *p;
  unsigned long int *prev;
  unsigned long int *last_object;
  char *return_value_GC_build_fl2$2;
  char *return_value_GC_build_fl4$4;
  switch(sz)
  {
    case (unsigned long int)2:
    {
      if(!(clear == 0))
      {
        char *return_value_GC_build_fl_clear2$1;
        return_value_GC_build_fl_clear2$1=GC_build_fl_clear2(h, list);
        return return_value_GC_build_fl_clear2$1;
      }

      return_value_GC_build_fl2$2=GC_build_fl2(h, list);
      return return_value_GC_build_fl2$2;
    }
    case (unsigned long int)4:
    {
      if(!(clear == 0))
      {
        char *return_value_GC_build_fl_clear4$3;
        return_value_GC_build_fl_clear4$3=GC_build_fl_clear4(h, list);
        return return_value_GC_build_fl_clear4$3;
      }

      return_value_GC_build_fl4$4=GC_build_fl4(h, list);
      return return_value_GC_build_fl4$4;
    }
    default:
    {
      if(!(clear == 0))
        memset((void *)h, 0, (unsigned long int)(1 << 12));

      p = (unsigned long int *)h->hb_body + (signed long int)sz;
      prev = (unsigned long int *)h->hb_body;
      last_object = (unsigned long int *)((char *)h + (signed long int)(unsigned long int)(1 << 12));
      last_object = last_object - (signed long int)sz;
      for( ; (unsigned long int)last_object >= (unsigned long int)p; p = p + (signed long int)sz)
      {
        *((void **)p) = (void *)(char *)prev;
        prev = p;
      }
      p = p - (signed long int)sz;
      *((char **)h) = list;
      return (char *)p;
    }
  }
}

// GC_build_fl2
// file new_hblk.c line 70
char * GC_build_fl2(struct hblk *h, char *ofl)
{
  unsigned long int *p = (unsigned long int *)h->hb_body;
  unsigned long int *lim = (unsigned long int *)(h + (signed long int)1);
  p[(signed long int)0] = (unsigned long int)ofl;
  p[(signed long int)2] = (unsigned long int)p;
  p = p + (signed long int)4;
  for( ; !((unsigned long int)p >= (unsigned long int)lim); p = p + (signed long int)4)
  {
    p[(signed long int)0] = (unsigned long int)(p - (signed long int)2);
    p[(signed long int)2] = (unsigned long int)p;
  }
  return (char *)(p - (signed long int)2);
}

// GC_build_fl4
// file new_hblk.c line 86
char * GC_build_fl4(struct hblk *h, char *ofl)
{
  unsigned long int *p = (unsigned long int *)h->hb_body;
  unsigned long int *lim = (unsigned long int *)(h + (signed long int)1);
  p[(signed long int)0] = (unsigned long int)ofl;
  p[(signed long int)4] = (unsigned long int)p;
  p = p + (signed long int)8;
  for( ; !((unsigned long int)p >= (unsigned long int)lim); p = p + (signed long int)8)
  {
    p[(signed long int)0] = (unsigned long int)(p - (signed long int)4);
    p[(signed long int)4] = (unsigned long int)p;
  }
  return (char *)(p - (signed long int)4);
}

// GC_build_fl_clear2
// file new_hblk.c line 30
char * GC_build_fl_clear2(struct hblk *h, char *ofl)
{
  unsigned long int *p = (unsigned long int *)h->hb_body;
  unsigned long int *lim = (unsigned long int *)(h + (signed long int)1);
  p[(signed long int)0] = (unsigned long int)ofl;
  p[(signed long int)1] = (unsigned long int)0;
  p[(signed long int)2] = (unsigned long int)p;
  p[(signed long int)3] = (unsigned long int)0;
  p = p + (signed long int)4;
  for( ; !((unsigned long int)p >= (unsigned long int)lim); p = p + (signed long int)4)
  {
    p[(signed long int)0] = (unsigned long int)(p - (signed long int)2);
    p[(signed long int)1] = (unsigned long int)0;
    p[(signed long int)2] = (unsigned long int)p;
    p[(signed long int)3] = (unsigned long int)0;
  }
  return (char *)(p - (signed long int)2);
}

// GC_build_fl_clear4
// file new_hblk.c line 50
char * GC_build_fl_clear4(struct hblk *h, char *ofl)
{
  unsigned long int *p = (unsigned long int *)h->hb_body;
  unsigned long int *lim = (unsigned long int *)(h + (signed long int)1);
  p[(signed long int)0] = (unsigned long int)ofl;
  p[(signed long int)1] = (unsigned long int)0;
  p[(signed long int)2] = (unsigned long int)0;
  p[(signed long int)3] = (unsigned long int)0;
  p = p + (signed long int)4;
  for( ; !((unsigned long int)p >= (unsigned long int)lim); p = p + (signed long int)4)
  {
    p[(signed long int)0] = (unsigned long int)(p - (signed long int)4);
    p[(signed long int)1] = (unsigned long int)0;
    ((unsigned long int *)(p + (signed long int)2))[(signed long int)0] = (unsigned long int)0;
    ((unsigned long int *)(p + (signed long int)2))[(signed long int)1] = (unsigned long int)0;
  }
  return (char *)(p - (signed long int)4);
}

// GC_call_with_alloc_lock
// file misc.c line 1814
extern void * GC_call_with_alloc_lock(void * (*fn)(void *), void *client_data)
{
  void *result;
  do
    if(!(GC_need_to_lock == 0))
    {
      signed int return_value_pthread_mutex_trylock$1;
      return_value_pthread_mutex_trylock$1=pthread_mutex_trylock(&GC_allocate_ml);
      if(!(return_value_pthread_mutex_trylock$1 == 0))
        GC_lock();

    }

  while((_Bool)0);
  result=fn(client_data);
  if(!(GC_need_to_lock == 0))
    pthread_mutex_unlock(&GC_allocate_ml);

  return result;
}

// GC_call_with_gc_active
// file pthread_support.c line 1244
extern void * GC_call_with_gc_active(void * (*fn)(void *), void *client_data)
{
  struct GC_traced_stack_sect_s stacksect;
  unsigned long int self;
  self=pthread_self();
  struct GC_Thread_Rep *me;
  do
    if(!(GC_need_to_lock == 0))
    {
      signed int return_value_pthread_mutex_trylock$1;
      return_value_pthread_mutex_trylock$1=pthread_mutex_trylock(&GC_allocate_ml);
      if(!(return_value_pthread_mutex_trylock$1 == 0))
        GC_lock();

    }

  while((_Bool)0);
  me=GC_lookup_thread(self);
  if((4 & (signed int)me->flags) == 0)
  {
    if(!((unsigned long int)me->stack_end >= (unsigned long int)&stacksect))
      me->stack_end = (char *)&stacksect;

  }

  else
    if(!((unsigned long int)GC_stackbottom >= (unsigned long int)&stacksect))
      GC_stackbottom = (char *)&stacksect;

  if(me->thread_blocked == 0)
  {
    do
      if(!(GC_need_to_lock == 0))
        pthread_mutex_unlock(&GC_allocate_ml);

    while((_Bool)0);
    client_data=fn(client_data);
    GC_noop1((unsigned long int)&stacksect);
    return client_data;
  }

  else
  {
    stacksect.saved_stack_ptr = me->stop_info.stack_ptr;
    stacksect.prev = me->traced_stack_sect;
    me->thread_blocked = (unsigned char)0;
    me->traced_stack_sect = &stacksect;
    do
      if(!(GC_need_to_lock == 0))
        pthread_mutex_unlock(&GC_allocate_ml);

    while((_Bool)0);
    client_data=fn(client_data);
    if(!(GC_need_to_lock == 0))
    {
      signed int return_value_pthread_mutex_trylock$2;
      return_value_pthread_mutex_trylock$2=pthread_mutex_trylock(&GC_allocate_ml);
      if(!(return_value_pthread_mutex_trylock$2 == 0))
        GC_lock();

    }

    me->traced_stack_sect = stacksect.prev;
    me->thread_blocked = (unsigned char)1;
    me->stop_info.stack_ptr = stacksect.saved_stack_ptr;
    if(!(GC_need_to_lock == 0))
      pthread_mutex_unlock(&GC_allocate_ml);

    return client_data;
  }
}

// GC_call_with_stack_base
// file misc.c line 1829
extern void * GC_call_with_stack_base(void * (*fn)(struct GC_stack_base *, void *), void *arg)
{
  struct GC_stack_base base;
  void *result;
  base.mem_base = (void *)&base;
  result=fn(&base, arg);
  GC_noop1((unsigned long int)&base);
  return result;
}

// GC_calloc_explicitly_typed
// file typd_mlc.c line 658
extern void * GC_calloc_explicitly_typed(unsigned long int n, unsigned long int lb, unsigned long int d)
{
  char *op;
  char **opp;
  unsigned long int lg;
  unsigned long int simple_descr;
  union ComplexDescriptor *complex_descr;
  signed int descr_type;
  struct LeafDescriptor leaf;
  descr_type=GC_make_array_descriptor((unsigned long int)n, (unsigned long int)lb, d, &simple_descr, &complex_descr, &leaf);
  if(!(descr_type == -1))
  {
    if(descr_type == 0)
      goto __CPROVER_DUMP_L2;

    if(descr_type == 1)
      goto __CPROVER_DUMP_L3;

    if(descr_type == 2)
      goto __CPROVER_DUMP_L4;

  }

  else
  {
    return NULL;

  __CPROVER_DUMP_L2:
    ;
    void *return_value_GC_malloc_explicitly_typed$1;
    return_value_GC_malloc_explicitly_typed$1=GC_malloc_explicitly_typed(n * lb, simple_descr);
    return return_value_GC_malloc_explicitly_typed$1;

  __CPROVER_DUMP_L3:
    ;
    lb = lb * n;
    lb = lb + sizeof(struct LeafDescriptor) /*32ul*/  + (sizeof(unsigned long int) /*8ul*/  - (unsigned long int)GC_all_interior_pointers);
    goto __CPROVER_DUMP_L5;

  __CPROVER_DUMP_L4:
    ;
    lb = lb * n;
    lb = lb + (sizeof(unsigned long int) /*8ul*/  - (unsigned long int)GC_all_interior_pointers);
    goto __CPROVER_DUMP_L5;
  }

__CPROVER_DUMP_L5:
  ;
  if(2048ul + -((unsigned long int)GC_all_interior_pointers) >= lb || !(lb >= 2048ul))
  {
    lg = GC_arrays._size_map[(signed long int)lb];
    opp = &GC_arobjfreelist[(signed long int)lg];
    do
      if(!(GC_need_to_lock == 0))
      {
        signed int return_value_pthread_mutex_trylock$2;
        return_value_pthread_mutex_trylock$2=pthread_mutex_trylock(&GC_allocate_ml);
        if(!(return_value_pthread_mutex_trylock$2 == 0))
          GC_lock();

      }

    while((_Bool)0);
    op = *opp;
    if(op == ((char *)NULL))
    {
      do
        if(!(GC_need_to_lock == 0))
          pthread_mutex_unlock(&GC_allocate_ml);

      while((_Bool)0);
      void *return_value_GC_generic_malloc$3;
      return_value_GC_generic_malloc$3=GC_generic_malloc((unsigned long int)lb, GC_array_kind);
      void *return_value_GC_clear_stack$4;
      return_value_GC_clear_stack$4=GC_clear_stack(return_value_GC_generic_malloc$3);
      op = (char *)return_value_GC_clear_stack$4;
      if(op == ((char *)NULL))
        return NULL;

      lg = GC_arrays._size_map[(signed long int)lb];
    }

    else
    {
      *opp = (char *)*((void **)op);
      *((void **)op) = NULL;
      GC_arrays._bytes_allocd = GC_arrays._bytes_allocd + (lg << 4);
      do
        if(!(GC_need_to_lock == 0))
          pthread_mutex_unlock(&GC_allocate_ml);

      while((_Bool)0);
    }
  }

  else
  {
    void *return_value_GC_generic_malloc$5;
    return_value_GC_generic_malloc$5=GC_generic_malloc((unsigned long int)lb, GC_array_kind);
    void *return_value_GC_clear_stack$6;
    return_value_GC_clear_stack$6=GC_clear_stack(return_value_GC_generic_malloc$5);
    op = (char *)return_value_GC_clear_stack$6;
    if(op == ((char *)NULL))
      return NULL;

    unsigned long int return_value_GC_size$7;
    return_value_GC_size$7=GC_size((const void *)op);
    lg = return_value_GC_size$7 >> 4;
  }
  if(descr_type == 1)
  {
    struct LeafDescriptor *lp = (struct LeafDescriptor *)(((unsigned long int *)op + (signed long int)(lg << 1)) - (signed long int)((sizeof(struct LeafDescriptor) /*32ul*/  >> 3) + (unsigned long int)1));
    lp->ld_tag = (unsigned long int)1;
    lp->ld_size = leaf.ld_size;
    lp->ld_nelements = leaf.ld_nelements;
    lp->ld_descriptor = leaf.ld_descriptor;
    ((volatile unsigned long int *)op)[(signed long int)((lg << 1) - (unsigned long int)1)] = (unsigned long int)lp;
  }

  else
  {
    unsigned long int lw = lg << 1;
    ((unsigned long int *)op)[(signed long int)(lw - (unsigned long int)1)] = (unsigned long int)complex_descr;
    signed int return_value_GC_general_register_disappearing_link$9;
    return_value_GC_general_register_disappearing_link$9=GC_general_register_disappearing_link((void **)(((unsigned long int *)op + (signed long int)lw) - (signed long int)1), (const void *)op);
    if(return_value_GC_general_register_disappearing_link$9 == 2)
    {
      void *return_value_GC_malloc$8;
      return_value_GC_malloc$8=GC_malloc(n * lb);
      return return_value_GC_malloc$8;
    }

  }
  return (void *)op;
}

// GC_change_stubborn
// file stubborn.c line 52
extern void GC_change_stubborn(const void *p)
{
  ;
}

// GC_check_annotated_obj
// file dbg_mlc.c line 295
char * GC_check_annotated_obj(struct anonymous$17 *ohdr)
{
  char *body = (char *)(ohdr + (signed long int)1);
  unsigned long int gc_sz;
  gc_sz=GC_size((const void *)(char *)ohdr);
  if(!(gc_sz >= sizeof(unsigned long int) * 5 /*40ul*/  + ohdr->oh_sz + -((unsigned long int)GC_all_interior_pointers)))
    return (char *)&ohdr->oh_sz;

  else
    if(!(ohdr->oh_sf == (0xFEDCEDCBfedcedcbUL ^ (unsigned long int)body)))
      return (char *)&ohdr->oh_sf;

    else
      if(!(((unsigned long int *)ohdr)[-1l + (signed long int)(gc_sz >> 3)] == (0xBCDECDEFbcdecdefUL ^ (unsigned long int)body)))
        return (char *)(((unsigned long int *)ohdr + (signed long int)(gc_sz >> 3)) - (signed long int)1);

      else
        if(!(((unsigned long int *)body)[(signed long int)(8ul + ohdr->oh_sz + 18446744073709551615ul >> 3)] == (0xBCDECDEFbcdecdefUL ^ (unsigned long int)body)))
          return (char *)((unsigned long int *)body + (signed long int)((ohdr->oh_sz + (unsigned long int)(1 << 3)) - (unsigned long int)1 >> 3));

        else
          return ((char *)NULL);
}

// GC_check_finalizer_nested
// file ./include/private/gc_priv.h line 2270
unsigned char * GC_check_finalizer_nested(void)
{
  struct GC_Thread_Rep *me;
  unsigned long int return_value_pthread_self$1;
  return_value_pthread_self$1=pthread_self();
  me=GC_lookup_thread(return_value_pthread_self$1);
  unsigned int nesting_level = (unsigned int)me->finalizer_nested;
  if(!(nesting_level == 0u))
  {
    me->finalizer_skipped = me->finalizer_skipped + 1;
    if(!((unsigned int)me->finalizer_skipped >= 1U << nesting_level))
      return (unsigned char *)(void *)0;

    me->finalizer_skipped = (unsigned short int)0;
  }

  me->finalizer_nested = (unsigned char)(nesting_level + (unsigned int)1);
  return &me->finalizer_nested;
}

// GC_check_heap_block
// file dbg_mlc.c line 979
void GC_check_heap_block(struct hblk *hbp, unsigned long int dummy)
{
  struct hblkhdr *hhdr;
  hhdr=GC_find_header((char *)hbp);
  unsigned long int sz = hhdr->hb_sz;
  unsigned long int bit_no;
  char *p;
  char *plim;
  p = hbp->hb_body;
  if(sz >= 2049ul)
    plim = p;

  else
    plim = (hbp->hb_body + (signed long int)(unsigned long int)(1 << 12)) - (signed long int)sz;
  bit_no = (unsigned long int)0;
  signed int return_value_GC_has_other_debug_info$1;
  for( ; (unsigned long int)plim >= (unsigned long int)p; p = p + (signed long int)sz)
  {
    if(!(hhdr->_mark_byte_union._hb_marks[(signed long int)bit_no] == 0))
    {
      return_value_GC_has_other_debug_info$1=GC_has_other_debug_info((char *)p);
      if(return_value_GC_has_other_debug_info$1 >= 1)
      {
        char *clobbered;
        clobbered=GC_check_annotated_obj((struct anonymous$17 *)p);
        if(!(clobbered == ((char *)NULL)))
          GC_add_smashed(clobbered);

      }

    }

    bit_no = bit_no + (sz >> 4);
  }
}

// GC_check_heap_proc
// file dbg_mlc.c line 1005
void GC_check_heap_proc(void)
{
  GC_apply_to_all_blocks(GC_check_heap_block, (unsigned long int)0);
}

// GC_check_leaked
// file dbg_mlc.c line 1012
signed int GC_check_leaked(char *base)
{
  unsigned long int i;
  unsigned long int obj_sz;
  unsigned long int *p;
  signed int return_value_GC_has_other_debug_info$1;
  return_value_GC_has_other_debug_info$1=GC_has_other_debug_info(base);
  if(return_value_GC_has_other_debug_info$1 >= 0)
    return 1;

  else
  {
    p = (unsigned long int *)(base + (signed long int)sizeof(struct anonymous$17) /*32ul*/ );
    struct hblkhdr *return_value_GC_find_header$2;
    return_value_GC_find_header$2=GC_find_header((char *)base);
    obj_sz = return_value_GC_find_header$2->hb_sz - sizeof(struct anonymous$17) /*32ul*/  >> 3;
    i = (unsigned long int)0;
    for( ; !(i >= obj_sz); i = i + 1ul)
      if(!(p[(signed long int)i] == 0xEFBEADDEdeadbeefUL))
      {
        GC_set_mark_bit((const void *)base);
        GC_add_smashed((char *)&p[(signed long int)i]);
        break;
      }

    return 0;
  }
}

// GC_clear_a_few_frames
// file alloc.c line 285
void GC_clear_a_few_frames(void)
{
  volatile unsigned long int frames[64l];
  memset((void *)(unsigned long int *)frames, 0, (unsigned long int)((unsigned long int)64 * sizeof(unsigned long int) /*8ul*/ ));
}

// GC_clear_bl
// file blacklst.c line 122
void GC_clear_bl(unsigned long int *doomed)
{
  memset((void *)doomed, 0, (unsigned long int)sizeof(unsigned long int [4096l]) /*32768ul*/ );
}

// GC_clear_fl_links
// file reclaim.c line 591
void GC_clear_fl_links(void **flp)
{
  void *next = *flp;
  for( ; !(next == NULL); next = *flp)
  {
    *flp = NULL;
    flp = &(*((void **)next));
  }
}

// GC_clear_fl_marks
// file alloc.c line 765
void GC_clear_fl_marks(char *q)
{
  struct hblk *h;
  struct hblk *last_h;
  struct hblkhdr *hhdr;
  unsigned long int sz;
  unsigned int bit_no;
  if(!(q == ((char *)NULL)))
  {
    h = (struct hblk *)((unsigned long int)q & ~((unsigned long int)(1 << 12) - (unsigned long int)1));
    last_h = h;
    hhdr=GC_find_header((char *)h);
    sz = hhdr->hb_sz;
    do
    {
      bit_no = (unsigned int)((char *)q - (char *)h) >> 4;
      if(!(hhdr->_mark_byte_union._hb_marks[(signed long int)bit_no] == 0))
      {
        unsigned long int n_marks = hhdr->hb_n_marks - (unsigned long int)1;
        hhdr->_mark_byte_union._hb_marks[(signed long int)bit_no] = (char)0;
        if(GC_parallel == 0 || !(n_marks == 0ul))
          hhdr->hb_n_marks = n_marks;

      }

      GC_bytes_found = GC_bytes_found - (signed long int)sz;
      q = (char *)*((void **)q);
      if(q == ((char *)NULL))
        break;

      h = (struct hblk *)((unsigned long int)q & ~((unsigned long int)(1 << 12) - (unsigned long int)1));
      if(!(h == last_h))
      {
        last_h = h;
        hhdr=GC_find_header((char *)h);
        sz = hhdr->hb_sz;
      }

    }
    while((_Bool)1);
  }

}

// GC_clear_hdr_marks
// file ./include/private/gc_priv.h line 1647
void GC_clear_hdr_marks(struct hblkhdr *hhdr)
{
  unsigned long int last_bit;
  unsigned long int tmp_if_expr$1;
  if(hhdr->hb_sz >= 2049ul)
    tmp_if_expr$1 = (unsigned long int)(1 << 12) / (unsigned long int)16;

  else
    tmp_if_expr$1 = hhdr->hb_sz * ((unsigned long int)(1 << 12) / hhdr->hb_sz) >> 4;
  last_bit = tmp_if_expr$1;
  memset((void *)hhdr->_mark_byte_union._hb_marks, 0, (unsigned long int)sizeof(char [257l]) /*257ul*/ );
  hhdr->_mark_byte_union._hb_marks[(signed long int)last_bit] = (char)1;
  hhdr->hb_n_marks = (volatile unsigned long int)0;
}

// GC_clear_mark_bit
// file ./include/private/../gc_mark.h line 246
extern void GC_clear_mark_bit(const void *p)
{
  struct hblk *h = (struct hblk *)((unsigned long int)p & ~((unsigned long int)(1 << 12) - (unsigned long int)1));
  struct hblkhdr *hhdr;
  hhdr=GC_find_header((char *)h);
  unsigned long int bit_no = (unsigned long int)((unsigned int)((char *)p - (char *)h) >> 4);
  if(!(hhdr->_mark_byte_union._hb_marks[(signed long int)bit_no] == 0))
  {
    unsigned long int n_marks;
    hhdr->_mark_byte_union._hb_marks[(signed long int)bit_no] = (char)0;
    n_marks = hhdr->hb_n_marks - (unsigned long int)1;
    if(GC_parallel == 0 || !(n_marks == 0ul))
      hhdr->hb_n_marks = n_marks;

  }

}

// GC_clear_marks
// file ./include/private/gc_priv.h line 1553
void GC_clear_marks(void)
{
  GC_apply_to_all_blocks(clear_marks_for_block, (unsigned long int)0);
  GC_objects_are_marked = 0;
  GC_mark_state = 5;
  scan_ptr = ((struct hblk *)NULL);
}

// GC_clear_roots
// file mark_rts.c line 265
extern void GC_clear_roots(void)
{
  if((signed long int)GC_is_initialized == 0l)
    GC_init();

  do
    if(!(GC_need_to_lock == 0))
    {
      signed int return_value_pthread_mutex_trylock$1;
      return_value_pthread_mutex_trylock$1=pthread_mutex_trylock(&GC_allocate_ml);
      if(!(return_value_pthread_mutex_trylock$1 == 0))
        GC_lock();

    }

  while((_Bool)0);
  roots_were_cleared = 1;
  n_root_sets = 0;
  GC_root_size = (unsigned long int)0;
  memset((void *)GC_arrays._root_index, 0, (unsigned long int)((unsigned long int)(1 << 6) * sizeof(void *) /*8ul*/ ));
  do
    if(!(GC_need_to_lock == 0))
      pthread_mutex_unlock(&GC_allocate_ml);

  while((_Bool)0);
}

// GC_clear_stack
// file ./include/private/../gc_mark.h line 229
extern void * GC_clear_stack(void *arg)
{
  char *sp;
  sp=GC_approx_sp();
  volatile unsigned long int dummy[256l];
  char *limit;
  static unsigned int random_no = (unsigned int)0;
  random_no = random_no + 1u;
  if(random_no % 13u == 0u)
  {
    limit = sp;
    limit = limit - (signed long int)((unsigned long int)2048 * sizeof(unsigned long int) /*8ul*/ );
    limit = (char *)((unsigned long int)limit & (unsigned long int)~0xf);
    void *return_value_GC_clear_stack_inner$1;
    return_value_GC_clear_stack_inner$1=GC_clear_stack_inner(arg, limit);
    return return_value_GC_clear_stack_inner$1;
  }

  else
  {
    memset((void *)dummy, 0, (unsigned long int)((unsigned long int)256 * sizeof(unsigned long int) /*8ul*/ ));
    return arg;
  }
}

// GC_clear_stack_inner
// file misc.c line 328
void * GC_clear_stack_inner(void *arg, char *limit)
{
  volatile unsigned long int dummy[213l];
  memset((void *)dummy, 0, (unsigned long int)sizeof(volatile unsigned long int [213l]) /*1704ul*/ );
  char *return_value_GC_approx_sp$1;
  return_value_GC_approx_sp$1=GC_approx_sp();
  if(!((unsigned long int)limit >= (unsigned long int)return_value_GC_approx_sp$1))
    GC_clear_stack_inner(arg, limit);

  GC_noop1((unsigned long int)dummy);
  return arg;
}

// GC_collect_a_little
// file alloc.c line 546
extern signed int GC_collect_a_little(void)
{
  signed int result;
  do
    if(!(GC_need_to_lock == 0))
    {
      signed int return_value_pthread_mutex_trylock$1;
      return_value_pthread_mutex_trylock$1=pthread_mutex_trylock(&GC_allocate_ml);
      if(!(return_value_pthread_mutex_trylock$1 == 0))
        GC_lock();

    }

  while((_Bool)0);
  GC_collect_a_little_inner(1);
  signed int return_value_GC_collection_in_progress$2;
  return_value_GC_collection_in_progress$2=GC_collection_in_progress();
  result = (signed int)return_value_GC_collection_in_progress$2;
  do
    if(!(GC_need_to_lock == 0))
      pthread_mutex_unlock(&GC_allocate_ml);

  while((_Bool)0);
  if(result == 0 && !(GC_debugging_started == 0))
    GC_print_all_smashed();

  return result;
}

// GC_collect_a_little_inner
// file alloc.c line 499
void GC_collect_a_little_inner(signed int n)
{
  signed int i;
  signed int cancel_state;
  signed int return_value_GC_collection_in_progress$3;
  if(GC_dont_gc == 0)
  {
    do
      pthread_setcancelstate(1, &cancel_state);
    while((_Bool)0);
    _Bool tmp_if_expr$4;
    if(!(GC_incremental == 0))
    {
      return_value_GC_collection_in_progress$3=GC_collection_in_progress();
      tmp_if_expr$4 = return_value_GC_collection_in_progress$3 != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$4 = (_Bool)0;
    if(tmp_if_expr$4)
    {
      i = GC_deficit;
      for( ; !(i >= 10 * n); i = i + 1)
      {
        signed int return_value_GC_mark_some$2;
        return_value_GC_mark_some$2=GC_mark_some((char *)0);
        if(!(return_value_GC_mark_some$2 == 0))
        {
          if(!(GC_parallel == 0))
            GC_wait_for_reclaim();

          if(!(GC_time_limit == 999999ul) && !(GC_n_attempts >= 1))
          {
            GC_start_time=clock();
            signed int return_value_GC_stopped_mark$1;
            return_value_GC_stopped_mark$1=GC_stopped_mark(GC_timeout_stop_func);
            if(return_value_GC_stopped_mark$1 == 0)
            {
              GC_n_attempts = GC_n_attempts + 1;
              break;
            }

          }

          else
            GC_stopped_mark(GC_never_stop_func);
          GC_finish_collection();
          break;
        }

      }
      if(GC_deficit >= 1)
        GC_deficit = GC_deficit - 10 * n;

      if(!(GC_deficit >= 0))
        GC_deficit = 0;

    }

    else
      GC_maybe_gc();
    do
      pthread_setcancelstate(cancel_state, (signed int *)(void *)0);
    while((_Bool)0);
  }

}

// GC_collect_or_expand
// file alloc.c line 1249
signed int GC_collect_or_expand(unsigned long int needed_blocks, signed int ignore_off_page, signed int retry)
{
  signed int gc_not_stopped = 1;
  unsigned long int blocks_to_get;
  signed int cancel_state;
  do
    pthread_setcancelstate(1, &cancel_state);
  while((_Bool)0);
  signed int return_value_GC_should_collect$1;
  if(GC_dont_gc == 0 && GC_incremental == 0)
  {
    _Bool tmp_if_expr$2;
    if(GC_arrays._bytes_allocd >= 1ul && !(GC_dont_expand == 0) || !((GC_arrays._bytes_finalized | last_bytes_finalized) == 0ul) && !(500ul + last_fo_entries >= GC_fo_entries))
      tmp_if_expr$2 = (_Bool)1;

    else
    {
      return_value_GC_should_collect$1=GC_should_collect();
      tmp_if_expr$2 = return_value_GC_should_collect$1 != 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$2)
    {
      gc_not_stopped=GC_try_to_collect_inner(GC_arrays._bytes_allocd > (unsigned long int)0 && (!(GC_dont_expand != 0) || !(retry != 0)) ? GC_default_stop_func : GC_never_stop_func);
      if(gc_not_stopped == 1 || retry == 0)
      {
        last_fo_entries = GC_fo_entries;
        last_bytes_finalized = GC_arrays._bytes_finalized;
        do
          pthread_setcancelstate(cancel_state, (signed int *)(void *)0);
        while((_Bool)0);
        return 1;
      }

    }

  }

  blocks_to_get = GC_arrays._heapsize / ((unsigned long int)(1 << 12) * GC_free_space_divisor) + needed_blocks;
  if(blocks_to_get >= 2049ul)
  {
    unsigned long int slop;
    if(!(ignore_off_page == 0))
      slop = (unsigned long int)4;

    else
    {
      slop = (unsigned long int)2 * (GC_black_list_spacing >> (unsigned long int)12);
      if(!(needed_blocks >= slop))
        slop = needed_blocks;

    }
    if(slop + needed_blocks >= 2049ul)
      blocks_to_get = needed_blocks + slop;

    else
      blocks_to_get = (unsigned long int)2048;
  }

  signed int return_value_GC_expand_hp_inner$4;
  return_value_GC_expand_hp_inner$4=GC_expand_hp_inner(blocks_to_get);
  _Bool tmp_if_expr$6;
  signed int return_value_GC_expand_hp_inner$5;
  if(return_value_GC_expand_hp_inner$4 == 0)
  {
    return_value_GC_expand_hp_inner$5=GC_expand_hp_inner(needed_blocks);
    tmp_if_expr$6 = !(return_value_GC_expand_hp_inner$5 != 0) ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$6 = (_Bool)0;
  if(tmp_if_expr$6)
  {
    if(gc_not_stopped == 0)
      GC_try_to_collect_inner(GC_never_stop_func);

    else
    {
      unsigned int tmp_post$3 = GC_fail_count;
      GC_fail_count = GC_fail_count + 1u;
      if(!((unsigned long int)tmp_post$3 >= GC_max_retries))
      {
        GC_current_warn_proc("GC Warning: Out of Memory!  Trying to continue ...\n", (unsigned long int)0);
        GC_try_to_collect_inner(GC_never_stop_func);
      }

      else
      {
        GC_current_warn_proc("GC Warning: Out of Memory! Heap size: %ld MiB. Returning NULL!\n", (unsigned long int)(GC_arrays._heapsize - (unsigned long int)0 >> 20));
        pthread_setcancelstate(cancel_state, (signed int *)(void *)0);
        return 0;
      }
    }
  }

  else
    if(!(GC_fail_count == 0u))
    {
      if(!(GC_print_stats == 0))
        GC_log_printf("Memory available again...\n");

    }

  do
    pthread_setcancelstate(cancel_state, (signed int *)(void *)0);
  while((_Bool)0);
  return 1;
}

// GC_collection_in_progress
// file ./include/private/gc_priv.h line 1571
signed int GC_collection_in_progress(void)
{
  return (signed int)(GC_mark_state != 0);
}

// GC_compute_heap_usage_percent
// file alloc.c line 815
static inline signed int GC_compute_heap_usage_percent(void)
{
  unsigned long int used = GC_arrays._composite_in_use + GC_arrays._atomic_in_use;
  unsigned long int heap_sz = GC_arrays._heapsize - (unsigned long int)0;
  return used >= heap_sz ? 0 : (used < (unsigned long int)-1 / (unsigned long int)100 ? (signed int)((used * (unsigned long int)100) / heap_sz) : (signed int)(used / (heap_sz / (unsigned long int)100)));
}

// GC_compute_heap_usage_percent$link1
// file alloc.c line 815
static inline signed int GC_compute_heap_usage_percent$link1(void)
{
  unsigned long int used$link1 = GC_arrays._composite_in_use + GC_arrays._atomic_in_use;
  unsigned long int heap_sz$link1 = GC_arrays._heapsize - (unsigned long int)0;
  return used$link1 >= heap_sz$link1 ? 0 : (used$link1 < (unsigned long int)-1 / (unsigned long int)100 ? (signed int)((used$link1 * (unsigned long int)100) / heap_sz$link1) : (signed int)(used$link1 / (heap_sz$link1 / (unsigned long int)100)));
}

// GC_compute_large_free_bytes
// file allchblk.c line 104
unsigned long int GC_compute_large_free_bytes(void)
{
  struct hblk *h;
  struct hblkhdr *hhdr;
  unsigned long int total_free = (unsigned long int)0;
  unsigned int i = (unsigned int)0;
  for( ; !(i >= 61u); i = i + 1u)
  {
    h = GC_hblkfreelist[(signed long int)i];
    for( ; !(h == ((struct hblk *)NULL)); h = hhdr->hb_next)
    {
      hhdr=GC_find_header((char *)h);
      total_free = total_free + hhdr->hb_sz;
    }
  }
  return total_free;
}

// GC_compute_root_size
// file mark_rts.c line 44
unsigned long int GC_compute_root_size(void)
{
  signed int i;
  unsigned long int size = (unsigned long int)0;
  i = 0;
  for( ; !(i >= n_root_sets); i = i + 1)
    size = size + (unsigned long int)(GC_arrays._static_roots[(signed long int)i].r_end - GC_arrays._static_roots[(signed long int)i].r_start);
  return size;
}

// GC_cond_register_dynamic_libraries
// file ./include/private/gc_priv.h line 1667
void GC_cond_register_dynamic_libraries(void)
{
  GC_remove_tmp_roots();
  if(GC_no_dls == 0)
    GC_register_dynamic_libraries();

}

// GC_continue_reclaim
// file ./include/private/gc_priv.h line 1784
void GC_continue_reclaim(unsigned long int sz, signed int kind)
{
  struct hblkhdr *hhdr;
  struct hblk *hbp;
  struct obj_kind *ok = &GC_obj_kinds[(signed long int)kind];
  struct hblk **rlh = ok->ok_reclaim_list;
  void **flh = &ok->ok_freelist[(signed long int)sz];
  if(!(rlh == ((struct hblk **)NULL)))
  {
    rlh = rlh + (signed long int)sz;
    do
    {
      hbp = *rlh;
      if(hbp == ((struct hblk *)NULL))
        break;

      hhdr=GC_find_header((char *)hbp);
      *rlh = hhdr->hb_next;
      GC_reclaim_small_nonempty_block(hbp, 0);
      if(!(*flh == NULL))
        break;

    }
    while((_Bool)1);
  }

}

// GC_copy_bl
// file blacklst.c line 127
void GC_copy_bl(unsigned long int *old, unsigned long int *new)
{
  memcpy((void *)new, (const void *)old, (unsigned long int)sizeof(unsigned long int [4096l]) /*32768ul*/ );
}

// GC_core_finalized_malloc
// file fnlz_mlc.c line 85
void * GC_core_finalized_malloc(unsigned long int lb, struct GC_finalizer_closure *fclos)
{
  char *op;
  char **opp;
  unsigned long int lg;
  lb = lb + sizeof(unsigned long int) /*8ul*/ ;
  if(2048ul + -((unsigned long int)GC_all_interior_pointers) >= lb || !(lb >= 2048ul))
  {
    lg = GC_arrays._size_map[(signed long int)lb];
    opp = &GC_finalized_objfreelist[(signed long int)lg];
    do
      if(!(GC_need_to_lock == 0))
      {
        signed int return_value_pthread_mutex_trylock$1;
        return_value_pthread_mutex_trylock$1=pthread_mutex_trylock(&GC_allocate_ml);
        if(!(return_value_pthread_mutex_trylock$1 == 0))
          GC_lock();

      }

    while((_Bool)0);
    op = *opp;
    if(op == ((char *)NULL))
    {
      do
        if(!(GC_need_to_lock == 0))
          pthread_mutex_unlock(&GC_allocate_ml);

      while((_Bool)0);
      void *return_value_GC_generic_malloc$2;
      return_value_GC_generic_malloc$2=GC_generic_malloc((unsigned long int)lb, GC_finalized_kind);
      op = (char *)return_value_GC_generic_malloc$2;
      if(op == ((char *)NULL))
        return (void *)0;

      lg = GC_arrays._size_map[(signed long int)lb];
    }

    else
    {
      *opp = (char *)*((void **)op);
      *((void **)op) = NULL;
      GC_arrays._bytes_allocd = GC_arrays._bytes_allocd + (lg << 4);
      do
        if(!(GC_need_to_lock == 0))
          pthread_mutex_unlock(&GC_allocate_ml);

      while((_Bool)0);
    }
  }

  else
  {
    void *return_value_GC_generic_malloc$3;
    return_value_GC_generic_malloc$3=GC_generic_malloc(lb, GC_finalized_kind);
    op = (char *)return_value_GC_generic_malloc$3;
    if(op == ((char *)NULL))
      return (void *)0;

  }
  *((unsigned long int *)op) = (unsigned long int)fclos | (unsigned long int)1;
  void *return_value_GC_clear_stack$4;
  return_value_GC_clear_stack$4=GC_clear_stack((void *)((unsigned long int *)op + (signed long int)1));
  return return_value_GC_clear_stack$4;
}

// GC_core_gcj_malloc
// file gcj_mlc.c line 159
void * GC_core_gcj_malloc(unsigned long int lb, void *ptr_to_struct_containing_descr)
{
  char *op;
  char **opp;
  unsigned long int lg;
  if(2048ul + -((unsigned long int)GC_all_interior_pointers) >= lb || !(lb >= 2048ul))
  {
    lg = GC_arrays._size_map[(signed long int)lb];
    opp = &GC_gcjobjfreelist[(signed long int)lg];
    do
      if(!(GC_need_to_lock == 0))
      {
        signed int return_value_pthread_mutex_trylock$1;
        return_value_pthread_mutex_trylock$1=pthread_mutex_trylock(&GC_allocate_ml);
        if(!(return_value_pthread_mutex_trylock$1 == 0))
          GC_lock();

      }

    while((_Bool)0);
    op = *opp;
    if(op == ((char *)NULL))
    {
      maybe_finalize();
      void *return_value_GC_generic_malloc_inner$2;
      return_value_GC_generic_malloc_inner$2=GC_generic_malloc_inner((unsigned long int)lb, GC_gcj_kind);
      void *return_value_GC_clear_stack$3;
      return_value_GC_clear_stack$3=GC_clear_stack(return_value_GC_generic_malloc_inner$2);
      op = (char *)return_value_GC_clear_stack$3;
      if(op == ((char *)NULL))
      {
        void * (*oom_fn)(unsigned long int) = GC_oom_fn;
        do
          if(!(GC_need_to_lock == 0))
            pthread_mutex_unlock(&GC_allocate_ml);

        while((_Bool)0);
        void *return_value;
        return_value=oom_fn(lb);
        return return_value;
      }

    }

    else
    {
      *opp = (char *)*((void **)op);
      GC_arrays._bytes_allocd = GC_arrays._bytes_allocd + (lg << 4);
    }
    *((void **)op) = ptr_to_struct_containing_descr;
    do
      if(!(GC_need_to_lock == 0))
        pthread_mutex_unlock(&GC_allocate_ml);

    while((_Bool)0);
  }

  else
  {
    do
      if(!(GC_need_to_lock == 0))
      {
        signed int return_value_pthread_mutex_trylock$4;
        return_value_pthread_mutex_trylock$4=pthread_mutex_trylock(&GC_allocate_ml);
        if(!(return_value_pthread_mutex_trylock$4 == 0))
          GC_lock();

      }

    while((_Bool)0);
    maybe_finalize();
    void *return_value_GC_generic_malloc_inner$5;
    return_value_GC_generic_malloc_inner$5=GC_generic_malloc_inner((unsigned long int)lb, GC_gcj_kind);
    void *return_value_GC_clear_stack$6;
    return_value_GC_clear_stack$6=GC_clear_stack(return_value_GC_generic_malloc_inner$5);
    op = (char *)return_value_GC_clear_stack$6;
    if(op == ((char *)NULL))
    {
      void * (*GC_core_gcj_malloc$$1$$2$$2$$oom_fn)(unsigned long int) = GC_oom_fn;
      do
        if(!(GC_need_to_lock == 0))
          pthread_mutex_unlock(&GC_allocate_ml);

      while((_Bool)0);
      void *return_value_1;
      return_value_1=GC_core_gcj_malloc$$1$$2$$2$$oom_fn(lb);
      return return_value_1;
    }

    *((void **)op) = ptr_to_struct_containing_descr;
    do
      if(!(GC_need_to_lock == 0))
        pthread_mutex_unlock(&GC_allocate_ml);

    while((_Bool)0);
  }
  return (void *)op;
}

// GC_core_malloc
// file malloc.c line 257
void * GC_core_malloc(unsigned long int lb)
{
  void *op;
  void **opp;
  unsigned long int lg;
  if(2048ul + -((unsigned long int)GC_all_interior_pointers) >= lb || !(lb >= 2048ul))
  {
    lg = GC_arrays._size_map[(signed long int)lb];
    opp = (void **)&GC_arrays._objfreelist[(signed long int)lg];
    do
      if(!(GC_need_to_lock == 0))
      {
        signed int return_value_pthread_mutex_trylock$1;
        return_value_pthread_mutex_trylock$1=pthread_mutex_trylock(&GC_allocate_ml);
        if(!(return_value_pthread_mutex_trylock$1 == 0))
          GC_lock();

      }

    while((_Bool)0);
    op = *opp;
    if(op == NULL)
    {
      do
        if(!(GC_need_to_lock == 0))
          pthread_mutex_unlock(&GC_allocate_ml);

      while((_Bool)0);
      void *return_value_GC_generic_malloc$2;
      return_value_GC_generic_malloc$2=GC_generic_malloc((unsigned long int)lb, 1);
      void *return_value_GC_clear_stack$3;
      return_value_GC_clear_stack$3=GC_clear_stack(return_value_GC_generic_malloc$2);
      return return_value_GC_clear_stack$3;
    }

    *opp = *((void **)op);
    *((void **)op) = NULL;
    GC_arrays._bytes_allocd = GC_arrays._bytes_allocd + (lg << 4);
    do
      if(!(GC_need_to_lock == 0))
        pthread_mutex_unlock(&GC_allocate_ml);

    while((_Bool)0);
    return op;
  }

  else
  {
    void *return_value_GC_generic_malloc$4;
    return_value_GC_generic_malloc$4=GC_generic_malloc(lb, 1);
    void *return_value_GC_clear_stack$5;
    return_value_GC_clear_stack$5=GC_clear_stack(return_value_GC_generic_malloc$4);
    return return_value_GC_clear_stack$5;
  }
}

// GC_core_malloc_atomic
// file malloc.c line 227
void * GC_core_malloc_atomic(unsigned long int lb)
{
  void *op;
  void **opp;
  unsigned long int lg;
  if(2048ul + -((unsigned long int)GC_all_interior_pointers) >= lb || !(lb >= 2048ul))
  {
    lg = GC_arrays._size_map[(signed long int)lb];
    opp = &GC_arrays._aobjfreelist[(signed long int)lg];
    do
      if(!(GC_need_to_lock == 0))
      {
        signed int return_value_pthread_mutex_trylock$1;
        return_value_pthread_mutex_trylock$1=pthread_mutex_trylock(&GC_allocate_ml);
        if(!(return_value_pthread_mutex_trylock$1 == 0))
          GC_lock();

      }

    while((_Bool)0);
    op = *opp;
    if(op == NULL)
    {
      do
        if(!(GC_need_to_lock == 0))
          pthread_mutex_unlock(&GC_allocate_ml);

      while((_Bool)0);
      void *return_value_GC_generic_malloc$2;
      return_value_GC_generic_malloc$2=GC_generic_malloc((unsigned long int)lb, 0);
      void *return_value_GC_clear_stack$3;
      return_value_GC_clear_stack$3=GC_clear_stack(return_value_GC_generic_malloc$2);
      return return_value_GC_clear_stack$3;
    }

    *opp = *((void **)op);
    GC_arrays._bytes_allocd = GC_arrays._bytes_allocd + (lg << 4);
    do
      if(!(GC_need_to_lock == 0))
        pthread_mutex_unlock(&GC_allocate_ml);

    while((_Bool)0);
    return (void *)op;
  }

  else
  {
    void *return_value_GC_generic_malloc$4;
    return_value_GC_generic_malloc$4=GC_generic_malloc((unsigned long int)lb, 0);
    void *return_value_GC_clear_stack$5;
    return_value_GC_clear_stack$5=GC_clear_stack(return_value_GC_generic_malloc$4);
    return return_value_GC_clear_stack$5;
  }
}

// GC_debug_change_stubborn
// file dbg_mlc.c line 667
extern void GC_debug_change_stubborn(const void *p)
{
  ;
}

// GC_debug_end_stubborn_change
// file dbg_mlc.c line 670
extern void GC_debug_end_stubborn_change(const void *p)
{
  ;
}

// GC_debug_free
// file dbg_mlc.c line 797
extern void GC_debug_free(void *p)
{
  char *base;
  if(!(p == NULL))
  {
    void *return_value_GC_base$1;
    return_value_GC_base$1=GC_base(p);
    base = (char *)return_value_GC_base$1;
    if(base == ((char *)NULL))
    {
      if(!(GC_print_stats == 0))
        GC_log_printf("Invalid pointer passed to free(): %p", p);

      GC_on_abort("Invalid pointer passed to free()");
      abort();
    }

    if(!((unsigned long int)((char *)p - base) == sizeof(struct anonymous$17) /*32ul*/ ))
      GC_err_printf("GC_debug_free called on pointer %p w/o debugging info\n", p);

    else
    {
      char *clobbered;
      clobbered=GC_check_annotated_obj((struct anonymous$17 *)base);
      unsigned long int sz;
      sz=GC_size((const void *)base);
      if(!(clobbered == ((char *)NULL)))
      {
        GC_have_errors = 1;
        if(((struct anonymous$17 *)base)->oh_sz == sz)
        {
          GC_print_smashed_obj("GC_debug_free: found previously deallocated (?) object at", (char *)p, clobbered);
          goto __CPROVER_DUMP_L17;
        }

        else
          GC_print_smashed_obj("GC_debug_free: found smashed location at", (char *)p, clobbered);
      }

      ((struct anonymous$17 *)base)->oh_sz = sz;
    }
    if(!(GC_find_leak == 0) && (GC_findleak_delay_free == 0 || !((unsigned long int)((char *)p - base) == sizeof(struct anonymous$17) /*32ul*/ )))
      GC_free((void *)base);

    else
    {
      struct hblkhdr *hhdr;
      hhdr=GC_find_header((char *)p);
      _Bool tmp_if_expr$2;
      if((signed int)hhdr->hb_obj_kind == 2)
        tmp_if_expr$2 = (_Bool)1;

      else
        tmp_if_expr$2 = (signed int)hhdr->hb_obj_kind == 3 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$2)
        GC_free((void *)base);

      else
      {
        unsigned long int i;
        unsigned long int obj_sz = hhdr->hb_sz - sizeof(struct anonymous$17) /*32ul*/  >> 3;
        i = (unsigned long int)0;
        for( ; !(i >= obj_sz); i = i + 1ul)
          ((unsigned long int *)p)[(signed long int)i] = (unsigned long int)0xEFBEADDEdeadbeefUL;
      }
    }
  }


__CPROVER_DUMP_L17:
  ;
}

// GC_debug_gcj_malloc
// file gcj_mlc.c line 209
extern void * GC_debug_gcj_malloc(unsigned long int lb, void *ptr_to_struct_containing_descr, const char *s, signed int i)
{
  void *result;
  do
    if(!(GC_need_to_lock == 0))
    {
      signed int return_value_pthread_mutex_trylock$1;
      return_value_pthread_mutex_trylock$1=pthread_mutex_trylock(&GC_allocate_ml);
      if(!(return_value_pthread_mutex_trylock$1 == 0))
        GC_lock();

    }

  while((_Bool)0);
  maybe_finalize();
  result=GC_generic_malloc_inner(lb + ((sizeof(struct anonymous$17) /*32ul*/  + sizeof(unsigned long int) /*8ul*/ ) - (unsigned long int)GC_all_interior_pointers), GC_gcj_debug_kind);
  if(result == NULL)
  {
    void * (*oom_fn)(unsigned long int) = GC_oom_fn;
    do
      if(!(GC_need_to_lock == 0))
        pthread_mutex_unlock(&GC_allocate_ml);

    while((_Bool)0);
    GC_err_printf("GC_debug_gcj_malloc(%lu, %p) returning NULL (%s:%d)\n", (unsigned long int)lb, ptr_to_struct_containing_descr, s, i);
    void *return_value;
    return_value=oom_fn(lb);
    return return_value;
  }

  *((void **)((char *)result + (signed long int)sizeof(struct anonymous$17) /*32ul*/ )) = ptr_to_struct_containing_descr;
  do
    if(!(GC_need_to_lock == 0))
      pthread_mutex_unlock(&GC_allocate_ml);

  while((_Bool)0);
  if(GC_debugging_started == 0)
    GC_start_debugging();

  char *return_value_GC_store_debug_info$2;
  return_value_GC_store_debug_info$2=GC_store_debug_info((char *)result, (unsigned long int)lb, s, i);
  return (void *)return_value_GC_store_debug_info$2;
}

// GC_debug_invoke_finalizer
// file dbg_mlc.c line 1065
void GC_debug_invoke_finalizer(void *obj, void *data)
{
  struct closure *cl = (struct closure *)data;
  cl->cl_fn((void *)((char *)obj + (signed long int)sizeof(struct anonymous$17) /*32ul*/ ), cl->cl_data);
}

// GC_debug_malloc
// file dbg_mlc.c line 509
extern void * GC_debug_malloc(unsigned long int lb, const char *s, signed int i)
{
  void *result;
  result=GC_malloc(lb + ((sizeof(struct anonymous$17) /*32ul*/  + sizeof(unsigned long int) /*8ul*/ ) - (unsigned long int)GC_all_interior_pointers));
  if(result == NULL)
  {
    GC_err_printf("GC_debug_malloc(%lu) returning NULL (%s:%d)\n", (unsigned long int)lb, s, i);
    return NULL;
  }

  else
  {
    if(GC_debugging_started == 0)
      GC_start_debugging();

    char *return_value_GC_store_debug_info$1;
    return_value_GC_store_debug_info$1=GC_store_debug_info((char *)result, (unsigned long int)lb, s, i);
    return (void *)return_value_GC_store_debug_info$1;
  }
}

// GC_debug_malloc_atomic
// file dbg_mlc.c line 674
extern void * GC_debug_malloc_atomic(unsigned long int lb, const char *s, signed int i)
{
  void *result;
  result=GC_malloc_atomic(lb + ((sizeof(struct anonymous$17) /*32ul*/  + sizeof(unsigned long int) /*8ul*/ ) - (unsigned long int)GC_all_interior_pointers));
  if(result == NULL)
  {
    GC_err_printf("GC_debug_malloc_atomic(%lu) returning NULL (%s:%d)\n", (unsigned long int)lb, s, i);
    return NULL;
  }

  else
  {
    if(GC_debugging_started == 0)
      GC_start_debugging();

    char *return_value_GC_store_debug_info$1;
    return_value_GC_store_debug_info$1=GC_store_debug_info((char *)result, (unsigned long int)lb, s, i);
    return (void *)return_value_GC_store_debug_info$1;
  }
}

// GC_debug_malloc_atomic_ignore_off_page
// file dbg_mlc.c line 553
extern void * GC_debug_malloc_atomic_ignore_off_page(unsigned long int lb, const char *s, signed int i)
{
  void *result;
  result=GC_malloc_atomic_ignore_off_page(lb + ((sizeof(struct anonymous$17) /*32ul*/  + sizeof(unsigned long int) /*8ul*/ ) - (unsigned long int)GC_all_interior_pointers));
  if(result == NULL)
  {
    GC_err_printf("GC_debug_malloc_atomic_ignore_off_page(%lu) returning NULL (%s:%d)\n", (unsigned long int)lb, s, i);
    return NULL;
  }

  else
  {
    if(GC_debugging_started == 0)
      GC_start_debugging();

    char *return_value_GC_store_debug_info$1;
    return_value_GC_store_debug_info$1=GC_store_debug_info((char *)result, (unsigned long int)lb, s, i);
    return (void *)return_value_GC_store_debug_info$1;
  }
}

// GC_debug_malloc_atomic_uncollectable
// file dbg_mlc.c line 771
extern void * GC_debug_malloc_atomic_uncollectable(unsigned long int lb, const char *s, signed int i)
{
  void *result;
  result=GC_malloc_atomic_uncollectable(lb + sizeof(struct anonymous$17) /*32ul*/  + sizeof(unsigned long int) /*8ul*/ );
  if(result == NULL)
  {
    GC_err_printf("GC_debug_malloc_atomic_uncollectable(%lu) returning NULL (%s:%d)\n", (unsigned long int)lb, s, i);
    return NULL;
  }

  else
  {
    if(GC_debugging_started == 0)
      GC_start_debugging();

    char *return_value_GC_store_debug_info$1;
    return_value_GC_store_debug_info$1=GC_store_debug_info((char *)result, (unsigned long int)lb, s, i);
    return (void *)return_value_GC_store_debug_info$1;
  }
}

// GC_debug_malloc_ignore_off_page
// file dbg_mlc.c line 536
extern void * GC_debug_malloc_ignore_off_page(unsigned long int lb, const char *s, signed int i)
{
  void *result;
  result=GC_malloc_ignore_off_page(lb + ((sizeof(struct anonymous$17) /*32ul*/  + sizeof(unsigned long int) /*8ul*/ ) - (unsigned long int)GC_all_interior_pointers));
  if(result == NULL)
  {
    GC_err_printf("GC_debug_malloc_ignore_off_page(%lu) returning NULL (%s:%d)\n", (unsigned long int)lb, s, i);
    return NULL;
  }

  else
  {
    if(GC_debugging_started == 0)
      GC_start_debugging();

    char *return_value_GC_store_debug_info$1;
    return_value_GC_store_debug_info$1=GC_store_debug_info((char *)result, (unsigned long int)lb, s, i);
    return (void *)return_value_GC_store_debug_info$1;
  }
}

// GC_debug_malloc_replacement
// file dbg_mlc.c line 1216
extern void * GC_debug_malloc_replacement(unsigned long int lb)
{
  void *return_value_GC_debug_malloc$1;
  return_value_GC_debug_malloc$1=GC_debug_malloc(lb, "unknown", 0);
  return return_value_GC_debug_malloc$1;
}

// GC_debug_malloc_stubborn
// file dbg_mlc.c line 661
extern void * GC_debug_malloc_stubborn(unsigned long int lb, const char *s, signed int i)
{
  void *return_value_GC_debug_malloc$1;
  return_value_GC_debug_malloc$1=GC_debug_malloc(lb, s, i);
  return return_value_GC_debug_malloc$1;
}

// GC_debug_malloc_uncollectable
// file dbg_mlc.c line 752
extern void * GC_debug_malloc_uncollectable(unsigned long int lb, const char *s, signed int i)
{
  void *result;
  result=GC_malloc_uncollectable(lb + sizeof(struct anonymous$17) /*32ul*/  + sizeof(unsigned long int) /*8ul*/ );
  if(result == NULL)
  {
    GC_err_printf("GC_debug_malloc_uncollectable(%lu) returning NULL (%s:%d)\n", (unsigned long int)lb, s, i);
    return NULL;
  }

  else
  {
    if(GC_debugging_started == 0)
      GC_start_debugging();

    char *return_value_GC_store_debug_info$1;
    return_value_GC_store_debug_info$1=GC_store_debug_info((char *)result, (unsigned long int)lb, s, i);
    return (void *)return_value_GC_store_debug_info$1;
  }
}

// GC_debug_print_heap_obj_proc
// file dbg_mlc.c line 404
void GC_debug_print_heap_obj_proc(char *p)
{
  signed int return_value_GC_has_other_debug_info$1;
  return_value_GC_has_other_debug_info$1=GC_has_other_debug_info(p);
  if(return_value_GC_has_other_debug_info$1 >= 1)
    GC_print_obj(p);

  else
    GC_default_print_heap_obj_proc(p);
}

// GC_debug_realloc
// file dbg_mlc.c line 871
extern void * GC_debug_realloc(void *p, unsigned long int lb, const char *s, signed int i)
{
  void *base;
  void *result;
  struct hblkhdr *hhdr;
  if(p == NULL)
  {
    void *return_value_GC_debug_malloc$1;
    return_value_GC_debug_malloc$1=GC_debug_malloc(lb, s, i);
    return return_value_GC_debug_malloc$1;
  }

  base=GC_base(p);
  if(base == NULL)
  {
    if(!(GC_print_stats == 0))
      GC_log_printf("Invalid pointer passed to realloc(): %p", p);

    GC_on_abort("Invalid pointer passed to realloc()");
    abort();
  }

  if(!((unsigned long int)((char *)p - (char *)base) == sizeof(struct anonymous$17) /*32ul*/ ))
  {
    GC_err_printf("GC_debug_realloc called on pointer %p w/o debugging info\n", p);
    void *return_value_GC_realloc$2;
    return_value_GC_realloc$2=GC_realloc(p, lb);
    return return_value_GC_realloc$2;
  }

  hhdr=GC_find_header((char *)base);
  switch((signed int)hhdr->hb_obj_kind)
  {
    case 1:
    {
      result=GC_debug_malloc(lb, s, i);
      break;
    }
    case 0:
    {
      result=GC_debug_malloc_atomic(lb, s, i);
      break;
    }
    case 2:
    {
      result=GC_debug_malloc_uncollectable(lb, s, i);
      break;
    }
    case 3:
    {
      result=GC_debug_malloc_atomic_uncollectable(lb, s, i);
      break;
    }
    default:
    {
      result = (void *)0;
      if((signed long int)GC_current_warn_proc == -1l)
        break;

      GC_on_abort("GC_debug_realloc: encountered bad kind");
    }
  }
  abort();
  if(!(result == NULL))
  {
    unsigned long int old_sz = ((struct anonymous$17 *)base)->oh_sz;
    memcpy(result, p, (unsigned long int)(old_sz < lb ? old_sz : lb));
    GC_debug_free(p);
  }

  return result;
}

// GC_debug_realloc_replacement
// file dbg_mlc.c line 1221
extern void * GC_debug_realloc_replacement(void *p, unsigned long int lb)
{
  void *return_value_GC_debug_realloc$1;
  return_value_GC_debug_realloc$1=GC_debug_realloc(p, lb, "unknown", 0);
  return return_value_GC_debug_realloc$1;
}

// GC_debug_register_displacement
// file dbg_mlc.c line 478
extern void GC_debug_register_displacement(unsigned long int offset)
{
  do
    if(!(GC_need_to_lock == 0))
    {
      signed int return_value_pthread_mutex_trylock$1;
      return_value_pthread_mutex_trylock$1=pthread_mutex_trylock(&GC_allocate_ml);
      if(!(return_value_pthread_mutex_trylock$1 == 0))
        GC_lock();

    }

  while((_Bool)0);
  GC_register_displacement_inner(offset);
  GC_register_displacement_inner((unsigned long int)sizeof(struct anonymous$17) /*32ul*/  + offset);
  do
    if(!(GC_need_to_lock == 0))
      pthread_mutex_unlock(&GC_allocate_ml);

  while((_Bool)0);
}

// GC_debug_register_finalizer
// file dbg_mlc.c line 1098
extern void GC_debug_register_finalizer(void *obj, void (*fn)(void *, void *), void *cd, void (**ofn)(void *, void *), void **ocd)
{
  void (*my_old_fn)(void *, void *) = (void (*)(void *, void *))(signed long int)-1;
  void *my_old_cd;
  char *base;
  void *return_value_GC_base$1;
  return_value_GC_base$1=GC_base(obj);
  base = (char *)return_value_GC_base$1;
  if(base == ((char *)NULL))
  {
    if(!(ocd == ((void **)NULL)))
      *ocd = NULL;

    if(!(ofn == ((void (**)(void *, void *))NULL)))
      *ofn = ((void (*)(void *, void *))NULL);

  }

  else
  {
    if(!((unsigned long int)((char *)obj - base) == sizeof(struct anonymous$17) /*32ul*/ ))
      GC_err_printf("GC_debug_register_finalizer called with non-base-pointer %p\n", obj);

    if(fn == ((void (*)(void *, void *))NULL))
      GC_register_finalizer((void *)base, ((void (*)(void *, void *))NULL), NULL, &my_old_fn, &my_old_cd);

    else
    {
      cd=GC_make_closure(fn, cd);
      if(cd == NULL)
        goto __CPROVER_DUMP_L8;

      GC_register_finalizer((void *)base, GC_debug_invoke_finalizer, cd, &my_old_fn, &my_old_cd);
    }
    store_old(obj, my_old_fn, (struct closure *)my_old_cd, ofn, ocd);
  }

__CPROVER_DUMP_L8:
  ;
}

// GC_debug_register_finalizer_ignore_self
// file dbg_mlc.c line 1185
extern void GC_debug_register_finalizer_ignore_self(void *obj, void (*fn)(void *, void *), void *cd, void (**ofn)(void *, void *), void **ocd)
{
  void (*my_old_fn)(void *, void *) = (void (*)(void *, void *))(signed long int)-1;
  void *my_old_cd;
  char *base;
  void *return_value_GC_base$1;
  return_value_GC_base$1=GC_base(obj);
  base = (char *)return_value_GC_base$1;
  if(base == ((char *)NULL))
  {
    if(!(ocd == ((void **)NULL)))
      *ocd = NULL;

    if(!(ofn == ((void (**)(void *, void *))NULL)))
      *ofn = ((void (*)(void *, void *))NULL);

  }

  else
  {
    if(!((unsigned long int)((char *)obj - base) == sizeof(struct anonymous$17) /*32ul*/ ))
      GC_err_printf("GC_debug_register_finalizer_ignore_self called with non-base-pointer %p\n", obj);

    if(fn == ((void (*)(void *, void *))NULL))
      GC_register_finalizer_ignore_self((void *)base, ((void (*)(void *, void *))NULL), NULL, &my_old_fn, &my_old_cd);

    else
    {
      cd=GC_make_closure(fn, cd);
      if(cd == NULL)
        goto __CPROVER_DUMP_L8;

      GC_register_finalizer_ignore_self((void *)base, GC_debug_invoke_finalizer, cd, &my_old_fn, &my_old_cd);
    }
    store_old(obj, my_old_fn, (struct closure *)my_old_cd, ofn, ocd);
  }

__CPROVER_DUMP_L8:
  ;
}

// GC_debug_register_finalizer_no_order
// file dbg_mlc.c line 1127
extern void GC_debug_register_finalizer_no_order(void *obj, void (*fn)(void *, void *), void *cd, void (**ofn)(void *, void *), void **ocd)
{
  void (*my_old_fn)(void *, void *) = (void (*)(void *, void *))(signed long int)-1;
  void *my_old_cd;
  char *base;
  void *return_value_GC_base$1;
  return_value_GC_base$1=GC_base(obj);
  base = (char *)return_value_GC_base$1;
  if(base == ((char *)NULL))
  {
    if(!(ocd == ((void **)NULL)))
      *ocd = NULL;

    if(!(ofn == ((void (**)(void *, void *))NULL)))
      *ofn = ((void (*)(void *, void *))NULL);

  }

  else
  {
    if(!((unsigned long int)((char *)obj - base) == sizeof(struct anonymous$17) /*32ul*/ ))
      GC_err_printf("GC_debug_register_finalizer_no_order called with non-base-pointer %p\n", obj);

    if(fn == ((void (*)(void *, void *))NULL))
      GC_register_finalizer_no_order((void *)base, ((void (*)(void *, void *))NULL), NULL, &my_old_fn, &my_old_cd);

    else
    {
      cd=GC_make_closure(fn, cd);
      if(cd == NULL)
        goto __CPROVER_DUMP_L8;

      GC_register_finalizer_no_order((void *)base, GC_debug_invoke_finalizer, cd, &my_old_fn, &my_old_cd);
    }
    store_old(obj, my_old_fn, (struct closure *)my_old_cd, ofn, ocd);
  }

__CPROVER_DUMP_L8:
  ;
}

// GC_debug_register_finalizer_unreachable
// file dbg_mlc.c line 1156
extern void GC_debug_register_finalizer_unreachable(void *obj, void (*fn)(void *, void *), void *cd, void (**ofn)(void *, void *), void **ocd)
{
  void (*my_old_fn)(void *, void *) = (void (*)(void *, void *))(signed long int)-1;
  void *my_old_cd;
  char *base;
  void *return_value_GC_base$1;
  return_value_GC_base$1=GC_base(obj);
  base = (char *)return_value_GC_base$1;
  if(base == ((char *)NULL))
  {
    if(!(ocd == ((void **)NULL)))
      *ocd = NULL;

    if(!(ofn == ((void (**)(void *, void *))NULL)))
      *ofn = ((void (*)(void *, void *))NULL);

  }

  else
  {
    if(!((unsigned long int)((char *)obj - base) == sizeof(struct anonymous$17) /*32ul*/ ))
      GC_err_printf("GC_debug_register_finalizer_unreachable called with non-base-pointer %p\n", obj);

    if(fn == ((void (*)(void *, void *))NULL))
      GC_register_finalizer_unreachable((void *)base, ((void (*)(void *, void *))NULL), NULL, &my_old_fn, &my_old_cd);

    else
    {
      cd=GC_make_closure(fn, cd);
      if(cd == NULL)
        goto __CPROVER_DUMP_L8;

      GC_register_finalizer_unreachable((void *)base, GC_debug_invoke_finalizer, cd, &my_old_fn, &my_old_cd);
    }
    store_old(obj, my_old_fn, (struct closure *)my_old_cd, ofn, ocd);
  }

__CPROVER_DUMP_L8:
  ;
}

// GC_debug_strdup
// file dbg_mlc.c line 691
extern char * GC_debug_strdup(const char *str, const char *s, signed int i)
{
  char *copy;
  unsigned long int lb;
  if(str == ((const char *)NULL))
  {
    if(!(GC_find_leak == 0))
      GC_err_printf("strdup(NULL) behavior is undefined\n");

    return (char *)(void *)0;
  }

  else
  {
    unsigned long int return_value_strlen$1;
    return_value_strlen$1=strlen(str);
    lb = return_value_strlen$1 + (unsigned long int)1;
    void *return_value_GC_debug_malloc_atomic$2;
    return_value_GC_debug_malloc_atomic$2=GC_debug_malloc_atomic(lb, s, i);
    copy = (char *)return_value_GC_debug_malloc_atomic$2;
    if(copy == ((char *)NULL))
    {
      signed int *return_value___errno_location$3;
      return_value___errno_location$3=__errno_location();
      *return_value___errno_location$3 = 12;
      return (char *)(void *)0;
    }

    memcpy((void *)copy, (const void *)str, (unsigned long int)lb);
    return copy;
  }
}

// GC_debug_strndup
// file dbg_mlc.c line 714
extern char * GC_debug_strndup(const char *str, unsigned long int size, const char *s, signed int i)
{
  char *copy;
  unsigned long int len;
  len=strlen(str);
  if(!(size >= len))
    len = size;

  void *return_value_GC_debug_malloc_atomic$1;
  return_value_GC_debug_malloc_atomic$1=GC_debug_malloc_atomic(len + (unsigned long int)1, s, i);
  copy = (char *)return_value_GC_debug_malloc_atomic$1;
  if(copy == ((char *)NULL))
  {
    signed int *return_value___errno_location$2;
    return_value___errno_location$2=__errno_location();
    *return_value___errno_location$2 = 12;
    return (char *)(void *)0;
  }

  memcpy((void *)copy, (const void *)str, (unsigned long int)len);
  copy[(signed long int)len] = (char)0;
  return copy;
}

// GC_default_is_valid_displacement_print_proc
// file ptr_chck.c line 103
void GC_default_is_valid_displacement_print_proc(void *p)
{
  if(!(GC_print_stats == 0))
    GC_log_printf("GC_is_valid_displacement test failed: %p not valid", p);

  GC_on_abort("GC_is_valid_displacement test failed");
  abort();
}

// GC_default_is_visible_print_proc
// file ptr_chck.c line 152
void GC_default_is_visible_print_proc(void *p)
{
  if(!(GC_print_stats == 0))
    GC_log_printf("GC_is_visible test failed: %p not GC-visible", p);

  GC_on_abort("GC_is_visible test failed");
  abort();
}

// GC_default_on_abort
// file misc.c line 1638
void GC_default_on_abort(const char *msg)
{
  GC_find_leak = 0;
  if(!(msg == ((const char *)NULL)))
  {
    unsigned long int return_value_strlen$1;
    return_value_strlen$1=strlen(msg);
    signed int return_value_GC_write$2;
    return_value_GC_write$2=GC_write(GC_stderr, (const char *)(void *)msg, return_value_strlen$1);
    if(return_value_GC_write$2 >= 0)
      GC_write(GC_stderr, (const char *)(void *)"\n", (unsigned long int)1);

  }

  char *return_value_getenv$3;
  return_value_getenv$3=getenv("GC_LOOP_ON_ABORT");
  if(!(return_value_getenv$3 == ((char *)NULL)))
  {

  __CPROVER_DUMP_L3:
    ;
    goto __CPROVER_DUMP_L3;
  }

}

// GC_default_oom_fn
// file misc.c line 164
void * GC_default_oom_fn(unsigned long int bytes_requested)
{
  return NULL;
}

// GC_default_print_heap_obj_proc
// file blacklst.c line 57
void GC_default_print_heap_obj_proc(char *p)
{
  char *base;
  void *return_value_GC_base$1;
  return_value_GC_base$1=GC_base((void *)p);
  base = (char *)return_value_GC_base$1;
  signed int kind;
  struct hblkhdr *return_value_GC_find_header$2;
  return_value_GC_find_header$2=GC_find_header((char *)base);
  kind = (signed int)return_value_GC_find_header$2->hb_obj_kind;
  unsigned long int return_value_GC_size$3;
  return_value_GC_size$3=GC_size((const void *)base);
  GC_err_printf("object at %p of appr. %lu bytes (%s)\n", base, (unsigned long int)return_value_GC_size$3, kind == 0 ? "atomic" : ((kind & ~1) == 2 ? "uncollectable" : "composite"));
}

// GC_default_push_other_roots
// file os_dep.c line 2589
void GC_default_push_other_roots(void)
{
  GC_push_all_stacks();
}

// GC_default_same_obj_print_proc
// file ptr_chck.c line 21
void GC_default_same_obj_print_proc(void *p, void *q)
{
  if(!(GC_print_stats == 0))
    GC_log_printf("GC_same_obj test failed: %p and %p are not in the same object", p, q);

  GC_on_abort("GC_same_obj test failed");
  abort();
}

// GC_default_warn_proc
// file misc.c line 1590
void GC_default_warn_proc(char *msg, unsigned long int arg)
{
  GC_err_printf(msg, arg);
}

// GC_delete_gc_thread
// file pthread_support.c line 562
void GC_delete_gc_thread(struct GC_Thread_Rep *t)
{
  unsigned long int id = t->id;
  signed int hv = (signed int)((unsigned long int)id % (unsigned long int)256);
  struct GC_Thread_Rep *p = GC_threads[(signed long int)hv];
  struct GC_Thread_Rep *prev = ((struct GC_Thread_Rep *)NULL);
  for( ; !(p == t); p = p->next)
    prev = p;
  if(prev == ((struct GC_Thread_Rep *)NULL))
    GC_threads[(signed long int)hv] = p->next;

  else
    prev->next = p->next;
  GC_free_inner((void *)p);
}

// GC_delete_thread
// file pthread_support.c line 524
void GC_delete_thread(unsigned long int id)
{
  signed int hv = (signed int)((unsigned long int)id % (unsigned long int)256);
  struct GC_Thread_Rep *p = GC_threads[(signed long int)hv];
  struct GC_Thread_Rep *prev = ((struct GC_Thread_Rep *)NULL);
  for( ; !(p->id == id); p = p->next)
    prev = p;
  if(prev == ((struct GC_Thread_Rep *)NULL))
    GC_threads[(signed long int)hv] = p->next;

  else
    prev->next = p->next;
  if(!(p == &first_thread))
    GC_free_inner((void *)p);

}

// GC_descr_obj_size
// file typd_mlc.c line 421
unsigned long int GC_descr_obj_size(union ComplexDescriptor *d)
{
  unsigned long int return_value_GC_descr_obj_size$1;
  unsigned long int return_value_GC_descr_obj_size$2;
  unsigned long int return_value_GC_descr_obj_size$3;
  switch(d->ld.ld_tag)
  {
    case (unsigned long int)1:
      return d->ld.ld_nelements * d->ld.ld_size;
    case (unsigned long int)2:
    {
      return_value_GC_descr_obj_size$1=GC_descr_obj_size(d->ad.ad_element_descr);
      return d->ad.ad_nelements * return_value_GC_descr_obj_size$1;
    }
    case (unsigned long int)3:
    {
      return_value_GC_descr_obj_size$2=GC_descr_obj_size(d->sd.sd_first);
      return_value_GC_descr_obj_size$3=GC_descr_obj_size(d->sd.sd_second);
      return return_value_GC_descr_obj_size$2 + return_value_GC_descr_obj_size$3;
    }
    default:
    {
      if(!((signed long int)GC_current_warn_proc == -1l))
      {
        GC_on_abort("Bad complex descriptor");
        abort();
      }

      return (unsigned long int)0;
    }
  }
}

// GC_destroy_thread_local
// file thread_local_alloc.c line 127
void GC_destroy_thread_local(struct thread_local_freelists *p)
{
  return_freelists(p->ptrfree_freelists, GC_arrays._aobjfreelist);
  return_freelists(p->normal_freelists, GC_arrays._objfreelist);
  return_freelists(p->gcj_freelists, (void **)GC_gcjobjfreelist);
  return_freelists(p->finalized_freelists, (void **)GC_finalized_objfreelist);
}

// GC_dirty_init
// file ./include/private/gc_priv.h line 2039
void GC_dirty_init(void)
{
  struct sigaction act;
  struct sigaction oldact;
  act.sa_flags = 0x10000000 | 4;
  act.__sigaction_handler.sa_sigaction = GC_write_fault_handler;
  sigemptyset(&act.sa_mask);
  signed int return_value_GC_get_suspend_signal$1;
  return_value_GC_get_suspend_signal$1=GC_get_suspend_signal();
  sigaddset(&act.sa_mask, return_value_GC_get_suspend_signal$1);
  if(GC_print_stats == 2)
    GC_log_printf("Initializing mprotect virtual dirty bit implementation\n");

  GC_dirty_maintained = 1;
  if(!(GC_page_size % 4096ul == 0ul))
  {
    GC_on_abort("Page size not multiple of HBLKSIZE");
    abort();
  }

  signed int res;
  res=sigaction(11, &act, &oldact);
  if(!(res == 0))
  {
    GC_on_abort("Sigaction failed");
    abort();
  }

  if(!((4 & oldact.sa_flags) == 0))
  {
    GC_old_segv_handler = oldact.__sigaction_handler.sa_sigaction;
    GC_old_segv_handler_used_si = 1;
  }

  else
  {
    GC_old_segv_handler = (void (*)(signed int, struct anonymous$13 *, void *))oldact.__sigaction_handler.sa_handler;
    GC_old_segv_handler_used_si = 0;
  }
  if(GC_old_segv_handler == (void (*)(signed int, struct anonymous$13 *, void *))1)
  {
    GC_current_warn_proc("GC Warning: Previously ignored segmentation violation!?\n", (unsigned long int)0);
    GC_old_segv_handler = (void (*)(signed int, struct anonymous$13 *, void *))(void (*)(signed int))0;
  }

  if(!(GC_old_segv_handler == ((void (*)(signed int, struct anonymous$13 *, void *))NULL)))
  {
    if(GC_print_stats == 2)
      GC_log_printf("Replaced other SIGSEGV handler\n");

  }

  sigaction(7, &act, &oldact);
  if(!((4 & oldact.sa_flags) == 0))
    GC_old_bus_handler = oldact.__sigaction_handler.sa_sigaction;

  else
    GC_old_bus_handler = (void (*)(signed int, struct anonymous$13 *, void *))oldact.__sigaction_handler.sa_handler;
  if(GC_old_bus_handler == (void (*)(signed int, struct anonymous$13 *, void *))1)
    GC_current_warn_proc("GC Warning: Previously ignored bus error!?\n", (unsigned long int)0);

  else
    if(!(GC_old_bus_handler == ((void (*)(signed int, struct anonymous$13 *, void *))NULL)))
    {
      if(GC_print_stats == 2)
        GC_log_printf("Replaced other SIGBUS handler\n");

    }

}

// GC_disable
// file misc.c line 1725
extern void GC_disable(void)
{
  do
    if(!(GC_need_to_lock == 0))
    {
      signed int return_value_pthread_mutex_trylock$1;
      return_value_pthread_mutex_trylock$1=pthread_mutex_trylock(&GC_allocate_ml);
      if(!(return_value_pthread_mutex_trylock$1 == 0))
        GC_lock();

    }

  while((_Bool)0);
  GC_dont_gc = GC_dont_gc + 1;
  do
    if(!(GC_need_to_lock == 0))
      pthread_mutex_unlock(&GC_allocate_ml);

  while((_Bool)0);
}

// GC_disclaim_and_reclaim
// file reclaim.c line 222
char * GC_disclaim_and_reclaim(struct hblk *hbp, struct hblkhdr *hhdr, unsigned long int sz, char *list, signed long int *count)
{
  signed int bit_no = 0;
  unsigned long int *p;
  unsigned long int *q;
  unsigned long int *plim;
  signed long int n_bytes_found = (signed long int)0;
  struct obj_kind *ok = &GC_obj_kinds[(signed long int)hhdr->hb_obj_kind];
  signed int (*disclaim)(void *) = ok->ok_disclaim_proc;
  p = (unsigned long int *)hbp->hb_body;
  plim = (unsigned long int *)(((char *)p + (signed long int)(unsigned long int)(1 << 12)) - (signed long int)sz);
  signed int return_value;
  while((unsigned long int)plim >= (unsigned long int)p)
  {
    signed int marked = (signed int)hhdr->_mark_byte_union._hb_marks[(signed long int)bit_no];
    if(marked == 0)
    {
      return_value=disclaim((void *)p);
      if(!(return_value == 0))
      {
        hhdr->hb_n_marks = hhdr->hb_n_marks + 1ul;
        marked = 1;
      }

    }

    if(!(marked == 0))
      p = (unsigned long int *)((char *)p + (signed long int)sz);

    else
    {
      n_bytes_found = n_bytes_found + (signed long int)sz;
      *((void **)p) = (void *)list;
      list = (char *)p;
      q = (unsigned long int *)((char *)p + (signed long int)sz);
      p[(signed long int)1] = (unsigned long int)0;
      p = p + (signed long int)2;
      for( ; !((unsigned long int)p >= (unsigned long int)q); p = p + (signed long int)2)
      {
        ((unsigned long int *)p)[(signed long int)0] = (unsigned long int)0;
        ((unsigned long int *)p)[(signed long int)1] = (unsigned long int)0;
      }
    }
    bit_no = bit_no + (signed int)(sz >> 4);
  }
  *count = *count + n_bytes_found;
  return list;
}

// GC_disclaim_and_reclaim_or_free_small_block
// file reclaim.c line 346
void GC_disclaim_and_reclaim_or_free_small_block(struct hblk *hbp)
{
  struct hblkhdr *hhdr;
  hhdr=GC_find_header((char *)hbp);
  unsigned long int sz = hhdr->hb_sz;
  struct obj_kind *ok = &GC_obj_kinds[(signed long int)hhdr->hb_obj_kind];
  void **flh = &ok->ok_freelist[(signed long int)(sz >> 4)];
  void *flh_next;
  hhdr->hb_last_reclaimed = (unsigned short int)GC_gc_no;
  char *return_value_GC_reclaim_generic$1;
  return_value_GC_reclaim_generic$1=GC_reclaim_generic(hbp, hhdr, sz, ok->ok_init, (char *)*flh, &GC_bytes_found);
  flh_next = (void *)return_value_GC_reclaim_generic$1;
  if(!(hhdr->hb_n_marks == 0ul))
    *flh = flh_next;

  else
  {
    GC_bytes_found = GC_bytes_found + (signed long int)(unsigned long int)(1 << 12);
    GC_freehblk(hbp);
  }
}

// GC_dlopen
// file gc_dlopen.c line 70
extern void * GC_dlopen(const char *path, signed int mode)
{
  void *result;
  disable_gc_for_dlopen();
  result=dlopen(path, mode);
  GC_enable();
  return result;
}

// GC_do_blocking
// file misc.c line 1940
extern void * GC_do_blocking(void * (*fn)(void *), void *client_data)
{
  struct blocking_data my_data;
  my_data.fn = fn;
  my_data.client_data = client_data;
  GC_with_callee_saves_pushed(GC_do_blocking_inner, (char *)&my_data);
  return my_data.client_data;
}

// GC_do_blocking_inner
// file ./include/private/gc_priv.h line 2271
void GC_do_blocking_inner(char *data, void *context)
{
  struct blocking_data *d = (struct blocking_data *)data;
  unsigned long int self;
  self=pthread_self();
  struct GC_Thread_Rep *me;
  do
    if(!(GC_need_to_lock == 0))
    {
      signed int return_value_pthread_mutex_trylock$1;
      return_value_pthread_mutex_trylock$1=pthread_mutex_trylock(&GC_allocate_ml);
      if(!(return_value_pthread_mutex_trylock$1 == 0))
        GC_lock();

    }

  while((_Bool)0);
  me=GC_lookup_thread(self);
  me->stop_info.stack_ptr=GC_approx_sp();
  me->thread_blocked = (unsigned char)1;
  do
    if(!(GC_need_to_lock == 0))
      pthread_mutex_unlock(&GC_allocate_ml);

  while((_Bool)0);
  d->client_data=d->fn(d->client_data);
  if(!(GC_need_to_lock == 0))
  {
    signed int return_value_pthread_mutex_trylock$2;
    return_value_pthread_mutex_trylock$2=pthread_mutex_trylock(&GC_allocate_ml);
    if(!(return_value_pthread_mutex_trylock$2 == 0))
      GC_lock();

  }

  me->thread_blocked = (unsigned char)0;
  if(!(GC_need_to_lock == 0))
    pthread_mutex_unlock(&GC_allocate_ml);

}

// GC_do_local_mark
// file mark.c line 964
void GC_do_local_mark(struct GC_ms_entry *local_mark_stack, struct GC_ms_entry *local_top)
{
  unsigned int n;
  do
  {
    n = (unsigned int)0;
    for( ; !(n >= 1u); n = n + 1u)
    {
      local_top=GC_mark_from(local_top, local_mark_stack, local_mark_stack + (signed long int)(unsigned long int)(1 << 12));
      if(!((unsigned long int)local_top >= (unsigned long int)local_mark_stack))
        goto __CPROVER_DUMP_L7;

      if((unsigned long int)(local_top - local_mark_stack) >= 2048ul)
      {
        GC_return_mark_stack(local_mark_stack, local_top);
        goto __CPROVER_DUMP_L7;
      }

    }
    unsigned long int return_value_AO_load$1;
    return_value_AO_load$1=AO_load$link1((volatile unsigned long int *)&GC_arrays._mark_stack_top);
    unsigned long int return_value_AO_load$2;
    return_value_AO_load$2=AO_load$link1(&GC_first_nonempty);
    if(!(return_value_AO_load$1 >= return_value_AO_load$2))
    {
      if(!(GC_active_count >= GC_helper_count))
      {
        if(!((unsigned long int)(local_mark_stack + 1l) >= (unsigned long int)local_top))
        {
          struct GC_ms_entry *new_bottom = local_mark_stack + (local_top - local_mark_stack) / (signed long int)2;
          GC_return_mark_stack(local_mark_stack, new_bottom - (signed long int)1);
          memmove((void *)local_mark_stack, (const void *)new_bottom, (unsigned long int)((local_top - new_bottom) + (signed long int)1) * sizeof(struct GC_ms_entry) /*16ul*/ );
          local_top = local_top - (new_bottom - local_mark_stack);
        }

      }

    }

  }
  while((_Bool)1);

__CPROVER_DUMP_L7:
  ;
}

// GC_do_parallel_mark
// file mark.c line 1119
void GC_do_parallel_mark(void)
{
  struct GC_ms_entry local_mark_stack[4096l];
  GC_acquire_mark_lock();
  if(!(GC_help_wanted == 0) || !(GC_active_count == 0u) || !(GC_helper_count == 0u))
  {
    GC_on_abort("Tried to start parallel mark in bad state");
    abort();
  }

  if(GC_print_stats == 2)
    GC_log_printf("Starting marking for mark phase number %lu\n", (unsigned long int)GC_mark_no);

  GC_first_nonempty = (unsigned long int)GC_arrays._mark_stack;
  GC_active_count = (unsigned int)0;
  GC_helper_count = (unsigned int)1;
  GC_help_wanted = 1;
  GC_release_mark_lock();
  GC_notify_all_marker();
  GC_mark_local(local_mark_stack, 0);
  GC_acquire_mark_lock();
  GC_help_wanted = 0;
  while(GC_helper_count >= 1u)
    GC_wait_marker();
  if(GC_print_stats == 2)
    GC_log_printf("Finished marking for mark phase number %lu\n", (unsigned long int)GC_mark_no);

  GC_mark_no = GC_mark_no + 1ul;
  GC_release_mark_lock();
  GC_notify_all_marker();
}

// GC_double_descr
// file typd_mlc.c line 175
unsigned long int GC_double_descr(unsigned long int descriptor, unsigned long int nwords)
{
  if((3ul & descriptor) == 0ul)
    descriptor = GC_bm_table[(signed long int)((unsigned long int)descriptor >> 3)];

  descriptor = descriptor | (descriptor & (unsigned long int)~((1 << 2) - 1)) >> nwords;
  return descriptor;
}

// GC_dump
// file ./include/private/../gc.h line 1395
extern void GC_dump(void)
{
  GC_printf("***Static roots:\n");
  GC_print_static_roots();
  GC_printf("\n***Heap sections:\n");
  GC_print_heap_sects();
  GC_printf("\n***Free blocks:\n");
  GC_print_hblkfreelist();
  GC_printf("\n***Blocks in use:\n");
  GC_print_block_list();
}

// GC_dump_finalization
// file finalize.c line 612
void GC_dump_finalization(void)
{
  struct finalizable_object *curr_fo;
  unsigned long int fo_size = (unsigned long int)(log_fo_table_size == (signed long int)-1 ? 0 : 1 << log_fo_table_size);
  char *real_ptr;
  unsigned long int i;
  GC_printf("Disappearing (short) links:\n");
  GC_dump_finalization_links(&GC_dl_hashtbl);
  GC_printf("Disappearing long links:\n");
  GC_dump_finalization_links(&GC_ll_hashtbl);
  GC_printf("Finalizers:\n");
  i = (unsigned long int)0;
  for( ; !(i >= fo_size); i = i + 1ul)
  {
    curr_fo = GC_fo_head[(signed long int)i];
    for( ; !(curr_fo == ((struct finalizable_object *)NULL)); curr_fo = (struct finalizable_object *)curr_fo->prolog.next)
    {
      real_ptr = (char *)(void *)~((unsigned long int)curr_fo->prolog.hidden_key);
      GC_printf("Finalizable object: %p\n", real_ptr);
    }
  }
}

// GC_dump_finalization_links
// file finalize.c line 593
void GC_dump_finalization_links(struct dl_hashtbl_s *dl_hashtbl)
{
  struct disappearing_link *curr_dl;
  char *real_ptr;
  char *real_link;
  unsigned long int dl_size;
  signed int tmp_if_expr$1;
  if(dl_hashtbl->log_size == -1l)
    tmp_if_expr$1 = 0;

  else
    tmp_if_expr$1 = 1 << dl_hashtbl->log_size;
  dl_size = (unsigned long int)tmp_if_expr$1;
  unsigned long int i = (unsigned long int)0;
  for( ; !(i >= dl_size); i = i + 1ul)
  {
    curr_dl = dl_hashtbl->head[(signed long int)i];
    for( ; !(curr_dl == ((struct disappearing_link *)NULL)); curr_dl = (struct disappearing_link *)curr_dl->prolog.next)
    {
      real_ptr = (char *)(void *)~((unsigned long int)curr_dl->dl_hidden_obj);
      real_link = (char *)(void *)~((unsigned long int)curr_dl->prolog.hidden_key);
      GC_printf("Object: %p, link: %p\n", real_ptr, real_link);
    }
  }
}

// GC_dump_regions
// file allchblk.c line 170
void GC_dump_regions(void)
{
  unsigned int i;
  char *start;
  char *end;
  char *p;
  unsigned long int bytes;
  struct hblkhdr *hhdr;
  i = (unsigned int)0;
  for( ; !((unsigned long int)i >= GC_n_heap_sects); i = i + 1u)
  {
    start = GC_arrays._heap_sects[(signed long int)i].hs_start;
    bytes = GC_arrays._heap_sects[(signed long int)i].hs_bytes;
    end = start + (signed long int)bytes;
    for( ; !((unsigned long int)(1u + i) >= GC_n_heap_sects); end = GC_arrays._heap_sects[(signed long int)i].hs_start + (signed long int)GC_arrays._heap_sects[(signed long int)i].hs_bytes)
    {
      if(!(GC_arrays._heap_sects[(signed long int)(1u + i)].hs_start == end))
        break;

      i = i + 1u;
    }
    GC_printf("***Section from %p to %p\n", start, end);
    p = start;
    while(!((unsigned long int)p >= (unsigned long int)end))
    {
      hhdr=GC_find_header((char *)p);
      if(!((unsigned long int)hhdr >= 4096ul))
      {
        GC_printf("\t%p Missing header!!(%p)\n", p, (void *)hhdr);
        p = p + (signed long int)(unsigned long int)(1 << 12);
      }

      else
        if(!((4 & (signed int)hhdr->hb_flags) == 0))
        {
          signed int correct_index;
          correct_index=GC_hblk_fl_from_blocks(hhdr->hb_sz >> (unsigned long int)12);
          signed int actual_index;
          GC_printf("\t%p\tfree block of size 0x%lx bytes%s\n", p, (unsigned long int)hhdr->hb_sz, 1 != 0 ? "" : " (unmapped)");
          actual_index=free_list_index_of(hhdr);
          if(actual_index == -1)
            GC_printf("\t\tBlock not on free list %d!!\n", correct_index);

          else
            if(!(correct_index == actual_index))
              GC_printf("\t\tBlock on list %d, should be on %d!!\n", actual_index, correct_index);

          p = p + (signed long int)hhdr->hb_sz;
        }

        else
        {
          GC_printf("\t%p\tused for blocks of size 0x%lx bytes\n", p, (unsigned long int)hhdr->hb_sz);
          p = p + (signed long int)((unsigned long int)(1 << 12) * ((hhdr->hb_sz + (unsigned long int)(1 << 12)) - (unsigned long int)1 >> (unsigned long int)12));
        }
    }
  }
}

// GC_enable
// file ./include/private/../gc.h line 693
extern void GC_enable(void)
{
  do
    if(!(GC_need_to_lock == 0))
    {
      signed int return_value_pthread_mutex_trylock$1;
      return_value_pthread_mutex_trylock$1=pthread_mutex_trylock(&GC_allocate_ml);
      if(!(return_value_pthread_mutex_trylock$1 == 0))
        GC_lock();

    }

  while((_Bool)0);
  GC_dont_gc = GC_dont_gc - 1;
  do
    if(!(GC_need_to_lock == 0))
      pthread_mutex_unlock(&GC_allocate_ml);

  while((_Bool)0);
}

// GC_enable_incremental
// file misc.c line 1228
extern void GC_enable_incremental(void)
{
  char *return_value_getenv$2;
  if(GC_find_leak == 0)
  {
    return_value_getenv$2=getenv("GC_DISABLE_INCREMENTAL");
    if(return_value_getenv$2 == ((char *)NULL))
    {
      do
        if(!(GC_need_to_lock == 0))
        {
          signed int return_value_pthread_mutex_trylock$1;
          return_value_pthread_mutex_trylock$1=pthread_mutex_trylock(&GC_allocate_ml);
          if(!(return_value_pthread_mutex_trylock$1 == 0))
            GC_lock();

        }

      while((_Bool)0);
      if(GC_incremental == 0)
      {
        GC_setpagesize();
        maybe_install_looping_handler();
        GC_incremental = 1;
        if(GC_is_initialized == 0)
          GC_init();

        else
          GC_dirty_init();
        if(GC_dont_gc == 0 && !(GC_dirty_maintained == 0))
        {
          if(GC_arrays._bytes_allocd >= 1ul)
            GC_try_to_collect_inner(GC_never_stop_func);

          GC_read_dirty();
        }

      }

      do
        if(!(GC_need_to_lock == 0))
          pthread_mutex_unlock(&GC_allocate_ml);

      while((_Bool)0);
      goto __CPROVER_DUMP_L11;
    }

  }

  GC_init();

__CPROVER_DUMP_L11:
  ;
}

// GC_end_stubborn_change
// file stubborn.c line 48
extern void GC_end_stubborn_change(const void *p)
{
  ;
}

// GC_enough_large_bytes_left
// file allchblk.c line 70
static inline signed int GC_enough_large_bytes_left(void)
{
  signed int n;
  unsigned long int bytes = GC_arrays._large_allocd_bytes;
  n = (256 - 32) / 8 + 32;
  for( ; n >= 0; n = n - 1)
  {
    bytes = bytes + GC_free_bytes[(signed long int)n];
    if(bytes >= GC_arrays._max_large_allocd_bytes)
      return n;

  }
  return 0;
}

// GC_enough_large_bytes_left$link1
// file allchblk.c line 70
static inline signed int GC_enough_large_bytes_left$link1(void)
{
  signed int n$link1;
  unsigned long int bytes$link1 = GC_arrays._large_allocd_bytes;
  n$link1 = (256 - 32) / 8 + 32;
  for( ; n$link1 >= 0; n$link1 = n$link1 - 1)
  {
    bytes$link1 = bytes$link1 + GC_free_bytes[(signed long int)n$link1];
    if(bytes$link1 >= GC_arrays._max_large_allocd_bytes)
      return n$link1;

  }
  return 0;
}

// GC_enqueue_all_finalizers
// file finalize.c line 881
void GC_enqueue_all_finalizers(void)
{
  struct finalizable_object *curr_fo;
  struct finalizable_object *prev_fo;
  struct finalizable_object *next_fo;
  char *real_ptr;
  signed int i;
  signed int fo_size = log_fo_table_size == (signed long int)-1 ? 0 : 1 << log_fo_table_size;
  GC_arrays._bytes_finalized = (unsigned long int)0;
  i = 0;
  for( ; !(i >= fo_size); i = i + 1)
  {
    curr_fo = GC_fo_head[(signed long int)i];
    prev_fo = ((struct finalizable_object *)NULL);
    if(!(curr_fo == ((struct finalizable_object *)NULL)))
    {
      real_ptr = (char *)(void *)~((unsigned long int)curr_fo->prolog.hidden_key);
      (GC_normal_finalize_mark_proc)(real_ptr);
      if((unsigned long int)GC_arrays._mark_stack_top >= (unsigned long int)GC_arrays._mark_stack)
        GC_arrays._mark_stack_top=GC_mark_from(GC_arrays._mark_stack_top, GC_arrays._mark_stack, GC_arrays._mark_stack + (signed long int)GC_mark_stack_size);

      if(!(GC_mark_state == 0))
      {
        GC_set_mark_bit((const void *)real_ptr);
        signed int return_value_GC_mark_some$1;
        return_value_GC_mark_some$1=GC_mark_some((char *)0);
      }

      GC_set_mark_bit((const void *)real_ptr);
      next_fo = (struct finalizable_object *)curr_fo->prolog.next;
      if(prev_fo == ((struct finalizable_object *)NULL))
        GC_fo_head[(signed long int)i] = next_fo;

      else
        prev_fo->prolog.next = (struct hash_chain_entry *)next_fo;
      GC_fo_entries = GC_fo_entries - 1ul;
      curr_fo->prolog.next = (struct hash_chain_entry *)GC_finalize_now;
      GC_finalize_now = curr_fo;
      curr_fo->prolog.hidden_key = (unsigned long int)(void *)~((unsigned long int)curr_fo->prolog.hidden_key);
      GC_arrays._bytes_finalized = GC_arrays._bytes_finalized + curr_fo->fo_object_size + sizeof(struct finalizable_object) /*48ul*/ ;
      curr_fo = next_fo;
    }

  }
}

// GC_err_printf
// file ./include/private/gc_priv.h line 2096
extern void GC_err_printf(const char *format, ...)
{
  char buf[1025l];
  do
  {
    void **args = (void **)&format;
    buf[(signed long int)(sizeof(char [1025l]) /*1025ul*/  - (unsigned long int)1)] = (char)0x15;
    vsnprintf(buf, sizeof(char [1025l]) /*1025ul*/  - (unsigned long int)1, format, args);
    args = ((void **)NULL);
    if(!((signed int)buf[1024l] == 0x15))
    {
      GC_on_abort("GC_printf clobbered stack");
      abort();
    }

  }
  while((_Bool)0);
  GC_err_puts(buf);
}

// GC_err_puts
// file misc.c line 1585
void GC_err_puts(const char *s)
{
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(s);
  GC_write(GC_stderr, s, return_value_strlen$1);
}

// GC_exclude_static_roots
// file mark_rts.c line 474
extern void GC_exclude_static_roots(void *b, void *e)
{
  if(!(b == e))
  {
    b = (void *)((unsigned long int)b & ~(sizeof(unsigned long int) /*8ul*/  - (unsigned long int)1));
    e = (void *)((unsigned long int)e + (sizeof(unsigned long int) /*8ul*/  - (unsigned long int)1) & ~(sizeof(unsigned long int) /*8ul*/  - (unsigned long int)1));
    if(e == NULL)
      e = (void *)(unsigned long int)~(sizeof(unsigned long int) /*8ul*/  - (unsigned long int)1);

    do
      if(!(GC_need_to_lock == 0))
      {
        signed int return_value_pthread_mutex_trylock$1;
        return_value_pthread_mutex_trylock$1=pthread_mutex_trylock(&GC_allocate_ml);
        if(!(return_value_pthread_mutex_trylock$1 == 0))
          GC_lock();

      }

    while((_Bool)0);
    GC_exclude_static_roots_inner(b, e);
    do
      if(!(GC_need_to_lock == 0))
        pthread_mutex_unlock(&GC_allocate_ml);

    while((_Bool)0);
  }

}

// GC_exclude_static_roots_inner
// file ./include/private/gc_priv.h line 1661
void GC_exclude_static_roots_inner(void *start, void *finish)
{
  struct exclusion *next;
  unsigned long int next_index;
  unsigned long int i;
  if(GC_excl_table_entries == 0ul)
    next = ((struct exclusion *)NULL);

  else
    next=GC_next_exclusion((char *)start);
  if(!(next == ((struct exclusion *)NULL)))
  {
    if(!((unsigned long int)next->e_start >= (unsigned long int)finish))
    {
      GC_on_abort("Exclusion ranges overlap");
      abort();
    }

    if((unsigned long int)next->e_start == (unsigned long int)finish)
    {
      next->e_start = (char *)start;
      goto __CPROVER_DUMP_L10;
    }

    next_index = (unsigned long int)(next - GC_arrays._excl_table);
    i = GC_excl_table_entries;
    for( ; !(next_index >= i); i = i - 1ul)
      GC_arrays._excl_table[(signed long int)i] = GC_arrays._excl_table[(signed long int)(i - (unsigned long int)1)];
  }

  else
    next_index = GC_excl_table_entries;
  if(GC_excl_table_entries == 512ul)
  {
    GC_on_abort("Too many exclusions");
    abort();
  }

  GC_arrays._excl_table[(signed long int)next_index].e_start = (char *)start;
  GC_arrays._excl_table[(signed long int)next_index].e_end = (char *)finish;
  GC_excl_table_entries = GC_excl_table_entries + 1ul;

__CPROVER_DUMP_L10:
  ;
}

// GC_exit_check
// file misc.c line 744
void GC_exit_check(void)
{
  if(!(GC_find_leak == 0))
    GC_gcollect();

}

// GC_expand_hp
// file alloc.c line 1223
extern signed int GC_expand_hp(unsigned long int bytes)
{
  signed int result;
  do
    if(!(GC_need_to_lock == 0))
    {
      signed int return_value_pthread_mutex_trylock$1;
      return_value_pthread_mutex_trylock$1=pthread_mutex_trylock(&GC_allocate_ml);
      if(!(return_value_pthread_mutex_trylock$1 == 0))
        GC_lock();

    }

  while((_Bool)0);
  if((signed long int)GC_is_initialized == 0l)
    GC_init();

  signed int return_value_GC_expand_hp_inner$2;
  return_value_GC_expand_hp_inner$2=GC_expand_hp_inner((unsigned long int)bytes >> (unsigned long int)12);
  result = (signed int)return_value_GC_expand_hp_inner$2;
  if(!(result == 0))
    GC_arrays._requested_heapsize = GC_arrays._requested_heapsize + bytes;

  do
    if(!(GC_need_to_lock == 0))
      pthread_mutex_unlock(&GC_allocate_ml);

  while((_Bool)0);
  return result;
}

// GC_expand_hp_inner
// file alloc.c line 1155
signed int GC_expand_hp_inner(unsigned long int n)
{
  unsigned long int bytes;
  struct hblk *space;
  unsigned long int expansion_slop;
  if(!(n >= 16ul))
    n = (unsigned long int)16;

  bytes = n * (unsigned long int)(1 << 12);
  unsigned long int mask = GC_page_size - (unsigned long int)1;
  bytes = bytes + mask;
  bytes = bytes & ~mask;
  if(!(GC_max_heapsize == 0ul) && !(GC_max_heapsize >= GC_arrays._heapsize + bytes))
    return 0;

  else
  {
    char *return_value_GC_unix_get_mem$1;
    return_value_GC_unix_get_mem$1=GC_unix_get_mem(bytes);
    space = (struct hblk *)return_value_GC_unix_get_mem$1;
    if(space == ((struct hblk *)NULL))
    {
      GC_current_warn_proc("GC Warning: Failed to expand heap by %ld bytes\n", (unsigned long int)bytes);
      return 0;
    }

    else
    {
      if(!(GC_print_stats == 0))
        GC_log_printf("Grow heap to %lu KiB after %lu bytes allocated\n", (unsigned long int)(GC_arrays._heapsize + bytes + (unsigned long int)((1 << 9) - 1) >> 10), (unsigned long int)GC_arrays._bytes_allocd);

      unsigned long int return_value_min_bytes_allocd$2;
      return_value_min_bytes_allocd$2=min_bytes_allocd();
      expansion_slop = return_value_min_bytes_allocd$2 + (unsigned long int)(4 * 2048) * (unsigned long int)(1 << 12);
      if((9223372036854775808ul & (unsigned long int)space) == 0ul && GC_arrays._last_heap_addr == ((char *)NULL) || !(GC_arrays._last_heap_addr == ((char *)NULL)) && !((unsigned long int)GC_arrays._last_heap_addr >= (unsigned long int)space))
      {
        unsigned long int GC_expand_hp_inner$$1$$5$$new_limit = (unsigned long int)space + bytes + expansion_slop;
        if(!((unsigned long int)space >= GC_expand_hp_inner$$1$$5$$new_limit))
        {
          unsigned long int return_value_GC_max$3;
          return_value_GC_max$3=GC_max((unsigned long int)GC_greatest_plausible_heap_addr, (unsigned long int)GC_expand_hp_inner$$1$$5$$new_limit);
          GC_greatest_plausible_heap_addr = (void *)return_value_GC_max$3;
        }

      }

      else
      {
        unsigned long int new_limit = (unsigned long int)space - expansion_slop;
        if(!(new_limit >= (unsigned long int)space))
        {
          unsigned long int return_value_GC_min$4;
          return_value_GC_min$4=GC_min((unsigned long int)GC_least_plausible_heap_addr, (unsigned long int)space - expansion_slop);
          GC_least_plausible_heap_addr = (void *)return_value_GC_min$4;
        }

      }
      GC_arrays._prev_heap_addr = GC_arrays._last_heap_addr;
      GC_arrays._last_heap_addr = (char *)space;
      GC_add_to_heap(space, bytes);
      GC_collect_at_heapsize = (GC_arrays._heapsize + expansion_slop) - (unsigned long int)(2 * 2048) * (unsigned long int)(1 << 12);
      if(!(GC_collect_at_heapsize >= GC_arrays._heapsize))
        GC_collect_at_heapsize = (unsigned long int)-1;

      if(!(GC_on_heap_resize == ((void (*)(unsigned long int))NULL)))
        GC_on_heap_resize(GC_arrays._heapsize);

      return 1;
    }
  }
}

// GC_extend_size_map
// file ./include/private/gc_priv.h line 2220
void GC_extend_size_map(unsigned long int i)
{
  unsigned long int orig_granule_sz = i + (unsigned long int)((16 - 1) + GC_all_interior_pointers) >> 4;
  unsigned long int granule_sz = orig_granule_sz;
  unsigned long int byte_sz = granule_sz << 4;
  unsigned long int smaller_than_i = byte_sz - (byte_sz >> 3);
  unsigned long int much_smaller_than_i = byte_sz - (byte_sz >> 2);
  unsigned long int low_limit;
  unsigned long int j;
  if(GC_arrays._size_map[(signed long int)smaller_than_i] == 0ul)
  {
    low_limit = much_smaller_than_i;
    for( ; !(GC_arrays._size_map[(signed long int)low_limit] == 0ul); low_limit = low_limit + 1ul)
      ;
  }

  else
  {
    low_limit = smaller_than_i + (unsigned long int)1;
    for( ; !(GC_arrays._size_map[(signed long int)low_limit] == 0ul); low_limit = low_limit + 1ul)
      ;
    granule_sz = low_limit + (unsigned long int)((16 - 1) + GC_all_interior_pointers) >> 4;
    granule_sz = granule_sz + (granule_sz >> 3);
    if(!(granule_sz >= orig_granule_sz))
      granule_sz = orig_granule_sz;

  }
  granule_sz = granule_sz + (unsigned long int)1;
  granule_sz = granule_sz & (unsigned long int)~1;
  if(granule_sz >= 129ul)
    granule_sz = (unsigned long int)((1 << 12) / 2 >> 4);

  unsigned long int number_of_objs = ((unsigned long int)(1 << 12) / (unsigned long int)16) / granule_sz;
  granule_sz = ((unsigned long int)(1 << 12) / (unsigned long int)16) / number_of_objs;
  granule_sz = granule_sz & (unsigned long int)~1;
  byte_sz = granule_sz << 4;
  byte_sz = byte_sz - (unsigned long int)GC_all_interior_pointers;
  j = low_limit;
  for( ; byte_sz >= j; j = j + 1ul)
    GC_arrays._size_map[(signed long int)j] = granule_sz;
}

// GC_fault_handler
// file os_dep.c line 922
void GC_fault_handler(signed int sig)
{
  siglongjmp(GC_jmp_buf, 1);
}

// GC_finalize
// file ./include/private/gc_priv.h line 262
void GC_finalize(void)
{
  struct finalizable_object *curr_fo;
  struct finalizable_object *prev_fo;
  struct finalizable_object *next_fo;
  char *real_ptr;
  unsigned long int i;
  unsigned long int fo_size = (unsigned long int)(log_fo_table_size == (signed long int)-1 ? 0 : 1 << log_fo_table_size);
  GC_old_dl_entries = GC_dl_hashtbl.entries;
  GC_old_ll_entries = GC_ll_hashtbl.entries;
  GC_make_disappearing_links_disappear(&GC_dl_hashtbl);
  i = (unsigned long int)0;
  for( ; !(i >= fo_size); i = i + 1ul)
  {
    curr_fo = GC_fo_head[(signed long int)i];
    for( ; !(curr_fo == ((struct finalizable_object *)NULL)); curr_fo = (struct finalizable_object *)curr_fo->prolog.next)
    {
      real_ptr = (char *)(void *)~((unsigned long int)curr_fo->prolog.hidden_key);
      signed int return_value_GC_is_marked$3;
      return_value_GC_is_marked$3=GC_is_marked((const void *)real_ptr);
      if(return_value_GC_is_marked$3 == 0)
      {
        curr_fo->fo_mark_proc(real_ptr);
        if((unsigned long int)GC_arrays._mark_stack_top >= (unsigned long int)GC_arrays._mark_stack)
          GC_arrays._mark_stack_top=GC_mark_from(GC_arrays._mark_stack_top, GC_arrays._mark_stack, GC_arrays._mark_stack + (signed long int)GC_mark_stack_size);

        if(!(GC_mark_state == 0))
        {
          GC_set_mark_bit((const void *)real_ptr);
          signed int return_value_GC_mark_some$1;
          return_value_GC_mark_some$1=GC_mark_some((char *)0);
        }

        signed int return_value_GC_is_marked$2;
        return_value_GC_is_marked$2=GC_is_marked((const void *)real_ptr);
        if(!(return_value_GC_is_marked$2 == 0))
          GC_current_warn_proc("GC Warning: Finalization cycle involving %p\n", (unsigned long int)real_ptr);

      }

    }
  }
  GC_arrays._bytes_finalized = (unsigned long int)0;
  i = (unsigned long int)0;
  for( ; !(i >= fo_size); i = i + 1ul)
  {
    curr_fo = GC_fo_head[(signed long int)i];
    prev_fo = ((struct finalizable_object *)NULL);
    while(!(curr_fo == ((struct finalizable_object *)NULL)))
    {
      real_ptr = (char *)(void *)~((unsigned long int)curr_fo->prolog.hidden_key);
      signed int return_value_GC_is_marked$4;
      return_value_GC_is_marked$4=GC_is_marked((const void *)real_ptr);
      if(return_value_GC_is_marked$4 == 0)
      {
        if(GC_java_finalization == 0)
          GC_set_mark_bit((const void *)real_ptr);

        next_fo = (struct finalizable_object *)curr_fo->prolog.next;
        if(prev_fo == ((struct finalizable_object *)NULL))
          GC_fo_head[(signed long int)i] = next_fo;

        else
          prev_fo->prolog.next = (struct hash_chain_entry *)next_fo;
        GC_fo_entries = GC_fo_entries - 1ul;
        curr_fo->prolog.next = (struct hash_chain_entry *)GC_finalize_now;
        GC_finalize_now = curr_fo;
        curr_fo->prolog.hidden_key = (unsigned long int)(void *)~((unsigned long int)curr_fo->prolog.hidden_key);
        GC_arrays._bytes_finalized = GC_arrays._bytes_finalized + curr_fo->fo_object_size + sizeof(struct finalizable_object) /*48ul*/ ;
        curr_fo = next_fo;
      }

      else
      {
        prev_fo = curr_fo;
        curr_fo = (struct finalizable_object *)curr_fo->prolog.next;
      }
    }
  }
  if(!(GC_java_finalization == 0))
  {
    curr_fo = GC_finalize_now;
    for( ; !(curr_fo == ((struct finalizable_object *)NULL)); curr_fo = (struct finalizable_object *)curr_fo->prolog.next)
    {
      real_ptr = (char *)curr_fo->prolog.hidden_key;
      signed int return_value_GC_is_marked$6;
      return_value_GC_is_marked$6=GC_is_marked((const void *)real_ptr);
      if(return_value_GC_is_marked$6 == 0)
      {
        if(curr_fo->fo_mark_proc == GC_null_finalize_mark_proc)
        {
          (GC_normal_finalize_mark_proc)(real_ptr);
          if((unsigned long int)GC_arrays._mark_stack_top >= (unsigned long int)GC_arrays._mark_stack)
            GC_arrays._mark_stack_top=GC_mark_from(GC_arrays._mark_stack_top, GC_arrays._mark_stack, GC_arrays._mark_stack + (signed long int)GC_mark_stack_size);

          if(!(GC_mark_state == 0))
          {
            GC_set_mark_bit((const void *)real_ptr);
            signed int return_value_GC_mark_some$5;
            return_value_GC_mark_some$5=GC_mark_some((char *)0);
          }

        }

        if(!(curr_fo->fo_mark_proc == GC_unreachable_finalize_mark_proc))
          GC_set_mark_bit((const void *)real_ptr);

      }

    }
    if(!(need_unreachable_finalization == 0))
    {
      curr_fo = GC_finalize_now;
      prev_fo = ((struct finalizable_object *)NULL);
      for( ; !(curr_fo == ((struct finalizable_object *)NULL)); curr_fo = next_fo)
      {
        next_fo = (struct finalizable_object *)curr_fo->prolog.next;
        if(curr_fo->fo_mark_proc == GC_unreachable_finalize_mark_proc)
        {
          real_ptr = (char *)curr_fo->prolog.hidden_key;
          signed int return_value_GC_is_marked$7;
          return_value_GC_is_marked$7=GC_is_marked((const void *)real_ptr);
          if(return_value_GC_is_marked$7 == 0)
            GC_set_mark_bit((const void *)real_ptr);

          else
          {
            if(prev_fo == ((struct finalizable_object *)NULL))
              GC_finalize_now = next_fo;

            else
              prev_fo->prolog.next = (struct hash_chain_entry *)next_fo;
            curr_fo->prolog.hidden_key = ~((unsigned long int)curr_fo->prolog.hidden_key);
            GC_arrays._bytes_finalized = GC_arrays._bytes_finalized - (curr_fo->fo_object_size + sizeof(struct finalizable_object) /*48ul*/ );
            i = ((unsigned long int)real_ptr >> 3 ^ (unsigned long int)real_ptr >> (signed long int)3 + log_fo_table_size) & (unsigned long int)((1 << log_fo_table_size) - 1);
            curr_fo->prolog.next = (struct hash_chain_entry *)GC_fo_head[(signed long int)i];
            GC_fo_entries = GC_fo_entries + 1ul;
            GC_fo_head[(signed long int)i] = curr_fo;
            curr_fo = prev_fo;
          }
        }

        prev_fo = curr_fo;
      }
    }

  }

  GC_remove_dangling_disappearing_links(&GC_dl_hashtbl);
  GC_make_disappearing_links_disappear(&GC_ll_hashtbl);
  GC_remove_dangling_disappearing_links(&GC_ll_hashtbl);
  if(!(GC_fail_count == 0u))
    GC_reset_finalizer_nested();

}

// GC_finalize_all
// file finalize.c line 936
extern void GC_finalize_all(void)
{
  do
    if(!(GC_need_to_lock == 0))
    {
      signed int return_value_pthread_mutex_trylock$1;
      return_value_pthread_mutex_trylock$1=pthread_mutex_trylock(&GC_allocate_ml);
      if(!(return_value_pthread_mutex_trylock$1 == 0))
        GC_lock();

    }

  while((_Bool)0);
  while(GC_fo_entries >= 1ul)
  {
    GC_enqueue_all_finalizers();
    do
      if(!(GC_need_to_lock == 0))
        pthread_mutex_unlock(&GC_allocate_ml);

    while((_Bool)0);
    GC_invoke_finalizers();
    do
      if(!(GC_need_to_lock == 0))
      {
        signed int return_value_pthread_mutex_trylock$2;
        return_value_pthread_mutex_trylock$2=pthread_mutex_trylock(&GC_allocate_ml);
        if(!(return_value_pthread_mutex_trylock$2 == 0))
          GC_lock();

      }

    while((_Bool)0);
  }
  do
    if(!(GC_need_to_lock == 0))
      pthread_mutex_unlock(&GC_allocate_ml);

  while((_Bool)0);
}

// GC_finalized_disclaim
// file fnlz_mlc.c line 29
signed int GC_finalized_disclaim(void *obj)
{
  unsigned long int fc_word = *((unsigned long int *)obj);
  if(!((1ul & fc_word) == 0ul))
  {
    struct GC_finalizer_closure *fc = (struct GC_finalizer_closure *)(void *)(fc_word & ~((unsigned long int)1));
    fc->proc((void *)((unsigned long int *)obj + (signed long int)1), fc->cd);
  }

  return 0;
}

// GC_finalized_malloc
// file fnlz_mlc.c line 130
extern void * GC_finalized_malloc(unsigned long int client_lb, struct GC_finalizer_closure *fclos)
{
  unsigned long int lb = client_lb + sizeof(unsigned long int) /*8ul*/ ;
  unsigned long int lg = lb + (unsigned long int)((16 - 1) + GC_all_interior_pointers) >> 4;
  struct thread_local_freelists *tsd;
  void *result;
  void **tiny_fl;
  void **my_fl;
  void *my_entry;
  void *next;
  void *return_value_GC_core_finalized_malloc$1;
  if(lg >= 25ul)
  {
    return_value_GC_core_finalized_malloc$1=GC_core_finalized_malloc(client_lb, fclos);
    return return_value_GC_core_finalized_malloc$1;
  }

  tsd = (struct thread_local_freelists *)GC_thread_key;
  tiny_fl = tsd->finalized_freelists;
  my_fl = tiny_fl + (signed long int)lg;
  my_entry = *my_fl;
  while(!((unsigned long int)my_entry >= 283ul))
    if(!((unsigned long int)my_entry + 18446744073709551615ul >= 256ul))
    {
      *my_fl = (void *)((char *)my_entry + (signed long int)lg + (signed long int)1);
      void *return_value_GC_core_finalized_malloc$2;
      return_value_GC_core_finalized_malloc$2=GC_core_finalized_malloc(client_lb, fclos);
      return return_value_GC_core_finalized_malloc$2;
    }

    else
    {
      GC_generic_malloc_many(lg * (unsigned long int)16, GC_finalized_kind, my_fl);
      my_entry = *my_fl;
      if(my_entry == NULL)
      {
        void * (*return_value_GC_get_oom_fn$3)(unsigned long int);
        return_value_GC_get_oom_fn$3=GC_get_oom_fn();
        void *return_value;
        return_value=return_value_GC_get_oom_fn$3(lb);
        return return_value;
      }

    }
  next = *((void **)my_entry);
  result = (void *)my_entry;
  *my_fl = next;
  *((void **)result) = NULL;
  *((unsigned long int *)result) = (unsigned long int)fclos | (unsigned long int)1;
  return (void *)((unsigned long int *)result + (signed long int)1);
}

// GC_find_header
// file ./include/private/gc_priv.h line 1895
struct hblkhdr * GC_find_header(char *h)
{
  struct hblkhdr *result;
  do
  {
    struct hblkhdr **_ha;
    do
    {
      struct bi *bi;
      do
      {
        unsigned long int hi = (unsigned long int)h >> (unsigned long int)10 + (unsigned long int)12;
        struct bi *_bi = GC_arrays._top_index[(signed long int)(hi & (unsigned long int)((1 << 11) - 1))];
        for( ; !(_bi->key == hi); _bi = _bi->hash_link)
          if(_bi == GC_arrays._all_nils)
            break;

        bi = _bi;
      }
      while((_Bool)0);
      _ha = &bi->index[(signed long int)((unsigned long int)h >> (unsigned long int)12 & (unsigned long int)((1 << 10) - 1))];
    }
    while((_Bool)0);
    result = *_ha;
  }
  while((_Bool)0);
  return result;
}

// GC_find_limit
// file os_dep.c line 998
char * GC_find_limit(char *p, signed int up)
{
  char *return_value_GC_find_limit_with_bound$1;
  return_value_GC_find_limit_with_bound$1=GC_find_limit_with_bound(p, up, up != 0 ? (char *)(unsigned long int)-1 : ((char *)NULL));
  return return_value_GC_find_limit_with_bound$1;
}

// GC_find_limit_with_bound
// file os_dep.c line 956
char * GC_find_limit_with_bound(char *p, signed int up, char *bound)
{
  GC_setup_temporary_fault_handler();
  signed int return_value___sigsetjmp$1;
  return_value___sigsetjmp$1=__sigsetjmp(GC_jmp_buf, 1);
  static char * volatile result;
  if(return_value___sigsetjmp$1 == 0)
  {
    result = (char *)((unsigned long int)p & (unsigned long int)~(256 - 1));
    while((_Bool)1)
    {
      if(!(up == 0))
      {
        result = result + (signed long int)256;
        if((unsigned long int)result >= (unsigned long int)bound)
        {
          result = bound;
          goto __CPROVER_DUMP_L5;
        }

      }

      else
      {
        result = result - (signed long int)256;
        if((unsigned long int)bound >= (unsigned long int)result)
        {
          result = bound - (signed long int)256;
          goto __CPROVER_DUMP_L5;
        }

      }
      GC_noop1((unsigned long int)*result);
    }
  }


__CPROVER_DUMP_L5:
  ;
  GC_reset_fault_handler();
  if(up == 0)
    result = result + (signed long int)256;

  return result;
}

// GC_finish_collection
// file alloc.c line 825
void GC_finish_collection(void)
{
  signed long int start_time = (signed long int)0;
  signed long int finalize_time = (signed long int)0;
  signed long int done_time;
  if(!(GC_print_stats == 0))
    start_time=clock();

  if(GC_bytes_found >= 1l)
    GC_reclaimed_bytes_before_gc = GC_reclaimed_bytes_before_gc + (unsigned long int)GC_bytes_found;

  GC_bytes_found = (signed long int)0;
  char *return_value_getenv$1;
  return_value_getenv$1=getenv("GC_PRINT_ADDRESS_MAP");
  if(!(return_value_getenv$1 == ((char *)NULL)))
    GC_print_address_map();

  if(!((signed long int)GC_dump_regularly == 0l))
    GC_dump();

  else

    __CPROVER_DUMP_L4:
      ;
  if(!(GC_find_leak == 0))
  {
    unsigned long int size;
    unsigned int kind;
    char *q;
    kind = (unsigned int)0;
    for( ; !(kind >= GC_n_kinds); kind = kind + 1u)
    {
      size = (unsigned long int)1;
      for( ; !(size >= 129ul); size = size + 1ul)
      {
        q = (char *)GC_obj_kinds[(signed long int)kind].ok_freelist[(signed long int)size];
        if(!(q == ((char *)NULL)))
          GC_set_fl_marks(q);

      }
    }
    GC_start_reclaim(1);
  }

  GC_finalize();
  if(!(GC_print_stats == 0))
    finalize_time=clock();

  if(!(GC_print_back_height == 0))
    GC_err_printf("Back height not available: Rebuild collector with -DMAKE_BACK_GRAPH\n");

  unsigned long int GC_finish_collection$$1$$5$$size;
  char *GC_finish_collection$$1$$5$$q;
  unsigned int GC_finish_collection$$1$$5$$kind = (unsigned int)0;
  for( ; !(GC_finish_collection$$1$$5$$kind >= GC_n_kinds); GC_finish_collection$$1$$5$$kind = GC_finish_collection$$1$$5$$kind + 1u)
  {
    GC_finish_collection$$1$$5$$size = (unsigned long int)1;
    for( ; !(GC_finish_collection$$1$$5$$size >= 129ul); GC_finish_collection$$1$$5$$size = GC_finish_collection$$1$$5$$size + 1ul)
    {
      GC_finish_collection$$1$$5$$q = (char *)GC_obj_kinds[(signed long int)GC_finish_collection$$1$$5$$kind].ok_freelist[(signed long int)GC_finish_collection$$1$$5$$size];
      if(!(GC_finish_collection$$1$$5$$q == ((char *)NULL)))
        GC_clear_fl_marks(GC_finish_collection$$1$$5$$q);

    }
  }
  if(GC_print_stats == 2)
    GC_log_printf("Bytes recovered before sweep - f.l. count = %ld\n", (signed long int)GC_bytes_found);

  GC_start_reclaim(0);
  signed int return_value_GC_compute_heap_usage_percent$2;
  if(!(GC_print_stats == 0))
  {
    return_value_GC_compute_heap_usage_percent$2=GC_compute_heap_usage_percent();
    GC_log_printf("In-use heap: %d%% (%lu KiB pointers + %lu KiB other)\n", return_value_GC_compute_heap_usage_percent$2, (unsigned long int)(GC_arrays._composite_in_use + (unsigned long int)((1 << 9) - 1) >> 10), (unsigned long int)(GC_arrays._atomic_in_use + (unsigned long int)((1 << 9) - 1) >> 10));
  }

  if(!(GC_is_full_gc == 0))
  {
    GC_used_heap_size_after_full = GC_arrays._heapsize - GC_arrays._large_free_bytes;
    GC_need_full_gc = 0;
  }

  else
  {
    unsigned long int return_value_min_bytes_allocd$3;
    return_value_min_bytes_allocd$3=min_bytes_allocd();
    GC_need_full_gc = (signed int)((GC_arrays._heapsize - GC_arrays._large_free_bytes) - GC_used_heap_size_after_full > return_value_min_bytes_allocd$3);
  }
  if(GC_print_stats == 2)
    GC_log_printf("Immediately reclaimed %ld bytes, heapsize: %lu bytes\n", (signed long int)GC_bytes_found, (unsigned long int)GC_arrays._heapsize);

  GC_n_attempts = 0;
  GC_is_full_gc = 0;
  GC_arrays._bytes_allocd_before_gc = GC_arrays._bytes_allocd_before_gc + GC_arrays._bytes_allocd;
  GC_non_gc_bytes_at_gc = GC_non_gc_bytes;
  GC_arrays._bytes_allocd = (unsigned long int)0;
  GC_arrays._bytes_dropped = (unsigned long int)0;
  GC_arrays._bytes_freed = (unsigned long int)0;
  GC_arrays._finalizer_bytes_freed = (unsigned long int)0;
  if(!(GC_print_stats == 0))
  {
    done_time=clock();
    GC_print_finalization_stats();
    GC_log_printf("Finalize plus initiate sweep took %lu + %lu msecs\n", (signed long int)1000000 % (signed long int)1000 == (signed long int)0 ? (unsigned long int)(finalize_time - start_time) / (unsigned long int)((signed long int)1000000 / (signed long int)1000) : ((unsigned long int)(finalize_time - start_time) * (unsigned long int)1000) / (unsigned long int)(signed long int)1000000, (signed long int)1000000 % (signed long int)1000 == (signed long int)0 ? (unsigned long int)(done_time - finalize_time) / (unsigned long int)((signed long int)1000000 / (signed long int)1000) : ((unsigned long int)(done_time - finalize_time) * (unsigned long int)1000) / (unsigned long int)(signed long int)1000000);
  }

}

// GC_free
// file ./include/private/../gc.h line 435
extern void GC_free(void *p)
{
  struct hblk *h;
  struct hblkhdr *hhdr;
  unsigned long int sz;
  unsigned long int ngranules;
  void **flh;
  signed int knd;
  struct obj_kind *ok;
  if(!(p == NULL))
  {
    h = (struct hblk *)((unsigned long int)p & ~((unsigned long int)(1 << 12) - (unsigned long int)1));
    hhdr=GC_find_header((char *)h);
    sz = hhdr->hb_sz;
    ngranules = sz >> 4;
    knd = (signed int)hhdr->hb_obj_kind;
    ok = &GC_obj_kinds[(signed long int)knd];
    if(!(ngranules >= 129ul))
    {
      do
        if(!(GC_need_to_lock == 0))
        {
          signed int return_value_pthread_mutex_trylock$1;
          return_value_pthread_mutex_trylock$1=pthread_mutex_trylock(&GC_allocate_ml);
          if(!(return_value_pthread_mutex_trylock$1 == 0))
            GC_lock();

        }

      while((_Bool)0);
      GC_arrays._bytes_freed = GC_arrays._bytes_freed + sz;
      if((-2 & knd) == 2)
        GC_non_gc_bytes = GC_non_gc_bytes - sz;

      if(!(ok->ok_init == 0))
        memset((void *)((unsigned long int *)p + (signed long int)1), 0, (unsigned long int)(sz - sizeof(unsigned long int) /*8ul*/ ));

      flh = &ok->ok_freelist[(signed long int)ngranules];
      *((void **)p) = *flh;
      *flh = (void *)(char *)p;
      do
        if(!(GC_need_to_lock == 0))
          pthread_mutex_unlock(&GC_allocate_ml);

      while((_Bool)0);
    }

    else
    {
      unsigned long int nblocks = (sz + (unsigned long int)(1 << 12)) - (unsigned long int)1 >> (unsigned long int)12;
      do
        if(!(GC_need_to_lock == 0))
        {
          signed int return_value_pthread_mutex_trylock$2;
          return_value_pthread_mutex_trylock$2=pthread_mutex_trylock(&GC_allocate_ml);
          if(!(return_value_pthread_mutex_trylock$2 == 0))
            GC_lock();

        }

      while((_Bool)0);
      GC_arrays._bytes_freed = GC_arrays._bytes_freed + sz;
      if((-2 & knd) == 2)
        GC_non_gc_bytes = GC_non_gc_bytes - sz;

      if(nblocks >= 2ul)
        GC_arrays._large_allocd_bytes = GC_arrays._large_allocd_bytes - nblocks * (unsigned long int)(1 << 12);

      GC_freehblk(h);
      do
        if(!(GC_need_to_lock == 0))
          pthread_mutex_unlock(&GC_allocate_ml);

      while((_Bool)0);
    }
  }

}

// GC_free_block_ending_at
// file allchblk.c line 323
struct hblk * GC_free_block_ending_at(struct hblk *h)
{
  struct hblk *p = h - (signed long int)1;
  struct hblkhdr *phdr;
  do
  {
    struct hblkhdr **_ha;
    do
    {
      struct bi *bi;
      do
      {
        unsigned long int hi = (unsigned long int)p >> (unsigned long int)10 + (unsigned long int)12;
        struct bi *_bi = GC_arrays._top_index[(signed long int)(hi & (unsigned long int)((1 << 11) - 1))];
        for( ; !(_bi->key == hi); _bi = _bi->hash_link)
          if(_bi == GC_arrays._all_nils)
            break;

        bi = _bi;
      }
      while((_Bool)0);
      _ha = &bi->index[(signed long int)((unsigned long int)p >> (unsigned long int)12 & (unsigned long int)((1 << 10) - 1))];
    }
    while((_Bool)0);
    phdr = *_ha;
  }
  while((_Bool)0);
  while(!(phdr == ((struct hblkhdr *)NULL)) && !((unsigned long int)phdr >= 4096ul))
  {
    p = (struct hblk *)p - (signed long int)(unsigned long int)phdr;
    phdr=GC_find_header((char *)p);
  }
  if(!(phdr == ((struct hblkhdr *)NULL)))
  {
    if(!((4 & (signed int)phdr->hb_flags) == 0))
      return p;

    return ((struct hblk *)NULL);
  }

  else
  {
    p=GC_prev_block(h - (signed long int)1);
    if(!(p == ((struct hblk *)NULL)))
    {
      phdr=GC_find_header((char *)p);
      if((4 & (signed int)phdr->hb_flags) == 0)
        goto __CPROVER_DUMP_L10;

      if(!((char *)p + (signed long int)phdr->hb_sz == (char *)h))
        goto __CPROVER_DUMP_L10;

      return p;
    }

    else
    {

    __CPROVER_DUMP_L10:
      ;
      return ((struct hblk *)NULL);
    }
  }
}

// GC_free_inner
// file malloc.c line 542
void GC_free_inner(void *p)
{
  struct hblk *h;
  struct hblkhdr *hhdr;
  unsigned long int sz;
  unsigned long int ngranules;
  void **flh;
  signed int knd;
  struct obj_kind *ok;
  h = (struct hblk *)((unsigned long int)p & ~((unsigned long int)(1 << 12) - (unsigned long int)1));
  hhdr=GC_find_header((char *)h);
  knd = (signed int)hhdr->hb_obj_kind;
  sz = hhdr->hb_sz;
  ngranules = sz >> 4;
  ok = &GC_obj_kinds[(signed long int)knd];
  if(!(ngranules >= 129ul))
  {
    GC_arrays._bytes_freed = GC_arrays._bytes_freed + sz;
    if((-2 & knd) == 2)
      GC_non_gc_bytes = GC_non_gc_bytes - sz;

    if(!(ok->ok_init == 0))
      memset((void *)((unsigned long int *)p + (signed long int)1), 0, (unsigned long int)(sz - sizeof(unsigned long int) /*8ul*/ ));

    flh = &ok->ok_freelist[(signed long int)ngranules];
    *((void **)p) = *flh;
    *flh = (void *)(char *)p;
  }

  else
  {
    unsigned long int nblocks = (sz + (unsigned long int)(1 << 12)) - (unsigned long int)1 >> (unsigned long int)12;
    GC_arrays._bytes_freed = GC_arrays._bytes_freed + sz;
    if((-2 & knd) == 2)
      GC_non_gc_bytes = GC_non_gc_bytes - sz;

    if(nblocks >= 2ul)
      GC_arrays._large_allocd_bytes = GC_arrays._large_allocd_bytes - nblocks * (unsigned long int)(1 << 12);

    GC_freehblk(h);
  }
}

// GC_freehblk
// file allchblk.c line 825
void GC_freehblk(struct hblk *hbp)
{
  struct hblk *next;
  struct hblk *prev;
  struct hblkhdr *hhdr;
  struct hblkhdr *prevhdr;
  struct hblkhdr *nexthdr;
  unsigned long int size;
  do
  {
    struct hblkhdr **_ha;
    do
    {
      struct bi *bi;
      do
      {
        unsigned long int GC_freehblk$$1$$1$$1$$1$$hi = (unsigned long int)hbp >> (unsigned long int)10 + (unsigned long int)12;
        struct bi *_bi = GC_arrays._top_index[(signed long int)(GC_freehblk$$1$$1$$1$$1$$hi & (unsigned long int)((1 << 11) - 1))];
        for( ; !(_bi->key == GC_freehblk$$1$$1$$1$$1$$hi); _bi = _bi->hash_link)
          if(_bi == GC_arrays._all_nils)
            break;

        bi = _bi;
      }
      while((_Bool)0);
      _ha = &bi->index[(signed long int)((unsigned long int)hbp >> (unsigned long int)12 & (unsigned long int)((1 << 10) - 1))];
    }
    while((_Bool)0);
    hhdr = *_ha;
  }
  while((_Bool)0);
  size = (unsigned long int)(1 << 12) * ((hhdr->hb_sz + (unsigned long int)(1 << 12)) - (unsigned long int)1 >> (unsigned long int)12);
  if(!((signed long int)size >= 1l))
  {
    GC_on_abort("Deallocating excessively large block.  Too large an allocation?");
    abort();
  }

  GC_remove_counts(hbp, size);
  hhdr->hb_sz = size;
  if(!((4 & (signed int)hhdr->hb_flags) == 0))
  {
    if(!(GC_print_stats == 0))
      GC_log_printf("Duplicate large block deallocation of %p", (void *)hbp);

    GC_on_abort("Duplicate large block deallocation");
    abort();
  }

  hhdr->hb_flags = hhdr->hb_flags | (unsigned char)4;
  next = (struct hblk *)((char *)hbp + (signed long int)size);
  do
  {
    struct hblkhdr **GC_freehblk$$1$$3$$_ha;
    do
    {
      struct bi *GC_freehblk$$1$$3$$1$$bi;
      do
      {
        unsigned long int hi = (unsigned long int)next >> (unsigned long int)10 + (unsigned long int)12;
        struct bi *GC_freehblk$$1$$3$$1$$1$$_bi = GC_arrays._top_index[(signed long int)(hi & (unsigned long int)((1 << 11) - 1))];
        for( ; !(GC_freehblk$$1$$3$$1$$1$$_bi->key == hi); GC_freehblk$$1$$3$$1$$1$$_bi = GC_freehblk$$1$$3$$1$$1$$_bi->hash_link)
          if(GC_freehblk$$1$$3$$1$$1$$_bi == GC_arrays._all_nils)
            break;

        GC_freehblk$$1$$3$$1$$bi = GC_freehblk$$1$$3$$1$$1$$_bi;
      }
      while((_Bool)0);
      GC_freehblk$$1$$3$$_ha = &GC_freehblk$$1$$3$$1$$bi->index[(signed long int)((unsigned long int)next >> (unsigned long int)12 & (unsigned long int)((1 << 10) - 1))];
    }
    while((_Bool)0);
    nexthdr = *GC_freehblk$$1$$3$$_ha;
  }
  while((_Bool)0);
  prev=GC_free_block_ending_at(hbp);
  if(!(nexthdr == ((struct hblkhdr *)NULL)))
  {
    if(!((4 & (signed int)nexthdr->hb_flags) == 0))
    {
      if((signed long int)hhdr->hb_sz + (signed long int)nexthdr->hb_sz >= 1l)
      {
        GC_remove_from_fl(nexthdr);
        hhdr->hb_sz = hhdr->hb_sz + nexthdr->hb_sz;
        GC_remove_header(next);
      }

    }

  }

  if(!(prev == ((struct hblk *)NULL)))
  {
    prevhdr=GC_find_header((char *)prev);
    if((signed long int)hhdr->hb_sz + (signed long int)prevhdr->hb_sz >= 1l)
    {
      GC_remove_from_fl(prevhdr);
      prevhdr->hb_sz = prevhdr->hb_sz + hhdr->hb_sz;
      GC_remove_header(hbp);
      hbp = prev;
      hhdr = prevhdr;
    }

  }

  GC_arrays._large_free_bytes = GC_arrays._large_free_bytes + size;
  GC_add_to_fl(hbp, hhdr);
}

// GC_gcj_fake_mark_proc
// file gcj_mlc.c line 59
struct GC_ms_entry * GC_gcj_fake_mark_proc(unsigned long int *addr, struct GC_ms_entry *mark_stack_ptr, struct GC_ms_entry *mark_stack_limit, unsigned long int env)
{
  if(!((signed long int)GC_current_warn_proc == -1l))
  {
    GC_on_abort("No client gcj mark proc is specified");
    abort();
  }

  return mark_stack_ptr;
}

// GC_gcj_malloc
// file thread_local_alloc.c line 240
extern void * GC_gcj_malloc(unsigned long int bytes, void *ptr_to_struct_containing_descr)
{
  if(!((signed long int)GC_incremental == 0l))
  {
    void *return_value_GC_core_gcj_malloc$1;
    return_value_GC_core_gcj_malloc$1=GC_core_gcj_malloc(bytes, ptr_to_struct_containing_descr);
    return return_value_GC_core_gcj_malloc$1;
  }

  else
  {
    unsigned long int granules = bytes + (unsigned long int)((16 - 1) + GC_all_interior_pointers) >> 4;
    void *result;
    void **tiny_fl = ((struct thread_local_freelists *)GC_thread_key)->gcj_freelists;
    do
    {
      if(granules >= 25ul)
        result=GC_core_gcj_malloc(bytes, ptr_to_struct_containing_descr);

      else
      {
        void **my_fl = tiny_fl + (signed long int)granules;
        void *my_entry = *my_fl;
        void *next;
        while(!((unsigned long int)my_entry >= 283ul))
          if(!((unsigned long int)my_entry + 18446744073709551615ul >= 256ul))
          {
            *my_fl = (void *)((char *)my_entry + (signed long int)granules + (signed long int)1);
            result=GC_core_gcj_malloc(bytes, ptr_to_struct_containing_descr);
            goto out;
          }

          else
          {
            GC_generic_malloc_many(granules == (unsigned long int)0 ? (unsigned long int)16 : granules * (unsigned long int)16, GC_gcj_kind, my_fl);
            my_entry = *my_fl;
            if(my_entry == NULL)
            {
              void * (*return_value_GC_get_oom_fn$2)(unsigned long int);
              return_value_GC_get_oom_fn$2=GC_get_oom_fn();
              result=return_value_GC_get_oom_fn$2(granules * (unsigned long int)16);
            }

          }
        next = *((void **)my_entry);
        result = (void *)my_entry;
        *my_fl = next;
        asm("" :  :  : "memory");
        *((void **)result) = ptr_to_struct_containing_descr;
      }

    out:
      ;
    }
    while((_Bool)0);
    return result;
  }
}

// GC_gcj_malloc_ignore_off_page
// file gcj_mlc.c line 237
extern void * GC_gcj_malloc_ignore_off_page(unsigned long int lb, void *ptr_to_struct_containing_descr)
{
  char *op;
  char **opp;
  unsigned long int lg;
  if(2048ul + -((unsigned long int)GC_all_interior_pointers) >= lb || !(lb >= 2048ul))
  {
    lg = GC_arrays._size_map[(signed long int)lb];
    opp = &GC_gcjobjfreelist[(signed long int)lg];
    do
      if(!(GC_need_to_lock == 0))
      {
        signed int return_value_pthread_mutex_trylock$1;
        return_value_pthread_mutex_trylock$1=pthread_mutex_trylock(&GC_allocate_ml);
        if(!(return_value_pthread_mutex_trylock$1 == 0))
          GC_lock();

      }

    while((_Bool)0);
    op = *opp;
    if(op == ((char *)NULL))
    {
      maybe_finalize();
      void *return_value_GC_generic_malloc_inner_ignore_off_page$2;
      return_value_GC_generic_malloc_inner_ignore_off_page$2=GC_generic_malloc_inner_ignore_off_page(lb, GC_gcj_kind);
      void *return_value_GC_clear_stack$3;
      return_value_GC_clear_stack$3=GC_clear_stack(return_value_GC_generic_malloc_inner_ignore_off_page$2);
      op = (char *)return_value_GC_clear_stack$3;
      if(op == ((char *)NULL))
      {
        void * (*oom_fn)(unsigned long int) = GC_oom_fn;
        do
          if(!(GC_need_to_lock == 0))
            pthread_mutex_unlock(&GC_allocate_ml);

        while((_Bool)0);
        void *return_value;
        return_value=oom_fn(lb);
        return return_value;
      }

    }

    else
    {
      *opp = (char *)*((void **)op);
      GC_arrays._bytes_allocd = GC_arrays._bytes_allocd + (lg << 4);
    }
  }

  else
  {
    do
      if(!(GC_need_to_lock == 0))
      {
        signed int return_value_pthread_mutex_trylock$4;
        return_value_pthread_mutex_trylock$4=pthread_mutex_trylock(&GC_allocate_ml);
        if(!(return_value_pthread_mutex_trylock$4 == 0))
          GC_lock();

      }

    while((_Bool)0);
    maybe_finalize();
    void *return_value_GC_generic_malloc_inner_ignore_off_page$5;
    return_value_GC_generic_malloc_inner_ignore_off_page$5=GC_generic_malloc_inner_ignore_off_page(lb, GC_gcj_kind);
    void *return_value_GC_clear_stack$6;
    return_value_GC_clear_stack$6=GC_clear_stack(return_value_GC_generic_malloc_inner_ignore_off_page$5);
    op = (char *)return_value_GC_clear_stack$6;
    if(op == ((char *)NULL))
    {
      void * (*GC_gcj_malloc_ignore_off_page$$1$$2$$2$$oom_fn)(unsigned long int) = GC_oom_fn;
      do
        if(!(GC_need_to_lock == 0))
          pthread_mutex_unlock(&GC_allocate_ml);

      while((_Bool)0);
      void *return_value_1;
      return_value_1=GC_gcj_malloc_ignore_off_page$$1$$2$$2$$oom_fn(lb);
      return return_value_1;
    }

  }
  *((void **)op) = ptr_to_struct_containing_descr;
  do
    if(!(GC_need_to_lock == 0))
      pthread_mutex_unlock(&GC_allocate_ml);

  while((_Bool)0);
  return (void *)op;
}

// GC_gcollect
// file ./include/gc.h line 542
extern void GC_gcollect(void)
{
  GC_try_to_collect_general(((signed int (*)(void))NULL), 0);
  if(!(GC_have_errors == 0))
    GC_print_all_errors();

}

// GC_gcollect_and_unmap
// file alloc.c line 1014
extern void GC_gcollect_and_unmap(void)
{
  GC_try_to_collect_general(GC_never_stop_func, 1);
}

// GC_general_register_disappearing_link
// file finalize.c line 211
extern signed int GC_general_register_disappearing_link(void **link, const void *obj)
{
  if(link == ((void **)NULL) || !((7ul & (unsigned long int)link) == 0ul))
  {
    GC_on_abort("Bad arg to GC_general_register_disappearing_link");
    abort();
  }

  signed int return_value_GC_register_disappearing_link_inner$1;
  return_value_GC_register_disappearing_link_inner$1=GC_register_disappearing_link_inner(&GC_dl_hashtbl, link, obj);
  return return_value_GC_register_disappearing_link_inner$1;
}

// GC_generic_lock
// file pthread_support.c line 1826
void GC_generic_lock(union anonymous$7 *lock)
{
  unsigned int pause_length = (unsigned int)1;
  unsigned int i;
  signed int return_value_pthread_mutex_trylock$1;
  return_value_pthread_mutex_trylock$1=pthread_mutex_trylock(lock);
  if(!(return_value_pthread_mutex_trylock$1 == 0))
  {
    for( ; !(pause_length >= 129u); pause_length = pause_length << 1)
    {
      i = (unsigned int)0;
      for( ; !(i >= pause_length); i = i + 1u)
        GC_pause();
      signed int return_value_pthread_mutex_trylock$2;
      return_value_pthread_mutex_trylock$2=pthread_mutex_trylock(lock);
      switch(return_value_pthread_mutex_trylock$2)
      {
        case 0:
          goto __CPROVER_DUMP_L10;
        case 16:
          break;
        default:
          GC_on_abort("Unexpected error from pthread_mutex_trylock");
      }
      abort();
    }
    pthread_mutex_lock(lock);
  }


__CPROVER_DUMP_L10:
  ;
}

// GC_generic_malloc
// file malloc.c line 171
extern void * GC_generic_malloc(unsigned long int lb, signed int k)
{
  void *result;
  if(!((signed long int)GC_have_errors == 0l))
    GC_print_all_errors();

  GC_notify_or_invoke_finalizers();
  void * (*return_value_GC_get_oom_fn$2)(unsigned long int);
  void *return_value;
  if(2048ul + -((unsigned long int)GC_all_interior_pointers) >= lb || !(lb >= 2048ul))
  {
    do
      if(!(GC_need_to_lock == 0))
      {
        signed int return_value_pthread_mutex_trylock$1;
        return_value_pthread_mutex_trylock$1=pthread_mutex_trylock(&GC_allocate_ml);
        if(!(return_value_pthread_mutex_trylock$1 == 0))
          GC_lock();

      }

    while((_Bool)0);
    result=GC_generic_malloc_inner((unsigned long int)lb, k);
    do
      if(!(GC_need_to_lock == 0))
        pthread_mutex_unlock(&GC_allocate_ml);

    while((_Bool)0);
  }

  else
  {
    unsigned long int lg;
    unsigned long int lb_rounded;
    unsigned long int n_blocks;
    signed int init;
    lg = lb + (unsigned long int)((16 - 1) + GC_all_interior_pointers) >> 4;
    lb_rounded = lg << 4;
    if(!(lb_rounded >= lb))
    {
      return_value_GC_get_oom_fn$2=GC_get_oom_fn();
      return_value=return_value_GC_get_oom_fn$2(lb);
      return return_value;
    }

    n_blocks = (lb_rounded + (unsigned long int)(1 << 12)) - (unsigned long int)1 >> (unsigned long int)12;
    init = GC_obj_kinds[(signed long int)k].ok_init;
    do
      if(!(GC_need_to_lock == 0))
      {
        signed int return_value_pthread_mutex_trylock$3;
        return_value_pthread_mutex_trylock$3=pthread_mutex_trylock(&GC_allocate_ml);
        if(!(return_value_pthread_mutex_trylock$3 == 0))
          GC_lock();

      }

    while((_Bool)0);
    char *return_value_GC_alloc_large$4;
    return_value_GC_alloc_large$4=GC_alloc_large(lb_rounded, k, (unsigned int)0);
    result = (void *)(char *)return_value_GC_alloc_large$4;
    if(!(result == NULL))
    {
      if(!(GC_debugging_started == 0))
        memset(result, 0, (unsigned long int)(n_blocks * (unsigned long int)(1 << 12)));

      else
      {
        ((unsigned long int *)result)[(signed long int)0] = (unsigned long int)0;
        ((unsigned long int *)result)[(signed long int)1] = (unsigned long int)0;
        ((unsigned long int *)result)[(signed long int)((lg << 1) - (unsigned long int)1)] = (unsigned long int)0;
        ((unsigned long int *)result)[(signed long int)((lg << 1) - (unsigned long int)2)] = (unsigned long int)0;
      }
    }

    GC_arrays._bytes_allocd = GC_arrays._bytes_allocd + lb_rounded;
    do
      if(!(GC_need_to_lock == 0))
        pthread_mutex_unlock(&GC_allocate_ml);

    while((_Bool)0);
    if(GC_debugging_started == 0 && !(result == NULL) && !(init == 0))
      memset(result, 0, (unsigned long int)(n_blocks * (unsigned long int)(1 << 12)));

  }
  if(result == NULL)
  {
    void * (*return_value_GC_get_oom_fn$5)(unsigned long int);
    return_value_GC_get_oom_fn$5=GC_get_oom_fn();
    void *return_value_1;
    return_value_1=return_value_GC_get_oom_fn$5(lb);
    return return_value_1;
  }

  else
    return result;
}

// GC_generic_malloc_ignore_off_page
// file mallocx.c line 170
extern void * GC_generic_malloc_ignore_off_page(unsigned long int lb, signed int k)
{
  void *result;
  unsigned long int lg;
  unsigned long int lb_rounded;
  unsigned long int n_blocks;
  signed int init;
  void *return_value_GC_generic_malloc$1;
  if(2048ul + -((unsigned long int)GC_all_interior_pointers) >= lb || !(lb >= 2048ul))
  {
    return_value_GC_generic_malloc$1=GC_generic_malloc((unsigned long int)lb, k);
    return return_value_GC_generic_malloc$1;
  }

  lg = lb + (unsigned long int)((16 - 1) + GC_all_interior_pointers) >> 4;
  lb_rounded = lg << 4;
  void * (*return_value_GC_get_oom_fn$2)(unsigned long int);
  void *return_value;
  if(!(lb_rounded >= lb))
  {
    return_value_GC_get_oom_fn$2=GC_get_oom_fn();
    return_value=return_value_GC_get_oom_fn$2(lb);
    return return_value;
  }

  n_blocks = (lb_rounded + (unsigned long int)(1 << 12)) - (unsigned long int)1 >> (unsigned long int)12;
  init = GC_obj_kinds[(signed long int)k].ok_init;
  if(!((signed long int)GC_have_errors == 0l))
    GC_print_all_errors();

  GC_notify_or_invoke_finalizers();
  do
    if(!(GC_need_to_lock == 0))
    {
      signed int return_value_pthread_mutex_trylock$3;
      return_value_pthread_mutex_trylock$3=pthread_mutex_trylock(&GC_allocate_ml);
      if(!(return_value_pthread_mutex_trylock$3 == 0))
        GC_lock();

    }

  while((_Bool)0);
  char *return_value_GC_alloc_large$4;
  return_value_GC_alloc_large$4=GC_alloc_large(lb + (unsigned long int)GC_all_interior_pointers, k, (unsigned int)1);
  result = (void *)(char *)return_value_GC_alloc_large$4;
  if(!(result == NULL))
  {
    if(!(GC_debugging_started == 0))
      memset(result, 0, (unsigned long int)(n_blocks * (unsigned long int)(1 << 12)));

    else
    {
      ((unsigned long int *)result)[(signed long int)0] = (unsigned long int)0;
      ((unsigned long int *)result)[(signed long int)1] = (unsigned long int)0;
      ((unsigned long int *)result)[(signed long int)((lg << 1) - (unsigned long int)1)] = (unsigned long int)0;
      ((unsigned long int *)result)[(signed long int)((lg << 1) - (unsigned long int)2)] = (unsigned long int)0;
    }
  }

  GC_arrays._bytes_allocd = GC_arrays._bytes_allocd + lb_rounded;
  if(result == NULL)
  {
    void * (*oom_fn)(unsigned long int) = GC_oom_fn;
    do
      if(!(GC_need_to_lock == 0))
        pthread_mutex_unlock(&GC_allocate_ml);

    while((_Bool)0);
    void *return_value_1;
    return_value_1=oom_fn(lb);
    return return_value_1;
  }

  else
  {
    do
      if(!(GC_need_to_lock == 0))
        pthread_mutex_unlock(&GC_allocate_ml);

    while((_Bool)0);
    if(GC_debugging_started == 0 && !(init == 0))
      memset(result, 0, (unsigned long int)(n_blocks * (unsigned long int)(1 << 12)));

    return result;
  }
}

// GC_generic_malloc_inner
// file ./include/private/gc_priv.h line 1828
void * GC_generic_malloc_inner(unsigned long int lb, signed int k)
{
  void *op;
  signed int return_value_GC_alloc_reclaim_list$1;
  if(2048ul + -((unsigned long int)GC_all_interior_pointers) >= lb || !(lb >= 2048ul))
  {
    struct obj_kind *kind = GC_obj_kinds + (signed long int)k;
    unsigned long int lg = GC_arrays._size_map[(signed long int)lb];
    void **opp = &kind->ok_freelist[(signed long int)lg];
    op = *opp;
    if(op == NULL)
    {
      if(lg == 0ul)
      {
        if((signed long int)GC_is_initialized == 0l)
        {
          GC_init();
          lg = GC_arrays._size_map[(signed long int)lb];
        }

        if(lg == 0ul)
        {
          GC_extend_size_map(lb);
          lg = GC_arrays._size_map[(signed long int)lb];
        }

        opp = &kind->ok_freelist[(signed long int)lg];
        op = *opp;
      }

      if(op == NULL)
      {
        if(kind->ok_reclaim_list == ((struct hblk **)NULL))
        {
          return_value_GC_alloc_reclaim_list$1=GC_alloc_reclaim_list(kind);
          if(return_value_GC_alloc_reclaim_list$1 == 0)
            return (void *)0;

        }

        char *return_value_GC_allocobj$2;
        return_value_GC_allocobj$2=GC_allocobj(lg, k);
        op = (void *)return_value_GC_allocobj$2;
        if(op == NULL)
          return (void *)0;

      }

    }

    *opp = *((void **)op);
    *((void **)op) = NULL;
    GC_arrays._bytes_allocd = GC_arrays._bytes_allocd + (lg << 4);
  }

  else
  {
    char *return_value_GC_alloc_large_and_clear$3;
    return_value_GC_alloc_large_and_clear$3=GC_alloc_large_and_clear(lb + (unsigned long int)GC_all_interior_pointers, k, (unsigned int)0);
    op = (void *)(char *)return_value_GC_alloc_large_and_clear$3;
    GC_arrays._bytes_allocd = GC_arrays._bytes_allocd + lb;
  }
  return op;
}

// GC_generic_malloc_inner_ignore_off_page
// file ./include/private/gc_priv.h line 1831
void * GC_generic_malloc_inner_ignore_off_page(unsigned long int lb, signed int k)
{
  unsigned long int lb_adjusted;
  void *op;
  void *return_value_GC_generic_malloc_inner$1;
  if(!(lb >= 4097ul))
  {
    return_value_GC_generic_malloc_inner$1=GC_generic_malloc_inner(lb, k);
    return return_value_GC_generic_malloc_inner$1;
  }

  lb_adjusted = lb + (unsigned long int)GC_all_interior_pointers;
  char *return_value_GC_alloc_large_and_clear$2;
  return_value_GC_alloc_large_and_clear$2=GC_alloc_large_and_clear(lb_adjusted, k, (unsigned int)1);
  op = (void *)return_value_GC_alloc_large_and_clear$2;
  GC_arrays._bytes_allocd = GC_arrays._bytes_allocd + lb_adjusted;
  return op;
}

// GC_generic_malloc_many
// file mallocx.c line 272
extern void GC_generic_malloc_many(unsigned long int lb, signed int k, void **result)
{
  void *op;
  void *p;
  void **opp;
  unsigned long int lw;
  unsigned long int lg;
  signed long int my_bytes_allocd = (signed long int)0;
  struct obj_kind *ok = &GC_obj_kinds[(signed long int)k];
  struct hblk **rlh;
  struct hblkhdr *return_value_GC_find_header$5;
  if(!(2048ul + -((unsigned long int)GC_all_interior_pointers) >= lb) && lb >= 2048ul)
  {
    op=GC_generic_malloc(lb, k);
    if(!(op == NULL))
      *((void **)op) = NULL;

    *result = op;
  }

  else
  {
    lw = lb >> 3;
    lg = lb >> 4;
    if(!((signed long int)GC_have_errors == 0l))
      GC_print_all_errors();

    GC_notify_or_invoke_finalizers();
    do
      if(!(GC_need_to_lock == 0))
      {
        signed int return_value_pthread_mutex_trylock$1;
        return_value_pthread_mutex_trylock$1=pthread_mutex_trylock(&GC_allocate_ml);
        if(!(return_value_pthread_mutex_trylock$1 == 0))
          GC_lock();

      }

    while((_Bool)0);
    if((signed long int)GC_is_initialized == 0l)
      GC_init();

    if(GC_dont_gc == 0 && !(GC_incremental == 0))
    {
      GC_collecting = 1;
      GC_collect_a_little_inner(1);
      GC_collecting = 0;
    }

    rlh = ok->ok_reclaim_list;
    if(!(rlh == ((struct hblk **)NULL)))
    {
      struct hblk *hbp;
      struct hblkhdr *hhdr;
      rlh = rlh + (signed long int)lg;
      do
      {
        hbp = *rlh;
        if(hbp == ((struct hblk *)NULL))
          break;

        hhdr=GC_find_header((char *)hbp);
        *rlh = hhdr->hb_next;
        hhdr->hb_last_reclaimed = (unsigned short int)GC_gc_no;
        if(!(GC_parallel == 0))
        {
          signed long int my_bytes_allocd_tmp;
          unsigned long int return_value_AO_load$2;
          return_value_AO_load$2=AO_load(&GC_bytes_allocd_tmp);
          my_bytes_allocd_tmp = (signed long int)return_value_AO_load$2;
          if(!(my_bytes_allocd_tmp == 0l))
          {
            AO_fetch_and_add(&GC_bytes_allocd_tmp, (unsigned long int)-my_bytes_allocd_tmp);
            GC_arrays._bytes_allocd = GC_arrays._bytes_allocd + (unsigned long int)my_bytes_allocd_tmp;
          }

          GC_acquire_mark_lock();
          GC_fl_builder_count = GC_fl_builder_count + 1ul;
          do
            if(!(GC_need_to_lock == 0))
              pthread_mutex_unlock(&GC_allocate_ml);

          while((_Bool)0);
          GC_release_mark_lock();
        }

        char *return_value_GC_reclaim_generic$3;
        return_value_GC_reclaim_generic$3=GC_reclaim_generic(hbp, hhdr, lb, ok->ok_init, ((char *)NULL), &my_bytes_allocd);
        op = (void *)return_value_GC_reclaim_generic$3;
        if(!(op == NULL))
        {
          GC_bytes_found = GC_bytes_found + my_bytes_allocd;
          if(!(GC_parallel == 0))
          {
            *result = op;
            AO_fetch_and_add(&GC_bytes_allocd_tmp, (unsigned long int)my_bytes_allocd);
            GC_acquire_mark_lock();
            GC_fl_builder_count = GC_fl_builder_count - 1ul;
            if(GC_fl_builder_count == 0ul)
              GC_notify_all_builder();

            GC_release_mark_lock();
            GC_clear_stack(NULL);
            goto __CPROVER_DUMP_L37;
          }

          GC_arrays._bytes_allocd = GC_arrays._bytes_allocd + (unsigned long int)my_bytes_allocd;
          goto out;
        }

        if(!(GC_parallel == 0))
        {
          GC_acquire_mark_lock();
          GC_fl_builder_count = GC_fl_builder_count - 1ul;
          if(GC_fl_builder_count == 0ul)
            GC_notify_all_builder();

          GC_release_mark_lock();
          do
            if(!(GC_need_to_lock == 0))
            {
              signed int return_value_pthread_mutex_trylock$4;
              return_value_pthread_mutex_trylock$4=pthread_mutex_trylock(&GC_allocate_ml);
              if(!(return_value_pthread_mutex_trylock$4 == 0))
                GC_lock();

            }

          while((_Bool)0);
        }

      }
      while((_Bool)1);
    }

    opp = &GC_obj_kinds[(signed long int)k].ok_freelist[(signed long int)lg];
    op = *opp;
    if(!(op == NULL))
    {
      *opp = NULL;
      my_bytes_allocd = (signed long int)0;
      p = op;
      for( ; !(p == NULL); p = *((void **)p))
      {
        my_bytes_allocd = my_bytes_allocd + (signed long int)lb;
        if((unsigned long int)my_bytes_allocd >= 4096ul)
        {
          *opp = *((void **)p);
          *((void **)p) = NULL;
          break;
        }

      }
      GC_arrays._bytes_allocd = GC_arrays._bytes_allocd + (unsigned long int)my_bytes_allocd;
    }

    else
    {
      struct hblk *h;
      h=GC_allochblk(lb, k, (unsigned int)0);
      if(!(h == ((struct hblk *)NULL)))
      {
        if((-2 & k) == 2)
        {
          return_value_GC_find_header$5=GC_find_header((char *)h);
          GC_set_hdr_marks(return_value_GC_find_header$5);
        }

        GC_arrays._bytes_allocd = GC_arrays._bytes_allocd + ((unsigned long int)(1 << 12) - (unsigned long int)(1 << 12) % lb);
        if(!(GC_parallel == 0))
        {
          GC_acquire_mark_lock();
          GC_fl_builder_count = GC_fl_builder_count + 1ul;
          do
            if(!(GC_need_to_lock == 0))
              pthread_mutex_unlock(&GC_allocate_ml);

          while((_Bool)0);
          GC_release_mark_lock();
          char *return_value_GC_build_fl$6;
          return_value_GC_build_fl$6=GC_build_fl(h, lw, (signed int)(ok->ok_init != 0 ? (_Bool)1 : (GC_debugging_started != 0 ? (_Bool)1 : (_Bool)0)), ((char *)NULL));
          op = (void *)return_value_GC_build_fl$6;
          *result = op;
          GC_acquire_mark_lock();
          GC_fl_builder_count = GC_fl_builder_count - 1ul;
          if(GC_fl_builder_count == 0ul)
            GC_notify_all_builder();

          GC_release_mark_lock();
          GC_clear_stack(NULL);
          goto __CPROVER_DUMP_L37;
        }

        char *return_value_GC_build_fl$7;
        return_value_GC_build_fl$7=GC_build_fl(h, lw, (signed int)(ok->ok_init != 0 ? (_Bool)1 : (GC_debugging_started != 0 ? (_Bool)1 : (_Bool)0)), ((char *)NULL));
        op = (void *)return_value_GC_build_fl$7;
        goto out;
      }

      op=GC_generic_malloc_inner(lb, k);
      if(!(op == NULL))
        *((void **)op) = NULL;

    }

  out:
    ;
    *result = op;
    do
      if(!(GC_need_to_lock == 0))
        pthread_mutex_unlock(&GC_allocate_ml);

    while((_Bool)0);
    GC_clear_stack(NULL);
  }

__CPROVER_DUMP_L37:
  ;
}

// GC_generic_or_special_malloc
// file mallocx.c line 50
void * GC_generic_or_special_malloc(unsigned long int lb, signed int knd)
{
  void *return_value_GC_malloc_atomic$1;
  void *return_value_GC_malloc$2;
  void *return_value_GC_malloc_uncollectable$3;
  void *return_value_GC_malloc_atomic_uncollectable$4;
  void *return_value_GC_generic_malloc$5;
  switch(knd)
  {
    case 0:
    {
      return_value_GC_malloc_atomic$1=GC_malloc_atomic((unsigned long int)lb);
      return return_value_GC_malloc_atomic$1;
    }
    case 1:
    {
      return_value_GC_malloc$2=GC_malloc((unsigned long int)lb);
      return return_value_GC_malloc$2;
    }
    case 2:
    {
      return_value_GC_malloc_uncollectable$3=GC_malloc_uncollectable((unsigned long int)lb);
      return return_value_GC_malloc_uncollectable$3;
    }
    case 3:
    {
      return_value_GC_malloc_atomic_uncollectable$4=GC_malloc_atomic_uncollectable((unsigned long int)lb);
      return return_value_GC_malloc_atomic_uncollectable$4;
    }
    default:
    {
      return_value_GC_generic_malloc$5=GC_generic_malloc(lb, knd);
      return return_value_GC_generic_malloc$5;
    }
  }
}

// GC_get_abort_func
// file misc.c line 1704
extern void (*GC_get_abort_func(void))(const char *)
{
  void (*fn)(const char *);
  do
    if(!(GC_need_to_lock == 0))
    {
      signed int return_value_pthread_mutex_trylock$1;
      return_value_pthread_mutex_trylock$1=pthread_mutex_trylock(&GC_allocate_ml);
      if(!(return_value_pthread_mutex_trylock$1 == 0))
        GC_lock();

    }

  while((_Bool)0);
  fn = GC_on_abort;
  do
    if(!(GC_need_to_lock == 0))
      pthread_mutex_unlock(&GC_allocate_ml);

  while((_Bool)0);
  return fn;
}

// GC_get_all_interior_pointers
// file misc.c line 2078
extern signed int GC_get_all_interior_pointers(void)
{
  return GC_all_interior_pointers;
}

// GC_get_bytes_since_gc
// file misc.c line 503
extern unsigned long int GC_get_bytes_since_gc(void)
{
  return (unsigned long int)GC_arrays._bytes_allocd;
}

// GC_get_dont_expand
// file misc.c line 2114
extern signed int GC_get_dont_expand(void)
{
  return GC_dont_expand;
}

// GC_get_dont_precollect
// file misc.c line 2170
extern signed int GC_get_dont_precollect(void)
{
  return GC_dont_precollect;
}

// GC_get_file_len
// file os_dep.c line 164
unsigned long int GC_get_file_len(signed int f)
{
  unsigned long int total = (unsigned long int)0;
  signed long int result;
  char buf[500l];
  do
  {
    result=read(f, (void *)buf, (unsigned long int)500);
    if(result == -1l)
      return (unsigned long int)0;

    total = total + (unsigned long int)result;
  }
  while(result >= 1l);
  return total;
}

// GC_get_finalize_on_demand
// file misc.c line 2090
extern signed int GC_get_finalize_on_demand(void)
{
  return GC_finalize_on_demand;
}

// GC_get_finalizer_notifier
// file misc.c line 2033
extern void (*GC_get_finalizer_notifier(void))(void)
{
  void (*fn)(void);
  do
    if(!(GC_need_to_lock == 0))
    {
      signed int return_value_pthread_mutex_trylock$1;
      return_value_pthread_mutex_trylock$1=pthread_mutex_trylock(&GC_allocate_ml);
      if(!(return_value_pthread_mutex_trylock$1 == 0))
        GC_lock();

    }

  while((_Bool)0);
  fn = GC_finalizer_notifier;
  do
    if(!(GC_need_to_lock == 0))
      pthread_mutex_unlock(&GC_allocate_ml);

  while((_Bool)0);
  return fn;
}

// GC_get_find_leak
// file misc.c line 2056
extern signed int GC_get_find_leak(void)
{
  return GC_find_leak;
}

// GC_get_first_part
// file allchblk.c line 489
struct hblk * GC_get_first_part(struct hblk *h, struct hblkhdr *hhdr, unsigned long int bytes, signed int index)
{
  unsigned long int total_size = hhdr->hb_sz;
  struct hblk *rest;
  struct hblkhdr *rest_hdr;
  GC_remove_from_fl_at(hhdr, index);
  if(total_size == bytes)
    return h;

  else
  {
    rest = (struct hblk *)((unsigned long int)h + bytes);
    rest_hdr=GC_install_header(rest);
    if(rest_hdr == ((struct hblkhdr *)NULL))
    {
      GC_current_warn_proc("GC Warning: Header allocation failed: Dropping block.\n", (unsigned long int)0);
      return ((struct hblk *)NULL);
    }

    else
    {
      rest_hdr->hb_sz = total_size - bytes;
      rest_hdr->hb_flags = (unsigned char)0;
      GC_add_to_fl(rest, rest_hdr);
      return h;
    }
  }
}

// GC_get_force_unmap_on_gcollect
// file misc.c line 2202
extern signed int GC_get_force_unmap_on_gcollect(void)
{
  return (signed int)GC_force_unmap_on_gcollect;
}

// GC_get_free_bytes
// file misc.c line 492
extern unsigned long int GC_get_free_bytes(void)
{
  return (unsigned long int)(GC_arrays._large_free_bytes - (unsigned long int)0);
}

// GC_get_free_space_divisor
// file misc.c line 2147
extern unsigned long int GC_get_free_space_divisor(void)
{
  return GC_free_space_divisor;
}

// GC_get_full_freq
// file misc.c line 2181
extern signed int GC_get_full_freq(void)
{
  return GC_full_freq;
}

// GC_get_gc_no
// file misc.c line 1969
extern unsigned long int GC_get_gc_no(void)
{
  return GC_gc_no;
}

// GC_get_heap_size
// file misc.c line 485
extern unsigned long int GC_get_heap_size(void)
{
  return (unsigned long int)(GC_arrays._heapsize - (unsigned long int)0);
}

// GC_get_heap_usage_safe
// file misc.c line 518
extern void GC_get_heap_usage_safe(unsigned long int *pheap_size, unsigned long int *pfree_bytes, unsigned long int *punmapped_bytes, unsigned long int *pbytes_since_gc, unsigned long int *ptotal_bytes)
{
  do
    if(!(GC_need_to_lock == 0))
    {
      signed int return_value_pthread_mutex_trylock$1;
      return_value_pthread_mutex_trylock$1=pthread_mutex_trylock(&GC_allocate_ml);
      if(!(return_value_pthread_mutex_trylock$1 == 0))
        GC_lock();

    }

  while((_Bool)0);
  if(!(pheap_size == ((unsigned long int *)NULL)))
    *pheap_size = GC_arrays._heapsize - (unsigned long int)0;

  if(!(pfree_bytes == ((unsigned long int *)NULL)))
    *pfree_bytes = GC_arrays._large_free_bytes - (unsigned long int)0;

  if(!(punmapped_bytes == ((unsigned long int *)NULL)))
    *punmapped_bytes = (unsigned long int)0;

  if(!(pbytes_since_gc == ((unsigned long int *)NULL)))
    *pbytes_since_gc = GC_arrays._bytes_allocd;

  if(!(ptotal_bytes == ((unsigned long int *)NULL)))
    *ptotal_bytes = GC_arrays._bytes_allocd + GC_arrays._bytes_allocd_before_gc;

  do
    if(!(GC_need_to_lock == 0))
      pthread_mutex_unlock(&GC_allocate_ml);

  while((_Bool)0);
}

// GC_get_java_finalization
// file misc.c line 2102
extern signed int GC_get_java_finalization(void)
{
  return GC_java_finalization;
}

// GC_get_main_stack_base
// file ./include/private/gc_priv.h line 1672
char * GC_get_main_stack_base(void)
{
  char *result;
  union pthread_attr_t attr;
  void *stackaddr;
  unsigned long int size;
  unsigned long int return_value_pthread_self$2;
  return_value_pthread_self$2=pthread_self();
  signed int return_value_pthread_getattr_np$3;
  return_value_pthread_getattr_np$3=pthread_getattr_np(return_value_pthread_self$2, &attr);
  if(return_value_pthread_getattr_np$3 == 0)
  {
    signed int return_value_pthread_attr_getstack$1;
    return_value_pthread_attr_getstack$1=pthread_attr_getstack(&attr, &stackaddr, &size);
    if(return_value_pthread_attr_getstack$1 == 0)
    {
      if(!(stackaddr == NULL))
      {
        pthread_attr_destroy(&attr);
        stackaddr = (void *)((char *)stackaddr + (signed long int)size);
        return (char *)stackaddr;
      }

    }

    pthread_attr_destroy(&attr);
  }

  GC_current_warn_proc("GC Warning: pthread_getattr_np or pthread_attr_getstack failed for main thread\n", (unsigned long int)0);
  result=GC_linux_main_stack_base();
  if(result == ((char *)NULL))
    result = (char *)(signed long int)-sizeof(char *) /*8ul*/ ;

  return result;
}

// GC_get_maps
// file os_dep.c line 194
char * GC_get_maps(void)
{
  signed int f;
  signed long int result;
  unsigned long int maps_size;
  unsigned long int old_maps_size = (unsigned long int)0;
  maps_size=GC_get_maps_len();
  if(maps_size == 0ul)
    return ((char *)NULL);

  else
  {

  __CPROVER_DUMP_L1:
    ;
    static char *maps_buf = (char *)(void *)0;
    while((_Bool)1)
    {
      static unsigned long int maps_buf_sz = (unsigned long int)1;
      if(maps_size >= maps_buf_sz)
      {
        for( ; maps_size >= maps_buf_sz; maps_buf_sz = maps_buf_sz * (unsigned long int)2)
          ;
        maps_buf=GC_scratch_alloc(maps_buf_sz);
        maps_size=GC_get_maps_len();
        if(maps_size == 0ul)
          return ((char *)NULL);

        if(maps_buf == ((char *)NULL))
          return ((char *)NULL);

        goto __CPROVER_DUMP_L1;
      }

      f=open("/proc/self/maps", 00);
      if(f == -1)
        return ((char *)NULL);

      old_maps_size = maps_size;
      maps_size = (unsigned long int)0;
      do
      {
        result=GC_repeat_read(f, maps_buf, maps_buf_sz - (unsigned long int)1);
        if(!(result >= 1l))
          break;

        maps_size = maps_size + (unsigned long int)result;
      }
      while((unsigned long int)result == maps_buf_sz + 18446744073709551615ul);
      close(f);
      if(!(result >= 1l))
        return ((char *)NULL);

      if(!(old_maps_size >= maps_size))
      {
        if(!(GC_print_stats == 0))
          GC_log_printf("Unexpected asynchronous /proc/self/maps growth (unregistered thread?) from %lu to %lu", (unsigned long int)old_maps_size, (unsigned long int)maps_size);

        GC_on_abort("Unexpected asynchronous /proc/self/maps growth (unregistered thread?)");
        abort();
      }

      if(!(maps_size >= maps_buf_sz) && maps_size >= old_maps_size)
        break;

    }
    maps_buf[(signed long int)maps_size] = (char)0;
    return maps_buf;
  }
}

// GC_get_maps_len
// file os_dep.c line 179
unsigned long int GC_get_maps_len(void)
{
  signed int f;
  f=open("/proc/self/maps", 00);
  unsigned long int result;
  if(!(f >= 0))
    return (unsigned long int)0;

  else
  {
    result=GC_get_file_len(f);
    close(f);
    return result;
  }
}

// GC_get_max_retries
// file misc.c line 2158
extern unsigned long int GC_get_max_retries(void)
{
  return GC_max_retries;
}

// GC_get_no_dls
// file misc.c line 2126
extern signed int GC_get_no_dls(void)
{
  return GC_no_dls;
}

// GC_get_non_gc_bytes
// file misc.c line 2136
extern unsigned long int GC_get_non_gc_bytes(void)
{
  return GC_non_gc_bytes;
}

// GC_get_nprocs
// file pthread_support.c line 804
signed int GC_get_nprocs(void)
{
  char stat_buf[4096l];
  signed int f;
  signed int result;
  signed int i;
  signed int len;
  f=open("/proc/stat", 00);
  if(!(f >= 0))
  {
    GC_current_warn_proc("GC Warning: Couldn't read /proc/stat\n", (unsigned long int)0);
    return 1;
  }

  else
  {
    signed long int return_value_read$1;
    return_value_read$1=read(f, (void *)stat_buf, (unsigned long int)4096);
    len = (signed int)return_value_read$1;
    close(f);
    result = 1;
    i = 0;
    for( ; !(i >= len + -100); i = i + 1)
      if((signed int)stat_buf[(signed long int)i] == 10)
      {
        if((signed int)stat_buf[(signed long int)(1 + i)] == 99)
        {
          if((signed int)stat_buf[(signed long int)(2 + i)] == 112)
          {
            if((signed int)stat_buf[(signed long int)(3 + i)] == 117)
            {
              signed int cpu_no;
              cpu_no=atoi$link1(&stat_buf[(signed long int)(i + 4)]);
              if(cpu_no >= result)
                result = cpu_no + 1;

            }

          }

        }

      }

    return result;
  }
}

// GC_get_on_heap_resize
// file misc.c line 2014
extern void (*GC_get_on_heap_resize(void))(unsigned long int)
{
  void (*fn)(unsigned long int);
  do
    if(!(GC_need_to_lock == 0))
    {
      signed int return_value_pthread_mutex_trylock$1;
      return_value_pthread_mutex_trylock$1=pthread_mutex_trylock(&GC_allocate_ml);
      if(!(return_value_pthread_mutex_trylock$1 == 0))
        GC_lock();

    }

  while((_Bool)0);
  fn = GC_on_heap_resize;
  do
    if(!(GC_need_to_lock == 0))
      pthread_mutex_unlock(&GC_allocate_ml);

  while((_Bool)0);
  return fn;
}

// GC_get_oom_fn
// file ./include/private/../gc.h line 120
extern void * (*GC_get_oom_fn(void))(unsigned long int)
{
  void * (*fn)(unsigned long int);
  do
    if(!(GC_need_to_lock == 0))
    {
      signed int return_value_pthread_mutex_trylock$1;
      return_value_pthread_mutex_trylock$1=pthread_mutex_trylock(&GC_allocate_ml);
      if(!(return_value_pthread_mutex_trylock$1 == 0))
        GC_lock();

    }

  while((_Bool)0);
  fn = GC_oom_fn;
  do
    if(!(GC_need_to_lock == 0))
      pthread_mutex_unlock(&GC_allocate_ml);

  while((_Bool)0);
  return fn;
}

// GC_get_pages_executable
// file os_dep.c line 4446
extern signed int GC_get_pages_executable(void)
{
  return (signed int)GC_pages_executable;
}

// GC_get_parallel
// file misc.c line 1975
extern signed int GC_get_parallel(void)
{
  return GC_parallel;
}

// GC_get_prof_stats
// file misc.c line 562
extern unsigned long int GC_get_prof_stats(struct GC_prof_stats_s *pstats, unsigned long int stats_sz)
{
  struct GC_prof_stats_s stats;
  do
    if(!(GC_need_to_lock == 0))
    {
      signed int return_value_pthread_mutex_trylock$1;
      return_value_pthread_mutex_trylock$1=pthread_mutex_trylock(&GC_allocate_ml);
      if(!(return_value_pthread_mutex_trylock$1 == 0))
        GC_lock();

    }

  while((_Bool)0);
  fill_prof_stats(stats_sz >= sizeof(struct GC_prof_stats_s) /*80ul*/  ? pstats : &stats);
  do
    if(!(GC_need_to_lock == 0))
      pthread_mutex_unlock(&GC_allocate_ml);

  while((_Bool)0);
  if(stats_sz == sizeof(struct GC_prof_stats_s) /*80ul*/ )
    return sizeof(struct GC_prof_stats_s) /*80ul*/ ;

  else
    if(stats_sz >= 81ul)
    {
      memset((void *)((char *)pstats + (signed long int)sizeof(struct GC_prof_stats_s) /*80ul*/ ), 0xff, stats_sz - sizeof(struct GC_prof_stats_s) /*80ul*/ );
      return sizeof(struct GC_prof_stats_s) /*80ul*/ ;
    }

    else
    {
      memcpy((void *)pstats, (const void *)&stats, (unsigned long int)stats_sz);
      return stats_sz;
    }
}

// GC_get_prof_stats_unsafe
// file misc.c line 586
extern unsigned long int GC_get_prof_stats_unsafe(struct GC_prof_stats_s *pstats, unsigned long int stats_sz)
{
  struct GC_prof_stats_s stats;
  if(stats_sz >= sizeof(struct GC_prof_stats_s) /*80ul*/ )
  {
    fill_prof_stats(pstats);
    if(stats_sz >= 81ul)
      memset((void *)((char *)pstats + (signed long int)sizeof(struct GC_prof_stats_s) /*80ul*/ ), 0xff, stats_sz - sizeof(struct GC_prof_stats_s) /*80ul*/ );

    return sizeof(struct GC_prof_stats_s) /*80ul*/ ;
  }

  else
  {
    fill_prof_stats(&stats);
    memcpy((void *)pstats, (const void *)&stats, (unsigned long int)stats_sz);
    return stats_sz;
  }
}

// GC_get_push_other_roots
// file os_dep.c line 2615
extern void (*GC_get_push_other_roots(void))(void)
{
  return GC_push_other_roots;
}

// GC_get_stack_base
// file os_dep.c line 1273
extern signed int GC_get_stack_base(struct GC_stack_base *b)
{
  union pthread_attr_t attr;
  unsigned long int size;
  unsigned long int return_value_pthread_self$1;
  return_value_pthread_self$1=pthread_self();
  signed int return_value_pthread_getattr_np$2;
  return_value_pthread_getattr_np$2=pthread_getattr_np(return_value_pthread_self$1, &attr);
  if(!(return_value_pthread_getattr_np$2 == 0))
  {
    GC_current_warn_proc("GC Warning: pthread_getattr_np failed\n", (unsigned long int)0);
    return 3;
  }

  else
  {
    signed int return_value_pthread_attr_getstack$3;
    return_value_pthread_attr_getstack$3=pthread_attr_getstack(&attr, &b->mem_base, &size);
    if(!(return_value_pthread_attr_getstack$3 == 0))
    {
      GC_on_abort("pthread_attr_getstack failed");
      abort();
    }

    pthread_attr_destroy(&attr);
    b->mem_base = (void *)((char *)b->mem_base + (signed long int)size);
    return 0;
  }
}

// GC_get_start_callback
// file alloc.c line 324
extern void (*GC_get_start_callback(void))(void)
{
  void (*fn)(void);
  do
    if(!(GC_need_to_lock == 0))
    {
      signed int return_value_pthread_mutex_trylock$1;
      return_value_pthread_mutex_trylock$1=pthread_mutex_trylock(&GC_allocate_ml);
      if(!(return_value_pthread_mutex_trylock$1 == 0))
        GC_lock();

    }

  while((_Bool)0);
  fn = GC_start_call_back;
  do
    if(!(GC_need_to_lock == 0))
      pthread_mutex_unlock(&GC_allocate_ml);

  while((_Bool)0);
  return fn;
}

// GC_get_stop_func
// file alloc.c line 158
extern signed int (*GC_get_stop_func(void))(void)
{
  signed int (*stop_func)(void);
  do
    if(!(GC_need_to_lock == 0))
    {
      signed int return_value_pthread_mutex_trylock$1;
      return_value_pthread_mutex_trylock$1=pthread_mutex_trylock(&GC_allocate_ml);
      if(!(return_value_pthread_mutex_trylock$1 == 0))
        GC_lock();

    }

  while((_Bool)0);
  stop_func = GC_default_stop_func;
  do
    if(!(GC_need_to_lock == 0))
      pthread_mutex_unlock(&GC_allocate_ml);

  while((_Bool)0);
  return stop_func;
}

// GC_get_suspend_signal
// file ./include/private/../gc.h line 1259
extern signed int GC_get_suspend_signal(void)
{
  return GC_sig_suspend != -1 ? GC_sig_suspend : 30;
}

// GC_get_thr_restart_signal
// file pthread_stop_world.c line 172
extern signed int GC_get_thr_restart_signal(void)
{
  return GC_sig_thr_restart != -1 ? GC_sig_thr_restart : 24;
}

// GC_get_time_limit
// file misc.c line 2192
extern unsigned long int GC_get_time_limit(void)
{
  return GC_time_limit;
}

// GC_get_total_bytes
// file misc.c line 508
extern unsigned long int GC_get_total_bytes(void)
{
  return (unsigned long int)(GC_arrays._bytes_allocd + GC_arrays._bytes_allocd_before_gc);
}

// GC_get_unmapped_bytes
// file misc.c line 498
extern unsigned long int GC_get_unmapped_bytes(void)
{
  return (unsigned long int)0;
}

// GC_get_version
// file alloc.c line 105
extern unsigned int GC_get_version(void)
{
  return (unsigned int)(7 << 16 | 4 << 8 | 2);
}

// GC_get_warn_proc
// file misc.c line 1624
extern void (*GC_get_warn_proc(void))(char *, unsigned long int)
{
  void (*result)(char *, unsigned long int);
  do
    if(!(GC_need_to_lock == 0))
    {
      signed int return_value_pthread_mutex_trylock$1;
      return_value_pthread_mutex_trylock$1=pthread_mutex_trylock(&GC_allocate_ml);
      if(!(return_value_pthread_mutex_trylock$1 == 0))
        GC_lock();

    }

  while((_Bool)0);
  result = GC_current_warn_proc;
  do
    if(!(GC_need_to_lock == 0))
      pthread_mutex_unlock(&GC_allocate_ml);

  while((_Bool)0);
  return result;
}

// GC_grow_table
// file finalize.c line 100
void GC_grow_table(struct hash_chain_entry ***table, signed long int *log_size_ptr)
{
  unsigned long int i;
  struct hash_chain_entry *p;
  signed long int log_old_size = *log_size_ptr;
  signed long int log_new_size = log_old_size + (signed long int)1;
  unsigned long int old_size = (unsigned long int)(log_old_size == (signed long int)-1 ? 0 : 1 << log_old_size);
  unsigned long int new_size = (unsigned long int)1 << log_new_size;
  struct hash_chain_entry **new_table;
  void *return_value_GC_generic_malloc_inner_ignore_off_page$1;
  return_value_GC_generic_malloc_inner_ignore_off_page$1=GC_generic_malloc_inner_ignore_off_page((unsigned long int)new_size * sizeof(struct hash_chain_entry *) /*8ul*/ , 1);
  new_table = (struct hash_chain_entry **)return_value_GC_generic_malloc_inner_ignore_off_page$1;
  if(new_table == ((struct hash_chain_entry **)NULL))
  {
    if(*table == ((struct hash_chain_entry **)NULL))
    {
      GC_on_abort("Insufficient space for initial table allocation");
      abort();
    }

  }

  else
  {
    i = (unsigned long int)0;
    for( ; !(i >= old_size); i = i + 1ul)
    {
      p = (*table)[(signed long int)i];
      while(!(p == ((struct hash_chain_entry *)NULL)))
      {
        char *real_key = (char *)(void *)~((unsigned long int)p->hidden_key);
        struct hash_chain_entry *next = p->next;
        unsigned long int new_hash = ((unsigned long int)real_key >> 3 ^ (unsigned long int)real_key >> (signed long int)3 + log_new_size) & new_size - (unsigned long int)1;
        p->next = new_table[(signed long int)new_hash];
        new_table[(signed long int)new_hash] = p;
        p = next;
      }
    }
    *log_size_ptr = log_new_size;
    *table = new_table;
  }
}

// GC_has_other_debug_info
// file dbg_mlc.c line 36
signed int GC_has_other_debug_info(char *p)
{
  char *body = (char *)((struct anonymous$17 *)p + (signed long int)1);
  unsigned long int sz;
  sz=GC_size((const void *)p);
  if(!((struct hblk *)(18446744073709547520ul & (unsigned long int)p) == (struct hblk *)(18446744073709547520ul & (unsigned long int)body)) || !(sz >= sizeof(unsigned long int) * 5 /*40ul*/ ))
    return 0;

  else
    if(!(((struct anonymous$17 *)p)->oh_sf == (0xFEDCEDCBfedcedcbUL ^ (unsigned long int)body)))
    {
      if(((unsigned long int *)p)[-1l + (signed long int)(sz >> 3)] == (0xBCDECDEFbcdecdefUL ^ (unsigned long int)body))
        goto __CPROVER_DUMP_L2;

      return 0;
    }

    else
    {

    __CPROVER_DUMP_L2:
      ;
      if(((struct anonymous$17 *)p)->oh_sz == sz)
        return -1;

      else
        return 1;
    }
}

// GC_hblk_fl_from_blocks
// file allchblk.c line 84
signed int GC_hblk_fl_from_blocks(unsigned long int blocks_needed)
{
  if(!(blocks_needed >= 33ul))
    return (signed int)blocks_needed;

  else
    if(blocks_needed >= 256ul)
      return (256 - 32) / 8 + 32;

    else
      return (signed int)(blocks_needed - (unsigned long int)32) / 8 + 32;
}

// GC_header_cache_miss
// file headers.c line 58
struct hblkhdr * GC_header_cache_miss(char *p, struct hce *hce)
{
  struct hblkhdr *hhdr;
  do
  {
    struct hblkhdr **_ha;
    do
    {
      struct bi *bi;
      do
      {
        unsigned long int hi = (unsigned long int)p >> (unsigned long int)10 + (unsigned long int)12;
        struct bi *_bi = GC_arrays._top_index[(signed long int)(hi & (unsigned long int)((1 << 11) - 1))];
        for( ; !(_bi->key == hi); _bi = _bi->hash_link)
          if(_bi == GC_arrays._all_nils)
            break;

        bi = _bi;
      }
      while((_Bool)0);
      _ha = &bi->index[(signed long int)((unsigned long int)p >> (unsigned long int)12 & (unsigned long int)((1 << 10) - 1))];
    }
    while((_Bool)0);
    hhdr = *_ha;
  }
  while((_Bool)0);
  if(!((unsigned long int)hhdr >= 4096ul))
  {
    if(!(GC_all_interior_pointers == 0))
    {
      if(!(hhdr == ((struct hblkhdr *)NULL)))
      {
        char *current = p;
        current = (char *)(struct hblk *)((unsigned long int)current & ~((unsigned long int)(1 << 12) - (unsigned long int)1));
        do
        {
          current = current - (signed long int)((unsigned long int)(1 << 12) * (unsigned long int)hhdr);
          hhdr=GC_find_header((char *)current);
        }
        while(!((unsigned long int)hhdr >= 4096ul));
        if(!((1 & (signed int)hhdr->hb_flags) == 0))
          return ((struct hblkhdr *)NULL);

        _Bool tmp_if_expr$1;
        if(!((4 & (signed int)hhdr->hb_flags) == 0))
          tmp_if_expr$1 = (_Bool)1;

        else
          tmp_if_expr$1 = p - current >= (signed long int)hhdr->hb_sz ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$1)
        {
          if(!(GC_all_interior_pointers == 0))
            GC_add_to_black_list_stack((unsigned long int)p);

          else
            GC_add_to_black_list_normal((unsigned long int)p);
          return ((struct hblkhdr *)NULL);
        }

      }

      else
        if(!(GC_all_interior_pointers == 0))
          GC_add_to_black_list_stack((unsigned long int)p);

        else
          GC_add_to_black_list_normal((unsigned long int)p);
      return hhdr;
    }

    else
    {
      if(hhdr == ((struct hblkhdr *)NULL))
      {
        if(!(GC_all_interior_pointers == 0))
          GC_add_to_black_list_stack((unsigned long int)p);

        else
          GC_add_to_black_list_normal((unsigned long int)p);
      }

      return ((struct hblkhdr *)NULL);
    }
  }

  else
    if(!((4 & (signed int)hhdr->hb_flags) == 0))
    {
      if(!(GC_all_interior_pointers == 0))
        GC_add_to_black_list_stack((unsigned long int)p);

      else
        GC_add_to_black_list_normal((unsigned long int)p);
      return ((struct hblkhdr *)NULL);
    }

    else
    {
      hce->block_addr = (unsigned long int)p >> (unsigned long int)12;
      hce->hce_hdr = hhdr;
      return hhdr;
    }
}

// GC_help_marker
// file mark.c line 1157
void GC_help_marker(unsigned long int my_mark_no)
{
  unsigned int my_id;
  struct GC_ms_entry local_mark_stack[4096l];
  if(!(GC_parallel == 0))
  {
    GC_acquire_mark_lock();
    while(GC_help_wanted == 0 && GC_mark_no == my_mark_no || !(GC_mark_no >= my_mark_no))
      GC_wait_marker();
    my_id = GC_helper_count;
    if(!(GC_mark_no == my_mark_no) || !((unsigned int)GC_parallel >= my_id))
      GC_release_mark_lock();

    else
    {
      GC_helper_count = my_id + (unsigned int)1;
      GC_release_mark_lock();
      GC_mark_local(local_mark_stack, (signed int)my_id);
    }
  }

}

// GC_ignore_self_finalize_mark_proc
// file finalize.c line 391
void GC_ignore_self_finalize_mark_proc(char *p)
{
  struct hblkhdr *hhdr;
  hhdr=GC_find_header((char *)p);
  unsigned long int descr = hhdr->hb_descr;
  char *q;
  unsigned long int r;
  char *scan_limit;
  char *target_limit = (p + (signed long int)hhdr->hb_sz) - (signed long int)1;
  if((3ul & descr) == 0ul)
    scan_limit = (p + (signed long int)descr) - (signed long int)sizeof(unsigned long int) /*8ul*/ ;

  else
    scan_limit = (target_limit + (signed long int)1) - (signed long int)sizeof(unsigned long int) /*8ul*/ ;
  q = p;
  for( ; (unsigned long int)scan_limit >= (unsigned long int)q; q = q + (signed long int)8)
  {
    r = *((unsigned long int *)q);
    if(!(r >= (unsigned long int)p) || !((unsigned long int)target_limit >= r))
      do
        if(r >= (unsigned long int)GC_least_plausible_heap_addr && !(r >= (unsigned long int)GC_greatest_plausible_heap_addr))
          GC_arrays._mark_stack_top=GC_mark_and_push((void *)r, GC_arrays._mark_stack_top, GC_arrays._mark_stack_limit, (void **)q);

      while((_Bool)0);

  }
}

// GC_ignore_warn_proc
// file misc.c line 1599
extern void GC_ignore_warn_proc(char *msg, unsigned long int arg)
{
  if(!(GC_print_stats == 0))
    GC_default_warn_proc(msg, arg);

}

// GC_incr_bytes_allocd
// file mallocx.c line 234
extern void GC_incr_bytes_allocd(unsigned long int n)
{
  GC_arrays._bytes_allocd = GC_arrays._bytes_allocd + n;
}

// GC_incr_bytes_freed
// file mallocx.c line 240
extern void GC_incr_bytes_freed(unsigned long int n)
{
  GC_arrays._bytes_freed = GC_arrays._bytes_freed + n;
}

// GC_incremental_protection_needs
// file os_dep.c line 3379
extern signed int GC_incremental_protection_needs(void)
{
  if(GC_page_size == 4096ul)
    return 1;

  else
    return 1 | 2;
}

// GC_init
// file ./include/gc.h line 396
extern void GC_init(void)
{
  unsigned long int initial_heap_sz;
  signed int cancel_state;
  char *return_value_getenv$1;
  _Bool tmp_if_expr$3;
  char *return_value_getenv$12;
  if((signed long int)GC_is_initialized == 0l)
  {
    initial_heap_sz = (unsigned long int)16;
    do
      pthread_setcancelstate(1, &cancel_state);
    while((_Bool)0);
    GC_setpagesize();
    char *return_value_getenv$2;
    return_value_getenv$2=getenv("GC_PRINT_VERBOSE_STATS");
    if(!(return_value_getenv$2 == ((char *)NULL)))
      GC_print_stats = 2;

    else
    {
      return_value_getenv$1=getenv("GC_PRINT_STATS");
      if(!(return_value_getenv$1 == ((char *)NULL)))
        GC_print_stats = 1;

    }
    char *file_name;
    file_name=getenv("GC_LOG_FILE");
    if(!(file_name == ((char *)NULL)))
    {
      signed int log_d;
      log_d=open(file_name, 0100 | 01 | 02000, 0666);
      if(!(log_d >= 0))
        GC_err_printf("Failed to open %s as log file\n", file_name);

      else
      {
        char *str;
        GC_log = log_d;
        str=getenv("GC_ONLY_LOG_TO_FILE");
        _Bool tmp_if_expr$4;
        if(str == ((char *)NULL))
          tmp_if_expr$4 = (_Bool)1;

        else
        {
          if((signed int)*str == 48)
            tmp_if_expr$3 = (signed int)str[(signed long int)1] == 0 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$3 = (_Bool)0;
          tmp_if_expr$4 = tmp_if_expr$3 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$4)
        {
          GC_stdout = log_d;
          GC_stderr = log_d;
        }

      }
    }

    char *return_value_getenv$5;
    return_value_getenv$5=getenv("GC_DUMP_REGULARLY");
    if(!(return_value_getenv$5 == ((char *)NULL)))
      GC_dump_regularly = 1;

    char *return_value_getenv$6;
    return_value_getenv$6=getenv("GC_FIND_LEAK");
    if(!(return_value_getenv$6 == ((char *)NULL)))
      GC_find_leak = 1;

    char *return_value_getenv$7;
    return_value_getenv$7=getenv("GC_FINDLEAK_DELAY_FREE");
    if(!(return_value_getenv$7 == ((char *)NULL)))
      GC_findleak_delay_free = 1;

    char *return_value_getenv$8;
    return_value_getenv$8=getenv("GC_ALL_INTERIOR_POINTERS");
    if(!(return_value_getenv$8 == ((char *)NULL)))
      GC_all_interior_pointers = 1;

    char *return_value_getenv$9;
    return_value_getenv$9=getenv("GC_DONT_GC");
    if(!(return_value_getenv$9 == ((char *)NULL)))
      GC_dont_gc = 1;

    char *return_value_getenv$10;
    return_value_getenv$10=getenv("GC_PRINT_BACK_HEIGHT");
    if(!(return_value_getenv$10 == ((char *)NULL)))
      GC_print_back_height = 1;

    char *return_value_getenv$11;
    return_value_getenv$11=getenv("GC_NO_BLACKLIST_WARNING");
    if(!(return_value_getenv$11 == ((char *)NULL)))
      GC_large_alloc_warn_interval = 0x7fffffffffffffffL;

    char *addr_string;
    addr_string=getenv("GC_TRACE");
    if(!(addr_string == ((char *)NULL)))
      GC_current_warn_proc("GC Warning: Tracing not enabled: Ignoring GC_TRACE value\n", (unsigned long int)0);

    char *time_limit_string;
    time_limit_string=getenv("GC_PAUSE_TIME_TARGET");
    if(!(time_limit_string == ((char *)NULL)))
    {
      signed long int time_limit;
      time_limit=atol(time_limit_string);
      if(!(time_limit >= 5l))
        GC_current_warn_proc("GC Warning: GC_PAUSE_TIME_TARGET environment variable value too small or bad syntax: Ignoring\n", (unsigned long int)0);

      else
        GC_time_limit = (unsigned long int)time_limit;
    }

    char *full_freq_string;
    full_freq_string=getenv("GC_FULL_FREQUENCY");
    if(!(full_freq_string == ((char *)NULL)))
    {
      signed int full_freq;
      full_freq=atoi(full_freq_string);
      if(full_freq >= 1)
        GC_full_freq = full_freq;

    }

    char *interval_string;
    interval_string=getenv("GC_LARGE_ALLOC_WARN_INTERVAL");
    if(!(interval_string == ((char *)NULL)))
    {
      signed long int interval;
      interval=atol(interval_string);
      if(!(interval >= 1l))
        GC_current_warn_proc("GC Warning: GC_LARGE_ALLOC_WARN_INTERVAL environment variable has bad value: Ignoring\n", (unsigned long int)0);

      else
        GC_large_alloc_warn_interval = interval;
    }

    char *space_divisor_string;
    space_divisor_string=getenv("GC_FREE_SPACE_DIVISOR");
    if(!(space_divisor_string == ((char *)NULL)))
    {
      signed int space_divisor;
      space_divisor=atoi(space_divisor_string);
      if(space_divisor >= 1)
        GC_free_space_divisor = (unsigned long int)space_divisor;

    }

    maybe_install_looping_handler();
    if(!(GC_all_interior_pointers == 0))
      GC_obj_kinds[(signed long int)1].ok_descriptor = (unsigned long int)-8 | (unsigned long int)0;

    GC_exclude_static_roots_inner((void *)(char *)&GC_arrays, (void *)((char *)&GC_arrays + (signed long int)sizeof(struct _GC_arrays) /*198880ul*/ ));
    GC_exclude_static_roots_inner((void *)(char *)&GC_obj_kinds, (void *)((char *)&GC_obj_kinds + (signed long int)sizeof(struct obj_kind [16l]) /*768ul*/ ));
    GC_init_linux_data_start();
    if(GC_stackbottom == ((char *)NULL))
      GC_stackbottom=GC_get_main_stack_base();

    _Bool tmp_if_expr$13;
    if(!(GC_incremental == 0))
      tmp_if_expr$13 = (_Bool)1;

    else
    {
      return_value_getenv$12=getenv("GC_ENABLE_INCREMENTAL");
      tmp_if_expr$13 = ((char *)NULL) != return_value_getenv$12 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$13)
    {
      GC_dirty_init();
      GC_incremental = 1;
    }

    signed int return_value_GC_register_main_static_data$14;
    return_value_GC_register_main_static_data$14=GC_register_main_static_data();
    if(!(return_value_GC_register_main_static_data$14 == 0))
      GC_register_data_segments();

    GC_init_headers();
    GC_bl_init();
    GC_mark_init();
    char *sz_str;
    sz_str=getenv("GC_INITIAL_HEAP_SIZE");
    if(!(sz_str == ((char *)NULL)))
    {
      initial_heap_sz=GC_parse_mem_size_arg(sz_str);
      if(!(initial_heap_sz >= 65537ul))
        GC_current_warn_proc("GC Warning: Bad initial heap size %s - ignoring it.\n", (unsigned long int)sz_str);

      initial_heap_sz = initial_heap_sz >> (unsigned long int)12;
    }

    char *GC_init$$1$$22$$sz_str;
    GC_init$$1$$22$$sz_str=getenv("GC_MAXIMUM_HEAP_SIZE");
    if(!(GC_init$$1$$22$$sz_str == ((char *)NULL)))
    {
      unsigned long int max_heap_sz;
      max_heap_sz=GC_parse_mem_size_arg(GC_init$$1$$22$$sz_str);
      if(!(max_heap_sz >= 4096ul * initial_heap_sz))
        GC_current_warn_proc("GC Warning: Bad maximum heap size %s - ignoring it.\n", (unsigned long int)GC_init$$1$$22$$sz_str);

      if(GC_max_retries == 0ul)
        GC_max_retries = (unsigned long int)2;

      GC_set_max_heap_size(max_heap_sz);
    }

    signed int return_value_GC_expand_hp_inner$15;
    return_value_GC_expand_hp_inner$15=GC_expand_hp_inner(initial_heap_sz);
    if(return_value_GC_expand_hp_inner$15 == 0)
    {
      GC_err_printf("Can't start up: not enough memory\n");
      GC_on_abort((const char *)(void *)0);
      exit(1);
    }

    else
      GC_arrays._requested_heapsize = GC_arrays._requested_heapsize + initial_heap_sz;
    if(!(GC_all_interior_pointers == 0))
      GC_initialize_offsets();

    GC_register_displacement_inner((unsigned long int)0L);
    GC_init_size_map();
    GC_is_initialized = 1;
    GC_thr_init();
    if(!((signed long int)GC_dump_regularly == 0l))
      GC_dump();

    else

      __CPROVER_DUMP_L46:
        ;
    if(GC_dont_precollect == 0 || !(GC_incremental == 0))
      GC_try_to_collect_inner(GC_never_stop_func);

    if(!(GC_find_leak == 0))
      atexit(GC_exit_check);

    GC_init_parallel();
    do
      pthread_setcancelstate(cancel_state, (signed int *)(void *)0);
    while((_Bool)0);
  }

}

// GC_init_explicit_typing
// file typd_mlc.c line 348
void GC_init_explicit_typing(void)
{
  unsigned int i;
  do
    if(!(GC_need_to_lock == 0))
    {
      signed int return_value_pthread_mutex_trylock$1;
      return_value_pthread_mutex_trylock$1=pthread_mutex_trylock(&GC_allocate_ml);
      if(!(return_value_pthread_mutex_trylock$1 == 0))
        GC_lock();

    }

  while((_Bool)0);
  if(!(GC_explicit_typing_initialized == 0))
    do
      if(!(GC_need_to_lock == 0))
        pthread_mutex_unlock(&GC_allocate_ml);

    while((_Bool)0);

  else
  {
    GC_explicit_typing_initialized = 1;
    void **return_value_GC_new_free_list_inner$2;
    return_value_GC_new_free_list_inner$2=GC_new_free_list_inner();
    GC_eobjfreelist = (char **)return_value_GC_new_free_list_inner$2;
    unsigned int return_value_GC_new_kind_inner$3;
    return_value_GC_new_kind_inner$3=GC_new_kind_inner((void **)GC_eobjfreelist, (unsigned long int)-1 << 3 | (unsigned long int)3, 1, 1);
    GC_explicit_kind = (signed int)return_value_GC_new_kind_inner$3;
    unsigned int return_value_GC_new_proc_inner$4;
    return_value_GC_new_proc_inner$4=GC_new_proc_inner(GC_typed_mark_proc);
    GC_typed_mark_proc_index = (signed int)return_value_GC_new_proc_inner$4;
    void **return_value_GC_new_free_list_inner$5;
    return_value_GC_new_free_list_inner$5=GC_new_free_list_inner();
    GC_arobjfreelist = (char **)return_value_GC_new_free_list_inner$5;
    unsigned int return_value_GC_new_proc_inner$6;
    return_value_GC_new_proc_inner$6=GC_new_proc_inner(GC_array_mark_proc);
    GC_array_mark_proc_index = (signed int)return_value_GC_new_proc_inner$6;
    unsigned int return_value_GC_new_kind_inner$7;
    return_value_GC_new_kind_inner$7=GC_new_kind_inner((void **)GC_arobjfreelist, (unsigned long int)((0 << 6 | GC_array_mark_proc_index) << 2 | 2), 0, 1);
    GC_array_kind = (signed int)return_value_GC_new_kind_inner$7;
    i = (unsigned int)0;
    for( ; !((unsigned long int)i >= 32ul); i = i + 1u)
      GC_bm_table[(signed long int)i] = (unsigned long int)-1 << (unsigned long int)64 - (unsigned long int)i | (unsigned long int)1;
    do
      if(!(GC_need_to_lock == 0))
        pthread_mutex_unlock(&GC_allocate_ml);

    while((_Bool)0);
  }
}

// GC_init_finalized_malloc
// file fnlz_mlc.c line 50
extern void GC_init_finalized_malloc(void)
{
  GC_init();
  do
    if(!(GC_need_to_lock == 0))
    {
      signed int return_value_pthread_mutex_trylock$1;
      return_value_pthread_mutex_trylock$1=pthread_mutex_trylock(&GC_allocate_ml);
      if(!(return_value_pthread_mutex_trylock$1 == 0))
        GC_lock();

    }

  while((_Bool)0);
  if(!(done_init == 0))
    do
      if(!(GC_need_to_lock == 0))
        pthread_mutex_unlock(&GC_allocate_ml);

    while((_Bool)0);

  else
  {
    done_init = 1;
    GC_register_displacement_inner(sizeof(unsigned long int) /*8ul*/ );
    void **return_value_GC_new_free_list_inner$2;
    return_value_GC_new_free_list_inner$2=GC_new_free_list_inner();
    GC_finalized_objfreelist = (char **)return_value_GC_new_free_list_inner$2;
    unsigned int return_value_GC_new_kind_inner$3;
    return_value_GC_new_kind_inner$3=GC_new_kind_inner((void **)GC_finalized_objfreelist, (unsigned long int)0, 1, 1);
    GC_finalized_kind = (signed int)return_value_GC_new_kind_inner$3;
    GC_register_disclaim_proc(GC_finalized_kind, GC_finalized_disclaim, 1);
    do
      if(!(GC_need_to_lock == 0))
        pthread_mutex_unlock(&GC_allocate_ml);

    while((_Bool)0);
  }
}

// GC_init_gcj_malloc
// file gcj_mlc.c line 69
extern void GC_init_gcj_malloc(signed int mp_index, void *mp)
{
  signed int ignore_gcj_info;
  if(mp == NULL)
    mp = (void *)(unsigned long int)GC_gcj_fake_mark_proc;

  GC_init();
  do
    if(!(GC_need_to_lock == 0))
    {
      signed int return_value_pthread_mutex_trylock$1;
      return_value_pthread_mutex_trylock$1=pthread_mutex_trylock(&GC_allocate_ml);
      if(!(return_value_pthread_mutex_trylock$1 == 0))
        GC_lock();

    }

  while((_Bool)0);
  if(!(GC_gcj_malloc_initialized == 0))
    do
      if(!(GC_need_to_lock == 0))
        pthread_mutex_unlock(&GC_allocate_ml);

    while((_Bool)0);

  else
  {
    GC_gcj_malloc_initialized = 1;
    char *return_value_getenv$2;
    return_value_getenv$2=getenv("GC_IGNORE_GCJ_INFO");
    ignore_gcj_info = (signed int)(((char *)NULL) != return_value_getenv$2);
    if(!(ignore_gcj_info == 0))
    {
      if(!(GC_print_stats == 0))
        GC_log_printf("Gcj-style type information is disabled!\n");

    }

    GC_arrays._mark_procs[(signed long int)mp_index] = (struct GC_ms_entry * (*)(unsigned long int *, struct GC_ms_entry *, struct GC_ms_entry *, unsigned long int))(unsigned long int)mp;
    if((unsigned int)mp_index >= GC_n_mark_procs)
    {
      GC_on_abort("GC_init_gcj_malloc: bad index");
      abort();
    }

    void **return_value_GC_new_free_list_inner$3;
    return_value_GC_new_free_list_inner$3=GC_new_free_list_inner();
    GC_gcjobjfreelist = (char **)return_value_GC_new_free_list_inner$3;
    if(!(ignore_gcj_info == 0))
    {
      unsigned int return_value_GC_new_kind_inner$4;
      return_value_GC_new_kind_inner$4=GC_new_kind_inner((void **)GC_gcjobjfreelist, (unsigned long int)(0 | 0), 1, 1);
      GC_gcj_kind = (signed int)return_value_GC_new_kind_inner$4;
    }

    else
    {
      unsigned int return_value_GC_new_kind_inner$5;
      return_value_GC_new_kind_inner$5=GC_new_kind_inner((void **)GC_gcjobjfreelist, (unsigned long int)(-((signed long int)sizeof(unsigned long int) /*8ul*/ ) - (signed long int)0x10) | (unsigned long int)3, 0, 1);
      GC_gcj_kind = (signed int)return_value_GC_new_kind_inner$5;
    }
    if(!(ignore_gcj_info == 0))
    {
      GC_gcj_debug_kind = GC_gcj_kind;
      GC_gcjdebugobjfreelist = GC_gcjobjfreelist;
    }

    else
    {
      void **return_value_GC_new_free_list_inner$6;
      return_value_GC_new_free_list_inner$6=GC_new_free_list_inner();
      GC_gcjdebugobjfreelist = (char **)return_value_GC_new_free_list_inner$6;
      unsigned int return_value_GC_new_kind_inner$7;
      return_value_GC_new_kind_inner$7=GC_new_kind_inner((void **)GC_gcjdebugobjfreelist, (unsigned long int)((1 << 6 | mp_index) << 2 | 2), 0, 1);
      GC_gcj_debug_kind = (signed int)return_value_GC_new_kind_inner$7;
    }
    do
      if(!(GC_need_to_lock == 0))
        pthread_mutex_unlock(&GC_allocate_ml);

    while((_Bool)0);
  }
}

// GC_init_headers
// file headers.c line 189
void GC_init_headers(void)
{
  unsigned int i;
  char *return_value_GC_scratch_alloc$1;
  return_value_GC_scratch_alloc$1=GC_scratch_alloc((unsigned long int)sizeof(struct bi) /*8224ul*/ );
  GC_arrays._all_nils = (struct bi *)return_value_GC_scratch_alloc$1;
  if(GC_arrays._all_nils == ((struct bi *)NULL))
  {
    GC_err_printf("Insufficient memory for GC_all_nils\n");
    GC_on_abort((const char *)(void *)0);
    exit(1);
  }

  memset((void *)GC_arrays._all_nils, 0, (unsigned long int)sizeof(struct bi) /*8224ul*/ );
  i = (unsigned int)0;
  for( ; !(i >= 2048u); i = i + 1u)
    GC_arrays._top_index[(signed long int)i] = GC_arrays._all_nils;
}

// GC_init_linux_data_start
// file ./include/private/gc_priv.h line 2289
void GC_init_linux_data_start(void)
{
  GC_data_start = (char *)__data_start;
}

// GC_init_parallel
// file ./include/private/gc_priv.h line 1681
void GC_init_parallel(void)
{
  if(parallel_initialized == 0)
  {
    parallel_initialized = 1;
    if(GC_is_initialized == 0)
      GC_init();

    do
      if(!(GC_need_to_lock == 0))
      {
        signed int return_value_pthread_mutex_trylock$1;
        return_value_pthread_mutex_trylock$1=pthread_mutex_trylock(&GC_allocate_ml);
        if(!(return_value_pthread_mutex_trylock$1 == 0))
          GC_lock();

      }

    while((_Bool)0);
    unsigned long int return_value_pthread_self$2;
    return_value_pthread_self$2=pthread_self();
    struct GC_Thread_Rep *return_value_GC_lookup_thread$3;
    return_value_GC_lookup_thread$3=GC_lookup_thread(return_value_pthread_self$2);
    GC_init_thread_local(&return_value_GC_lookup_thread$3->tlfs);
    do
      if(!(GC_need_to_lock == 0))
        pthread_mutex_unlock(&GC_allocate_ml);

    while((_Bool)0);
  }

}

// GC_init_size_map
// file misc.c line 227
void GC_init_size_map(void)
{
  signed int i;
  GC_arrays._size_map[(signed long int)0] = (unsigned long int)1;
  i = 1;
  for( ; 384 + -GC_all_interior_pointers >= i; i = i + 1)
    GC_arrays._size_map[(signed long int)i] = (unsigned long int)(i + (16 - 1) + GC_all_interior_pointers >> 4);
}

// GC_init_thread_local
// file thread_local_alloc.c line 87
void GC_init_thread_local(struct thread_local_freelists *p)
{
  signed int i;
  if((signed long int)keys_initialized == 0l)
    keys_initialized = 1;

  GC_thread_key = (void *)p;
  i = 1;
  for( ; !(i >= 25); i = i + 1)
  {
    p->ptrfree_freelists[(signed long int)i] = (void *)(unsigned long int)1;
    p->normal_freelists[(signed long int)i] = (void *)(unsigned long int)1;
    p->gcj_freelists[(signed long int)i] = (void *)(unsigned long int)1;
    p->finalized_freelists[(signed long int)i] = (void *)(unsigned long int)1;
  }
  p->ptrfree_freelists[(signed long int)0] = (void *)(unsigned long int)1;
  p->normal_freelists[(signed long int)0] = (void *)(unsigned long int)1;
  p->gcj_freelists[(signed long int)0] = (void *)(unsigned long int)-1;
  p->finalized_freelists[(signed long int)0] = (void *)(unsigned long int)1;
}

// GC_initialize_offsets
// file ./include/private/gc_priv.h line 2224
void GC_initialize_offsets(void)
{
  unsigned int i;
  if(!(GC_all_interior_pointers == 0))
  {
    i = (unsigned int)0;
    for( ; !((unsigned long int)i >= 4096ul); i = i + 1u)
      GC_arrays._valid_offsets[(signed long int)i] = (char)1;
  }

  else
  {
    memset((void *)GC_arrays._valid_offsets, 0, (unsigned long int)sizeof(char [4096l]) /*4096ul*/ );
    i = (unsigned int)0;
    for( ; !((unsigned long int)i >= sizeof(unsigned long int) /*8ul*/ ); i = i + 1u)
      GC_arrays._modws_valid_offsets[(signed long int)i] = (char)0;
  }
}

// GC_initiate_gc
// file ./include/private/gc_priv.h line 1565
void GC_initiate_gc(void)
{
  if(!(GC_dirty_maintained == 0))
    GC_read_dirty();

  GC_n_rescuing_pages = (unsigned long int)0;
  if(GC_mark_state == 0)
    GC_mark_state = 1;

  else
    if(!(GC_mark_state == 5))
    {
      GC_on_abort("Unexpected state");
      abort();
    }

  scan_ptr = ((struct hblk *)NULL);
}

// GC_inner_start_routine
// file pthread_start.c line 45
void * GC_inner_start_routine(struct GC_stack_base *sb, void *arg)
{
  void * (*start)(void *);
  void *start_arg;
  void *result;
  struct GC_Thread_Rep * volatile me;
  me=GC_start_rtn_prepare_thread(&start, &start_arg, sb, arg);
  struct anonymous$24 __cancel_buf;
  void (*__cancel_routine)(void *) = GC_thread_exit_proc;
  void *__cancel_arg = (void *)me;
  signed int __not_first_call;
  __not_first_call=__sigsetjmp((struct __jmp_buf_tag *)(void *)__cancel_buf.__cancel_jmp_buf, 0);
  if(!((signed long int)__not_first_call == 0l))
  {
    __cancel_routine(__cancel_arg);
    __pthread_unwind_next(&__cancel_buf);
  }

  __pthread_register_cancel(&__cancel_buf);
  result=start(start_arg);
  me->status = result;
  __pthread_unregister_cancel(&__cancel_buf);
  __cancel_routine(__cancel_arg);
  return result;
}

// GC_install_counts
// file ./include/private/gc_priv.h line 1887
signed int GC_install_counts(struct hblk *h, unsigned long int sz)
{
  struct hblk *hbp;
  unsigned long int i;
  hbp = h;
  for( ; !((unsigned long int)hbp >= sz + (unsigned long int)h); hbp = hbp + (signed long int)(1 << 10))
  {
    signed int return_value_get_index$1;
    return_value_get_index$1=get_index((unsigned long int)hbp);
    if(return_value_get_index$1 == 0)
      return 0;

  }
  signed int return_value_get_index$2;
  return_value_get_index$2=get_index(((unsigned long int)h + sz) - (unsigned long int)1);
  if(return_value_get_index$2 == 0)
    return 0;

  else
  {
    hbp = h + (signed long int)1;
    for( ; !((unsigned long int)hbp >= sz + (unsigned long int)h); hbp = hbp + (signed long int)1)
    {
      i = (unsigned long int)((char *)hbp - (char *)h >> (unsigned long int)12);
      do
      {
        struct hblkhdr **_ha;
        do
        {
          struct bi *bi;
          do
          {
            unsigned long int hi = (unsigned long int)hbp >> (unsigned long int)10 + (unsigned long int)12;
            struct bi *_bi = GC_arrays._top_index[(signed long int)(hi & (unsigned long int)((1 << 11) - 1))];
            for( ; !(_bi->key == hi); _bi = _bi->hash_link)
              if(_bi == GC_arrays._all_nils)
                break;

            bi = _bi;
          }
          while((_Bool)0);
          _ha = &bi->index[(signed long int)((unsigned long int)hbp >> (unsigned long int)12 & (unsigned long int)((1 << 10) - 1))];
        }
        while((_Bool)0);
        *_ha = (struct hblkhdr *)(i > (unsigned long int)(1 << 12) - (unsigned long int)1 ? (unsigned long int)(1 << 12) - (unsigned long int)1 : i);
      }
      while((_Bool)0);
    }
    return 1;
  }
}

// GC_install_header
// file ./include/private/gc_priv.h line 1883
struct hblkhdr * GC_install_header(struct hblk *h)
{
  struct hblkhdr *result;
  signed int return_value_get_index$1;
  return_value_get_index$1=get_index((unsigned long int)h);
  if(return_value_get_index$1 == 0)
    return ((struct hblkhdr *)NULL);

  else
  {
    result=alloc_hdr();
    if(!(result == ((struct hblkhdr *)NULL)))
      do
      {
        struct hblkhdr **_ha;
        do
        {
          struct bi *bi;
          do
          {
            unsigned long int hi = (unsigned long int)h >> (unsigned long int)10 + (unsigned long int)12;
            struct bi *_bi = GC_arrays._top_index[(signed long int)(hi & (unsigned long int)((1 << 11) - 1))];
            for( ; !(_bi->key == hi); _bi = _bi->hash_link)
              if(_bi == GC_arrays._all_nils)
                break;

            bi = _bi;
          }
          while((_Bool)0);
          _ha = &bi->index[(signed long int)((unsigned long int)h >> (unsigned long int)12 & (unsigned long int)((1 << 10) - 1))];
        }
        while((_Bool)0);
        *_ha = result;
      }
      while((_Bool)0);

    return result;
  }
}

// GC_invalidate_mark_state
// file ./include/private/gc_priv.h line 1555
void GC_invalidate_mark_state(void)
{
  GC_mark_state = 5;
  GC_arrays._mark_stack_top = GC_arrays._mark_stack - (signed long int)1;
}

// GC_invoke_finalizers
// file ./include/gc.h line 1126
extern signed int GC_invoke_finalizers(void)
{
  struct finalizable_object *curr_fo;
  signed int GC_invoke_finalizers$$1$$count = 0;
  unsigned long int bytes_freed_before = (unsigned long int)0;
  if(!(GC_finalize_now == ((struct finalizable_object *)NULL)))
  {
    do
      if(!(GC_need_to_lock == 0))
      {
        signed int return_value_pthread_mutex_trylock$1;
        return_value_pthread_mutex_trylock$1=pthread_mutex_trylock(&GC_allocate_ml);
        if(!(return_value_pthread_mutex_trylock$1 == 0))
          GC_lock();

      }

    while((_Bool)0);
    if(GC_invoke_finalizers$$1$$count == 0)
      bytes_freed_before = GC_arrays._bytes_freed;

    curr_fo = GC_finalize_now;
    if(!(curr_fo == ((struct finalizable_object *)NULL)))
      GC_finalize_now = (struct finalizable_object *)curr_fo->prolog.next;

    do
      if(!(GC_need_to_lock == 0))
        pthread_mutex_unlock(&GC_allocate_ml);

    while((_Bool)0);
    if(!(curr_fo == ((struct finalizable_object *)NULL)))
    {
      curr_fo->prolog.next = (struct hash_chain_entry *)0;
      curr_fo->fo_fn((void *)(char *)curr_fo->prolog.hidden_key, (void *)curr_fo->fo_client_data);
      curr_fo->fo_client_data = ((char *)NULL);
      GC_invoke_finalizers$$1$$count = GC_invoke_finalizers$$1$$count + 1;
    }

  }

  if(!(GC_invoke_finalizers$$1$$count == 0) && !(bytes_freed_before == GC_arrays._bytes_freed))
  {
    do
      if(!(GC_need_to_lock == 0))
      {
        signed int return_value_pthread_mutex_trylock$2;
        return_value_pthread_mutex_trylock$2=pthread_mutex_trylock(&GC_allocate_ml);
        if(!(return_value_pthread_mutex_trylock$2 == 0))
          GC_lock();

      }

    while((_Bool)0);
    GC_arrays._finalizer_bytes_freed = GC_arrays._finalizer_bytes_freed + (GC_arrays._bytes_freed - bytes_freed_before);
    do
      if(!(GC_need_to_lock == 0))
        pthread_mutex_unlock(&GC_allocate_ml);

    while((_Bool)0);
  }

  return GC_invoke_finalizers$$1$$count;
}

// GC_is_black_listed
// file ./include/private/gc_priv.h line 1713
struct hblk * GC_is_black_listed(struct hblk *h, unsigned long int len)
{
  unsigned long int index = (unsigned long int)h >> (unsigned long int)12 & ((unsigned long int)1 << 18) - (unsigned long int)1;
  unsigned long int i;
  unsigned long int nblocks;
  if(GC_all_interior_pointers == 0)
  {
    _Bool tmp_if_expr$1;
    if(!((1ul & GC_old_normal_bl[(signed long int)(index >> 6ul)] >> (63ul & index)) == 0ul))
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = (GC_incomplete_normal_bl[(signed long int)(index >> (unsigned long int)6)] >> (index & (unsigned long int)0x3f) & (unsigned long int)1) != 0ul ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$1)
      return h + (signed long int)1;

  }

  nblocks = len >> (unsigned long int)12;
  i = (unsigned long int)0;
  do
  {
    _Bool tmp_if_expr$3;
    if(GC_old_stack_bl[(signed long int)(index >> 6ul)] == 0ul)
      tmp_if_expr$3 = GC_incomplete_stack_bl[(signed long int)(index >> (unsigned long int)6)] == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$3 = (_Bool)0;
    if(tmp_if_expr$3)
      i = i + ((unsigned long int)64 - (index & (unsigned long int)0x3f));

    else
    {
      _Bool tmp_if_expr$2;
      if(!((1ul & GC_old_stack_bl[(signed long int)(index >> 6ul)] >> (63ul & index)) == 0ul))
        tmp_if_expr$2 = (_Bool)1;

      else
        tmp_if_expr$2 = (GC_incomplete_stack_bl[(signed long int)(index >> (unsigned long int)6)] >> (index & (unsigned long int)0x3f) & (unsigned long int)1) != 0ul ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$2)
        return h + (signed long int)i + (signed long int)1;

      i = i + 1ul;
    }
    if(i >= nblocks)
      break;

    index = (unsigned long int)(h + (signed long int)i) >> (unsigned long int)12 & ((unsigned long int)1 << 18) - (unsigned long int)1;
  }
  while((_Bool)1);
  return ((struct hblk *)NULL);
}

// GC_is_disabled
// file misc.c line 1733
extern signed int GC_is_disabled(void)
{
  return (signed int)(GC_dont_gc != 0);
}

// GC_is_heap_ptr
// file misc.c line 462
extern signed int GC_is_heap_ptr(const void *p)
{
  struct bi *bi;
  do
  {
    unsigned long int hi = (unsigned long int)p >> (unsigned long int)10 + (unsigned long int)12;
    struct bi *_bi = GC_arrays._top_index[(signed long int)(hi & (unsigned long int)((1 << 11) - 1))];
    for( ; !(_bi->key == hi); _bi = _bi->hash_link)
      if(_bi == GC_arrays._all_nils)
        break;

    bi = _bi;
  }
  while((_Bool)0);
  return (signed int)(bi->index[(signed long int)((unsigned long int)p >> (unsigned long int)12 & (unsigned long int)((1 << 10) - 1))] != ((struct hblkhdr *)NULL));
}

// GC_is_marked
// file ./include/private/../gc_mark.h line 245
extern signed int GC_is_marked(const void *p)
{
  struct hblk *h = (struct hblk *)((unsigned long int)p & ~((unsigned long int)(1 << 12) - (unsigned long int)1));
  struct hblkhdr *hhdr;
  hhdr=GC_find_header((char *)h);
  unsigned long int bit_no = (unsigned long int)((unsigned int)((char *)p - (char *)h) >> 4);
  return (signed int)hhdr->_mark_byte_union._hb_marks[(signed long int)bit_no];
}

// GC_is_valid_displacement
// file ptr_chck.c line 117
extern void * GC_is_valid_displacement(void *p)
{
  struct hblkhdr *hhdr;
  unsigned long int pdispl;
  unsigned long int offset;
  struct hblk *h;
  unsigned long int sz;
  if((signed long int)GC_is_initialized == 0l)
    GC_init();

  hhdr=GC_find_header((char *)(unsigned long int)p);
  if(hhdr == ((struct hblkhdr *)NULL))
    return p;

  else
  {
    h = (struct hblk *)((unsigned long int)p & ~((unsigned long int)(1 << 12) - (unsigned long int)1));
    if(!(GC_all_interior_pointers == 0))
      while(!((unsigned long int)hhdr >= 4096ul))
      {
        h = (struct hblk *)h - (signed long int)(unsigned long int)hhdr;
        hhdr=GC_find_header((char *)h);
      }

    if((unsigned long int)hhdr >= 4096ul)
    {
      sz = hhdr->hb_sz;
      pdispl = (unsigned long int)p & (unsigned long int)(1 << 12) - (unsigned long int)1;
      offset = pdispl % sz;
      _Bool tmp_if_expr$1;
      if(sz >= 2049ul && (unsigned long int)p >= sz + (unsigned long int)h)
        tmp_if_expr$1 = (_Bool)1;

      else
        tmp_if_expr$1 = !(GC_arrays._valid_offsets[(signed long int)offset] != 0) ? (_Bool)1 : (_Bool)0;
      if(!((unsigned long int)(h + 1l) >= sz + (unsigned long int)p + -offset) || tmp_if_expr$1)
        goto fail;

      return p;
    }

    else
    {

    fail:
      ;
      GC_is_valid_displacement_print_proc((void *)(char *)p);
      return p;
    }
  }
}

// GC_is_visible
// file ptr_chck.c line 187
extern void * GC_is_visible(void *p)
{
  struct hblkhdr *hhdr;
  void *return_value_GC_base$1;
  if((7ul & (unsigned long int)p) == 0ul)
  {
    if((signed long int)GC_is_initialized == 0l)
      GC_init();

    hhdr=GC_find_header((char *)(unsigned long int)p);
    _Bool tmp_if_expr$2;
    if(!(hhdr == ((struct hblkhdr *)NULL)))
    {
      return_value_GC_base$1=GC_base(p);
      tmp_if_expr$2 = return_value_GC_base$1 == NULL ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$2 = (_Bool)0;
    if(tmp_if_expr$2)
      goto fail;

    else
      return p;
  }


fail:
  ;
  GC_is_visible_print_proc((void *)(char *)p);
  return p;
}

// GC_linux_main_stack_base
// file os_dep.c line 1071
char * GC_linux_main_stack_base(void)
{
  char stat_buf[4096l];
  signed int f;
  unsigned long int result;
  signed int i;
  signed int buf_offset = 0;
  signed int len;
  const unsigned short int **return_value___ctype_b_loc$2;
  signed int tmp_post$3;
  const unsigned short int **return_value___ctype_b_loc$4;
  signed int tmp_post$5;
  const unsigned short int **return_value___ctype_b_loc$6;
  if(!(__libc_stack_end == ((char *)NULL)))
    return __libc_stack_end;

  else
  {
    f=open("/proc/self/stat", 00);
    if(!(f >= 0))
    {
      GC_on_abort("Couldn't read /proc/self/stat");
      abort();
    }

    signed long int return_value_read$1;
    return_value_read$1=read(f, (void *)stat_buf, (unsigned long int)4096);
    len = (signed int)return_value_read$1;
    close(f);
    i = 0;
    for( ; !(i >= 27); i = i + 1)
    {
      while(!(buf_offset >= len))
      {
        return_value___ctype_b_loc$2=__ctype_b_loc();
        tmp_post$3 = buf_offset;
        buf_offset = buf_offset + 1;
        if((8192 & (signed int)(*return_value___ctype_b_loc$2)[(signed long int)(signed int)stat_buf[(signed long int)tmp_post$3]]) == 0)
          break;

      }
      while(!(buf_offset >= len))
      {
        return_value___ctype_b_loc$4=__ctype_b_loc();
        tmp_post$5 = buf_offset;
        buf_offset = buf_offset + 1;
        if(!((8192 & (signed int)(*return_value___ctype_b_loc$4)[(signed long int)(signed int)stat_buf[(signed long int)tmp_post$5]]) == 0))
          break;

      }
    }
    for( ; !(buf_offset >= len); buf_offset = buf_offset + 1)
    {
      return_value___ctype_b_loc$6=__ctype_b_loc();
      if((8192 & (signed int)(*return_value___ctype_b_loc$6)[(signed long int)(signed int)stat_buf[(signed long int)buf_offset]]) == 0)
        break;

    }
    i = 0;
    for( ; !(buf_offset + i >= len); i = i + 1)
    {
      const unsigned short int **return_value___ctype_b_loc$7;
      return_value___ctype_b_loc$7=__ctype_b_loc();
      if((2048 & (signed int)(*return_value___ctype_b_loc$7)[(signed long int)(signed int)stat_buf[(signed long int)(buf_offset + i)]]) == 0)
        break;

    }
    if(buf_offset + i >= len)
    {
      GC_on_abort("Could not parse /proc/self/stat");
      abort();
    }

    stat_buf[(signed long int)(buf_offset + i)] = (char)0;
    unsigned long int return_value_strtoul$8;
    return_value_strtoul$8=strtoul(&stat_buf[(signed long int)buf_offset], (char ** restrict )(void *)0, 10);
    result = (unsigned long int)return_value_strtoul$8;
    if(!((7ul & result) == 0ul) || !(result >= 1048576ul))
    {
      GC_on_abort("Absurd stack bottom value");
      abort();
    }

    return (char *)result;
  }
}

// GC_lock
// file ./include/private/gc_locks.h line 182
void GC_lock(void)
{
  if(GC_nprocs == 1 || !(GC_collecting == 0))
    pthread_mutex_lock(&GC_allocate_ml);

  else
    GC_generic_lock(&GC_allocate_ml);
}

// GC_log_printf
// file ./include/private/gc_priv.h line 2104
extern void GC_log_printf(const char *format, ...)
{
  char buf[1025l];
  do
  {
    void **args = (void **)&format;
    buf[(signed long int)(sizeof(char [1025l]) /*1025ul*/  - (unsigned long int)1)] = (char)0x15;
    vsnprintf(buf, sizeof(char [1025l]) /*1025ul*/  - (unsigned long int)1, format, args);
    args = ((void **)NULL);
    if(!((signed int)buf[1024l] == 0x15))
    {
      GC_on_abort("GC_printf clobbered stack");
      abort();
    }

  }
  while((_Bool)0);
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(buf);
  signed int return_value_GC_write$2;
  return_value_GC_write$2=GC_write(GC_log, buf, return_value_strlen$1);
  if(!(return_value_GC_write$2 >= 0))
  {
    GC_on_abort("write to GC log failed");
    abort();
  }

}

// GC_lookup_thread
// file pthread_support.c line 596
struct GC_Thread_Rep * GC_lookup_thread(unsigned long int id)
{
  signed int hv = (signed int)((unsigned long int)id % (unsigned long int)256);
  struct GC_Thread_Rep *p = GC_threads[(signed long int)hv];
  for( ; !(p == ((struct GC_Thread_Rep *)NULL)); p = p->next)
    if(p->id == id)
      break;

  return p;
}

// GC_make_array_descriptor
// file typd_mlc.c line 207
signed int GC_make_array_descriptor(unsigned long int nelements, unsigned long int size, unsigned long int descriptor, unsigned long int *simple_d, union ComplexDescriptor **complex_d, struct LeafDescriptor *leaf)
{
  struct LeafDescriptor *beginning;
  void *return_value_GC_malloc_atomic$3;
  struct LeafDescriptor *GC_make_array_descriptor$$1$$3$$2$$1$$2$$beginning;
  void *return_value_GC_malloc_atomic$4;
  if((3ul & descriptor) == 0ul)
  {
    if(descriptor == size)
    {
      *simple_d = nelements * descriptor;
      return 0;
    }

    if(!(descriptor == 0ul))
      goto __CPROVER_DUMP_L2;

    *simple_d = (unsigned long int)0;
    return 0;
  }

  else
  {

  __CPROVER_DUMP_L2:
    ;
    if(!(nelements >= 51ul))
    {
      if(!(nelements >= 2ul))
      {
        if(nelements == 1ul)
        {
          *simple_d = descriptor;
          return 0;
        }

        else
        {
          *simple_d = (unsigned long int)0;
          return 0;
        }
      }

    }

    else
      if((7ul & size) == 0ul && !((3ul & descriptor) == 2ul) && !(size >= 32ul))
      {
        signed int result;
        unsigned long int return_value_GC_double_descr$1;
        return_value_GC_double_descr$1=GC_double_descr(descriptor, size >> 3);
        result=GC_make_array_descriptor(nelements / (unsigned long int)2, (unsigned long int)2 * size, return_value_GC_double_descr$1, simple_d, complex_d, leaf);
        if((1ul & nelements) == 0ul)
          return result;

        else
        {
          struct LeafDescriptor *one_element;
          void *return_value_GC_malloc_atomic$2;
          return_value_GC_malloc_atomic$2=GC_malloc_atomic(sizeof(struct LeafDescriptor) /*32ul*/ );
          one_element = (struct LeafDescriptor *)return_value_GC_malloc_atomic$2;
          if(one_element == ((struct LeafDescriptor *)NULL) || result == -1)
            return -1;

          one_element->ld_tag = (unsigned long int)1;
          one_element->ld_size = size;
          one_element->ld_nelements = (unsigned long int)1;
          one_element->ld_descriptor = descriptor;
          switch(result)
          {
            case 0:
            {
              return_value_GC_malloc_atomic$3=GC_malloc_atomic(sizeof(struct LeafDescriptor) /*32ul*/ );
              beginning = (struct LeafDescriptor *)return_value_GC_malloc_atomic$3;
              if(beginning == ((struct LeafDescriptor *)NULL))
                return -1;

              beginning->ld_tag = (unsigned long int)1;
              beginning->ld_size = size;
              beginning->ld_nelements = (unsigned long int)1;
              beginning->ld_descriptor = *simple_d;
              *complex_d=GC_make_sequence_descriptor((union ComplexDescriptor *)beginning, (union ComplexDescriptor *)one_element);
              break;
            }
            case 1:
            {
              return_value_GC_malloc_atomic$4=GC_malloc_atomic(sizeof(struct LeafDescriptor) /*32ul*/ );
              GC_make_array_descriptor$$1$$3$$2$$1$$2$$beginning = (struct LeafDescriptor *)return_value_GC_malloc_atomic$4;
              if(GC_make_array_descriptor$$1$$3$$2$$1$$2$$beginning == ((struct LeafDescriptor *)NULL))
                return -1;

              GC_make_array_descriptor$$1$$3$$2$$1$$2$$beginning->ld_tag = (unsigned long int)1;
              GC_make_array_descriptor$$1$$3$$2$$1$$2$$beginning->ld_size = leaf->ld_size;
              GC_make_array_descriptor$$1$$3$$2$$1$$2$$beginning->ld_nelements = leaf->ld_nelements;
              GC_make_array_descriptor$$1$$3$$2$$1$$2$$beginning->ld_descriptor = leaf->ld_descriptor;
              *complex_d=GC_make_sequence_descriptor((union ComplexDescriptor *)GC_make_array_descriptor$$1$$3$$2$$1$$2$$beginning, (union ComplexDescriptor *)one_element);
              break;
            }
            case 2:
              *complex_d=GC_make_sequence_descriptor(*complex_d, (union ComplexDescriptor *)one_element);
          }
          return 2;
        }
      }

    leaf->ld_size = size;
    leaf->ld_nelements = nelements;
    leaf->ld_descriptor = descriptor;
    return 1;
  }
}

// GC_make_closure
// file dbg_mlc.c line 1047
void * GC_make_closure(void (*fn)(void *, void *), void *data)
{
  struct closure *result;
  void *return_value_GC_malloc$1;
  return_value_GC_malloc$1=GC_malloc(sizeof(struct closure) /*16ul*/ );
  result = (struct closure *)return_value_GC_malloc$1;
  if(!(result == ((struct closure *)NULL)))
  {
    result->cl_fn = fn;
    result->cl_data = data;
  }

  return (void *)result;
}

// GC_make_descriptor
// file typd_mlc.c line 534
extern unsigned long int GC_make_descriptor(const unsigned long int *bm, unsigned long int len)
{
  signed long int last_set_bit = (signed long int)(len - (unsigned long int)1);
  unsigned long int result;
  signed long int i;
  if((signed long int)GC_explicit_typing_initialized == 0l)
    GC_init_explicit_typing();

  for( ; last_set_bit >= 0l; last_set_bit = last_set_bit - 1l)
    if(!((1ul & bm[(signed long int)((unsigned long int)last_set_bit / sizeof(unsigned long int) * 8 /*64ul*/ )] >> (unsigned long int)last_set_bit % sizeof(unsigned long int) * 8 /*64ul*/ ) == 0ul))
      break;

  if(!(last_set_bit >= 0l))
    return (unsigned long int)0;

  else
  {
    signed int all_bits_set = 1;
    i = (signed long int)0;
    for( ; !(i >= last_set_bit); i = i + 1l)
      if((1ul & bm[(signed long int)((unsigned long int)i / sizeof(unsigned long int) * 8 /*64ul*/ )] >> (unsigned long int)i % sizeof(unsigned long int) * 8 /*64ul*/ ) == 0ul)
      {
        all_bits_set = 0;
        break;
      }

    if(!(all_bits_set == 0))
      return (unsigned long int)(last_set_bit + (signed long int)1 << 3 | (signed long int)0);

    else
      if(!((unsigned long int)last_set_bit >= 62ul))
      {
        result = (unsigned long int)1 << (unsigned long int)64 - (unsigned long int)1;
        i = last_set_bit - (signed long int)1;
        for( ; i >= 0l; i = i - 1l)
        {
          result = result >> 1;
          if(!((1ul & bm[(signed long int)((unsigned long int)i / sizeof(unsigned long int) * 8 /*64ul*/ )] >> (unsigned long int)i % sizeof(unsigned long int) * 8 /*64ul*/ ) == 0ul))
            result = result | (unsigned long int)1 << (unsigned long int)64 - (unsigned long int)1;

        }
        result = result | (unsigned long int)1;
        return result;
      }

      else
      {
        signed long int index;
        index=GC_add_ext_descriptor(bm, (unsigned long int)last_set_bit + (unsigned long int)1);
        if(index == -1l)
          return (unsigned long int)(last_set_bit + (signed long int)1 << 3 | (signed long int)0);

        result = ((unsigned long int)index << 6 | (unsigned long int)GC_typed_mark_proc_index) << 2 | (unsigned long int)2;
        return result;
      }
  }
}

// GC_make_disappearing_links_disappear
// file finalize.c line 702
static inline void GC_make_disappearing_links_disappear(struct dl_hashtbl_s *dl_hashtbl)
{
  struct disappearing_link *curr;
  struct disappearing_link *prev;
  struct disappearing_link *next;
  char *real_ptr;
  char *real_link;
  unsigned long int i;
  unsigned long int dl_size;
  signed int tmp_if_expr$1;
  if(dl_hashtbl->log_size == -1l)
    tmp_if_expr$1 = 0;

  else
    tmp_if_expr$1 = 1 << dl_hashtbl->log_size;
  dl_size = (unsigned long int)tmp_if_expr$1;
  i = (unsigned long int)0;
  for( ; !(i >= dl_size); i = i + 1ul)
  {
    curr = dl_hashtbl->head[(signed long int)i];
    prev = (struct disappearing_link *)(void *)0;
    while(!(curr == ((struct disappearing_link *)NULL)))
    {
      real_ptr = (char *)(void *)~((unsigned long int)curr->dl_hidden_obj);
      real_link = (char *)(void *)~((unsigned long int)curr->prolog.hidden_key);
      signed int return_value_GC_is_marked$2;
      return_value_GC_is_marked$2=GC_is_marked((const void *)real_ptr);
      if(return_value_GC_is_marked$2 == 0)
      {
        *((unsigned long int *)real_link) = (unsigned long int)0;
        GC_clear_mark_bit((const void *)curr);
        next = (struct disappearing_link *)curr->prolog.next;
        if(prev == ((struct disappearing_link *)NULL))
          dl_hashtbl->head[(signed long int)i] = next;

        else
          prev->prolog.next = (struct hash_chain_entry *)next;
        GC_clear_mark_bit((const void *)curr);
        dl_hashtbl->entries = dl_hashtbl->entries - 1ul;
        curr = next;
      }

      else
      {
        prev = curr;
        curr = (struct disappearing_link *)curr->prolog.next;
      }
    }
  }
}

// GC_make_disappearing_links_disappear$link1
// file finalize.c line 702
static inline void GC_make_disappearing_links_disappear$link1(struct dl_hashtbl_s *dl_hashtbl$link1)
{
  struct disappearing_link *curr$link1;
  struct disappearing_link *prev$link1;
  struct disappearing_link *next$link1;
  char *real_ptr$link1;
  char *real_link$link1;
  unsigned long int i$link1;
  unsigned long int dl_size$link1;
  signed int tmp_if_expr$1$link1;
  if(dl_hashtbl$link1->log_size == -1l)
    tmp_if_expr$1$link1 = 0;

  else
    tmp_if_expr$1$link1 = 1 << dl_hashtbl$link1->log_size;
  dl_size$link1 = (unsigned long int)tmp_if_expr$1$link1;
  i$link1 = (unsigned long int)0;
  for( ; !(i$link1 >= dl_size$link1); i$link1 = i$link1 + 1ul)
  {
    curr$link1 = dl_hashtbl$link1->head[(signed long int)i$link1];
    prev$link1 = (struct disappearing_link *)(void *)0;
    while(!(curr$link1 == ((struct disappearing_link *)NULL)))
    {
      real_ptr$link1 = (char *)(void *)~((unsigned long int)curr$link1->dl_hidden_obj);
      real_link$link1 = (char *)(void *)~((unsigned long int)curr$link1->prolog.hidden_key);
      signed int return_value_GC_is_marked$2$link1;
      return_value_GC_is_marked$2$link1=GC_is_marked((const void *)real_ptr$link1);
      if(return_value_GC_is_marked$2$link1 == 0)
      {
        *((unsigned long int *)real_link$link1) = (unsigned long int)0;
        GC_clear_mark_bit((const void *)curr$link1);
        next$link1 = (struct disappearing_link *)curr$link1->prolog.next;
        if(prev$link1 == ((struct disappearing_link *)NULL))
          dl_hashtbl$link1->head[(signed long int)i$link1] = next$link1;

        else
          prev$link1->prolog.next = (struct hash_chain_entry *)next$link1;
        GC_clear_mark_bit((const void *)curr$link1);
        dl_hashtbl$link1->entries = dl_hashtbl$link1->entries - 1ul;
        curr$link1 = next$link1;
      }

      else
      {
        prev$link1 = curr$link1;
        curr$link1 = (struct disappearing_link *)curr$link1->prolog.next;
      }
    }
  }
}

// GC_make_sequence_descriptor
// file typd_mlc.c line 303
union ComplexDescriptor * GC_make_sequence_descriptor(union ComplexDescriptor *first, union ComplexDescriptor *second)
{
  struct SequenceDescriptor *result;
  void *return_value_GC_malloc$1;
  return_value_GC_malloc$1=GC_malloc(sizeof(struct SequenceDescriptor) /*24ul*/ );
  result = (struct SequenceDescriptor *)return_value_GC_malloc$1;
  if(!(result == ((struct SequenceDescriptor *)NULL)))
  {
    result->sd_tag = (unsigned long int)3;
    result->sd_first = first;
    result->sd_second = second;
  }

  return (union ComplexDescriptor *)result;
}

// GC_malloc
// file ./include/private/../gc.h line 412
extern void * GC_malloc(unsigned long int bytes)
{
  unsigned long int granules = bytes + (unsigned long int)((16 - 1) + GC_all_interior_pointers) >> 4;
  void *tsd;
  void *result;
  void **tiny_fl;
  void *k = GC_thread_key;
  if(k == NULL)
  {
    void *return_value_GC_core_malloc$1;
    return_value_GC_core_malloc$1=GC_core_malloc(bytes);
    return return_value_GC_core_malloc$1;
  }

  tsd = k;
  tiny_fl = ((struct thread_local_freelists *)tsd)->normal_freelists;
  do
  {
    if(granules >= 25ul)
      result=GC_core_malloc(bytes);

    else
    {
      void **my_fl = tiny_fl + (signed long int)granules;
      void *my_entry = *my_fl;
      void *next;
      while(!((unsigned long int)my_entry >= 283ul))
        if(!((unsigned long int)my_entry + 18446744073709551615ul >= 256ul))
        {
          *my_fl = (void *)((char *)my_entry + (signed long int)granules + (signed long int)1);
          result=GC_core_malloc(bytes);
          goto out;
        }

        else
        {
          GC_generic_malloc_many(granules == (unsigned long int)0 ? (unsigned long int)16 : granules * (unsigned long int)16, 1, my_fl);
          my_entry = *my_fl;
          if(my_entry == NULL)
          {
            void * (*return_value_GC_get_oom_fn$2)(unsigned long int);
            return_value_GC_get_oom_fn$2=GC_get_oom_fn();
            result=return_value_GC_get_oom_fn$2(granules * (unsigned long int)16);
          }

        }
      next = *((void **)my_entry);
      result = (void *)my_entry;
      *my_fl = next;
      *((void **)result) = NULL;
    }

  out:
    ;
  }
  while((_Bool)0);
  return result;
}

// GC_malloc_atomic
// file ./include/private/../gc.h line 414
extern void * GC_malloc_atomic(unsigned long int bytes)
{
  unsigned long int granules = bytes + (unsigned long int)((16 - 1) + GC_all_interior_pointers) >> 4;
  void *tsd;
  void *result;
  void **tiny_fl;
  void *k = GC_thread_key;
  if(k == NULL)
  {
    void *return_value_GC_core_malloc_atomic$1;
    return_value_GC_core_malloc_atomic$1=GC_core_malloc_atomic(bytes);
    return return_value_GC_core_malloc_atomic$1;
  }

  tsd = k;
  tiny_fl = ((struct thread_local_freelists *)tsd)->ptrfree_freelists;
  do
  {
    if(granules >= 25ul)
      result=GC_core_malloc_atomic(bytes);

    else
    {
      void **my_fl = tiny_fl + (signed long int)granules;
      void *my_entry = *my_fl;
      void *next;
      while(!((unsigned long int)my_entry >= 283ul))
        if(!((unsigned long int)my_entry + 18446744073709551615ul >= 256ul))
        {
          *my_fl = (void *)((char *)my_entry + (signed long int)granules + (signed long int)1);
          result=GC_core_malloc_atomic(bytes);
          goto out;
        }

        else
        {
          GC_generic_malloc_many(granules == (unsigned long int)0 ? (unsigned long int)16 : granules * (unsigned long int)16, 0, my_fl);
          my_entry = *my_fl;
          if(my_entry == NULL)
          {
            void * (*return_value_GC_get_oom_fn$2)(unsigned long int);
            return_value_GC_get_oom_fn$2=GC_get_oom_fn();
            result=return_value_GC_get_oom_fn$2(granules * (unsigned long int)16);
          }

        }
      next = *((void **)my_entry);
      result = (void *)my_entry;
      *my_fl = next;
    }

  out:
    ;
  }
  while((_Bool)0);
  return result;
}

// GC_malloc_atomic_ignore_off_page
// file ./include/private/../gc.h line 745
extern void * GC_malloc_atomic_ignore_off_page(unsigned long int lb)
{
  void *return_value_GC_generic_malloc_ignore_off_page$1;
  return_value_GC_generic_malloc_ignore_off_page$1=GC_generic_malloc_ignore_off_page(lb, 0);
  return (void *)return_value_GC_generic_malloc_ignore_off_page$1;
}

// GC_malloc_atomic_uncollectable
// file ./include/private/../gc.h line 758
extern void * GC_malloc_atomic_uncollectable(unsigned long int lb)
{
  void *op;
  void **opp;
  unsigned long int lg;
  if(2048ul + -((unsigned long int)GC_all_interior_pointers) >= lb || !(lb >= 2048ul))
  {
    if(!(GC_all_interior_pointers == 0) && !(lb == 0ul))
      lb = lb - 1ul;

    lg = GC_arrays._size_map[(signed long int)lb];
    opp = &GC_arrays._auobjfreelist[(signed long int)lg];
    do
      if(!(GC_need_to_lock == 0))
      {
        signed int return_value_pthread_mutex_trylock$1;
        return_value_pthread_mutex_trylock$1=pthread_mutex_trylock(&GC_allocate_ml);
        if(!(return_value_pthread_mutex_trylock$1 == 0))
          GC_lock();

      }

    while((_Bool)0);
    op = *opp;
    if(!(op == NULL))
    {
      *opp = *((void **)op);
      *((void **)op) = NULL;
      GC_arrays._bytes_allocd = GC_arrays._bytes_allocd + (lg << 4);
      GC_non_gc_bytes = GC_non_gc_bytes + (lg << 4);
      do
        if(!(GC_need_to_lock == 0))
          pthread_mutex_unlock(&GC_allocate_ml);

      while((_Bool)0);
    }

    else
    {
      do
        if(!(GC_need_to_lock == 0))
          pthread_mutex_unlock(&GC_allocate_ml);

      while((_Bool)0);
      void *return_value_GC_generic_malloc$2;
      return_value_GC_generic_malloc$2=GC_generic_malloc(lb, 3);
      op = (void *)(char *)return_value_GC_generic_malloc$2;
    }
    return (void *)op;
  }

  else
  {
    struct hblkhdr *hhdr;
    void *return_value_GC_generic_malloc$3;
    return_value_GC_generic_malloc$3=GC_generic_malloc(lb, 3);
    op = (void *)(char *)return_value_GC_generic_malloc$3;
    if(op == NULL)
      return NULL;

    hhdr=GC_find_header((char *)op);
    do
      if(!(GC_need_to_lock == 0))
      {
        signed int return_value_pthread_mutex_trylock$4;
        return_value_pthread_mutex_trylock$4=pthread_mutex_trylock(&GC_allocate_ml);
        if(!(return_value_pthread_mutex_trylock$4 == 0))
          GC_lock();

      }

    while((_Bool)0);
    hhdr->_mark_byte_union._hb_marks[(signed long int)0] = (char)1;
    hhdr->hb_n_marks = (volatile unsigned long int)1;
    do
      if(!(GC_need_to_lock == 0))
        pthread_mutex_unlock(&GC_allocate_ml);

    while((_Bool)0);
    return (void *)op;
  }
}

// GC_malloc_explicitly_typed
// file typd_mlc.c line 584
extern void * GC_malloc_explicitly_typed(unsigned long int lb, unsigned long int d)
{
  char *op;
  char **opp;
  unsigned long int lg;
  lb = lb + (sizeof(unsigned long int) /*8ul*/  - (unsigned long int)GC_all_interior_pointers);
  if(2048ul + -((unsigned long int)GC_all_interior_pointers) >= lb || !(lb >= 2048ul))
  {
    lg = GC_arrays._size_map[(signed long int)lb];
    opp = &GC_eobjfreelist[(signed long int)lg];
    do
      if(!(GC_need_to_lock == 0))
      {
        signed int return_value_pthread_mutex_trylock$1;
        return_value_pthread_mutex_trylock$1=pthread_mutex_trylock(&GC_allocate_ml);
        if(!(return_value_pthread_mutex_trylock$1 == 0))
          GC_lock();

      }

    while((_Bool)0);
    op = *opp;
    if(op == ((char *)NULL))
    {
      do
        if(!(GC_need_to_lock == 0))
          pthread_mutex_unlock(&GC_allocate_ml);

      while((_Bool)0);
      void *return_value_GC_generic_malloc$2;
      return_value_GC_generic_malloc$2=GC_generic_malloc((unsigned long int)lb, GC_explicit_kind);
      void *return_value_GC_clear_stack$3;
      return_value_GC_clear_stack$3=GC_clear_stack(return_value_GC_generic_malloc$2);
      op = (char *)return_value_GC_clear_stack$3;
      if(op == ((char *)NULL))
        return NULL;

      lg = GC_arrays._size_map[(signed long int)lb];
    }

    else
    {
      *opp = (char *)*((void **)op);
      *((void **)op) = NULL;
      GC_arrays._bytes_allocd = GC_arrays._bytes_allocd + (lg << 4);
      do
        if(!(GC_need_to_lock == 0))
          pthread_mutex_unlock(&GC_allocate_ml);

      while((_Bool)0);
    }
    ((unsigned long int *)op)[(signed long int)((lg << 1) - (unsigned long int)1)] = d;
  }

  else
  {
    void *return_value_GC_generic_malloc$4;
    return_value_GC_generic_malloc$4=GC_generic_malloc((unsigned long int)lb, GC_explicit_kind);
    void *return_value_GC_clear_stack$5;
    return_value_GC_clear_stack$5=GC_clear_stack(return_value_GC_generic_malloc$4);
    op = (char *)return_value_GC_clear_stack$5;
    if(!(op == ((char *)NULL)))
    {
      unsigned long int return_value_GC_size$6;
      return_value_GC_size$6=GC_size((const void *)op);
      lg = return_value_GC_size$6 >> 4;
      ((unsigned long int *)op)[(signed long int)((lg << 1) - (unsigned long int)1)] = d;
    }

  }
  return (void *)op;
}

// GC_malloc_explicitly_typed_ignore_off_page
// file typd_mlc.c line 622
extern void * GC_malloc_explicitly_typed_ignore_off_page(unsigned long int lb, unsigned long int d)
{
  char *op;
  char **opp;
  unsigned long int lg;
  lb = lb + (sizeof(unsigned long int) /*8ul*/  - (unsigned long int)GC_all_interior_pointers);
  if(2048ul + -((unsigned long int)GC_all_interior_pointers) >= lb || !(lb >= 2048ul))
  {
    lg = GC_arrays._size_map[(signed long int)lb];
    opp = &GC_eobjfreelist[(signed long int)lg];
    do
      if(!(GC_need_to_lock == 0))
      {
        signed int return_value_pthread_mutex_trylock$1;
        return_value_pthread_mutex_trylock$1=pthread_mutex_trylock(&GC_allocate_ml);
        if(!(return_value_pthread_mutex_trylock$1 == 0))
          GC_lock();

      }

    while((_Bool)0);
    op = *opp;
    if(op == ((char *)NULL))
    {
      do
        if(!(GC_need_to_lock == 0))
          pthread_mutex_unlock(&GC_allocate_ml);

      while((_Bool)0);
      void *return_value_GC_generic_malloc_ignore_off_page$2;
      return_value_GC_generic_malloc_ignore_off_page$2=GC_generic_malloc_ignore_off_page(lb, GC_explicit_kind);
      void *return_value_GC_clear_stack$3;
      return_value_GC_clear_stack$3=GC_clear_stack(return_value_GC_generic_malloc_ignore_off_page$2);
      op = (char *)return_value_GC_clear_stack$3;
      if(op == ((char *)NULL))
        return NULL;

      lg = GC_arrays._size_map[(signed long int)lb];
    }

    else
    {
      *opp = (char *)*((void **)op);
      *((void **)op) = NULL;
      GC_arrays._bytes_allocd = GC_arrays._bytes_allocd + (lg << 4);
      do
        if(!(GC_need_to_lock == 0))
          pthread_mutex_unlock(&GC_allocate_ml);

      while((_Bool)0);
    }
    ((unsigned long int *)op)[(signed long int)((lg << 1) - (unsigned long int)1)] = d;
  }

  else
  {
    void *return_value_GC_generic_malloc_ignore_off_page$4;
    return_value_GC_generic_malloc_ignore_off_page$4=GC_generic_malloc_ignore_off_page(lb, GC_explicit_kind);
    void *return_value_GC_clear_stack$5;
    return_value_GC_clear_stack$5=GC_clear_stack(return_value_GC_generic_malloc_ignore_off_page$4);
    op = (char *)return_value_GC_clear_stack$5;
    if(!(op == ((char *)NULL)))
    {
      unsigned long int return_value_GC_size$6;
      return_value_GC_size$6=GC_size((const void *)op);
      lg = return_value_GC_size$6 >> 4;
      ((unsigned long int *)op)[(signed long int)((lg << 1) - (unsigned long int)1)] = d;
    }

  }
  return (void *)op;
}

// GC_malloc_ignore_off_page
// file ./include/private/../gc.h line 743
extern void * GC_malloc_ignore_off_page(unsigned long int lb)
{
  void *return_value_GC_generic_malloc_ignore_off_page$1;
  return_value_GC_generic_malloc_ignore_off_page$1=GC_generic_malloc_ignore_off_page(lb, 1);
  return (void *)return_value_GC_generic_malloc_ignore_off_page$1;
}

// GC_malloc_many
// file mallocx.c line 438
extern void * GC_malloc_many(unsigned long int lb)
{
  void *result;
  GC_generic_malloc_many((lb + (unsigned long int)GC_all_interior_pointers + (unsigned long int)16) - (unsigned long int)1 & (unsigned long int)~(16 - 1), 1, &result);
  return result;
}

// GC_malloc_stubborn
// file stubborn.c line 43
extern void * GC_malloc_stubborn(unsigned long int lb)
{
  void *return_value_GC_malloc$1;
  return_value_GC_malloc$1=GC_malloc(lb);
  return return_value_GC_malloc$1;
}

// GC_malloc_uncollectable
// file ./include/private/../gc.h line 419
extern void * GC_malloc_uncollectable(unsigned long int lb)
{
  void *op;
  void **opp;
  unsigned long int lg;
  if(2048ul + -((unsigned long int)GC_all_interior_pointers) >= lb || !(lb >= 2048ul))
  {
    if(!(GC_all_interior_pointers == 0) && !(lb == 0ul))
      lb = lb - 1ul;

    lg = GC_arrays._size_map[(signed long int)lb];
    opp = &GC_arrays._uobjfreelist[(signed long int)lg];
    do
      if(!(GC_need_to_lock == 0))
      {
        signed int return_value_pthread_mutex_trylock$1;
        return_value_pthread_mutex_trylock$1=pthread_mutex_trylock(&GC_allocate_ml);
        if(!(return_value_pthread_mutex_trylock$1 == 0))
          GC_lock();

      }

    while((_Bool)0);
    op = *opp;
    if(!(op == NULL))
    {
      *opp = *((void **)op);
      *((void **)op) = NULL;
      GC_arrays._bytes_allocd = GC_arrays._bytes_allocd + (lg << 4);
      GC_non_gc_bytes = GC_non_gc_bytes + (lg << 4);
      do
        if(!(GC_need_to_lock == 0))
          pthread_mutex_unlock(&GC_allocate_ml);

      while((_Bool)0);
    }

    else
    {
      do
        if(!(GC_need_to_lock == 0))
          pthread_mutex_unlock(&GC_allocate_ml);

      while((_Bool)0);
      void *return_value_GC_generic_malloc$2;
      return_value_GC_generic_malloc$2=GC_generic_malloc((unsigned long int)lb, 2);
      op = (void *)(char *)return_value_GC_generic_malloc$2;
    }
    return (void *)op;
  }

  else
  {
    struct hblkhdr *hhdr;
    void *return_value_GC_generic_malloc$3;
    return_value_GC_generic_malloc$3=GC_generic_malloc((unsigned long int)lb, 2);
    op = (void *)(char *)return_value_GC_generic_malloc$3;
    if(op == NULL)
      return NULL;

    hhdr=GC_find_header((char *)op);
    do
      if(!(GC_need_to_lock == 0))
      {
        signed int return_value_pthread_mutex_trylock$4;
        return_value_pthread_mutex_trylock$4=pthread_mutex_trylock(&GC_allocate_ml);
        if(!(return_value_pthread_mutex_trylock$4 == 0))
          GC_lock();

      }

    while((_Bool)0);
    hhdr->_mark_byte_union._hb_marks[(signed long int)0] = (char)1;
    hhdr->hb_n_marks = (volatile unsigned long int)1;
    do
      if(!(GC_need_to_lock == 0))
        pthread_mutex_unlock(&GC_allocate_ml);

    while((_Bool)0);
    return (void *)op;
  }
}

// GC_mark_and_push
// file ./include/private/../gc_mark.h line 145
extern struct GC_ms_entry * GC_mark_and_push(void *obj, struct GC_ms_entry *mark_stack_ptr, struct GC_ms_entry *mark_stack_limit, void **src)
{
  struct hblkhdr *hhdr;
  do
  {
    struct hblkhdr **_ha;
    do
    {
      struct bi *bi;
      do
      {
        unsigned long int hi = (unsigned long int)obj >> (unsigned long int)10 + (unsigned long int)12;
        struct bi *_bi = GC_arrays._top_index[(signed long int)(hi & (unsigned long int)((1 << 11) - 1))];
        for( ; !(_bi->key == hi); _bi = _bi->hash_link)
          if(_bi == GC_arrays._all_nils)
            break;

        bi = _bi;
      }
      while((_Bool)0);
      _ha = &bi->index[(signed long int)((unsigned long int)obj >> (unsigned long int)12 & (unsigned long int)((1 << 10) - 1))];
    }
    while((_Bool)0);
    hhdr = *_ha;
  }
  while((_Bool)0);
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$2;
  void *return_value_GC_base$1;
  if(!((unsigned long int)hhdr >= 4096ul))
  {
    if(GC_all_interior_pointers == 0)
      tmp_if_expr$2 = (_Bool)1;

    else
    {
      return_value_GC_base$1=GC_base(obj);
      hhdr=GC_find_header((char *)return_value_GC_base$1);
      tmp_if_expr$2 = (struct hblkhdr *)(void *)0 == hhdr ? (_Bool)1 : (_Bool)0;
    }
    tmp_if_expr$3 = tmp_if_expr$2 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$3 = (_Bool)0;
  _Bool tmp_if_expr$4;
  if(tmp_if_expr$3)
    tmp_if_expr$4 = (_Bool)1;

  else
    tmp_if_expr$4 = (signed long int)(((signed int)hhdr->hb_flags & 4) != 0) != 0l ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$4)
  {
    if(!(GC_all_interior_pointers == 0))
      GC_add_to_black_list_stack((unsigned long int)obj);

    else
      GC_add_to_black_list_normal((unsigned long int)obj);
    return mark_stack_ptr;
  }

  else
  {
    do
    {
      unsigned long int displ = (unsigned long int)obj & (unsigned long int)(1 << 12) - (unsigned long int)1;
      unsigned long int gran_displ = displ >> 4;
      unsigned long int gran_offset = (unsigned long int)hhdr->hb_map[(signed long int)gran_displ];
      unsigned long int byte_offset = displ & (unsigned long int)(16 - 1);
      char *base = (char *)obj;
      if(!((byte_offset | gran_offset) == 0ul))
      {
        if(!(hhdr->hb_large_block == 0))
        {
          unsigned long int obj_displ;
          base = (char *)hhdr->hb_block;
          obj_displ = (unsigned long int)((char *)obj - base);
          if(obj_displ == displ)
          {
            if(GC_arrays._valid_offsets[(signed long int)obj_displ] == 0)
            {
              if(!(GC_all_interior_pointers == 0))
                GC_add_to_black_list_stack((unsigned long int)obj);

              else
                GC_add_to_black_list_normal((unsigned long int)obj);
              break;
            }

          }

          gran_displ = (unsigned long int)0;
        }

        else
        {
          unsigned long int GC_mark_and_push$$1$$3$$1$$2$$obj_displ = (gran_offset << 4) + byte_offset;
          if(GC_arrays._valid_offsets[(signed long int)GC_mark_and_push$$1$$3$$1$$2$$obj_displ] == 0)
          {
            if(!(GC_all_interior_pointers == 0))
              GC_add_to_black_list_stack((unsigned long int)obj);

            else
              GC_add_to_black_list_normal((unsigned long int)obj);
            break;
          }

          gran_displ = gran_displ - gran_offset;
          base = base - (signed long int)GC_mark_and_push$$1$$3$$1$$2$$obj_displ;
        }
      }

      do
      {
        char *mark_byte_addr = (char *)hhdr->_mark_byte_union._hb_marks + (signed long int)gran_displ;
        if(!(*mark_byte_addr == 0))
          goto was_marked;

        *mark_byte_addr = (char)1;
      }
      while((_Bool)0);
      unsigned long int return_value_AO_load$5;
      return_value_AO_load$5=AO_load$link1(&hhdr->hb_n_marks);
      AO_store(&hhdr->hb_n_marks, return_value_AO_load$5 + (unsigned long int)1);
      do
      {
        unsigned long int _descr = hhdr->hb_descr;
        if(!(_descr == 0ul))
        {
          mark_stack_ptr = mark_stack_ptr + 1l;
          if((unsigned long int)mark_stack_ptr >= (unsigned long int)mark_stack_limit)
            mark_stack_ptr=GC_signal_mark_stack_overflow(mark_stack_ptr);

          mark_stack_ptr->mse_start = base;
          mark_stack_ptr->mse_descr.w = _descr;
        }

      }
      while((_Bool)0);
    }
    while((_Bool)0);

  was_marked:
    ;
    return mark_stack_ptr;
  }
}

// GC_mark_and_push_stack
// file mark.c line 1393
void GC_mark_and_push_stack(char *p)
{
  struct hblkhdr *hhdr;
  char *r = p;
  do
  {
    struct hblkhdr **_ha;
    do
    {
      struct bi *bi;
      do
      {
        unsigned long int hi = (unsigned long int)p >> (unsigned long int)10 + (unsigned long int)12;
        struct bi *_bi = GC_arrays._top_index[(signed long int)(hi & (unsigned long int)((1 << 11) - 1))];
        for( ; !(_bi->key == hi); _bi = _bi->hash_link)
          if(_bi == GC_arrays._all_nils)
            break;

        bi = _bi;
      }
      while((_Bool)0);
      _ha = &bi->index[(signed long int)((unsigned long int)p >> (unsigned long int)12 & (unsigned long int)((1 << 10) - 1))];
    }
    while((_Bool)0);
    hhdr = *_ha;
  }
  while((_Bool)0);
  if(!((unsigned long int)hhdr >= 4096ul))
  {
    if(!(hhdr == ((struct hblkhdr *)NULL)))
    {
      void *return_value_GC_base$1;
      return_value_GC_base$1=GC_base((void *)p);
      r = (char *)return_value_GC_base$1;
      hhdr=GC_find_header((char *)r);
    }

    if(!(hhdr == ((struct hblkhdr *)NULL)))
      goto __CPROVER_DUMP_L7;

    GC_add_to_black_list_stack((unsigned long int)p);
  }

  else
  {

  __CPROVER_DUMP_L7:
    ;
    if(!((4 & (signed int)hhdr->hb_flags) == 0))
    {
      if(!(GC_all_interior_pointers == 0))
        GC_add_to_black_list_stack((unsigned long int)p);

      else
        GC_add_to_black_list_normal((unsigned long int)p);
    }

    else
      do
      {
        unsigned long int displ = (unsigned long int)r & (unsigned long int)(1 << 12) - (unsigned long int)1;
        unsigned long int gran_displ = displ >> 4;
        unsigned long int gran_offset = (unsigned long int)hhdr->hb_map[(signed long int)gran_displ];
        unsigned long int byte_offset = displ & (unsigned long int)(16 - 1);
        char *base = r;
        if(!((byte_offset | gran_offset) == 0ul))
        {
          if(!(hhdr->hb_large_block == 0))
          {
            unsigned long int obj_displ;
            base = (char *)hhdr->hb_block;
            obj_displ = (unsigned long int)((char *)r - base);
            gran_displ = (unsigned long int)0;
          }

          else
          {
            unsigned long int GC_mark_and_push_stack$$1$$4$$1$$2$$obj_displ = (gran_offset << 4) + byte_offset;
            gran_displ = gran_displ - gran_offset;
            base = base - (signed long int)GC_mark_and_push_stack$$1$$4$$1$$2$$obj_displ;
          }
        }

        do
        {
          char *mark_byte_addr = (char *)hhdr->_mark_byte_union._hb_marks + (signed long int)gran_displ;
          if(!(*mark_byte_addr == 0))
            goto mark_and_push_exit;

          *mark_byte_addr = (char)1;
        }
        while((_Bool)0);
        unsigned long int return_value_AO_load$2;
        return_value_AO_load$2=AO_load$link1(&hhdr->hb_n_marks);
        AO_store(&hhdr->hb_n_marks, return_value_AO_load$2 + (unsigned long int)1);
        do
        {
          unsigned long int _descr = hhdr->hb_descr;
          if(!(_descr == 0ul))
          {
            GC_arrays._mark_stack_top = GC_arrays._mark_stack_top + 1l;
            if((unsigned long int)GC_arrays._mark_stack_top >= (unsigned long int)GC_arrays._mark_stack_limit)
              GC_arrays._mark_stack_top=GC_signal_mark_stack_overflow(GC_arrays._mark_stack_top);

            GC_arrays._mark_stack_top->mse_start = base;
            GC_arrays._mark_stack_top->mse_descr.w = _descr;
          }

        }
        while((_Bool)0);
      }
      while((_Bool)0);
  }

mark_and_push_exit:
  ;
}

// GC_mark_from
// file ./include/private/gc_pmark.h line 400
struct GC_ms_entry * GC_mark_from(struct GC_ms_entry *mark_stack_top, struct GC_ms_entry *mark_stack, struct GC_ms_entry *mark_stack_limit)
{
  signed long int credit = (signed long int)(unsigned long int)(1 << 12);
  char *current_p;
  unsigned long int current;
  char *limit;
  unsigned long int descr;
  char *greatest_ha = (char *)GC_greatest_plausible_heap_addr;
  char *least_ha = (char *)GC_least_plausible_heap_addr;
  struct hce hdr_cache[8l];
  GC_objects_are_marked = 1;
  memset((void *)hdr_cache, 0, (unsigned long int)sizeof(struct hce [8l]) /*128ul*/ );
  unsigned long int tag;
  while(((char *)mark_stack_top - (char *)mark_stack | credit) >= 0l)
  {
    current_p = mark_stack_top->mse_start;
    descr = mark_stack_top->mse_descr.w;

  retry:
    ;
    while((_Bool)1)
    {
      if((18446744073709550595ul & descr) == 0ul)
        goto __CPROVER_DUMP_L35;

      tag = descr & (unsigned long int)((1 << 2) - 1);
      if(!(tag == 0ul))
      {
        if(tag == 1ul)
          goto __CPROVER_DUMP_L5;

        if(tag == 2ul)
          goto __CPROVER_DUMP_L27;

        if(tag == 3ul)
          goto __CPROVER_DUMP_L28;

        break;
      }

      if(descr >= 2049ul && !(GC_parallel == 0) && !((unsigned long int)mark_stack_top >= (unsigned long int)(mark_stack_limit + -1l)))
      {
        signed int new_size = (signed int)(descr / (unsigned long int)2 & ~(sizeof(unsigned long int) /*8ul*/  - (unsigned long int)1));
        mark_stack_top->mse_start = current_p;
        mark_stack_top->mse_descr.w = (unsigned long int)new_size + sizeof(unsigned long int) /*8ul*/ ;
        mark_stack_top = mark_stack_top + 1l;
        current_p = current_p + (signed long int)new_size;
        descr = descr - (unsigned long int)new_size;
        goto retry;
      }

      limit = current_p + (signed long int)(128 - 1 << 3);
      mark_stack_top->mse_start = limit;
      mark_stack_top->mse_descr.w = descr - (unsigned long int)(128 - 1 << 3);
      limit = limit + (signed long int)(sizeof(unsigned long int) /*8ul*/  - (unsigned long int)8);
      goto __CPROVER_DUMP_L34;

    __CPROVER_DUMP_L5:
      ;
      mark_stack_top = mark_stack_top - 1l;
      descr = descr & (unsigned long int)~((1 << 2) - 1);
      credit = credit - (signed long int)((unsigned long int)64 / (unsigned long int)2 << 3);
      for( ; !(descr == 0ul); current_p = current_p + (signed long int)sizeof(unsigned long int) /*8ul*/ )
      {
        if(!((signed long int)descr >= 0l))
        {
          current = *((unsigned long int *)current_p);
          if(current >= (unsigned long int)least_ha && !(current >= (unsigned long int)greatest_ha))
            do
            {
              struct hblkhdr *my_hhdr;
              do
              {
                struct hce *hce = hdr_cache + (signed long int)((unsigned long int)(char *)current >> (unsigned long int)12 & (unsigned long int)(8 - 1));
                if(hce->block_addr == current >> 12ul)
                  my_hhdr = hce->hce_hdr;

                else
                {
                  my_hhdr=GC_header_cache_miss((char *)current, hce);
                  if(my_hhdr == ((struct hblkhdr *)NULL))
                    goto exit1;

                }
              }
              while((_Bool)0);
              do
              {
                unsigned long int GC_mark_from$$1$$1$$1$$1$$2$$1$$1$$1$$2$$displ = (unsigned long int)(char *)current & (unsigned long int)(1 << 12) - (unsigned long int)1;
                unsigned long int GC_mark_from$$1$$1$$1$$1$$2$$1$$1$$1$$2$$gran_displ = GC_mark_from$$1$$1$$1$$1$$2$$1$$1$$1$$2$$displ >> 4;
                unsigned long int GC_mark_from$$1$$1$$1$$1$$2$$1$$1$$1$$2$$gran_offset = (unsigned long int)my_hhdr->hb_map[(signed long int)GC_mark_from$$1$$1$$1$$1$$2$$1$$1$$1$$2$$gran_displ];
                unsigned long int GC_mark_from$$1$$1$$1$$1$$2$$1$$1$$1$$2$$byte_offset = GC_mark_from$$1$$1$$1$$1$$2$$1$$1$$1$$2$$displ & (unsigned long int)(16 - 1);
                char *GC_mark_from$$1$$1$$1$$1$$2$$1$$1$$1$$2$$base = (char *)current;
                if(!((GC_mark_from$$1$$1$$1$$1$$2$$1$$1$$1$$2$$byte_offset | GC_mark_from$$1$$1$$1$$1$$2$$1$$1$$1$$2$$gran_offset) == 0ul))
                {
                  if(!(my_hhdr->hb_large_block == 0))
                  {
                    unsigned long int GC_mark_from$$1$$1$$1$$1$$2$$1$$1$$1$$2$$1$$1$$obj_displ;
                    GC_mark_from$$1$$1$$1$$1$$2$$1$$1$$1$$2$$base = (char *)my_hhdr->hb_block;
                    GC_mark_from$$1$$1$$1$$1$$2$$1$$1$$1$$2$$1$$1$$obj_displ = (unsigned long int)((char *)current - GC_mark_from$$1$$1$$1$$1$$2$$1$$1$$1$$2$$base);
                    if(GC_mark_from$$1$$1$$1$$1$$2$$1$$1$$1$$2$$1$$1$$obj_displ == GC_mark_from$$1$$1$$1$$1$$2$$1$$1$$1$$2$$displ)
                    {
                      if(GC_arrays._valid_offsets[(signed long int)GC_mark_from$$1$$1$$1$$1$$2$$1$$1$$1$$2$$1$$1$$obj_displ] == 0)
                      {
                        if(!(GC_all_interior_pointers == 0))
                          GC_add_to_black_list_stack((unsigned long int)(char *)current);

                        else
                          GC_add_to_black_list_normal((unsigned long int)(char *)current);
                        break;
                      }

                    }

                    GC_mark_from$$1$$1$$1$$1$$2$$1$$1$$1$$2$$gran_displ = (unsigned long int)0;
                  }

                  else
                  {
                    unsigned long int GC_mark_from$$1$$1$$1$$1$$2$$1$$1$$1$$2$$1$$2$$obj_displ = (GC_mark_from$$1$$1$$1$$1$$2$$1$$1$$1$$2$$gran_offset << 4) + GC_mark_from$$1$$1$$1$$1$$2$$1$$1$$1$$2$$byte_offset;
                    if(GC_arrays._valid_offsets[(signed long int)GC_mark_from$$1$$1$$1$$1$$2$$1$$1$$1$$2$$1$$2$$obj_displ] == 0)
                    {
                      if(!(GC_all_interior_pointers == 0))
                        GC_add_to_black_list_stack((unsigned long int)(char *)current);

                      else
                        GC_add_to_black_list_normal((unsigned long int)(char *)current);
                      break;
                    }

                    GC_mark_from$$1$$1$$1$$1$$2$$1$$1$$1$$2$$gran_displ = GC_mark_from$$1$$1$$1$$1$$2$$1$$1$$1$$2$$gran_displ - GC_mark_from$$1$$1$$1$$1$$2$$1$$1$$1$$2$$gran_offset;
                    GC_mark_from$$1$$1$$1$$1$$2$$1$$1$$1$$2$$base = GC_mark_from$$1$$1$$1$$1$$2$$1$$1$$1$$2$$base - (signed long int)GC_mark_from$$1$$1$$1$$1$$2$$1$$1$$1$$2$$1$$2$$obj_displ;
                  }
                }

                do
                {
                  char *mark_byte_addr = (char *)my_hhdr->_mark_byte_union._hb_marks + (signed long int)GC_mark_from$$1$$1$$1$$1$$2$$1$$1$$1$$2$$gran_displ;
                  if(!(*mark_byte_addr == 0))
                    goto exit1;

                  *mark_byte_addr = (char)1;
                }
                while((_Bool)0);
                unsigned long int return_value_AO_load$1;
                return_value_AO_load$1=AO_load$link1(&my_hhdr->hb_n_marks);
                AO_store(&my_hhdr->hb_n_marks, return_value_AO_load$1 + (unsigned long int)1);
                do
                {
                  unsigned long int _descr = my_hhdr->hb_descr;
                  if(!(_descr == 0ul))
                  {
                    mark_stack_top = mark_stack_top + 1l;
                    if((unsigned long int)mark_stack_top >= (unsigned long int)mark_stack_limit)
                      mark_stack_top=GC_signal_mark_stack_overflow(mark_stack_top);

                    mark_stack_top->mse_start = GC_mark_from$$1$$1$$1$$1$$2$$1$$1$$1$$2$$base;
                    mark_stack_top->mse_descr.w = _descr;
                  }

                }
                while((_Bool)0);
              }
              while((_Bool)0);

            exit1:
              ;
            }
            while((_Bool)0);

        }

        descr = descr << 1;
      }
      goto __CPROVER_DUMP_L79;

    __CPROVER_DUMP_L27:
      ;
      mark_stack_top = mark_stack_top - 1l;
      credit = credit - (signed long int)100;
      mark_stack_top=GC_arrays._mark_procs[(signed long int)(descr >> 2 & (unsigned long int)((1 << 6) - 1))]((unsigned long int *)current_p, mark_stack_top, mark_stack_limit, descr >> 2 + 6);

    __CPROVER_DUMP_L28:
      ;
      if((signed long int)descr >= 0l)
        descr = *((unsigned long int *)((current_p + (signed long int)descr) - (signed long int)3));

      else
      {
        char *type_descr = *((char **)current_p);
        if(type_descr == ((char *)NULL))
        {
          mark_stack_top = mark_stack_top - 1l;
          goto __CPROVER_DUMP_L79;
        }

        descr = *((unsigned long int *)(type_descr - (signed long int)(descr + (unsigned long int)(0x10 - 3))));
      }
      if(descr == 0ul)
      {
        mark_stack_top = mark_stack_top - 1l;
        goto __CPROVER_DUMP_L79;
      }

    }
    limit = ((char *)NULL);
    if(!((signed long int)GC_current_warn_proc == -1l))
    {
      GC_on_abort("GC_mark_from: bad state");
      abort();
    }


  __CPROVER_DUMP_L34:
    ;
    goto __CPROVER_DUMP_L36;

  __CPROVER_DUMP_L35:
    ;
    mark_stack_top = mark_stack_top - 1l;
    if(descr >= sizeof(unsigned long int) /*8ul*/ )
    {
      limit = current_p + (signed long int)(unsigned long int)descr;

    __CPROVER_DUMP_L36:
      ;
      credit = credit - (limit - current_p);
      limit = limit - (signed long int)sizeof(unsigned long int) /*8ul*/ ;
      unsigned long int deferred;
      do
      {
        deferred = *((unsigned long int *)limit);
        limit = limit - (signed long int)8;
        if(deferred >= (unsigned long int)least_ha && !(deferred >= (unsigned long int)greatest_ha))
          break;

        if(!((unsigned long int)limit >= (unsigned long int)current_p))
          goto next_object;

        deferred = *((unsigned long int *)limit);
        limit = limit - (signed long int)8;
        if(deferred >= (unsigned long int)least_ha && !(deferred >= (unsigned long int)greatest_ha))
          break;

        if(!((unsigned long int)limit >= (unsigned long int)current_p))
          goto next_object;

      }
      while((_Bool)1);
      for( ; (unsigned long int)limit >= (unsigned long int)current_p; current_p = current_p + (signed long int)8)
      {
        current = *((unsigned long int *)current_p);
        if(current >= (unsigned long int)least_ha && !(current >= (unsigned long int)greatest_ha))
          do
          {
            struct hblkhdr *GC_mark_from$$1$$1$$3$$2$$1$$1$$my_hhdr;
            do
            {
              struct hce *GC_mark_from$$1$$1$$3$$2$$1$$1$$1$$hce = hdr_cache + (signed long int)((unsigned long int)(char *)current >> (unsigned long int)12 & (unsigned long int)(8 - 1));
              if(GC_mark_from$$1$$1$$3$$2$$1$$1$$1$$hce->block_addr == current >> 12ul)
                GC_mark_from$$1$$1$$3$$2$$1$$1$$my_hhdr = GC_mark_from$$1$$1$$3$$2$$1$$1$$1$$hce->hce_hdr;

              else
              {
                GC_mark_from$$1$$1$$3$$2$$1$$1$$my_hhdr=GC_header_cache_miss((char *)current, GC_mark_from$$1$$1$$3$$2$$1$$1$$1$$hce);
                if(GC_mark_from$$1$$1$$3$$2$$1$$1$$my_hhdr == ((struct hblkhdr *)NULL))
                  goto exit2;

              }
            }
            while((_Bool)0);
            do
            {
              unsigned long int displ = (unsigned long int)(char *)current & (unsigned long int)(1 << 12) - (unsigned long int)1;
              unsigned long int gran_displ = displ >> 4;
              unsigned long int gran_offset = (unsigned long int)GC_mark_from$$1$$1$$3$$2$$1$$1$$my_hhdr->hb_map[(signed long int)gran_displ];
              unsigned long int GC_mark_from$$1$$1$$3$$2$$1$$1$$2$$byte_offset = displ & (unsigned long int)(16 - 1);
              char *GC_mark_from$$1$$1$$3$$2$$1$$1$$2$$base = (char *)current;
              if(!((GC_mark_from$$1$$1$$3$$2$$1$$1$$2$$byte_offset | gran_offset) == 0ul))
              {
                if(!(GC_mark_from$$1$$1$$3$$2$$1$$1$$my_hhdr->hb_large_block == 0))
                {
                  unsigned long int obj_displ;
                  GC_mark_from$$1$$1$$3$$2$$1$$1$$2$$base = (char *)GC_mark_from$$1$$1$$3$$2$$1$$1$$my_hhdr->hb_block;
                  obj_displ = (unsigned long int)((char *)current - GC_mark_from$$1$$1$$3$$2$$1$$1$$2$$base);
                  if(obj_displ == displ)
                  {
                    if(GC_arrays._valid_offsets[(signed long int)obj_displ] == 0)
                    {
                      if(!(GC_all_interior_pointers == 0))
                        GC_add_to_black_list_stack((unsigned long int)(char *)current);

                      else
                        GC_add_to_black_list_normal((unsigned long int)(char *)current);
                      break;
                    }

                  }

                  gran_displ = (unsigned long int)0;
                }

                else
                {
                  unsigned long int GC_mark_from$$1$$1$$3$$2$$1$$1$$2$$1$$2$$obj_displ = (gran_offset << 4) + GC_mark_from$$1$$1$$3$$2$$1$$1$$2$$byte_offset;
                  if(GC_arrays._valid_offsets[(signed long int)GC_mark_from$$1$$1$$3$$2$$1$$1$$2$$1$$2$$obj_displ] == 0)
                  {
                    if(!(GC_all_interior_pointers == 0))
                      GC_add_to_black_list_stack((unsigned long int)(char *)current);

                    else
                      GC_add_to_black_list_normal((unsigned long int)(char *)current);
                    break;
                  }

                  gran_displ = gran_displ - gran_offset;
                  GC_mark_from$$1$$1$$3$$2$$1$$1$$2$$base = GC_mark_from$$1$$1$$3$$2$$1$$1$$2$$base - (signed long int)GC_mark_from$$1$$1$$3$$2$$1$$1$$2$$1$$2$$obj_displ;
                }
              }

              do
              {
                char *GC_mark_from$$1$$1$$3$$2$$1$$1$$2$$2$$mark_byte_addr = (char *)GC_mark_from$$1$$1$$3$$2$$1$$1$$my_hhdr->_mark_byte_union._hb_marks + (signed long int)gran_displ;
                if(!(*GC_mark_from$$1$$1$$3$$2$$1$$1$$2$$2$$mark_byte_addr == 0))
                  goto exit2;

                *GC_mark_from$$1$$1$$3$$2$$1$$1$$2$$2$$mark_byte_addr = (char)1;
              }
              while((_Bool)0);
              unsigned long int return_value_AO_load$2;
              return_value_AO_load$2=AO_load$link1(&GC_mark_from$$1$$1$$3$$2$$1$$1$$my_hhdr->hb_n_marks);
              AO_store(&GC_mark_from$$1$$1$$3$$2$$1$$1$$my_hhdr->hb_n_marks, return_value_AO_load$2 + (unsigned long int)1);
              do
              {
                unsigned long int GC_mark_from$$1$$1$$3$$2$$1$$1$$2$$3$$_descr = GC_mark_from$$1$$1$$3$$2$$1$$1$$my_hhdr->hb_descr;
                if(!(GC_mark_from$$1$$1$$3$$2$$1$$1$$2$$3$$_descr == 0ul))
                {
                  mark_stack_top = mark_stack_top + 1l;
                  if((unsigned long int)mark_stack_top >= (unsigned long int)mark_stack_limit)
                    mark_stack_top=GC_signal_mark_stack_overflow(mark_stack_top);

                  mark_stack_top->mse_start = GC_mark_from$$1$$1$$3$$2$$1$$1$$2$$base;
                  mark_stack_top->mse_descr.w = GC_mark_from$$1$$1$$3$$2$$1$$1$$2$$3$$_descr;
                }

              }
              while((_Bool)0);
            }
            while((_Bool)0);

          exit2:
            ;
          }
          while((_Bool)0);

      }
      do
      {
        struct hblkhdr *GC_mark_from$$1$$1$$3$$3$$my_hhdr;
        do
        {
          struct hce *GC_mark_from$$1$$1$$3$$3$$1$$hce = hdr_cache + (signed long int)((unsigned long int)(char *)deferred >> (unsigned long int)12 & (unsigned long int)(8 - 1));
          if(GC_mark_from$$1$$1$$3$$3$$1$$hce->block_addr == deferred >> 12ul)
            GC_mark_from$$1$$1$$3$$3$$my_hhdr = GC_mark_from$$1$$1$$3$$3$$1$$hce->hce_hdr;

          else
          {
            GC_mark_from$$1$$1$$3$$3$$my_hhdr=GC_header_cache_miss((char *)deferred, GC_mark_from$$1$$1$$3$$3$$1$$hce);
            if(GC_mark_from$$1$$1$$3$$3$$my_hhdr == ((struct hblkhdr *)NULL))
              goto exit4;

          }
        }
        while((_Bool)0);
        do
        {
          unsigned long int GC_mark_from$$1$$1$$3$$3$$2$$displ = (unsigned long int)(char *)deferred & (unsigned long int)(1 << 12) - (unsigned long int)1;
          unsigned long int GC_mark_from$$1$$1$$3$$3$$2$$gran_displ = GC_mark_from$$1$$1$$3$$3$$2$$displ >> 4;
          unsigned long int GC_mark_from$$1$$1$$3$$3$$2$$gran_offset = (unsigned long int)GC_mark_from$$1$$1$$3$$3$$my_hhdr->hb_map[(signed long int)GC_mark_from$$1$$1$$3$$3$$2$$gran_displ];
          unsigned long int byte_offset = GC_mark_from$$1$$1$$3$$3$$2$$displ & (unsigned long int)(16 - 1);
          char *base = (char *)deferred;
          if(!((byte_offset | GC_mark_from$$1$$1$$3$$3$$2$$gran_offset) == 0ul))
          {
            if(!(GC_mark_from$$1$$1$$3$$3$$my_hhdr->hb_large_block == 0))
            {
              unsigned long int GC_mark_from$$1$$1$$3$$3$$2$$1$$1$$obj_displ;
              base = (char *)GC_mark_from$$1$$1$$3$$3$$my_hhdr->hb_block;
              GC_mark_from$$1$$1$$3$$3$$2$$1$$1$$obj_displ = (unsigned long int)((char *)deferred - base);
              if(GC_mark_from$$1$$1$$3$$3$$2$$1$$1$$obj_displ == GC_mark_from$$1$$1$$3$$3$$2$$displ)
              {
                if(GC_arrays._valid_offsets[(signed long int)GC_mark_from$$1$$1$$3$$3$$2$$1$$1$$obj_displ] == 0)
                {
                  if(!(GC_all_interior_pointers == 0))
                    GC_add_to_black_list_stack((unsigned long int)(char *)deferred);

                  else
                    GC_add_to_black_list_normal((unsigned long int)(char *)deferred);
                  break;
                }

              }

              GC_mark_from$$1$$1$$3$$3$$2$$gran_displ = (unsigned long int)0;
            }

            else
            {
              unsigned long int GC_mark_from$$1$$1$$3$$3$$2$$1$$2$$obj_displ = (GC_mark_from$$1$$1$$3$$3$$2$$gran_offset << 4) + byte_offset;
              if(GC_arrays._valid_offsets[(signed long int)GC_mark_from$$1$$1$$3$$3$$2$$1$$2$$obj_displ] == 0)
              {
                if(!(GC_all_interior_pointers == 0))
                  GC_add_to_black_list_stack((unsigned long int)(char *)deferred);

                else
                  GC_add_to_black_list_normal((unsigned long int)(char *)deferred);
                break;
              }

              GC_mark_from$$1$$1$$3$$3$$2$$gran_displ = GC_mark_from$$1$$1$$3$$3$$2$$gran_displ - GC_mark_from$$1$$1$$3$$3$$2$$gran_offset;
              base = base - (signed long int)GC_mark_from$$1$$1$$3$$3$$2$$1$$2$$obj_displ;
            }
          }

          do
          {
            char *GC_mark_from$$1$$1$$3$$3$$2$$2$$mark_byte_addr = (char *)GC_mark_from$$1$$1$$3$$3$$my_hhdr->_mark_byte_union._hb_marks + (signed long int)GC_mark_from$$1$$1$$3$$3$$2$$gran_displ;
            if(!(*GC_mark_from$$1$$1$$3$$3$$2$$2$$mark_byte_addr == 0))
              goto exit4;

            *GC_mark_from$$1$$1$$3$$3$$2$$2$$mark_byte_addr = (char)1;
          }
          while((_Bool)0);
          unsigned long int return_value_AO_load$3;
          return_value_AO_load$3=AO_load$link1(&GC_mark_from$$1$$1$$3$$3$$my_hhdr->hb_n_marks);
          AO_store(&GC_mark_from$$1$$1$$3$$3$$my_hhdr->hb_n_marks, return_value_AO_load$3 + (unsigned long int)1);
          do
          {
            unsigned long int GC_mark_from$$1$$1$$3$$3$$2$$3$$_descr = GC_mark_from$$1$$1$$3$$3$$my_hhdr->hb_descr;
            if(!(GC_mark_from$$1$$1$$3$$3$$2$$3$$_descr == 0ul))
            {
              mark_stack_top = mark_stack_top + 1l;
              if((unsigned long int)mark_stack_top >= (unsigned long int)mark_stack_limit)
                mark_stack_top=GC_signal_mark_stack_overflow(mark_stack_top);

              mark_stack_top->mse_start = base;
              mark_stack_top->mse_descr.w = GC_mark_from$$1$$1$$3$$3$$2$$3$$_descr;
            }

          }
          while((_Bool)0);
        }
        while((_Bool)0);

      exit4:
        ;
      }
      while((_Bool)0);
    }


  next_object:
    ;

  __CPROVER_DUMP_L79:
    ;
  }
  return mark_stack_top;
}

// GC_mark_init
// file mark.c line 1238
void GC_mark_init(void)
{
  alloc_mark_stack((unsigned long int)1 * (unsigned long int)(1 << 12));
}

// GC_mark_local
// file mark.c line 1014
void GC_mark_local(struct GC_ms_entry *local_mark_stack, signed int id)
{
  struct GC_ms_entry *my_first_nonempty;
  GC_acquire_mark_lock();
  GC_active_count = GC_active_count + 1u;
  unsigned long int return_value_AO_load$1;
  return_value_AO_load$1=AO_load$link1(&GC_first_nonempty);
  my_first_nonempty = (struct GC_ms_entry *)return_value_AO_load$1;
  if(GC_print_stats == 2)
    GC_log_printf("Starting mark helper %lu\n", (unsigned long int)id);

  GC_release_mark_lock();
  unsigned long int return_value_AO_load$4;
  unsigned long int return_value_AO_load$5;
  do
  {
    unsigned long int n_on_stack;
    unsigned int n_to_get;
    struct GC_ms_entry *my_top;
    struct GC_ms_entry *local_top;
    struct GC_ms_entry *global_first_nonempty;
    unsigned long int return_value_AO_load$2;
    return_value_AO_load$2=AO_load$link1(&GC_first_nonempty);
    global_first_nonempty = (struct GC_ms_entry *)return_value_AO_load$2;
    if(!((unsigned long int)my_first_nonempty >= (unsigned long int)global_first_nonempty))
      my_first_nonempty = global_first_nonempty;

    else
      if(!((unsigned long int)global_first_nonempty >= (unsigned long int)my_first_nonempty))
        AO_compare_and_swap_full$link1(&GC_first_nonempty, (unsigned long int)global_first_nonempty, (unsigned long int)my_first_nonempty);

    unsigned long int return_value_AO_load_read$3;
    return_value_AO_load_read$3=AO_load_read((volatile unsigned long int *)&GC_arrays._mark_stack_top);
    my_top = (struct GC_ms_entry *)return_value_AO_load_read$3;
    n_on_stack = (unsigned long int)((my_top - my_first_nonempty) + (signed long int)1);
    if(n_on_stack == 0ul)
    {
      GC_acquire_mark_lock();
      my_top = GC_arrays._mark_stack_top;
      n_on_stack = (unsigned long int)((my_top - my_first_nonempty) + (signed long int)1);
      if(n_on_stack == 0ul)
      {
        GC_active_count = GC_active_count - 1u;
        if(GC_active_count == 0u)
          GC_notify_all_marker();

        while(GC_active_count >= 1u)
        {
          return_value_AO_load$4=AO_load$link1(&GC_first_nonempty);
          if((unsigned long int)GC_arrays._mark_stack_top >= return_value_AO_load$4)
            break;

          GC_wait_marker();
        }
        if(GC_active_count == 0u)
        {
          return_value_AO_load$5=AO_load$link1(&GC_first_nonempty);
          if(!((unsigned long int)GC_arrays._mark_stack_top >= return_value_AO_load$5))
          {
            signed int need_to_notify = 0;
            GC_helper_count = GC_helper_count - 1u;
            if(GC_helper_count == 0u)
              need_to_notify = 1;

            if(GC_print_stats == 2)
              GC_log_printf("Finished mark helper %lu\n", (unsigned long int)id);

            GC_release_mark_lock();
            if(!(need_to_notify == 0))
              GC_notify_all_marker();

            break;
          }

        }

        GC_active_count = GC_active_count + 1u;
        GC_release_mark_lock();
        continue;
      }

      else
        GC_release_mark_lock();
    }

    n_to_get = (unsigned int)5;
    if(!(n_on_stack >= 10ul))
      n_to_get = (unsigned int)1;

    local_top=GC_steal_mark_stack(my_first_nonempty, my_top, local_mark_stack, n_to_get, &my_first_nonempty);
    GC_do_local_mark(local_mark_stack, local_top);
  }
  while((_Bool)1);
}

// GC_mark_some
// file ./include/private/gc_priv.h line 1560
signed int GC_mark_some(char *cold_gc_frame)
{
  switch(GC_mark_state)
  {
    case 0:
      break;
    case 1:
    {
      if((unsigned long int)GC_arrays._mark_stack_top >= (unsigned long int)(GC_arrays._mark_stack_limit + -2048l))
      {
        GC_mark_stack_too_small = 1;
        GC_arrays._mark_stack_top=GC_mark_from(GC_arrays._mark_stack_top, GC_arrays._mark_stack, GC_arrays._mark_stack + (signed long int)GC_mark_stack_size);
        break;
      }

      else
      {
        scan_ptr=GC_push_next_marked_dirty(scan_ptr);
        if(scan_ptr == ((struct hblk *)NULL))
        {
          if(!(GC_print_stats == 0))
            GC_log_printf("Marked from %lu dirty pages\n", (unsigned long int)GC_n_rescuing_pages);

          GC_push_roots(0, cold_gc_frame);
          GC_objects_are_marked = 1;
          if(!(GC_mark_state == 5))
            GC_mark_state = 3;

        }

      }
      break;
    }
    case 2:
    {
      if((unsigned long int)GC_arrays._mark_stack_top >= (unsigned long int)(GC_arrays._mark_stack + (signed long int)(GC_mark_stack_size / 4ul)))
      {
        if(!(GC_parallel == 0))
          GC_mark_stack_too_small = 1;

        GC_arrays._mark_stack_top=GC_mark_from(GC_arrays._mark_stack_top, GC_arrays._mark_stack, GC_arrays._mark_stack + (signed long int)GC_mark_stack_size);
        break;
      }

      else
      {
        scan_ptr=GC_push_next_marked_uncollectable(scan_ptr);
        if(scan_ptr == ((struct hblk *)NULL))
        {
          GC_push_roots(1, cold_gc_frame);
          GC_objects_are_marked = 1;
          if(!(GC_mark_state == 5))
            GC_mark_state = 3;

        }

      }
      break;
    }
    case 3:
    {
      if(!(GC_parallel == 0))
      {
        GC_do_parallel_mark();
        GC_arrays._mark_stack_top = GC_arrays._mark_stack - (signed long int)1;
        if(!(GC_mark_stack_too_small == 0))
          alloc_mark_stack((unsigned long int)2 * GC_mark_stack_size);

        if(GC_mark_state == 3)
        {
          GC_mark_state = 0;
          return 1;
        }

        break;
      }

      if((unsigned long int)GC_arrays._mark_stack_top >= (unsigned long int)GC_arrays._mark_stack)
      {
        GC_arrays._mark_stack_top=GC_mark_from(GC_arrays._mark_stack_top, GC_arrays._mark_stack, GC_arrays._mark_stack + (signed long int)GC_mark_stack_size);
        break;
      }

      else
      {
        GC_mark_state = 0;
        if(!(GC_mark_stack_too_small == 0))
          alloc_mark_stack((unsigned long int)2 * GC_mark_stack_size);

        return 1;
      }
    }
    case 5:

    case 4:
    {
      if(GC_objects_are_marked == 0)
      {
        GC_mark_state = 2;
        break;
      }

      if((unsigned long int)GC_arrays._mark_stack_top >= (unsigned long int)GC_arrays._mark_stack)
      {
        GC_arrays._mark_stack_top=GC_mark_from(GC_arrays._mark_stack_top, GC_arrays._mark_stack, GC_arrays._mark_stack + (signed long int)GC_mark_stack_size);
        break;
      }

      if(scan_ptr == ((struct hblk *)NULL) && GC_mark_state == 5)
      {
        if(!(GC_mark_stack_too_small == 0))
          alloc_mark_stack((unsigned long int)2 * GC_mark_stack_size);

        GC_mark_state = 4;
      }

      scan_ptr=GC_push_next_marked(scan_ptr);
      if(scan_ptr == ((struct hblk *)NULL) && GC_mark_state == 4)
      {
        GC_push_roots(1, cold_gc_frame);
        GC_objects_are_marked = 1;
        if(!(GC_mark_state == 5))
          GC_mark_state = 3;

      }

      break;
    }
    default:
      GC_on_abort("GC_mark_some: bad state");
  }
  abort();
  return 0;
}

// GC_mark_thread
// file pthread_support.c line 356
void * GC_mark_thread(void *id)
{
  unsigned long int my_mark_no = (unsigned long int)0;
  signed int cancel_state;
  if((unsigned long int)id == 18446744073709551615ul)
    return NULL;

  else
  {
    do
      pthread_setcancelstate(1, &cancel_state);
    while((_Bool)0);
    marker_sp[(signed long int)(unsigned long int)id]=GC_approx_sp();
    for( ; (_Bool)1; my_mark_no = my_mark_no + 1ul)
    {
      if(!(2ul + GC_mark_no >= my_mark_no) || !(my_mark_no >= GC_mark_no))
        my_mark_no = GC_mark_no;

      GC_help_marker(my_mark_no);
    }
  }
}

// GC_mark_thread_local_fls_for
// file thread_local_alloc.c line 285
void GC_mark_thread_local_fls_for(struct thread_local_freelists *p)
{
  char *q;
  signed int j = 0;
  for( ; !(j >= 25); j = j + 1)
  {
    q = (char *)p->ptrfree_freelists[(signed long int)j];
    if((unsigned long int)q >= 4097ul)
      GC_set_fl_marks(q);

    q = (char *)p->normal_freelists[(signed long int)j];
    if((unsigned long int)q >= 4097ul)
      GC_set_fl_marks(q);

    if(j >= 1)
    {
      q = (char *)p->gcj_freelists[(signed long int)j];
      if((unsigned long int)q >= 4097ul)
        GC_set_fl_marks(q);

    }

    q = (char *)p->finalized_freelists[(signed long int)j];
    if((unsigned long int)q >= 4097ul)
      GC_set_fl_marks(q);

  }
}

// GC_mark_thread_local_free_lists
// file ./include/private/gc_priv.h line 2197
void GC_mark_thread_local_free_lists(void)
{
  signed int i;
  struct GC_Thread_Rep *p;
  i = 0;
  for( ; !(i >= 256); i = i + 1)
  {
    p = GC_threads[(signed long int)i];
    for( ; !(p == ((struct GC_Thread_Rep *)NULL)); p = p->next)
      if((1 & (signed int)p->flags) == 0)
        GC_mark_thread_local_fls_for(&p->tlfs);

  }
}

// GC_max
// file alloc.c line 1132
static inline unsigned long int GC_max(unsigned long int x, unsigned long int y)
{
  return x > y ? x : y;
}

// GC_max$link1
// file alloc.c line 1132
static inline unsigned long int GC_max$link1(unsigned long int x$link1, unsigned long int y$link1)
{
  return x$link1 > y$link1 ? x$link1 : y$link1;
}

// GC_maybe_gc
// file alloc.c line 351
void GC_maybe_gc(void)
{
  signed int return_value_GC_should_collect$2;
  return_value_GC_should_collect$2=GC_should_collect();
  if(!(return_value_GC_should_collect$2 == 0))
  {
    static signed int n_partial_gcs = 0;
    if(GC_incremental == 0)
    {
      GC_try_to_collect_inner(GC_never_stop_func);
      n_partial_gcs = 0;
      goto __CPROVER_DUMP_L10;
    }

    else
    {
      if(!(GC_parallel == 0))
        GC_wait_for_reclaim();

      if(n_partial_gcs >= GC_full_freq || !(GC_need_full_gc == 0))
      {
        if(!(GC_print_stats == 0))
          GC_log_printf("***>Full mark for collection #%lu after %lu allocd bytes\n", (unsigned long int)GC_gc_no + (unsigned long int)1, (unsigned long int)GC_arrays._bytes_allocd);

        GC_promote_black_lists();
        GC_reclaim_all((signed int (*)(void))0, 1);
        GC_notify_full_gc();
        GC_clear_marks();
        n_partial_gcs = 0;
        GC_is_full_gc = 1;
      }

      else
        n_partial_gcs = n_partial_gcs + 1;
    }
    if(!(GC_time_limit == 999999ul))
      GC_start_time=clock();

    signed int return_value_GC_stopped_mark$1;
    return_value_GC_stopped_mark$1=GC_stopped_mark(GC_time_limit == (unsigned long int)999999 ? GC_never_stop_func : GC_timeout_stop_func);
    if(!(return_value_GC_stopped_mark$1 == 0))
      GC_finish_collection();

    else
      if(GC_is_full_gc == 0)
        GC_n_attempts = GC_n_attempts + 1;

  }


__CPROVER_DUMP_L10:
  ;
}

// GC_memalign
// file mallocx.c line 451
extern void * GC_memalign(unsigned long int align, unsigned long int lb)
{
  unsigned long int new_lb;
  unsigned long int offset;
  char *result;
  void *return_value_GC_malloc$1;
  if(!(align >= 17ul))
  {
    return_value_GC_malloc$1=GC_malloc(lb);
    return return_value_GC_malloc$1;
  }

  if(align >= 2048ul || lb >= 2048ul)
  {
    if(align >= 4097ul)
    {
      void * (*return_value_GC_get_oom_fn$2)(unsigned long int);
      return_value_GC_get_oom_fn$2=GC_get_oom_fn();
      void *return_value;
      return_value=return_value_GC_get_oom_fn$2((unsigned long int)(0x7fffffffffffffffL - (signed long int)1024));
      return return_value;
    }

    void *return_value_GC_malloc$3;
    return_value_GC_malloc$3=GC_malloc(lb <= (unsigned long int)(1 << 12) ? (unsigned long int)(1 << 12) : lb);
    return return_value_GC_malloc$3;
  }

  new_lb = (lb + align) - (unsigned long int)1;
  void *return_value_GC_malloc$4;
  return_value_GC_malloc$4=GC_malloc(new_lb);
  result = (char *)return_value_GC_malloc$4;
  offset = (unsigned long int)result % align;
  void *return_value_GC_malloc$5;
  if(!(offset == 0ul))
  {
    offset = align - offset;
    if(GC_all_interior_pointers == 0)
    {
      if(offset >= 4096ul)
      {
        return_value_GC_malloc$5=GC_malloc((unsigned long int)(1 << 12));
        return return_value_GC_malloc$5;
      }

      GC_register_displacement(offset);
    }

  }

  result = (char *)(void *)((char *)result + (signed long int)offset);
  return (void *)result;
}

// GC_min
// file alloc.c line 1137
static inline unsigned long int GC_min(unsigned long int x, unsigned long int y)
{
  return x < y ? x : y;
}

// GC_min$link1
// file alloc.c line 1137
static inline unsigned long int GC_min$link1(unsigned long int x$link1, unsigned long int y$link1)
{
  return x$link1 < y$link1 ? x$link1 : y$link1;
}

// GC_move_disappearing_link
// file finalize.c line 343
extern signed int GC_move_disappearing_link(void **link, void **new_link)
{
  signed int result;
  if(new_link == ((void **)NULL) || !((7ul & (unsigned long int)new_link) == 0ul))
  {
    GC_on_abort("Bad new_link arg to GC_move_disappearing_link");
    abort();
  }

  if(!((7ul & (unsigned long int)link) == 0ul))
    return 4;

  else
  {
    do
      if(!(GC_need_to_lock == 0))
      {
        signed int return_value_pthread_mutex_trylock$1;
        return_value_pthread_mutex_trylock$1=pthread_mutex_trylock(&GC_allocate_ml);
        if(!(return_value_pthread_mutex_trylock$1 == 0))
          GC_lock();

      }

    while((_Bool)0);
    result=GC_move_disappearing_link_inner(&GC_dl_hashtbl, link, new_link);
    do
      if(!(GC_need_to_lock == 0))
        pthread_mutex_unlock(&GC_allocate_ml);

    while((_Bool)0);
    return result;
  }
}

// GC_move_disappearing_link_inner
// file finalize.c line 292
signed int GC_move_disappearing_link_inner(struct dl_hashtbl_s *dl_hashtbl, void **link, void **new_link)
{
  struct disappearing_link *curr_dl;
  struct disappearing_link *prev_dl;
  struct disappearing_link *new_dl;
  unsigned long int curr_index;
  unsigned long int new_index;
  unsigned long int curr_hidden_link;
  unsigned long int new_hidden_link;
  curr_index = ((unsigned long int)link >> 3 ^ (unsigned long int)link >> (signed long int)3 + dl_hashtbl->log_size) & (unsigned long int)((1 << dl_hashtbl->log_size) - 1);
  curr_hidden_link = ~((unsigned long int)link);
  prev_dl = (struct disappearing_link *)(void *)0;
  curr_dl = dl_hashtbl->head[(signed long int)curr_index];
  for( ; !(curr_dl == ((struct disappearing_link *)NULL)); curr_dl = (struct disappearing_link *)curr_dl->prolog.next)
  {
    if(curr_dl->prolog.hidden_key == curr_hidden_link)
      break;

    prev_dl = curr_dl;
  }
  if(curr_dl == ((struct disappearing_link *)NULL))
    return 4;

  else
    if(link == new_link)
      return 0;

    else
    {
      new_index = ((unsigned long int)new_link >> 3 ^ (unsigned long int)new_link >> (signed long int)3 + dl_hashtbl->log_size) & (unsigned long int)((1 << dl_hashtbl->log_size) - 1);
      new_hidden_link = ~((unsigned long int)new_link);
      new_dl = dl_hashtbl->head[(signed long int)new_index];
      for( ; !(new_dl == ((struct disappearing_link *)NULL)); new_dl = (struct disappearing_link *)new_dl->prolog.next)
        if(new_dl->prolog.hidden_key == new_hidden_link)
          return 1;

      if(prev_dl == ((struct disappearing_link *)NULL))
        dl_hashtbl->head[(signed long int)curr_index] = (struct disappearing_link *)curr_dl->prolog.next;

      else
        prev_dl->prolog.next = (struct hash_chain_entry *)(struct disappearing_link *)curr_dl->prolog.next;
      curr_dl->prolog.hidden_key = new_hidden_link;
      curr_dl->prolog.next = (struct hash_chain_entry *)dl_hashtbl->head[(signed long int)new_index];
      dl_hashtbl->head[(signed long int)new_index] = curr_dl;
      return 0;
    }
}

// GC_move_long_link
// file finalize.c line 360
extern signed int GC_move_long_link(void **link, void **new_link)
{
  signed int result;
  if(new_link == ((void **)NULL) || !((7ul & (unsigned long int)new_link) == 0ul))
  {
    GC_on_abort("Bad new_link arg to GC_move_disappearing_link");
    abort();
  }

  if(!((7ul & (unsigned long int)link) == 0ul))
    return 4;

  else
  {
    do
      if(!(GC_need_to_lock == 0))
      {
        signed int return_value_pthread_mutex_trylock$1;
        return_value_pthread_mutex_trylock$1=pthread_mutex_trylock(&GC_allocate_ml);
        if(!(return_value_pthread_mutex_trylock$1 == 0))
          GC_lock();

      }

    while((_Bool)0);
    result=GC_move_disappearing_link_inner(&GC_ll_hashtbl, link, new_link);
    do
      if(!(GC_need_to_lock == 0))
        pthread_mutex_unlock(&GC_allocate_ml);

    while((_Bool)0);
    return result;
  }
}

// GC_n_set_marks
// file reclaim.c line 474
signed int GC_n_set_marks(struct hblkhdr *hhdr)
{
  signed int result = 0;
  signed int i;
  unsigned long int sz = hhdr->hb_sz;
  signed int offset = (signed int)(sz >> 4);
  signed int limit = (signed int)(sz > (unsigned long int)((1 << 12) / 2) ? (unsigned long int)(1 << 12) / (unsigned long int)16 : sz * ((unsigned long int)(1 << 12) / sz) >> 4);
  i = 0;
  for( ; !(i >= limit); i = i + offset)
    result = result + (signed int)hhdr->_mark_byte_union._hb_marks[(signed long int)i];
  return result;
}

// GC_never_stop_func
// file alloc.c line 125
signed int GC_never_stop_func(void)
{
  return 0;
}

// GC_new_free_list
// file misc.c line 1748
extern void ** GC_new_free_list(void)
{
  void *result;
  do
    if(!(GC_need_to_lock == 0))
    {
      signed int return_value_pthread_mutex_trylock$1;
      return_value_pthread_mutex_trylock$1=pthread_mutex_trylock(&GC_allocate_ml);
      if(!(return_value_pthread_mutex_trylock$1 == 0))
        GC_lock();

    }

  while((_Bool)0);
  void **return_value_GC_new_free_list_inner$2;
  return_value_GC_new_free_list_inner$2=GC_new_free_list_inner();
  result = (void *)return_value_GC_new_free_list_inner$2;
  do
    if(!(GC_need_to_lock == 0))
      pthread_mutex_unlock(&GC_allocate_ml);

  while((_Bool)0);
  return (void **)result;
}

// GC_new_free_list_inner
// file ./include/private/../gc_mark.h line 168
extern void ** GC_new_free_list_inner(void)
{
  void *result;
  result=GC_generic_malloc_inner(((unsigned long int)((1 << 12) / 2 >> 4) + (unsigned long int)1) * sizeof(char *) /*8ul*/ , 0);
  if(result == NULL)
  {
    GC_on_abort("Failed to allocate freelist for new kind");
    abort();
  }

  memset(result, 0, (unsigned long int)(((unsigned long int)((1 << 12) / 2 >> 4) + (unsigned long int)1) * sizeof(char *) /*8ul*/ ));
  return (void **)result;
}

// GC_new_hblk
// file ./include/private/gc_priv.h line 1743
void GC_new_hblk(unsigned long int gran, signed int kind)
{
  struct hblk *h;
  signed int clear = GC_obj_kinds[(signed long int)kind].ok_init;
  if(!(GC_debugging_started == 0))
    clear = 1;

  h=GC_allochblk(gran << 4, kind, (unsigned int)0);
  struct hblkhdr *return_value_GC_find_header$1;
  if(!(h == ((struct hblk *)NULL)))
  {
    if((-2 & kind) == 2)
    {
      return_value_GC_find_header$1=GC_find_header((char *)h);
      GC_set_hdr_marks(return_value_GC_find_header$1);
    }

    char *return_value_GC_build_fl$2;
    return_value_GC_build_fl$2=GC_build_fl(h, gran << 1, clear, (char *)GC_obj_kinds[(signed long int)kind].ok_freelist[(signed long int)gran]);
    GC_obj_kinds[(signed long int)kind].ok_freelist[(signed long int)gran] = (void *)return_value_GC_build_fl$2;
  }

}

// GC_new_kind
// file misc.c line 1780
extern unsigned int GC_new_kind(void **fl, unsigned long int descr, signed int adjust, signed int clear)
{
  unsigned int result;
  do
    if(!(GC_need_to_lock == 0))
    {
      signed int return_value_pthread_mutex_trylock$1;
      return_value_pthread_mutex_trylock$1=pthread_mutex_trylock(&GC_allocate_ml);
      if(!(return_value_pthread_mutex_trylock$1 == 0))
        GC_lock();

    }

  while((_Bool)0);
  result=GC_new_kind_inner(fl, descr, adjust, clear);
  do
    if(!(GC_need_to_lock == 0))
      pthread_mutex_unlock(&GC_allocate_ml);

  while((_Bool)0);
  return result;
}

// GC_new_kind_inner
// file ./include/private/../gc_mark.h line 176
extern unsigned int GC_new_kind_inner(void **fl, unsigned long int descr, signed int adjust, signed int clear)
{
  unsigned int result = GC_n_kinds;
  if(!(result >= 16u))
  {
    GC_n_kinds = GC_n_kinds + 1u;
    GC_obj_kinds[(signed long int)result].ok_freelist = fl;
    GC_obj_kinds[(signed long int)result].ok_reclaim_list = ((struct hblk **)NULL);
    GC_obj_kinds[(signed long int)result].ok_descriptor = descr;
    GC_obj_kinds[(signed long int)result].ok_relocate_descr = adjust;
    GC_obj_kinds[(signed long int)result].ok_init = (signed int)clear;
    GC_obj_kinds[(signed long int)result].ok_mark_unconditionally = 0;
    GC_obj_kinds[(signed long int)result].ok_disclaim_proc = ((signed int (*)(void *))NULL);
  }

  else
  {
    GC_on_abort("Too many kinds");
    abort();
  }
  return result;
}

// GC_new_proc
// file misc.c line 1804
extern unsigned int GC_new_proc(struct GC_ms_entry * (*proc)(unsigned long int *, struct GC_ms_entry *, struct GC_ms_entry *, unsigned long int))
{
  unsigned int result;
  do
    if(!(GC_need_to_lock == 0))
    {
      signed int return_value_pthread_mutex_trylock$1;
      return_value_pthread_mutex_trylock$1=pthread_mutex_trylock(&GC_allocate_ml);
      if(!(return_value_pthread_mutex_trylock$1 == 0))
        GC_lock();

    }

  while((_Bool)0);
  result=GC_new_proc_inner(proc);
  do
    if(!(GC_need_to_lock == 0))
      pthread_mutex_unlock(&GC_allocate_ml);

  while((_Bool)0);
  return result;
}

// GC_new_proc_inner
// file misc.c line 1791
extern unsigned int GC_new_proc_inner(struct GC_ms_entry * (*proc)(unsigned long int *, struct GC_ms_entry *, struct GC_ms_entry *, unsigned long int))
{
  unsigned int result = GC_n_mark_procs;
  if(!(result >= 64u))
  {
    GC_n_mark_procs = GC_n_mark_procs + 1u;
    GC_arrays._mark_procs[(signed long int)result] = proc;
  }

  else
  {
    GC_on_abort("Too many mark procedures");
    abort();
  }
  return result;
}

// GC_new_thread
// file pthread_support.c line 489
struct GC_Thread_Rep * GC_new_thread(unsigned long int id)
{
  signed int hv = (signed int)((unsigned long int)id % (unsigned long int)256);
  struct GC_Thread_Rep *result;
  static signed int first_thread_used = 0;
  if((signed long int)first_thread_used == 0l)
  {
    result = &first_thread;
    first_thread_used = 1;
  }

  else
  {
    void *return_value_GC_generic_malloc_inner$1;
    return_value_GC_generic_malloc_inner$1=GC_generic_malloc_inner(sizeof(struct GC_Thread_Rep) /*864ul*/ , 1);
    result = (struct GC_Thread_Rep *)return_value_GC_generic_malloc_inner$1;
    if(result == ((struct GC_Thread_Rep *)NULL))
      return ((struct GC_Thread_Rep *)NULL);

  }
  result->id = id;
  result->next = GC_threads[(signed long int)hv];
  GC_threads[(signed long int)hv] = result;
  return result;
}

// GC_next_exclusion
// file mark_rts.c line 417
struct exclusion * GC_next_exclusion(char *start_addr)
{
  unsigned long int low = (unsigned long int)0;
  unsigned long int high = GC_excl_table_entries - (unsigned long int)1;
  unsigned long int mid;
  while(!(low >= high))
  {
    mid = low + high >> 1;
    if((unsigned long int)start_addr >= (unsigned long int)GC_arrays._excl_table[(signed long int)mid].e_end)
      low = mid + (unsigned long int)1;

    else
      high = mid;
  }
  if((unsigned long int)start_addr >= (unsigned long int)GC_arrays._excl_table[(signed long int)low].e_end)
    return ((struct exclusion *)NULL);

  else
    return GC_arrays._excl_table + (signed long int)low;
}

// GC_next_used_block
// file headers.c line 337
struct hblk * GC_next_used_block(struct hblk *h)
{
  struct bi *bi;
  unsigned long int j = (unsigned long int)h >> (unsigned long int)12 & (unsigned long int)((1 << 10) - 1);
  do
  {
    unsigned long int GC_next_used_block$$1$$1$$hi = (unsigned long int)h >> (unsigned long int)10 + (unsigned long int)12;
    struct bi *_bi = GC_arrays._top_index[(signed long int)(GC_next_used_block$$1$$1$$hi & (unsigned long int)((1 << 11) - 1))];
    for( ; !(_bi->key == GC_next_used_block$$1$$1$$hi); _bi = _bi->hash_link)
      if(_bi == GC_arrays._all_nils)
        break;

    bi = _bi;
  }
  while((_Bool)0);
  if(bi == GC_arrays._all_nils)
  {
    unsigned long int hi = (unsigned long int)h >> (unsigned long int)10 + (unsigned long int)12;
    bi = GC_all_bottom_indices;
    for( ; !(bi == ((struct bi *)NULL)); bi = bi->asc_link)
      if(bi->key >= hi)
        break;

    j = (unsigned long int)0;
  }

  for( ; !(bi == ((struct bi *)NULL)); bi = bi->asc_link)
  {
    while(!(j >= 1024ul))
    {
      struct hblkhdr *hhdr = bi->index[(signed long int)j];
      if(!((unsigned long int)hhdr >= 4096ul))
        j = j + 1ul;

      else
        if((4 & (signed int)hhdr->hb_flags) == 0)
          return (struct hblk *)((bi->key << 10) + j << (unsigned long int)12);

        else
          j = j + (hhdr->hb_sz >> (unsigned long int)12);
    }
    j = (unsigned long int)0;
  }
  return ((struct hblk *)NULL);
}

// GC_noop1
// file ./include/private/gc_priv.h line 2075
extern void GC_noop1(unsigned long int x)
{
  GC_noop_sink = x;
}

// GC_noop6
// file ./include/private/gc_priv.h line 2073
void GC_noop6(unsigned long int arg1, unsigned long int arg2, unsigned long int arg3, unsigned long int arg4, unsigned long int arg5, unsigned long int arg6)
{
  ;
}

// GC_normal_finalize_mark_proc
// file finalize.c line 380
void GC_normal_finalize_mark_proc(char *p)
{
  struct hblkhdr *hhdr;
  hhdr=GC_find_header((char *)p);
  do
  {
    unsigned long int _descr = hhdr->hb_descr;
    if(!(_descr == 0ul))
    {
      GC_arrays._mark_stack_top = GC_arrays._mark_stack_top + 1l;
      if((unsigned long int)GC_arrays._mark_stack_top >= (unsigned long int)(GC_arrays._mark_stack + (signed long int)GC_mark_stack_size))
        GC_arrays._mark_stack_top=GC_signal_mark_stack_overflow(GC_arrays._mark_stack_top);

      GC_arrays._mark_stack_top->mse_start = p;
      GC_arrays._mark_stack_top->mse_descr.w = _descr;
    }

  }
  while((_Bool)0);
}

// GC_notify_all_builder
// file ./include/private/gc_priv.h line 2373
void GC_notify_all_builder(void)
{
  signed int return_value_pthread_cond_broadcast$1;
  return_value_pthread_cond_broadcast$1=pthread_cond_broadcast(&builder_cv);
  if(!(return_value_pthread_cond_broadcast$1 == 0))
  {
    GC_on_abort("pthread_cond_broadcast failed");
    abort();
  }

}

// GC_notify_all_marker
// file ./include/private/gc_priv.h line 2378
void GC_notify_all_marker(void)
{
  signed int return_value_pthread_cond_broadcast$1;
  return_value_pthread_cond_broadcast$1=pthread_cond_broadcast(&mark_cv);
  if(!(return_value_pthread_cond_broadcast$1 == 0))
  {
    GC_on_abort("pthread_cond_broadcast failed");
    abort();
  }

}

// GC_notify_full_gc
// file alloc.c line 334
static inline void GC_notify_full_gc(void)
{
  if(!(GC_start_call_back == ((void (*)(void))NULL)))
    GC_start_call_back();

}

// GC_notify_full_gc$link1
// file alloc.c line 334
static inline void GC_notify_full_gc$link1(void)
{
  if(!(GC_start_call_back == ((void (*)(void))NULL)))
    GC_start_call_back();

}

// GC_notify_or_invoke_finalizers
// file ./include/private/gc_priv.h line 254
void GC_notify_or_invoke_finalizers(void)
{
  void (*notifier_fn)(void) = ((void (*)(void))NULL);
  if(!(GC_finalize_now == ((struct finalizable_object *)NULL)))
  {
    do
      if(!(GC_need_to_lock == 0))
      {
        signed int return_value_pthread_mutex_trylock$1;
        return_value_pthread_mutex_trylock$1=pthread_mutex_trylock(&GC_allocate_ml);
        if(!(return_value_pthread_mutex_trylock$1 == 0))
          GC_lock();

      }

    while((_Bool)0);
    if(GC_finalize_now == ((struct finalizable_object *)NULL))
      do
        if(!(GC_need_to_lock == 0))
          pthread_mutex_unlock(&GC_allocate_ml);

      while((_Bool)0);

    else
    {
      if(GC_finalize_on_demand == 0)
      {
        unsigned char *pnested;
        pnested=GC_check_finalizer_nested();
        do
          if(!(GC_need_to_lock == 0))
            pthread_mutex_unlock(&GC_allocate_ml);

        while((_Bool)0);
        if(!(pnested == ((unsigned char *)NULL)))
        {
          GC_invoke_finalizers();
          *pnested = (unsigned char)0;
        }

        goto __CPROVER_DUMP_L14;
      }

      if(!(last_finalizer_notification == GC_gc_no))
      {
        last_finalizer_notification = GC_gc_no;
        notifier_fn = GC_finalizer_notifier;
      }

      do
        if(!(GC_need_to_lock == 0))
          pthread_mutex_unlock(&GC_allocate_ml);

      while((_Bool)0);
      if(!(notifier_fn == ((void (*)(void))NULL)))
        notifier_fn();

    }
  }


__CPROVER_DUMP_L14:
  ;
}

// GC_null_finalize_mark_proc
// file finalize.c line 413
void GC_null_finalize_mark_proc(char *p)
{
  ;
}

// GC_number_stack_black_listed
// file blacklst.c line 262
unsigned long int GC_number_stack_black_listed(struct hblk *start, struct hblk *endp1)
{
  struct hblk *h;
  unsigned long int result = (unsigned long int)0;
  h = start;
  for( ; !((unsigned long int)h >= (unsigned long int)endp1); h = h + 1l)
  {
    unsigned long int index = (unsigned long int)h >> (unsigned long int)12 & ((unsigned long int)1 << 18) - (unsigned long int)1;
    if(!((1ul & GC_old_stack_bl[(signed long int)(index >> 6ul)] >> (63ul & index)) == 0ul))
      result = result + 1ul;

  }
  return result;
}

// GC_page_was_dirty
// file ./include/private/gc_priv.h line 2031
signed int GC_page_was_dirty(struct hblk *h)
{
  unsigned long int index = (unsigned long int)h >> (unsigned long int)12 & ((unsigned long int)1 << 18) - (unsigned long int)1;
  struct hblkhdr *return_value_GC_find_header$1;
  return_value_GC_find_header$1=GC_find_header((char *)h);
  _Bool tmp_if_expr$2;
  if(return_value_GC_find_header$1 == ((struct hblkhdr *)NULL))
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = (GC_arrays._grungy_pages[(signed long int)(index >> (unsigned long int)6)] >> (index & (unsigned long int)0x3f) & (unsigned long int)1) != 0ul ? (_Bool)1 : (_Bool)0;
  return (signed int)tmp_if_expr$2;
}

// GC_parse_mem_size_arg
// file misc.c line 787
unsigned long int GC_parse_mem_size_arg(const char *str)
{
  char *endptr;
  unsigned long int result = (unsigned long int)0;
  char ch;
  if(!((signed int)*str == 0))
  {
    unsigned long int return_value_strtoul$1;
    return_value_strtoul$1=strtoul(str, &endptr, 10);
    result = (unsigned long int)return_value_strtoul$1;
    ch = *endptr;
    if(!((signed int)ch == 0))
    {
      if(!((signed int)endptr[1l] == 0))
        return (unsigned long int)0;

      switch((signed int)ch)
      {
        case 75:

        case 107:
        {
          result = result << 10;
          break;
        }
        case 77:

        case 109:
        {
          result = result << 20;
          break;
        }
        case 71:

        case 103:
        {
          result = result << 30;
          break;
        }
        default:
          result = (unsigned long int)0;
      }
    }

  }

  return result;
}

// GC_pause
// file pthread_support.c line 1774
void GC_pause(void)
{
  signed int i = 0;
  for( ; !(i >= 10); i = i + 1)
    asm(" " :  :  : "memory");
}

// GC_posix_memalign
// file mallocx.c line 485
extern signed int GC_posix_memalign(void **memptr, unsigned long int align, unsigned long int lb)
{
  if(!((align + 18446744073709551615ul & align) == 0ul) || !(align >= sizeof(void *) /*8ul*/ ))
    return 22;

  else
  {
    *memptr=GC_memalign(align, lb);
    if(*memptr == NULL)
      return 12;

    else
      return 0;
  }
}

// GC_post_incr
// file ptr_chck.c line 268
extern void * GC_post_incr(void **p, signed long int how_much)
{
  void *initial = *p;
  void *result;
  result=GC_same_obj((void *)((char *)initial + how_much), initial);
  if(GC_all_interior_pointers == 0)
    GC_is_valid_displacement(result);

  *p = result;
  return initial;
}

// GC_pre_incr
// file ptr_chck.c line 257
extern void * GC_pre_incr(void **p, signed long int how_much)
{
  void *initial = *p;
  void *result;
  result=GC_same_obj((void *)((char *)initial + how_much), initial);
  if(GC_all_interior_pointers == 0)
    GC_is_valid_displacement(result);

  *p = result;
  return *p;
}

// GC_prev_block
// file ./include/private/gc_priv.h line 1548
struct hblk * GC_prev_block(struct hblk *h)
{
  struct bi *bi;
  signed long int j = (signed long int)((unsigned long int)h >> (unsigned long int)12 & (unsigned long int)((1 << 10) - 1));
  do
  {
    unsigned long int hi = (unsigned long int)h >> (unsigned long int)10 + (unsigned long int)12;
    struct bi *_bi = GC_arrays._top_index[(signed long int)(hi & (unsigned long int)((1 << 11) - 1))];
    for( ; !(_bi->key == hi); _bi = _bi->hash_link)
      if(_bi == GC_arrays._all_nils)
        break;

    bi = _bi;
  }
  while((_Bool)0);
  if(bi == GC_arrays._all_nils)
  {
    unsigned long int GC_prev_block$$1$$2$$hi = (unsigned long int)h >> (unsigned long int)10 + (unsigned long int)12;
    bi = GC_all_bottom_indices_end;
    for( ; !(bi == ((struct bi *)NULL)); bi = bi->desc_link)
      if(GC_prev_block$$1$$2$$hi >= bi->key)
        break;

    j = (signed long int)((1 << 10) - 1);
  }

  for( ; !(bi == ((struct bi *)NULL)); bi = bi->desc_link)
  {
    while(j >= 0l)
    {
      struct hblkhdr *hhdr = bi->index[j];
      if(hhdr == ((struct hblkhdr *)NULL))
        j = j - 1l;

      else
        if(!((unsigned long int)hhdr >= 4096ul))
          j = j - (signed long int)hhdr;

        else
          return (struct hblk *)((bi->key << 10) + (unsigned long int)j << (unsigned long int)12);
    }
    j = (signed long int)((1 << 10) - 1);
  }
  return ((struct hblk *)NULL);
}

// GC_print_address_map
// file ./include/private/gc_priv.h line 1925
void GC_print_address_map(void)
{
  char *maps;
  GC_err_printf("---------- Begin address map ----------\n");
  maps=GC_get_maps();
  GC_err_puts(maps != (char *)(void *)0 ? maps : "Failed to get map!\n");
  GC_err_printf("---------- End address map ----------\n");
}

// GC_print_all_errors
// file ./include/private/gc_priv.h line 1908
void GC_print_all_errors(void)
{
  signed int have_errors;
  unsigned int i;
  unsigned int n_leaked;
  char *leaked[40l];
  do
    if(!(GC_need_to_lock == 0))
    {
      signed int return_value_pthread_mutex_trylock$1;
      return_value_pthread_mutex_trylock$1=pthread_mutex_trylock(&GC_allocate_ml);
      if(!(return_value_pthread_mutex_trylock$1 == 0))
        GC_lock();

    }

  while((_Bool)0);
  char *return_value_getenv$2;
  static signed int printing_errors = 0;
  if(!(printing_errors == 0))
    do
      if(!(GC_need_to_lock == 0))
        pthread_mutex_unlock(&GC_allocate_ml);

    while((_Bool)0);

  else
  {
    have_errors = GC_have_errors;
    printing_errors = 1;
    n_leaked = GC_n_leaked;
    memcpy((void *)leaked, (const void *)GC_leaked, (unsigned long int)((unsigned long int)n_leaked * sizeof(char *) /*8ul*/ ));
    GC_n_leaked = (unsigned int)0;
    memset((void *)GC_leaked, 0, (unsigned long int)((unsigned long int)n_leaked * sizeof(char *) /*8ul*/ ));
    do
      if(!(GC_need_to_lock == 0))
        pthread_mutex_unlock(&GC_allocate_ml);

    while((_Bool)0);
    if(!(GC_debugging_started == 0))
      GC_print_all_smashed();

    else
      have_errors = 0;
    if(n_leaked >= 1u)
    {
      GC_err_printf("Found %u leaked objects:\n", n_leaked);
      have_errors = 1;
    }

    i = (unsigned int)0;
    if(!(i >= n_leaked))
    {
      char *p = leaked[(signed long int)i];
      GC_print_heap_obj(p);
      GC_free((void *)p);
      i = i + 1u;
    }

    if(!(have_errors == 0))
    {
      return_value_getenv$2=getenv("GC_ABORT_ON_LEAK");
      if(!(return_value_getenv$2 == ((char *)NULL)))
      {
        GC_on_abort("Leaked or smashed objects encountered");
        abort();
      }

    }

    do
      if(!(GC_need_to_lock == 0))
      {
        signed int return_value_pthread_mutex_trylock$3;
        return_value_pthread_mutex_trylock$3=pthread_mutex_trylock(&GC_allocate_ml);
        if(!(return_value_pthread_mutex_trylock$3 == 0))
          GC_lock();

      }

    while((_Bool)0);
    printing_errors = 0;
    do
      if(!(GC_need_to_lock == 0))
        pthread_mutex_unlock(&GC_allocate_ml);

    while((_Bool)0);
  }
}

// GC_print_all_smashed_proc
// file dbg_mlc.c line 957
void GC_print_all_smashed_proc(void)
{
  unsigned int i;
  if(!(GC_n_smashed == 0u))
  {
    GC_err_printf("GC_check_heap_block: found %u smashed heap objects:\n", GC_n_smashed);
    i = (unsigned int)0;
    for( ; !(i >= GC_n_smashed); i = i + 1u)
    {
      char *base;
      void *return_value_GC_base$1;
      return_value_GC_base$1=GC_base((void *)GC_smashed[(signed long int)i]);
      base = (char *)return_value_GC_base$1;
      GC_print_smashed_obj("", base + (signed long int)sizeof(struct anonymous$17) /*32ul*/ , GC_smashed[(signed long int)i]);
      GC_smashed[(signed long int)i] = ((char *)NULL);
    }
    GC_n_smashed = (unsigned int)0;
  }

}

// GC_print_block_descr
// file reclaim.c line 531
void GC_print_block_descr(struct hblk *h, unsigned long int raw_ps)
{
  struct hblkhdr *hhdr;
  hhdr=GC_find_header((char *)h);
  unsigned long int bytes = hhdr->hb_sz;
  struct Print_stats *ps;
  unsigned int n_marks;
  signed int return_value_GC_n_set_marks$1;
  return_value_GC_n_set_marks$1=GC_n_set_marks(hhdr);
  n_marks = (unsigned int)return_value_GC_n_set_marks$1;
  if(!(hhdr->hb_n_marks == (unsigned long int)n_marks))
    GC_printf("(%u:%u,%u!=%u)\n", hhdr->hb_obj_kind, (unsigned int)bytes, (unsigned int)hhdr->hb_n_marks, n_marks);

  else
    GC_printf("(%u:%u,%u)\n", hhdr->hb_obj_kind, (unsigned int)bytes, n_marks);
  bytes = bytes + ((unsigned long int)(1 << 12) - (unsigned long int)1);
  bytes = bytes & ~((unsigned long int)(1 << 12) - (unsigned long int)1);
  ps = (struct Print_stats *)raw_ps;
  ps->total_bytes = ps->total_bytes + bytes;
  ps->number_of_blocks = ps->number_of_blocks + 1ul;
}

// GC_print_block_list
// file ./include/private/gc_priv.h line 2054
void GC_print_block_list(void)
{
  struct Print_stats pstats;
  GC_printf("(kind(0=ptrfree,1=normal,2=unc.):size_in_bytes, #_marks_set)\n");
  pstats.number_of_blocks = (unsigned long int)0;
  pstats.total_bytes = (unsigned long int)0;
  GC_apply_to_all_blocks(GC_print_block_descr, (unsigned long int)&pstats);
  GC_printf("blocks= %lu, bytes= %lu\n", (unsigned long int)pstats.number_of_blocks, (unsigned long int)pstats.total_bytes);
}

// GC_print_finalization_stats
// file ./include/private/gc_priv.h line 270
void GC_print_finalization_stats(void)
{
  struct finalizable_object *fo;
  unsigned long int ready = (unsigned long int)0;
  GC_log_printf("%lu finalization entries; %lu/%lu short/long disappearing links alive\n", (unsigned long int)GC_fo_entries, (unsigned long int)GC_dl_hashtbl.entries, (unsigned long int)GC_ll_hashtbl.entries);
  fo = GC_finalize_now;
  for( ; !(fo == ((struct finalizable_object *)NULL)); fo = (struct finalizable_object *)fo->prolog.next)
    ready = ready + 1ul;
  GC_log_printf("%lu finalization-ready objects; %ld/%ld short/long links cleared\n", ready, (signed long int)GC_old_dl_entries - (signed long int)GC_dl_hashtbl.entries, (signed long int)(GC_old_ll_entries - GC_ll_hashtbl.entries));
}

// GC_print_free_list
// file reclaim.c line 568
void GC_print_free_list(signed int kind, unsigned long int sz_in_granules)
{
  struct obj_kind *ok = &GC_obj_kinds[(signed long int)kind];
  char *flh = (char *)ok->ok_freelist[(signed long int)sz_in_granules];
  signed int n = 0;
  for( ; !(flh == ((char *)NULL)); n = n + 1)
  {
    struct hblk *block = (struct hblk *)((unsigned long int)flh & ~((unsigned long int)(1 << 12) - (unsigned long int)1));
    GC_printf("Free object in heap block %p [%d]: %p\n", (void *)block, n, flh);
    flh = (char *)*((void **)flh);
  }
}

// GC_print_hblkfreelist
// file allchblk.c line 122
void GC_print_hblkfreelist(void)
{
  struct hblk *h;
  struct hblkhdr *hhdr;
  unsigned int i;
  unsigned long int total;
  i = (unsigned int)0;
  struct hblk *return_value_GC_is_black_listed$2;
  for( ; !(i >= 61u); i = i + 1u)
  {
    h = GC_hblkfreelist[(signed long int)i];
    if(!(h == ((struct hblk *)NULL)))
      GC_printf("Free list %u (total size %lu):\n", i, (unsigned long int)GC_free_bytes[(signed long int)i]);

    while(!(h == ((struct hblk *)NULL)))
    {
      hhdr=GC_find_header((char *)h);
      struct hblk *return_value_GC_is_black_listed$1;
      return_value_GC_is_black_listed$1=GC_is_black_listed(h, (unsigned long int)(1 << 12));
      char *tmp_if_expr$3;
      if(!(return_value_GC_is_black_listed$1 == ((struct hblk *)NULL)))
        tmp_if_expr$3 = "start";

      else
      {
        return_value_GC_is_black_listed$2=GC_is_black_listed(h, hhdr->hb_sz);
        tmp_if_expr$3 = return_value_GC_is_black_listed$2 != ((struct hblk *)NULL) ? "partially" : "not";
      }
      GC_printf("\t%p size %lu %s black listed\n", (void *)h, (unsigned long int)hhdr->hb_sz, tmp_if_expr$3);
      h = hhdr->hb_next;
    }
  }
  GC_printf("GC_large_free_bytes: %lu\n", (unsigned long int)GC_arrays._large_free_bytes);
  total=GC_compute_large_free_bytes();
  if(!(total == GC_arrays._large_free_bytes))
    GC_err_printf("GC_large_free_bytes INCONSISTENT!! Should be: %lu\n", (unsigned long int)total);

}

// GC_print_heap_sects
// file alloc.c line 1105
void GC_print_heap_sects(void)
{
  unsigned int i;
  GC_printf("Total heap size: %lu\n", (unsigned long int)GC_arrays._heapsize);
  i = (unsigned int)0;
  for( ; !((unsigned long int)i >= GC_n_heap_sects); i = i + 1u)
  {
    char *start = GC_arrays._heap_sects[(signed long int)i].hs_start;
    unsigned long int len = GC_arrays._heap_sects[(signed long int)i].hs_bytes;
    struct hblk *h;
    unsigned int nbl = (unsigned int)0;
    h = (struct hblk *)start;
    for( ; !((unsigned long int)h >= (unsigned long int)(start + (signed long int)len)); h = h + 1l)
    {
      struct hblk *return_value_GC_is_black_listed$1;
      return_value_GC_is_black_listed$1=GC_is_black_listed(h, (unsigned long int)(1 << 12));
      if(!(return_value_GC_is_black_listed$1 == ((struct hblk *)NULL)))
        nbl = nbl + 1u;

    }
    GC_printf("Section %d from %p to %p %lu/%lu blacklisted\n", i, start, start + (signed long int)len, (unsigned long int)nbl, (unsigned long int)(len / (unsigned long int)(1 << 12)));
  }
}

// GC_print_obj
// file dbg_mlc.c line 336
void GC_print_obj(char *p)
{
  struct anonymous$17 *ohdr;
  void *return_value_GC_base$1;
  return_value_GC_base$1=GC_base((void *)p);
  ohdr = (struct anonymous$17 *)return_value_GC_base$1;
  char *q;
  struct hblkhdr *hhdr;
  signed int kind;
  char *kind_str;
  char buffer[41l];
  q = (char *)(ohdr + (signed long int)1);
  hhdr=GC_find_header(q);
  kind = (signed int)hhdr->hb_obj_kind;
  _Bool tmp_if_expr$3;
  signed int return_value_GC_is_marked$2;
  if(!(GC_describe_type_fns[(signed long int)kind] == ((void (*)(void *, char *))NULL)))
  {
    return_value_GC_is_marked$2=GC_is_marked((const void *)ohdr);
    tmp_if_expr$3 = return_value_GC_is_marked$2 != 0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$3 = (_Bool)0;
  if(tmp_if_expr$3)
  {
    buffer[(signed long int)40] = (char)0;
    GC_describe_type_fns[(signed long int)kind]((void *)q, buffer);
    kind_str = buffer;
  }

  else
    switch(kind)
    {
      case 0:
      {
        kind_str = "PTRFREE";
        break;
      }
      case 1:
      {
        kind_str = "NORMAL";
        break;
      }
      case 2:
      {
        kind_str = "UNCOLLECTABLE";
        break;
      }
      case 3:
      {
        kind_str = "ATOMIC_UNCOLLECTABLE";
        break;
      }
      case 4:
      {
        kind_str = "STUBBORN";
        break;
      }
      default:
        kind_str = (char *)(void *)0;
    }
  if(!(kind_str == ((char *)NULL)))
    GC_err_printf("%p (%s:%d, sz=%lu, %s)\n", (char *)ohdr + (signed long int)sizeof(struct anonymous$17) /*32ul*/ , ohdr->oh_string, (signed int)ohdr->oh_int, (unsigned long int)ohdr->oh_sz, kind_str);

  else
    GC_err_printf("%p (%s:%d, sz=%lu, kind=%d descr=0x%lx)\n", (char *)ohdr + (signed long int)sizeof(struct anonymous$17) /*32ul*/ , ohdr->oh_string, (signed int)ohdr->oh_int, (unsigned long int)ohdr->oh_sz, kind, (unsigned long int)hhdr->hb_descr);
}

// GC_print_smashed_obj
// file dbg_mlc.c line 418
void GC_print_smashed_obj(const char *msg, char *p, char *clobbered_addr)
{
  struct anonymous$17 *ohdr;
  void *return_value_GC_base$1;
  return_value_GC_base$1=GC_base((void *)p);
  ohdr = (struct anonymous$17 *)return_value_GC_base$1;
  _Bool tmp_if_expr$5;
  if((unsigned long int)&ohdr->oh_sz >= (unsigned long int)clobbered_addr)
    tmp_if_expr$5 = (_Bool)1;

  else
    tmp_if_expr$5 = ohdr->oh_string == ((const char *)NULL) ? (_Bool)1 : (_Bool)0;
  char *tmp_if_expr$3;
  if(tmp_if_expr$5)
  {
    unsigned long int return_value_GC_size$2;
    return_value_GC_size$2=GC_size((const void *)(char *)ohdr);
    GC_err_printf("%s %p in or near object at %p(<smashed>, appr. sz = %lu)\n", msg, clobbered_addr, p, (unsigned long int)(return_value_GC_size$2 - ((sizeof(struct anonymous$17) /*32ul*/  + sizeof(unsigned long int) /*8ul*/ ) - (unsigned long int)GC_all_interior_pointers)));
  }

  else
  {
    char *tmp_if_expr$4;
    if(!((unsigned long int)ohdr->oh_string >= 4096ul))
      tmp_if_expr$4 = "(smashed string)";

    else
    {
      if((signed int)*ohdr->oh_string == 0)
        tmp_if_expr$3 = "EMPTY(smashed?)";

      else
        tmp_if_expr$3 = ohdr->oh_string;
      tmp_if_expr$4 = tmp_if_expr$3;
    }
    GC_err_printf("%s %p in or near object at %p (%s:%d, sz=%lu)\n", msg, clobbered_addr, p, tmp_if_expr$4, (signed int)ohdr->oh_int, (unsigned long int)ohdr->oh_sz);
  }
}

// GC_print_static_roots
// file mark_rts.c line 58
void GC_print_static_roots(void)
{
  signed int i;
  unsigned long int size;
  i = 0;
  for( ; !(i >= n_root_sets); i = i + 1)
    GC_printf("From %p to %p%s\n", GC_arrays._static_roots[(signed long int)i].r_start, GC_arrays._static_roots[(signed long int)i].r_end, GC_arrays._static_roots[(signed long int)i].r_tmp != 0 ? " (temporary)" : "");
  GC_printf("GC_root_size: %lu\n", (unsigned long int)GC_root_size);
  size=GC_compute_root_size();
  if(!(size == GC_root_size))
    GC_err_printf("GC_root_size incorrect!! Should be: %lu\n", (unsigned long int)size);

}

// GC_printf
// file ./include/private/gc_priv.h line 2090
extern void GC_printf(const char *format, ...)
{
  char buf[1025l];
  if(GC_quiet == 0)
  {
    do
    {
      void **args = (void **)&format;
      buf[(signed long int)(sizeof(char [1025l]) /*1025ul*/  - (unsigned long int)1)] = (char)0x15;
      vsnprintf(buf, sizeof(char [1025l]) /*1025ul*/  - (unsigned long int)1, format, args);
      args = ((void **)NULL);
      if(!((signed int)buf[1024l] == 0x15))
      {
        GC_on_abort("GC_printf clobbered stack");
        abort();
      }

    }
    while((_Bool)0);
    unsigned long int return_value_strlen$1;
    return_value_strlen$1=strlen(buf);
    signed int return_value_GC_write$2;
    return_value_GC_write$2=GC_write(GC_stdout, buf, return_value_strlen$1);
    if(!(return_value_GC_write$2 >= 0))
    {
      GC_on_abort("write to stdout failed");
      abort();
    }

  }

}

// GC_promote_black_lists
// file ./include/private/gc_priv.h line 1721
void GC_promote_black_lists(void)
{
  unsigned long int *very_old_normal_bl = GC_old_normal_bl;
  unsigned long int *very_old_stack_bl = GC_old_stack_bl;
  GC_old_normal_bl = GC_incomplete_normal_bl;
  GC_old_stack_bl = GC_incomplete_stack_bl;
  if(GC_all_interior_pointers == 0)
    GC_clear_bl(very_old_normal_bl);

  GC_clear_bl(very_old_stack_bl);
  GC_incomplete_normal_bl = very_old_normal_bl;
  GC_incomplete_stack_bl = very_old_stack_bl;
  GC_total_stack_black_listed=total_stack_black_listed();
  if(GC_print_stats == 2)
    GC_log_printf("%lu bytes in heap blacklisted for interior pointers\n", (unsigned long int)GC_total_stack_black_listed);

  if(!(GC_total_stack_black_listed == 0ul))
    GC_black_list_spacing = (unsigned long int)(1 << 12) * (GC_arrays._heapsize / GC_total_stack_black_listed);

  if(!(GC_black_list_spacing >= 12288ul))
    GC_black_list_spacing = (unsigned long int)3 * (unsigned long int)(1 << 12);

  if(GC_black_list_spacing >= 8388609ul)
    GC_black_list_spacing = (unsigned long int)2048 * (unsigned long int)(1 << 12);

}

// GC_protect_heap
// file os_dep.c line 3394
void GC_protect_heap(void)
{
  char *start;
  unsigned long int len;
  struct hblk *current;
  struct hblk *current_start;
  struct hblk *limit;
  unsigned int i;
  signed int protect_all;
  signed int return_value_GC_incremental_protection_needs$1;
  return_value_GC_incremental_protection_needs$1=GC_incremental_protection_needs();
  protect_all = (signed int)(0 != (return_value_GC_incremental_protection_needs$1 & 2));
  i = (unsigned int)0;
  for( ; !((unsigned long int)i >= GC_n_heap_sects); i = i + 1u)
  {
    start = GC_arrays._heap_sects[(signed long int)i].hs_start;
    len = GC_arrays._heap_sects[(signed long int)i].hs_bytes;
    if(!(protect_all == 0))
    {
      signed int return_value_mprotect$2;
      return_value_mprotect$2=mprotect((void *)(char *)start, (unsigned long int)len, 0x1 | (GC_pages_executable != 0 ? 0x4 : 0));
      if(!(return_value_mprotect$2 >= 0))
      {
        GC_on_abort("mprotect failed");
        abort();
      }

    }

    else
    {
      current = (struct hblk *)start;
      current_start = current;
      limit = (struct hblk *)(start + (signed long int)len);
      while(!((unsigned long int)current >= (unsigned long int)limit))
      {
        struct hblkhdr *hhdr;
        unsigned long int nhblks;
        signed int is_ptrfree;
        do
        {
          struct hblkhdr **_ha;
          do
          {
            struct bi *bi;
            do
            {
              unsigned long int hi = (unsigned long int)current >> (unsigned long int)10 + (unsigned long int)12;
              struct bi *_bi = GC_arrays._top_index[(signed long int)(hi & (unsigned long int)((1 << 11) - 1))];
              for( ; !(_bi->key == hi); _bi = _bi->hash_link)
                if(_bi == GC_arrays._all_nils)
                  break;

              bi = _bi;
            }
            while((_Bool)0);
            _ha = &bi->index[(signed long int)((unsigned long int)current >> (unsigned long int)12 & (unsigned long int)((1 << 10) - 1))];
          }
          while((_Bool)0);
          hhdr = *_ha;
        }
        while((_Bool)0);
        if(!((unsigned long int)hhdr >= 4096ul))
        {
          current = current + 1l;
          current_start = current;
        }

        else
        {
          if(!((4 & (signed int)hhdr->hb_flags) == 0))
          {
            nhblks = hhdr->hb_sz >> (unsigned long int)12;
            is_ptrfree = 1;
          }

          else
          {
            nhblks = (hhdr->hb_sz + (unsigned long int)(1 << 12)) - (unsigned long int)1 >> (unsigned long int)12;
            is_ptrfree = (signed int)(hhdr->hb_descr == (unsigned long int)0);
          }
          if(!(is_ptrfree == 0))
          {
            if(!((unsigned long int)current_start >= (unsigned long int)current))
            {
              signed int return_value_mprotect$3;
              return_value_mprotect$3=mprotect((void *)(char *)current_start, (unsigned long int)((char *)current - (char *)current_start), 0x1 | (GC_pages_executable != 0 ? 0x4 : 0));
              if(!(return_value_mprotect$3 >= 0))
              {
                GC_on_abort("mprotect failed");
                abort();
              }

            }

            current = current + (signed long int)nhblks;
            current_start = current;
          }

          else
            current = current + (signed long int)nhblks;
        }
      }
      if(!((unsigned long int)current_start >= (unsigned long int)current))
      {
        signed int return_value_mprotect$4;
        return_value_mprotect$4=mprotect((void *)(char *)current_start, (unsigned long int)((char *)current - (char *)current_start), 0x1 | (GC_pages_executable != 0 ? 0x4 : 0));
        if(!(return_value_mprotect$4 >= 0))
        {
          GC_on_abort("mprotect failed");
          abort();
        }

      }

    }
  }
}

// GC_pthread_cancel
// file pthread_support.c line 1451
extern signed int GC_pthread_cancel(unsigned long int thread)
{
  struct GC_Thread_Rep *t;
  do
    if(!(GC_need_to_lock == 0))
    {
      signed int return_value_pthread_mutex_trylock$1;
      return_value_pthread_mutex_trylock$1=pthread_mutex_trylock(&GC_allocate_ml);
      if(!(return_value_pthread_mutex_trylock$1 == 0))
        GC_lock();

    }

  while((_Bool)0);
  t=GC_lookup_thread(thread);
  if(!(t == ((struct GC_Thread_Rep *)NULL)))
  {
    if((0x10 & (signed int)t->flags) == 0)
    {
      t->flags = t->flags | (unsigned char)0x10;
      GC_dont_gc = GC_dont_gc + 1;
    }

  }

  do
    if(!(GC_need_to_lock == 0))
      pthread_mutex_unlock(&GC_allocate_ml);

  while((_Bool)0);
  signed int return_value_pthread_cancel$2;
  return_value_pthread_cancel$2=pthread_cancel(thread);
  return return_value_pthread_cancel$2;
}

// GC_pthread_create
// file pthread_support.c line 1661
extern signed int GC_pthread_create(unsigned long int *new_thread, const union pthread_attr_t *attr, void * (*start_routine)(void *), void *arg)
{
  signed int result;
  signed int detachstate;
  unsigned long int my_flags = (unsigned long int)0;
  struct start_info *si;
  do
    if(!(GC_need_to_lock == 0))
    {
      signed int return_value_pthread_mutex_trylock$1;
      return_value_pthread_mutex_trylock$1=pthread_mutex_trylock(&GC_allocate_ml);
      if(!(return_value_pthread_mutex_trylock$1 == 0))
        GC_lock();

    }

  while((_Bool)0);
  void *return_value_GC_generic_malloc_inner$2;
  return_value_GC_generic_malloc_inner$2=GC_generic_malloc_inner(sizeof(struct start_info) /*56ul*/ , 1);
  si = (struct start_info *)return_value_GC_generic_malloc_inner$2;
  do
    if(!(GC_need_to_lock == 0))
      pthread_mutex_unlock(&GC_allocate_ml);

  while((_Bool)0);
  if((signed long int)parallel_initialized == 0l)
    GC_init_parallel();

  void * (*return_value_GC_get_oom_fn$3)(unsigned long int);
  void *return_value;
  if(si == ((struct start_info *)NULL))
  {
    return_value_GC_get_oom_fn$3=GC_get_oom_fn();
    return_value=return_value_GC_get_oom_fn$3(sizeof(struct start_info) /*56ul*/ );
    si = (struct start_info *)return_value;
    if(si == ((struct start_info *)NULL))
      return 12;

  }

  signed int return_value_sem_init$4;
  return_value_sem_init$4=sem_init(&si->registered, 0, (unsigned int)0);
  if(!(return_value_sem_init$4 == 0))
  {
    GC_on_abort("sem_init failed");
    abort();
  }

  si->start_routine = start_routine;
  si->arg = arg;
  do
    if(!(GC_need_to_lock == 0))
    {
      signed int return_value_pthread_mutex_trylock$5;
      return_value_pthread_mutex_trylock$5=pthread_mutex_trylock(&GC_allocate_ml);
      if(!(return_value_pthread_mutex_trylock$5 == 0))
        GC_lock();

    }

  while((_Bool)0);
  if((signed long int)GC_thr_initialized == 0l)
    GC_thr_init();

  if(attr == ((const union pthread_attr_t *)NULL))
    detachstate = 0;

  else
    pthread_attr_getdetachstate(attr, &detachstate);
  if(detachstate == 1)
    my_flags = my_flags | (unsigned long int)2;

  si->flags = my_flags;
  do
    if(!(GC_need_to_lock == 0))
      pthread_mutex_unlock(&GC_allocate_ml);

  while((_Bool)0);
  GC_need_to_lock = 1;
  result=pthread_create(new_thread, attr, GC_start_routine, (void *)si);
  signed int return_value_sem_wait$6;
  if(result == 0)
  {
    signed int cancel_state;
    do
      pthread_setcancelstate(1, &cancel_state);
    while((_Bool)0);
    do
    {
      return_value_sem_wait$6=sem_wait(&si->registered);
      if(return_value_sem_wait$6 == 0)
        break;

      signed int *return_value___errno_location$7;
      return_value___errno_location$7=__errno_location();
      if(!(*return_value___errno_location$7 == 4))
      {
        GC_on_abort("sem_wait failed");
        abort();
      }

    }
    while((_Bool)1);
    do
      pthread_setcancelstate(cancel_state, (signed int *)(void *)0);
    while((_Bool)0);
  }

  sem_destroy(&si->registered);
  do
    if(!(GC_need_to_lock == 0))
    {
      signed int return_value_pthread_mutex_trylock$8;
      return_value_pthread_mutex_trylock$8=pthread_mutex_trylock(&GC_allocate_ml);
      if(!(return_value_pthread_mutex_trylock$8 == 0))
        GC_lock();

    }

  while((_Bool)0);
  GC_free_inner((void *)si);
  do
    if(!(GC_need_to_lock == 0))
      pthread_mutex_unlock(&GC_allocate_ml);

  while((_Bool)0);
  return result;
}

// GC_pthread_detach
// file pthread_support.c line 1418
extern signed int GC_pthread_detach(unsigned long int thread)
{
  signed int result;
  struct GC_Thread_Rep *t;
  do
    if(!(GC_need_to_lock == 0))
    {
      signed int return_value_pthread_mutex_trylock$1;
      return_value_pthread_mutex_trylock$1=pthread_mutex_trylock(&GC_allocate_ml);
      if(!(return_value_pthread_mutex_trylock$1 == 0))
        GC_lock();

    }

  while((_Bool)0);
  t=GC_lookup_thread(thread);
  do
    if(!(GC_need_to_lock == 0))
      pthread_mutex_unlock(&GC_allocate_ml);

  while((_Bool)0);
  result=pthread_detach(thread);
  if(result == 0)
  {
    do
      if(!(GC_need_to_lock == 0))
      {
        signed int return_value_pthread_mutex_trylock$2;
        return_value_pthread_mutex_trylock$2=pthread_mutex_trylock(&GC_allocate_ml);
        if(!(return_value_pthread_mutex_trylock$2 == 0))
          GC_lock();

      }

    while((_Bool)0);
    t->flags = t->flags | (unsigned char)2;
    if(!((1 & (signed int)t->flags) == 0))
      GC_delete_gc_thread(t);

    do
      if(!(GC_need_to_lock == 0))
        pthread_mutex_unlock(&GC_allocate_ml);

    while((_Bool)0);
  }

  return result;
}

// GC_pthread_exit
// file pthread_support.c line 1476
extern void GC_pthread_exit(void *retval)
{
  unsigned long int self;
  self=pthread_self();
  struct GC_Thread_Rep *me;
  do
    if(!(GC_need_to_lock == 0))
    {
      signed int return_value_pthread_mutex_trylock$1;
      return_value_pthread_mutex_trylock$1=pthread_mutex_trylock(&GC_allocate_ml);
      if(!(return_value_pthread_mutex_trylock$1 == 0))
        GC_lock();

    }

  while((_Bool)0);
  me=GC_lookup_thread(self);
  if(!(me == ((struct GC_Thread_Rep *)NULL)))
  {
    if((0x10 & (signed int)me->flags) == 0)
    {
      me->flags = me->flags | (unsigned char)0x10;
      GC_dont_gc = GC_dont_gc + 1;
    }

  }

  do
    if(!(GC_need_to_lock == 0))
      pthread_mutex_unlock(&GC_allocate_ml);

  while((_Bool)0);
  pthread_exit(retval);
}

// GC_pthread_join
// file pthread_support.c line 1384
extern signed int GC_pthread_join(unsigned long int thread, void **retval)
{
  signed int result;
  struct GC_Thread_Rep *t;
  do
    if(!(GC_need_to_lock == 0))
    {
      signed int return_value_pthread_mutex_trylock$1;
      return_value_pthread_mutex_trylock$1=pthread_mutex_trylock(&GC_allocate_ml);
      if(!(return_value_pthread_mutex_trylock$1 == 0))
        GC_lock();

    }

  while((_Bool)0);
  t=GC_lookup_thread(thread);
  do
    if(!(GC_need_to_lock == 0))
      pthread_mutex_unlock(&GC_allocate_ml);

  while((_Bool)0);
  result=pthread_join(thread, retval);
  if(result == 0)
  {
    do
      if(!(GC_need_to_lock == 0))
      {
        signed int return_value_pthread_mutex_trylock$2;
        return_value_pthread_mutex_trylock$2=pthread_mutex_trylock(&GC_allocate_ml);
        if(!(return_value_pthread_mutex_trylock$2 == 0))
          GC_lock();

      }

    while((_Bool)0);
    GC_delete_gc_thread(t);
    do
      if(!(GC_need_to_lock == 0))
        pthread_mutex_unlock(&GC_allocate_ml);

    while((_Bool)0);
  }

  return result;
}

// GC_pthread_sigmask
// file pthread_support.c line 1174
extern signed int GC_pthread_sigmask(signed int how, const struct anonymous$6 *set, struct anonymous$6 *oset)
{
  struct anonymous$6 fudged_set;
  signed int sig_suspend;
  if(!(set == ((const struct anonymous$6 *)NULL)) && (how == 0 || how == 2))
  {
    fudged_set = *set;
    sig_suspend=GC_get_suspend_signal();
    sigdelset(&fudged_set, sig_suspend);
    set = &fudged_set;
  }

  signed int return_value_pthread_sigmask$1;
  return_value_pthread_sigmask$1=pthread_sigmask(how, set, oset);
  return return_value_pthread_sigmask$1;
}

// GC_push_all
// file ./include/private/../gc_mark.h line 252
extern void GC_push_all(char *bottom, char *top)
{
  unsigned long int length;
  bottom = (char *)(((unsigned long int)bottom + (unsigned long int)8) - (unsigned long int)1 & (unsigned long int)~(8 - 1));
  top = (char *)((unsigned long int)top & (unsigned long int)~(8 - 1));
  if(!((unsigned long int)bottom >= (unsigned long int)top))
  {
    GC_arrays._mark_stack_top = GC_arrays._mark_stack_top + 1l;
    if((unsigned long int)GC_arrays._mark_stack_top >= (unsigned long int)GC_arrays._mark_stack_limit)
    {
      GC_on_abort("Unexpected mark stack overflow");
      abort();
    }

    length = (unsigned long int)(top - bottom);
    GC_arrays._mark_stack_top->mse_start = bottom;
    GC_arrays._mark_stack_top->mse_descr.w = length;
  }

}

// GC_push_all_eager
// file mark.c line 1491
void GC_push_all_eager(char *bottom, char *top)
{
  unsigned long int *b = (unsigned long int *)(((unsigned long int)bottom + (unsigned long int)8) - (unsigned long int)1 & (unsigned long int)~(8 - 1));
  unsigned long int *t = (unsigned long int *)((unsigned long int)top & (unsigned long int)~(8 - 1));
  unsigned long int *p;
  unsigned long int q;
  unsigned long int *lim;
  char *greatest_ha = (char *)GC_greatest_plausible_heap_addr;
  char *least_ha = (char *)GC_least_plausible_heap_addr;
  if(!(top == ((char *)NULL)))
  {
    lim = t - (signed long int)1;
    p = b;
    for( ; (unsigned long int)lim >= (unsigned long int)p; p = (unsigned long int *)((char *)p + (signed long int)8))
    {
      q = *p;
      do
        if(q >= (unsigned long int)least_ha && !(q >= (unsigned long int)greatest_ha))
          GC_mark_and_push_stack((char *)q);

      while((_Bool)0);
    }
  }

}

// GC_push_all_stack
// file mark.c line 1516
void GC_push_all_stack(char *bottom, char *top)
{
  GC_push_all_eager(bottom, top);
}

// GC_push_all_stack_sections
// file mark_rts.c line 536
void GC_push_all_stack_sections(char *lo, char *hi, struct GC_traced_stack_sect_s *traced_stack_sect)
{
  for( ; !(traced_stack_sect == ((struct GC_traced_stack_sect_s *)NULL)); traced_stack_sect = traced_stack_sect->prev)
  {
    GC_push_all_stack(lo, (char *)traced_stack_sect);
    lo = traced_stack_sect->saved_stack_ptr;
  }
  GC_push_all_stack(lo, hi);
}

// GC_push_all_stacks
// file ./include/private/gc_priv.h line 2272
void GC_push_all_stacks(void)
{
  signed int found_me = 0;
  unsigned long int nthreads = (unsigned long int)0;
  signed int i;
  struct GC_Thread_Rep *p;
  char *lo;
  char *hi;
  struct GC_traced_stack_sect_s *traced_stack_sect;
  unsigned long int self;
  self=pthread_self();
  unsigned long int total_size = (unsigned long int)0;
  if((signed long int)GC_thr_initialized == 0l)
    GC_thr_init();

  i = 0;
  for( ; !(i >= 256); i = i + 1)
  {
    p = GC_threads[(signed long int)i];
    for( ; !(p == ((struct GC_Thread_Rep *)NULL)); p = p->next)
      if((1 & (signed int)p->flags) == 0)
      {
        nthreads = nthreads + 1ul;
        traced_stack_sect = p->traced_stack_sect;
        if(p->id == self)
        {
          lo=GC_approx_sp();
          found_me = 1;
        }

        else
        {
          lo = p->stop_info.stack_ptr;
          if(!(traced_stack_sect == ((struct GC_traced_stack_sect_s *)NULL)))
          {
            if(traced_stack_sect->saved_stack_ptr == lo)
              traced_stack_sect = traced_stack_sect->prev;

          }

        }
        if((4 & (signed int)p->flags) == 0)
          hi = p->stack_end;

        else
          hi = GC_stackbottom;
        if(lo == ((char *)NULL))
        {
          GC_on_abort("GC_push_all_stacks: sp not set!");
          abort();
        }

        GC_push_all_stack_sections(lo, hi, traced_stack_sect);
        total_size = total_size + (unsigned long int)(hi - lo);
      }

  }
  if(GC_print_stats == 2)
    GC_log_printf("Pushed %d thread stacks\n", (signed int)nthreads);

  if(GC_in_thread_creation == 0 && found_me == 0)
  {
    GC_on_abort("Collecting from unknown thread");
    abort();
  }

  GC_total_stacksize = total_size;
}

// GC_push_complex_descriptor
// file typd_mlc.c line 440
struct GC_ms_entry * GC_push_complex_descriptor(unsigned long int *addr, union ComplexDescriptor *d, struct GC_ms_entry *msp, struct GC_ms_entry *msl)
{
  char *current = (char *)addr;
  unsigned long int nelements;
  unsigned long int sz;
  unsigned long int i;
  unsigned long int GC_push_complex_descriptor$$1$$1$$1$$descr;
  union ComplexDescriptor *descr;
  switch(d->ld.ld_tag)
  {
    case (unsigned long int)1:
    {
      GC_push_complex_descriptor$$1$$1$$1$$descr = d->ld.ld_descriptor;
      nelements = d->ld.ld_nelements;
      if((signed long int)nelements >= msl - msp)
        return ((struct GC_ms_entry *)NULL);

      sz = d->ld.ld_size;
      i = (unsigned long int)0;
      for( ; !(i >= nelements); i = i + 1ul)
      {
        msp = msp + 1l;
        msp->mse_start = current;
        msp->mse_descr.w = GC_push_complex_descriptor$$1$$1$$1$$descr;
        current = current + (signed long int)sz;
      }
      return msp;
    }
    case (unsigned long int)2:
    {
      descr = d->ad.ad_element_descr;
      nelements = d->ad.ad_nelements;
      sz=GC_descr_obj_size(descr);
      i = (unsigned long int)0;
      for( ; !(i >= nelements); i = i + 1ul)
      {
        msp=GC_push_complex_descriptor((unsigned long int *)current, descr, msp, msl);
        if(msp == ((struct GC_ms_entry *)NULL))
          return ((struct GC_ms_entry *)NULL);

        current = current + (signed long int)sz;
      }
      return msp;
    }
    case (unsigned long int)3:
    {
      sz=GC_descr_obj_size(d->sd.sd_first);
      msp=GC_push_complex_descriptor((unsigned long int *)current, d->sd.sd_first, msp, msl);
      if(msp == ((struct GC_ms_entry *)NULL))
        return ((struct GC_ms_entry *)NULL);

      current = current + (signed long int)sz;
      msp=GC_push_complex_descriptor((unsigned long int *)current, d->sd.sd_second, msp, msl);
      return msp;
    }
    default:
    {
      if(!((signed long int)GC_current_warn_proc == -1l))
      {
        GC_on_abort("Bad complex descriptor");
        abort();
      }

      return ((struct GC_ms_entry *)NULL);
    }
  }
}

// GC_push_conditional
// file mark.c line 1323
extern void GC_push_conditional(char *bottom, char *top, signed int all)
{
  if(all == 0)
    GC_push_selected((char *)bottom, (char *)top, GC_page_was_dirty);

  else
    GC_push_all(bottom, top);
}

// GC_push_conditional_with_exclusions
// file mark_rts.c line 491
void GC_push_conditional_with_exclusions(char *bottom, char *top, signed int all)
{
  struct exclusion *next;
  char *excl_start;
  for( ; !((unsigned long int)bottom >= (unsigned long int)top); bottom = next->e_end)
  {
    next=GC_next_exclusion(bottom);
    _Bool tmp_if_expr$1;
    if(next == ((struct exclusion *)NULL))
      tmp_if_expr$1 = (_Bool)1;

    else
    {
      excl_start = next->e_start;
      tmp_if_expr$1 = (unsigned long int)excl_start >= (unsigned long int)top ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$1)
    {
      GC_push_conditional((char *)bottom, (char *)top, all);
      goto __CPROVER_DUMP_L7;
    }

    if(!((unsigned long int)bottom >= (unsigned long int)excl_start))
      GC_push_conditional((char *)bottom, (char *)excl_start, all);

  }

__CPROVER_DUMP_L7:
  ;
}

// GC_push_current_stack
// file mark_rts.c line 658
void GC_push_current_stack(char *cold_gc_frame, void *context)
{
  if(!(cold_gc_frame == ((char *)NULL)))
  {
    char *return_value_GC_approx_sp$1;
    return_value_GC_approx_sp$1=GC_approx_sp();
    GC_push_all_eager(return_value_GC_approx_sp$1, cold_gc_frame);
  }

}

// GC_push_finalizer_structures
// file finalize.c line 77
void GC_push_finalizer_structures(void)
{
  GC_push_all((char *)&GC_ll_hashtbl.head, (char *)&GC_ll_hashtbl.head + (signed long int)sizeof(unsigned long int) /*8ul*/ );
  GC_push_all((char *)&GC_dl_hashtbl.head, (char *)&GC_dl_hashtbl.head + (signed long int)sizeof(unsigned long int) /*8ul*/ );
  GC_push_all((char *)&GC_fo_head, (char *)&GC_fo_head + (signed long int)sizeof(unsigned long int) /*8ul*/ );
  GC_push_all((char *)&GC_finalize_now, (char *)&GC_finalize_now + (signed long int)sizeof(unsigned long int) /*8ul*/ );
}

// GC_push_gc_structures
// file mark_rts.c line 716
void GC_push_gc_structures(void)
{
  GC_push_finalizer_structures();
  GC_push_thread_structures();
  if(!(GC_push_typed_structures == ((void (*)(void))NULL)))
    GC_push_typed_structures();

}

// GC_push_marked
// file mark.c line 1727
void GC_push_marked(struct hblk *h, struct hblkhdr *hhdr)
{
  unsigned long int sz = hhdr->hb_sz;
  unsigned long int descr = hhdr->hb_descr;
  char *p;
  unsigned long int bit_no;
  char *lim;
  struct GC_ms_entry *GC_mark_stack_top_reg;
  struct GC_ms_entry *mark_stack_limit = GC_arrays._mark_stack_limit;
  if(!(descr == 0ul))
  {
    signed int return_value_GC_block_empty$1;
    return_value_GC_block_empty$1=GC_block_empty(hhdr);
    if(return_value_GC_block_empty$1 == 0)
    {
      GC_n_rescuing_pages = GC_n_rescuing_pages + 1ul;
      GC_objects_are_marked = 1;
      if(sz >= 2049ul)
        lim = h->hb_body;

      else
        lim = (h + (signed long int)1)->hb_body - (signed long int)sz;
      GC_mark_stack_top_reg = GC_arrays._mark_stack_top;
      p = h->hb_body;
      bit_no = (unsigned long int)0;
      for( ; (unsigned long int)lim >= (unsigned long int)p; bit_no = bit_no + (sz >> 4))
      {
        if(!(hhdr->_mark_byte_union._hb_marks[(signed long int)bit_no] == 0))
          do
          {
            unsigned long int _descr = hhdr->hb_descr;
            if(!(_descr == 0ul))
            {
              GC_mark_stack_top_reg = GC_mark_stack_top_reg + 1l;
              if((unsigned long int)GC_mark_stack_top_reg >= (unsigned long int)mark_stack_limit)
                GC_mark_stack_top_reg=GC_signal_mark_stack_overflow(GC_mark_stack_top_reg);

              GC_mark_stack_top_reg->mse_start = p;
              GC_mark_stack_top_reg->mse_descr.w = _descr;
            }

          }
          while((_Bool)0);

        p = p + (signed long int)sz;
      }
      GC_arrays._mark_stack_top = GC_mark_stack_top_reg;
    }

  }

}

// GC_push_next_marked
// file mark.c line 1835
struct hblk * GC_push_next_marked(struct hblk *h)
{
  struct hblkhdr *hhdr;
  hhdr=GC_find_header((char *)h);
  _Bool tmp_if_expr$1;
  if(!((unsigned long int)hhdr >= 4096ul))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = ((signed int)hhdr->hb_flags & 4) != 0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
  {
    h=GC_next_used_block(h);
    if(h == ((struct hblk *)NULL))
      return ((struct hblk *)NULL);

    hhdr=GC_find_header((char *)h);
  }

  GC_push_marked(h, hhdr);
  return h + (signed long int)((hhdr->hb_sz + (unsigned long int)(1 << 12)) - (unsigned long int)1 >> (unsigned long int)12);
}

// GC_push_next_marked_dirty
// file mark.c line 1850
struct hblk * GC_push_next_marked_dirty(struct hblk *h)
{
  struct hblkhdr *hhdr;
  hhdr=GC_find_header((char *)h);
  if(GC_dirty_maintained == 0)
  {
    GC_on_abort("Dirty bits not set up");
    abort();
  }

  do
  {
    _Bool tmp_if_expr$1;
    if(!((unsigned long int)hhdr >= 4096ul))
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = ((signed int)hhdr->hb_flags & 4) != 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$1)
    {
      h=GC_next_used_block(h);
      if(h == ((struct hblk *)NULL))
        return ((struct hblk *)NULL);

      hhdr=GC_find_header((char *)h);
    }

    signed int return_value_GC_block_was_dirty$2;
    return_value_GC_block_was_dirty$2=GC_block_was_dirty(h, hhdr);
    if(!(return_value_GC_block_was_dirty$2 == 0))
      break;

    h = h + (signed long int)((hhdr->hb_sz + (unsigned long int)(1 << 12)) - (unsigned long int)1 >> (unsigned long int)12);
    hhdr=GC_find_header((char *)h);
  }
  while((_Bool)1);
  GC_push_marked(h, hhdr);
  return h + (signed long int)((hhdr->hb_sz + (unsigned long int)(1 << 12)) - (unsigned long int)1 >> (unsigned long int)12);
}

// GC_push_next_marked_uncollectable
// file mark.c line 1883
struct hblk * GC_push_next_marked_uncollectable(struct hblk *h)
{
  struct hblkhdr *hhdr;
  hhdr=GC_find_header((char *)h);
  do
  {
    _Bool tmp_if_expr$1;
    if(!((unsigned long int)hhdr >= 4096ul))
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = ((signed int)hhdr->hb_flags & 4) != 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$1)
    {
      h=GC_next_used_block(h);
      if(h == ((struct hblk *)NULL))
        return ((struct hblk *)NULL);

      hhdr=GC_find_header((char *)h);
    }

    if((signed int)hhdr->hb_obj_kind == 2)
    {
      GC_push_marked(h, hhdr);
      break;
    }

    if(!((0x10 & (signed int)hhdr->hb_flags) == 0))
    {
      GC_push_unconditionally(h, hhdr);
      break;
    }

    h = h + (signed long int)((hhdr->hb_sz + (unsigned long int)(1 << 12)) - (unsigned long int)1 >> (unsigned long int)12);
    hhdr=GC_find_header((char *)h);
  }
  while((_Bool)1);
  return h + (signed long int)((hhdr->hb_sz + (unsigned long int)(1 << 12)) - (unsigned long int)1 >> (unsigned long int)12);
}

// GC_push_one
// file mark.c line 1350
void GC_push_one(unsigned long int p)
{
  do
    if(p >= (unsigned long int)GC_least_plausible_heap_addr && !(p >= (unsigned long int)GC_greatest_plausible_heap_addr))
      GC_mark_and_push_stack((char *)p);

  while((_Bool)0);
}

// GC_push_regs_and_stack
// file mark_rts.c line 739
void GC_push_regs_and_stack(char *cold_gc_frame)
{
  GC_with_callee_saves_pushed(GC_push_current_stack, cold_gc_frame);
}

// GC_push_roots
// file ./include/private/gc_priv.h line 1598
void GC_push_roots(signed int all, char *cold_gc_frame)
{
  signed int i;
  unsigned int kind;
  i = 0;
  for( ; !(i >= n_root_sets); i = i + 1)
    GC_push_conditional_with_exclusions(GC_arrays._static_roots[(signed long int)i].r_start, GC_arrays._static_roots[(signed long int)i].r_end, all);
  kind = (unsigned int)0;
  for( ; !(kind >= GC_n_kinds); kind = kind + 1u)
  {
    void *base;
    base=GC_base((void *)GC_obj_kinds[(signed long int)kind].ok_freelist);
    if(!(base == NULL))
      GC_set_mark_bit(base);

  }
  if(!(GC_no_dls == 0) || !(roots_were_cleared == 0))
    GC_push_gc_structures();

  if(!(GC_world_stopped == 0))
    GC_mark_thread_local_free_lists();

  GC_push_regs_and_stack(cold_gc_frame);
  if(!(GC_push_other_roots == ((void (*)(void))NULL)))
    GC_push_other_roots();

}

// GC_push_selected
// file mark.c line 1281
void GC_push_selected(char *bottom, char *top, signed int (*dirty_fn)(struct hblk *))
{
  struct hblk *h;
  bottom = (char *)(((unsigned long int)bottom + (unsigned long int)8) - (unsigned long int)1 & (unsigned long int)~(8 - 1));
  top = (char *)((unsigned long int)top & (unsigned long int)~(8 - 1));
  signed int return_value_3;
  if(!((unsigned long int)bottom >= (unsigned long int)top))
  {
    h = (struct hblk *)((unsigned long int)(bottom + (signed long int)(unsigned long int)(1 << 12)) & ~((unsigned long int)(1 << 12) - (unsigned long int)1));
    if((unsigned long int)h >= (unsigned long int)top)
    {
      signed int return_value;
      return_value=dirty_fn(h - (signed long int)1);
      if(!(return_value == 0))
        GC_push_all(bottom, top);

    }

    signed int return_value_1;
    return_value_1=dirty_fn(h - (signed long int)1);
    if(!(return_value_1 == 0))
      GC_push_all(bottom, (char *)h);

    if((unsigned long int)top >= (unsigned long int)(h + 1l))
    {
      signed int return_value_2;
      return_value_2=dirty_fn(h);
      if(!(return_value_2 == 0))
      {
        if(!((3ul * GC_mark_stack_size) / 4ul >= (unsigned long int)(GC_arrays._mark_stack_top - GC_arrays._mark_stack)))
          GC_push_all((char *)h, top);

        else
          GC_push_all((char *)h, (char *)(h + (signed long int)1));
      }

      h = h + 1l;
    }

    if(!((char *)h == top))
    {
      return_value_3=dirty_fn(h);
      if(!(return_value_3 == 0))
        GC_push_all((char *)h, top);

    }

    if((unsigned long int)GC_arrays._mark_stack_top >= (unsigned long int)GC_arrays._mark_stack_limit)
    {
      GC_on_abort("Unexpected mark stack overflow");
      abort();
    }

  }

}

// GC_push_thread_structures
// file ./include/private/gc_priv.h line 1612
void GC_push_thread_structures(void)
{
  GC_push_all((char *)GC_threads, (char *)GC_threads + (signed long int)sizeof(struct GC_Thread_Rep * volatile [256l]) /*2048ul*/ );
  GC_push_all((char *)&GC_thread_key, (char *)&GC_thread_key + (signed long int)sizeof(void *) /*8ul*/ );
}

// GC_push_typed_structures_proc
// file typd_mlc.c line 103
void GC_push_typed_structures_proc(void)
{
  GC_push_all((char *)&GC_ext_descriptors, (char *)&GC_ext_descriptors + (signed long int)sizeof(unsigned long int) /*8ul*/ );
}

// GC_push_unconditionally
// file mark.c line 1787
void GC_push_unconditionally(struct hblk *h, struct hblkhdr *hhdr)
{
  unsigned long int sz = hhdr->hb_sz;
  unsigned long int descr = hhdr->hb_descr;
  char *p;
  char *lim;
  struct GC_ms_entry *GC_mark_stack_top_reg;
  struct GC_ms_entry *mark_stack_limit = GC_arrays._mark_stack_limit;
  if(!(descr == 0ul))
  {
    GC_n_rescuing_pages = GC_n_rescuing_pages + 1ul;
    GC_objects_are_marked = 1;
    if(sz >= 2049ul)
      lim = h->hb_body;

    else
      lim = (h + (signed long int)1)->hb_body - (signed long int)sz;
    GC_mark_stack_top_reg = GC_arrays._mark_stack_top;
    p = h->hb_body;
    for( ; (unsigned long int)lim >= (unsigned long int)p; p = p + (signed long int)sz)
      if(!((3ul & *((unsigned long int *)p)) == 0ul))
        do
        {
          unsigned long int _descr = hhdr->hb_descr;
          if(!(_descr == 0ul))
          {
            GC_mark_stack_top_reg = GC_mark_stack_top_reg + 1l;
            if((unsigned long int)GC_mark_stack_top_reg >= (unsigned long int)mark_stack_limit)
              GC_mark_stack_top_reg=GC_signal_mark_stack_overflow(GC_mark_stack_top_reg);

            GC_mark_stack_top_reg->mse_start = p;
            GC_mark_stack_top_reg->mse_descr.w = _descr;
          }

        }
        while((_Bool)0);

    GC_arrays._mark_stack_top = GC_mark_stack_top_reg;
  }

}

// GC_read_dirty
// file ./include/private/gc_priv.h line 2029
void GC_read_dirty(void)
{
  memcpy((void *)GC_arrays._grungy_pages, (const void *)(unsigned long int *)GC_arrays._dirty_pages, (unsigned long int)sizeof(unsigned long int [4096l]) /*32768ul*/ );
  memset((void *)(unsigned long int *)GC_arrays._dirty_pages, 0, (unsigned long int)sizeof(unsigned long int [4096l]) /*32768ul*/ );
  GC_protect_heap();
}

// GC_realloc
// file ./include/private/../gc.h line 485
extern void * GC_realloc(void *p, unsigned long int lb)
{
  struct hblk *h;
  struct hblkhdr *hhdr;
  unsigned long int sz;
  unsigned long int orig_sz;
  signed int obj_kind;
  void *return_value_GC_malloc$1;
  if(p == NULL)
  {
    return_value_GC_malloc$1=GC_malloc(lb);
    return return_value_GC_malloc$1;
  }

  h = (struct hblk *)((unsigned long int)p & ~((unsigned long int)(1 << 12) - (unsigned long int)1));
  hhdr=GC_find_header((char *)h);
  sz = hhdr->hb_sz;
  obj_kind = (signed int)hhdr->hb_obj_kind;
  orig_sz = sz;
  if(sz >= 2049ul)
  {
    unsigned long int descr;
    sz = (sz + (unsigned long int)(1 << 12)) - (unsigned long int)1 & ~((unsigned long int)(1 << 12) - (unsigned long int)1);
    hhdr->hb_sz = sz;
    descr = GC_obj_kinds[(signed long int)obj_kind].ok_descriptor;
    if(!(GC_obj_kinds[(signed long int)obj_kind].ok_relocate_descr == 0))
      descr = descr + sz;

    hhdr->hb_descr = descr;
    if((-2 & obj_kind) == 2)
      GC_non_gc_bytes = GC_non_gc_bytes + (sz - orig_sz);

  }

  if(sz >= lb + (unsigned long int)GC_all_interior_pointers)
  {
    if(lb >= sz >> 1)
    {
      if(!(lb >= orig_sz))
        memset((void *)((char *)p + (signed long int)lb), 0, (unsigned long int)(orig_sz - lb));

      return p;
    }

    else
    {
      void *result;
      result=GC_generic_or_special_malloc((unsigned long int)lb, obj_kind);
      if(result == NULL)
        return NULL;

      memcpy(result, p, (unsigned long int)lb);
      GC_free(p);
      return result;
    }
  }

  else
  {
    void *GC_realloc$$1$$3$$result;
    GC_realloc$$1$$3$$result=GC_generic_or_special_malloc((unsigned long int)lb, obj_kind);
    if(GC_realloc$$1$$3$$result == NULL)
      return NULL;

    memcpy(GC_realloc$$1$$3$$result, p, (unsigned long int)sz);
    GC_free(p);
    return GC_realloc$$1$$3$$result;
  }
}

// GC_rebuild_root_index
// file mark_rts.c line 299
void GC_rebuild_root_index(void)
{
  signed int i;
  memset((void *)GC_arrays._root_index, 0, (unsigned long int)((unsigned long int)(1 << 6) * sizeof(void *) /*8ul*/ ));
  i = 0;
  for( ; !(i >= n_root_sets); i = i + 1)
    add_roots_to_index(GC_arrays._static_roots + (signed long int)i);
}

// GC_reclaim_all
// file ./include/private/gc_priv.h line 1790
signed int GC_reclaim_all(signed int (*stop_func)(void), signed int ignore_old)
{
  unsigned long int sz;
  unsigned int kind;
  struct hblkhdr *hhdr;
  struct hblk *hbp;
  struct obj_kind *ok;
  struct hblk **rlp;
  struct hblk **rlh;
  signed long int start_time = (signed long int)0;
  signed long int done_time;
  if(GC_print_stats == 2)
    start_time=clock();

  kind = (unsigned int)0;
  signed int return_value;
  for( ; !(kind >= GC_n_kinds); kind = kind + 1u)
  {
    ok = &GC_obj_kinds[(signed long int)kind];
    rlp = ok->ok_reclaim_list;
    if(!(rlp == ((struct hblk **)NULL)))
    {
      sz = (unsigned long int)1;
      for( ; !(sz >= 129ul); sz = sz + 1ul)
      {
        rlh = rlp + (signed long int)sz;
        do
        {
          hbp = *rlh;
          if(hbp == ((struct hblk *)NULL))
            break;

          if(!(stop_func == ((signed int (*)(void))NULL)))
          {
            return_value=stop_func();
            if(!(return_value == 0))
              return 0;

          }

          hhdr=GC_find_header((char *)hbp);
          *rlh = hhdr->hb_next;
          _Bool tmp_if_expr$1;
          if(ignore_old == 0)
            tmp_if_expr$1 = (_Bool)1;

          else
            tmp_if_expr$1 = (unsigned long int)hhdr->hb_last_reclaimed == GC_gc_no - (unsigned long int)1 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$1)
            GC_reclaim_small_nonempty_block(hbp, 0);

        }
        while((_Bool)1);
      }
    }

  }
  if(GC_print_stats == 2)
  {
    done_time=clock();
    GC_log_printf("Disposing of reclaim lists took %lu msecs\n", (signed long int)1000000 % (signed long int)1000 == (signed long int)0 ? (unsigned long int)(done_time - start_time) / (unsigned long int)((signed long int)1000000 / (signed long int)1000) : ((unsigned long int)(done_time - start_time) * (unsigned long int)1000) / (unsigned long int)(signed long int)1000000);
  }

  return 1;
}

// GC_reclaim_block
// file reclaim.c line 374
void GC_reclaim_block(struct hblk *hbp, unsigned long int report_if_found)
{
  struct hblkhdr *hhdr;
  hhdr=GC_find_header((char *)hbp);
  unsigned long int sz = hhdr->hb_sz;
  struct obj_kind *ok = &GC_obj_kinds[(signed long int)hhdr->hb_obj_kind];
  struct hblk **rlh;
  signed int return_value_GC_block_nearly_full$1;
  if(sz >= 2049ul)
  {
    if(hhdr->_mark_byte_union._hb_marks[0l] == 0)
    {
      if(!(report_if_found == 0ul))
        GC_add_leaked((char *)hbp);

      else
      {
        unsigned long int blocks;
        if(!((signed long int)(8 & (signed int)hhdr->hb_flags) == 0l))
        {
          struct obj_kind *GC_reclaim_block$$1$$1$$1$$2$$1$$ok = &GC_obj_kinds[(signed long int)hhdr->hb_obj_kind];
          signed int return_value;
          return_value=GC_reclaim_block$$1$$1$$1$$2$$1$$ok->ok_disclaim_proc((void *)hbp);
          if(!(return_value == 0))
            hhdr->_mark_byte_union._hb_marks[(signed long int)0] = (char)1;

        }

        blocks = (sz + (unsigned long int)(1 << 12)) - (unsigned long int)1 >> (unsigned long int)12;
        if(blocks >= 2ul)
          GC_arrays._large_allocd_bytes = GC_arrays._large_allocd_bytes - blocks * (unsigned long int)(1 << 12);

        GC_bytes_found = GC_bytes_found + (signed long int)sz;
        GC_freehblk(hbp);
      }
    }

    else
    {

    in_use:
      ;
      if(!(hhdr->hb_descr == 0ul))
        GC_arrays._composite_in_use = GC_arrays._composite_in_use + sz;

      else
        GC_arrays._atomic_in_use = GC_arrays._atomic_in_use + sz;
    }
  }

  else
  {
    signed int empty;
    empty=GC_block_empty(hhdr);
    if(!(report_if_found == 0ul))
      GC_reclaim_small_nonempty_block(hbp, 1);

    else
      if(!(empty == 0))
      {
        if(!((8 & (signed int)hhdr->hb_flags) == 0))
          GC_disclaim_and_reclaim_or_free_small_block(hbp);

        else
        {
          GC_bytes_found = GC_bytes_found + (signed long int)(unsigned long int)(1 << 12);
          GC_freehblk(hbp);
        }
      }

      else
      {
        _Bool tmp_if_expr$2;
        if(!(GC_find_leak == 0))
          tmp_if_expr$2 = (_Bool)1;

        else
        {
          return_value_GC_block_nearly_full$1=GC_block_nearly_full(hhdr);
          tmp_if_expr$2 = !(return_value_GC_block_nearly_full$1 != 0) ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$2)
        {
          rlh = &ok->ok_reclaim_list[(signed long int)(sz >> 4)];
          hhdr->hb_next = *rlh;
          *rlh = hbp;
        }

      }
    if(!(hhdr->hb_descr == 0ul))
      GC_arrays._composite_in_use = GC_arrays._composite_in_use + sz * hhdr->hb_n_marks;

    else
      GC_arrays._atomic_in_use = GC_arrays._atomic_in_use + sz * hhdr->hb_n_marks;
  }
}

// GC_reclaim_check
// file reclaim.c line 274
void GC_reclaim_check(struct hblk *hbp, struct hblkhdr *hhdr, unsigned long int sz)
{
  unsigned long int bit_no;
  char *p;
  char *plim;
  p = hbp->hb_body;
  plim = (p + (signed long int)(unsigned long int)(1 << 12)) - (signed long int)sz;
  bit_no = (unsigned long int)0;
  for( ; (unsigned long int)plim >= (unsigned long int)p; bit_no = bit_no + (sz >> 4))
  {
    if(hhdr->_mark_byte_union._hb_marks[(signed long int)bit_no] == 0)
      GC_add_leaked(p);

    p = p + (signed long int)sz;
  }
}

// GC_reclaim_clear
// file reclaim.c line 146
char * GC_reclaim_clear(struct hblk *hbp, struct hblkhdr *hhdr, unsigned long int sz, char *list, signed long int *count)
{
  unsigned long int bit_no = (unsigned long int)0;
  unsigned long int *p;
  unsigned long int *q;
  unsigned long int *plim;
  signed long int n_bytes_found = (signed long int)0;
  p = (unsigned long int *)hbp->hb_body;
  plim = (unsigned long int *)((hbp->hb_body + (signed long int)(unsigned long int)(1 << 12)) - (signed long int)sz);
  for( ; (unsigned long int)plim >= (unsigned long int)p; bit_no = bit_no + (sz >> 4))
    if(!(hhdr->_mark_byte_union._hb_marks[(signed long int)bit_no] == 0))
      p = (unsigned long int *)((char *)p + (signed long int)sz);

    else
    {
      n_bytes_found = n_bytes_found + (signed long int)sz;
      *((void **)p) = (void *)list;
      list = (char *)p;
      q = (unsigned long int *)((char *)p + (signed long int)sz);
      p[(signed long int)1] = (unsigned long int)0;
      p = p + (signed long int)2;
      for( ; !((unsigned long int)p >= (unsigned long int)q); p = p + (signed long int)2)
      {
        ((unsigned long int *)p)[(signed long int)0] = (unsigned long int)0;
        ((unsigned long int *)p)[(signed long int)1] = (unsigned long int)0;
      }
    }
  *count = *count + n_bytes_found;
  return list;
}

// GC_reclaim_generic
// file ./include/private/gc_priv.h line 1793
char * GC_reclaim_generic(struct hblk *hbp, struct hblkhdr *hhdr, unsigned long int sz, signed int init, char *list, signed long int *count)
{
  char *result;
  GC_remove_protection(hbp, (unsigned long int)1, (signed int)(hhdr->hb_descr == (unsigned long int)0));
  if(!((8 & (signed int)hhdr->hb_flags) == 0))
    result=GC_disclaim_and_reclaim(hbp, hhdr, sz, list, count);

  else
    if(!(GC_debugging_started == 0) || !(init == 0))
      result=GC_reclaim_clear(hbp, hhdr, sz, list, count);

    else
      result=GC_reclaim_uninit(hbp, hhdr, sz, list, count);
  if((-2 & (signed int)hhdr->hb_obj_kind) == 2)
    GC_set_hdr_marks(hhdr);

  return result;
}

// GC_reclaim_small_nonempty_block
// file reclaim.c line 327
void GC_reclaim_small_nonempty_block(struct hblk *hbp, signed int report_if_found)
{
  struct hblkhdr *hhdr;
  hhdr=GC_find_header((char *)hbp);
  unsigned long int sz = hhdr->hb_sz;
  struct obj_kind *ok = &GC_obj_kinds[(signed long int)hhdr->hb_obj_kind];
  void **flh = &ok->ok_freelist[(signed long int)(sz >> 4)];
  hhdr->hb_last_reclaimed = (unsigned short int)GC_gc_no;
  if(!(report_if_found == 0))
    GC_reclaim_check(hbp, hhdr, sz);

  else
  {
    char *return_value_GC_reclaim_generic$1;
    return_value_GC_reclaim_generic$1=GC_reclaim_generic(hbp, hhdr, sz, ok->ok_init, (char *)*flh, &GC_bytes_found);
    *flh = (void *)return_value_GC_reclaim_generic$1;
  }
}

// GC_reclaim_unconditionally_marked
// file reclaim.c line 747
void GC_reclaim_unconditionally_marked(void)
{
  unsigned long int sz;
  unsigned int kind;
  struct hblkhdr *hhdr;
  struct hblk *hbp;
  struct obj_kind *ok;
  struct hblk **rlp;
  struct hblk **rlh;
  kind = (unsigned int)0;
  for( ; !(kind >= GC_n_kinds); kind = kind + 1u)
  {
    ok = &GC_obj_kinds[(signed long int)kind];
    if(!(ok->ok_mark_unconditionally == 0))
    {
      rlp = ok->ok_reclaim_list;
      if(!(rlp == ((struct hblk **)NULL)))
      {
        sz = (unsigned long int)1;
        for( ; !(sz >= 129ul); sz = sz + 1ul)
        {
          rlh = rlp + (signed long int)sz;
          do
          {
            hbp = *rlh;
            if(hbp == ((struct hblk *)NULL))
              break;

            hhdr=GC_find_header((char *)hbp);
            *rlh = hhdr->hb_next;
            GC_reclaim_small_nonempty_block(hbp, 0);
          }
          while((_Bool)1);
        }
      }

    }

  }
}

// GC_reclaim_uninit
// file reclaim.c line 193
char * GC_reclaim_uninit(struct hblk *hbp, struct hblkhdr *hhdr, unsigned long int sz, char *list, signed long int *count)
{
  unsigned long int bit_no = (unsigned long int)0;
  unsigned long int *p;
  unsigned long int *plim;
  signed long int n_bytes_found = (signed long int)0;
  p = (unsigned long int *)hbp->hb_body;
  plim = (unsigned long int *)(((char *)hbp + (signed long int)(unsigned long int)(1 << 12)) - (signed long int)sz);
  for( ; (unsigned long int)plim >= (unsigned long int)p; bit_no = bit_no + (sz >> 4))
  {
    if(hhdr->_mark_byte_union._hb_marks[(signed long int)bit_no] == 0)
    {
      n_bytes_found = n_bytes_found + (signed long int)sz;
      *((void **)p) = (void *)list;
      list = (char *)p;
    }

    p = (unsigned long int *)((char *)p + (signed long int)sz);
  }
  *count = *count + n_bytes_found;
  return list;
}

// GC_record_stack_base
// file pthread_support.c line 1506
static inline void GC_record_stack_base(struct GC_Thread_Rep *me, struct GC_stack_base *sb)
{
  me->stop_info.stack_ptr = (char *)sb->mem_base;
  me->stack_end = (char *)sb->mem_base;
  if(me->stack_end == ((char *)NULL))
  {
    GC_on_abort("Bad stack base in GC_register_my_thread");
    abort();
  }

}

// GC_record_stack_base$link1
// file pthread_support.c line 1506
static inline void GC_record_stack_base$link1(struct GC_Thread_Rep *me$link1, struct GC_stack_base *sb$link1)
{
  me$link1->stop_info.stack_ptr = (char *)sb$link1->mem_base;
  me$link1->stack_end = (char *)sb$link1->mem_base;
  if(me$link1->stack_end == ((char *)NULL))
  {
    GC_on_abort("Bad stack base in GC_register_my_thread");
    abort();
  }

}

// GC_register_data_segments
// file ./include/private/gc_priv.h line 1677
void GC_register_data_segments(void)
{
  GC_add_roots_inner(GC_data_start, (char *)_end, 0);
}

// GC_register_describe_type_fn
// file dbg_mlc.c line 318
extern void GC_register_describe_type_fn(signed int kind, void (*fn)(void *, char *))
{
  GC_describe_type_fns[(signed long int)kind] = fn;
}

// GC_register_disappearing_link
// file finalize.c line 137
extern signed int GC_register_disappearing_link(void **link)
{
  char *base;
  void *return_value_GC_base$1;
  return_value_GC_base$1=GC_base((void *)link);
  base = (char *)return_value_GC_base$1;
  if(base == ((char *)NULL))
  {
    GC_on_abort("Bad arg to GC_register_disappearing_link");
    abort();
  }

  signed int return_value_GC_general_register_disappearing_link$2;
  return_value_GC_general_register_disappearing_link$2=GC_general_register_disappearing_link(link, (const void *)base);
  return return_value_GC_general_register_disappearing_link$2;
}

// GC_register_disappearing_link_inner
// file finalize.c line 147
signed int GC_register_disappearing_link_inner(struct dl_hashtbl_s *dl_hashtbl, void **link, const void *obj)
{
  struct disappearing_link *curr_dl;
  unsigned long int index;
  struct disappearing_link *new_dl;
  do
    if(!(GC_need_to_lock == 0))
    {
      signed int return_value_pthread_mutex_trylock$1;
      return_value_pthread_mutex_trylock$1=pthread_mutex_trylock(&GC_allocate_ml);
      if(!(return_value_pthread_mutex_trylock$1 == 0))
        GC_lock();

    }

  while((_Bool)0);
  _Bool tmp_if_expr$2;
  if(dl_hashtbl->log_size == -1l)
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = dl_hashtbl->entries > (unsigned long int)1 << dl_hashtbl->log_size ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$2)
  {
    GC_grow_table((struct hash_chain_entry ***)&dl_hashtbl->head, &dl_hashtbl->log_size);
    if(!(GC_print_stats == 0))
      GC_log_printf("Grew dl table to %u entries\n", 1 << (unsigned int)dl_hashtbl->log_size);

  }

  index = ((unsigned long int)link >> 3 ^ (unsigned long int)link >> (signed long int)3 + dl_hashtbl->log_size) & (unsigned long int)((1 << dl_hashtbl->log_size) - 1);
  curr_dl = dl_hashtbl->head[(signed long int)index];
  for( ; !(curr_dl == ((struct disappearing_link *)NULL)); curr_dl = (struct disappearing_link *)curr_dl->prolog.next)
    if(curr_dl->prolog.hidden_key == ~((unsigned long int)link))
    {
      curr_dl->dl_hidden_obj = ~((unsigned long int)obj);
      do
        if(!(GC_need_to_lock == 0))
          pthread_mutex_unlock(&GC_allocate_ml);

      while((_Bool)0);
      return 1;
    }

  void *return_value_GC_generic_malloc_inner$3;
  return_value_GC_generic_malloc_inner$3=GC_generic_malloc_inner(sizeof(struct disappearing_link) /*24ul*/ , 1);
  new_dl = (struct disappearing_link *)return_value_GC_generic_malloc_inner$3;
  if(new_dl == ((struct disappearing_link *)NULL))
  {
    void * (*oom_fn)(unsigned long int) = GC_oom_fn;
    do
      if(!(GC_need_to_lock == 0))
        pthread_mutex_unlock(&GC_allocate_ml);

    while((_Bool)0);
    void *return_value;
    return_value=oom_fn(sizeof(struct disappearing_link) /*24ul*/ );
    new_dl = (struct disappearing_link *)return_value;
    if(new_dl == ((struct disappearing_link *)NULL))
      return 2;

    if(!(GC_need_to_lock == 0))
    {
      signed int return_value_pthread_mutex_trylock$4;
      return_value_pthread_mutex_trylock$4=pthread_mutex_trylock(&GC_allocate_ml);
      if(!(return_value_pthread_mutex_trylock$4 == 0))
        GC_lock();

    }

    index = ((unsigned long int)link >> 3 ^ (unsigned long int)link >> (signed long int)3 + dl_hashtbl->log_size) & (unsigned long int)((1 << dl_hashtbl->log_size) - 1);
    curr_dl = dl_hashtbl->head[(signed long int)index];
    if(!(curr_dl == ((struct disappearing_link *)NULL)))
    {
      if(curr_dl->prolog.hidden_key == ~((unsigned long int)link))
      {
        curr_dl->dl_hidden_obj = ~((unsigned long int)obj);
        if(!(GC_need_to_lock == 0))
          pthread_mutex_unlock(&GC_allocate_ml);

        GC_free((void *)new_dl);
        return 1;
      }

      curr_dl = (struct disappearing_link *)curr_dl->prolog.next;
    }

  }

  new_dl->dl_hidden_obj = ~((unsigned long int)obj);
  new_dl->prolog.hidden_key = ~((unsigned long int)link);
  new_dl->prolog.next = (struct hash_chain_entry *)dl_hashtbl->head[(signed long int)index];
  dl_hashtbl->head[(signed long int)index] = new_dl;
  dl_hashtbl->entries = dl_hashtbl->entries + 1ul;
  do
    if(!(GC_need_to_lock == 0))
      pthread_mutex_unlock(&GC_allocate_ml);

  while((_Bool)0);
  return 0;
}

// GC_register_disclaim_proc
// file fnlz_mlc.c line 76
extern void GC_register_disclaim_proc(signed int kind, signed int (*proc)(void *), signed int mark_unconditionally)
{
  GC_obj_kinds[(signed long int)kind].ok_disclaim_proc = proc;
  GC_obj_kinds[(signed long int)kind].ok_mark_unconditionally = (signed int)mark_unconditionally;
}

// GC_register_displacement
// file ./include/private/../gc.h line 535
extern void GC_register_displacement(unsigned long int offset)
{
  do
    if(!(GC_need_to_lock == 0))
    {
      signed int return_value_pthread_mutex_trylock$1;
      return_value_pthread_mutex_trylock$1=pthread_mutex_trylock(&GC_allocate_ml);
      if(!(return_value_pthread_mutex_trylock$1 == 0))
        GC_lock();

    }

  while((_Bool)0);
  GC_register_displacement_inner(offset);
  do
    if(!(GC_need_to_lock == 0))
      pthread_mutex_unlock(&GC_allocate_ml);

  while((_Bool)0);
}

// GC_register_displacement_inner
// file ./include/private/gc_priv.h line 1738
void GC_register_displacement_inner(unsigned long int offset)
{
  if(offset >= 4096ul)
  {
    GC_on_abort("Bad argument to GC_register_displacement");
    abort();
  }

  if(GC_arrays._valid_offsets[(signed long int)offset] == 0)
  {
    GC_arrays._valid_offsets[(signed long int)offset] = (char)1;
    GC_arrays._modws_valid_offsets[(signed long int)(offset % sizeof(unsigned long int) /*8ul*/ )] = (char)1;
  }

}

// GC_register_dynamic_libraries
// file dyn_load.c line 707
void GC_register_dynamic_libraries(void)
{
  struct link_map *lm;
  signed int return_value_GC_register_dynamic_libraries_dl_iterate_phdr$1;
  return_value_GC_register_dynamic_libraries_dl_iterate_phdr$1=GC_register_dynamic_libraries_dl_iterate_phdr();
  if(return_value_GC_register_dynamic_libraries_dl_iterate_phdr$1 == 0)
  {
    lm=GC_FirstDLOpenedLinkMap();
    for( ; !(lm == ((struct link_map *)NULL)); lm = lm->l_next)
    {
      struct anonymous$23 *e;
      struct anonymous$20 *p;
      unsigned long int offset;
      char *start;
      signed int i;
      e = (struct anonymous$23 *)lm->l_addr;
      p = (struct anonymous$20 *)((char *)e + (signed long int)e->e_phoff);
      offset = (unsigned long int)lm->l_addr;
      i = 0;
      for( ; !(i >= (signed int)e->e_phnum); p = p + 1l)
      {
        if(p->p_type == 1u)
        {
          if(!((2u & p->p_flags) == 0u))
          {
            start = (char *)p->p_vaddr + (signed long int)offset;
            GC_add_roots_inner(start, start + (signed long int)p->p_memsz, 1);
          }

        }

        i = i + 1;
      }
    }
  }

}

// GC_register_dynamic_libraries_dl_iterate_phdr
// file dyn_load.c line 568
signed int GC_register_dynamic_libraries_dl_iterate_phdr(void)
{
  signed int did_something;
  signed int return_value_GC_register_main_static_data$1;
  return_value_GC_register_main_static_data$1=GC_register_main_static_data();
  if(!(return_value_GC_register_main_static_data$1 == 0))
    return 0;

  else
  {
    n_load_segs = 0;
    static signed int excluded_segs = 0;
    if((signed long int)excluded_segs == 0l)
    {
      GC_exclude_static_roots_inner((void *)(char *)load_segs, (void *)((char *)load_segs + (signed long int)sizeof(struct load_segment [2048l]) /*65536ul*/ ));
      excluded_segs = 1;
    }

    did_something = 0;
    dl_iterate_phdr(GC_register_dynlib_callback, (void *)&did_something);
    if(!(did_something == 0))
    {
      signed int i = 0;
      for( ; !(i >= n_load_segs); i = i + 1)
      {
        if(!((unsigned long int)load_segs[(signed long int)i].start >= (unsigned long int)load_segs[(signed long int)i].end))
          GC_add_roots_inner(load_segs[(signed long int)i].start, load_segs[(signed long int)i].end, 1);

        if(!((unsigned long int)load_segs[(signed long int)i].start2 >= (unsigned long int)load_segs[(signed long int)i].end2))
          GC_add_roots_inner(load_segs[(signed long int)i].start2, load_segs[(signed long int)i].end2, 1);

      }
    }

    else
    {
      char *datastart;
      char *dataend;
      datastart = GC_data_start;
      dataend = (char *)_end;
      GC_add_roots_inner(datastart, dataend, 1);
    }
    return 1;
  }
}

// GC_register_dynlib_callback
// file dyn_load.c line 469
signed int GC_register_dynlib_callback(struct dl_phdr_info *info, unsigned long int size, void *ptr)
{
  const struct anonymous$20 *p;
  char *start;
  char *end;
  signed int i;
  signed int return_value;
  if(!(size >= sizeof(unsigned short int) * 13 /*26ul*/ ))
    return -1;

  else
  {
    p = info->dlpi_phdr;
    i = 0;
    for( ; !(i >= (signed int)info->dlpi_phnum); p = p + 1l)
    {
      switch(p->p_type)
      {
        case (unsigned int)0x6474e552:
        {
          signed int j;
          start = (char *)p->p_vaddr + (signed long int)info->dlpi_addr;
          end = start + (signed long int)p->p_memsz;
          j = n_load_segs;
          do
          {
            j = j - 1;
            if(!(j >= 0))
              break;

            if((unsigned long int)start >= (unsigned long int)load_segs[(signed long int)j].start)
            {
              if(!((unsigned long int)start >= (unsigned long int)load_segs[(signed long int)j].end))
              {
                if(!(load_segs[(signed long int)j].start2 == ((char *)NULL)))
                  GC_current_warn_proc("GC Warning: More than one GNU_RELRO segment per load seg\n", (unsigned long int)0);

                else
                {
                  load_segs[(signed long int)j].end2 = load_segs[(signed long int)j].end;
                  load_segs[(signed long int)j].end = start;
                  load_segs[(signed long int)j].start2 = end;
                }
                break;
              }

            }

            if(j == 0)
              GC_current_warn_proc("GC Warning: Failed to find PT_GNU_RELRO segment inside PT_LOAD region", (unsigned long int)0);

          }
          while((_Bool)1);
          break;
        }
        case (unsigned int)1:
        {
          signed int (*callback)(const char *, void *, unsigned long int) = GC_has_static_roots;
          if(!((2u & p->p_flags) == 0u))
          {
            start = (char *)p->p_vaddr + (signed long int)info->dlpi_addr;
            end = start + (signed long int)p->p_memsz;
            if(!(callback == ((signed int (*)(const char *, void *, unsigned long int))NULL)))
            {
              return_value=callback(info->dlpi_name, (void *)start, p->p_memsz);
              if(return_value == 0)
                break;

            }

            if(n_load_segs >= 2048)
            {
              GC_on_abort("Too many PT_LOAD segs");
              abort();
            }

            start = (char *)((unsigned long int)start & ~(sizeof(unsigned long int) /*8ul*/  - (unsigned long int)1));
            load_segs[(signed long int)n_load_segs].start = start;
            load_segs[(signed long int)n_load_segs].end = end;
            load_segs[(signed long int)n_load_segs].start2 = ((char *)NULL);
            load_segs[(signed long int)n_load_segs].end2 = ((char *)NULL);
            n_load_segs = n_load_segs + 1;
          }

        }
      }
      i = i + 1;
    }
    *((signed int *)ptr) = 1;
    return 0;
  }
}

// GC_register_finalizer
// file ./include/private/../gc.h line 914
extern void GC_register_finalizer(void *obj, void (*fn)(void *, void *), void *cd, void (**ofn)(void *, void *), void **ocd)
{
  GC_register_finalizer_inner(obj, fn, cd, ofn, ocd, GC_normal_finalize_mark_proc);
}

// GC_register_finalizer_ignore_self
// file ./include/private/../gc.h line 970
extern void GC_register_finalizer_ignore_self(void *obj, void (*fn)(void *, void *), void *cd, void (**ofn)(void *, void *), void **ocd)
{
  GC_register_finalizer_inner(obj, fn, cd, ofn, ocd, GC_ignore_self_finalize_mark_proc);
}

// GC_register_finalizer_inner
// file finalize.c line 433
void GC_register_finalizer_inner(void *obj, void (*fn)(void *, void *), void *cd, void (**ofn)(void *, void *), void **ocd, void (*mp)(char *))
{
  char *base;
  struct finalizable_object *curr_fo;
  struct finalizable_object *prev_fo;
  unsigned long int index;
  struct finalizable_object *new_fo = ((struct finalizable_object *)NULL);
  struct hblkhdr *hhdr = (struct hblkhdr *)(void *)0;
  void * (*oom_fn)(unsigned long int);
  do
    if(!(GC_need_to_lock == 0))
    {
      signed int return_value_pthread_mutex_trylock$1;
      return_value_pthread_mutex_trylock$1=pthread_mutex_trylock(&GC_allocate_ml);
      if(!(return_value_pthread_mutex_trylock$1 == 0))
        GC_lock();

    }

  while((_Bool)0);
  if(log_fo_table_size == -1l || !(1ul << log_fo_table_size >= GC_fo_entries))
  {
    GC_grow_table((struct hash_chain_entry ***)&GC_fo_head, &log_fo_table_size);
    if(!(GC_print_stats == 0))
      GC_log_printf("Grew fo table to %u entries\n", 1 << (unsigned int)log_fo_table_size);

  }

  base = (char *)obj;
  index = ((unsigned long int)base >> 3 ^ (unsigned long int)base >> (signed long int)3 + log_fo_table_size) & (unsigned long int)((1 << log_fo_table_size) - 1);
  prev_fo = ((struct finalizable_object *)NULL);
  curr_fo = GC_fo_head[(signed long int)index];
  for( ; !(curr_fo == ((struct finalizable_object *)NULL)); curr_fo = (struct finalizable_object *)curr_fo->prolog.next)
  {
    if(curr_fo->prolog.hidden_key == ~((unsigned long int)base))
    {
      if(!(ocd == ((void **)NULL)))
        *ocd = (void *)curr_fo->fo_client_data;

      if(!(ofn == ((void (**)(void *, void *))NULL)))
        *ofn = curr_fo->fo_fn;

      if(prev_fo == ((struct finalizable_object *)NULL))
        GC_fo_head[(signed long int)index] = (struct finalizable_object *)curr_fo->prolog.next;

      else
        prev_fo->prolog.next = (struct hash_chain_entry *)(struct finalizable_object *)curr_fo->prolog.next;
      if(fn == ((void (*)(void *, void *))NULL))
        GC_fo_entries = GC_fo_entries - 1ul;

      else
      {
        curr_fo->fo_fn = fn;
        curr_fo->fo_client_data = (char *)cd;
        curr_fo->fo_mark_proc = mp;
        if(prev_fo == ((struct finalizable_object *)NULL))
          GC_fo_head[(signed long int)index] = curr_fo;

        else
          prev_fo->prolog.next = (struct hash_chain_entry *)curr_fo;
      }
      do
        if(!(GC_need_to_lock == 0))
          pthread_mutex_unlock(&GC_allocate_ml);

      while((_Bool)0);
      if(!(new_fo == ((struct finalizable_object *)NULL)))
        GC_free((void *)new_fo);

      goto __CPROVER_DUMP_L41;
    }

    prev_fo = curr_fo;
  }
  if(new_fo == ((struct finalizable_object *)NULL))
  {
    if(fn == ((void (*)(void *, void *))NULL))
    {
      if(!(ocd == ((void **)NULL)))
        *ocd = NULL;

      if(!(ofn == ((void (**)(void *, void *))NULL)))
        *ofn = ((void (*)(void *, void *))NULL);

      do
        if(!(GC_need_to_lock == 0))
          pthread_mutex_unlock(&GC_allocate_ml);

      while((_Bool)0);
      goto __CPROVER_DUMP_L41;
    }

    do
    {
      struct hblkhdr **_ha;
      do
      {
        struct bi *bi;
        do
        {
          unsigned long int hi = (unsigned long int)base >> (unsigned long int)10 + (unsigned long int)12;
          struct bi *_bi = GC_arrays._top_index[(signed long int)(hi & (unsigned long int)((1 << 11) - 1))];
          for( ; !(_bi->key == hi); _bi = _bi->hash_link)
            if(_bi == GC_arrays._all_nils)
              break;

          bi = _bi;
        }
        while((_Bool)0);
        _ha = &bi->index[(signed long int)((unsigned long int)base >> (unsigned long int)12 & (unsigned long int)((1 << 10) - 1))];
      }
      while((_Bool)0);
      hhdr = *_ha;
    }
    while((_Bool)0);
    if(hhdr == ((struct hblkhdr *)NULL))
    {
      if(!(ocd == ((void **)NULL)))
        *ocd = NULL;

      if(!(ofn == ((void (**)(void *, void *))NULL)))
        *ofn = ((void (*)(void *, void *))NULL);

      do
        if(!(GC_need_to_lock == 0))
          pthread_mutex_unlock(&GC_allocate_ml);

      while((_Bool)0);
      goto __CPROVER_DUMP_L41;
    }

    void *return_value_GC_generic_malloc_inner$2;
    return_value_GC_generic_malloc_inner$2=GC_generic_malloc_inner(sizeof(struct finalizable_object) /*48ul*/ , 1);
    new_fo = (struct finalizable_object *)return_value_GC_generic_malloc_inner$2;
    if(new_fo == ((struct finalizable_object *)NULL))
    {
      oom_fn = GC_oom_fn;
      do
        if(!(GC_need_to_lock == 0))
          pthread_mutex_unlock(&GC_allocate_ml);

      while((_Bool)0);
      void *return_value;
      return_value=oom_fn(sizeof(struct finalizable_object) /*48ul*/ );
      new_fo = (struct finalizable_object *)return_value;
      if(!(GC_need_to_lock == 0))
      {
        signed int return_value_pthread_mutex_trylock$3;
        return_value_pthread_mutex_trylock$3=pthread_mutex_trylock(&GC_allocate_ml);
        if(!(return_value_pthread_mutex_trylock$3 == 0))
          GC_lock();

      }

    }

  }

  if(!(ocd == ((void **)NULL)))
    *ocd = NULL;

  if(!(ofn == ((void (**)(void *, void *))NULL)))
    *ofn = ((void (*)(void *, void *))NULL);

  new_fo->prolog.hidden_key = ~((unsigned long int)base);
  new_fo->fo_fn = fn;
  new_fo->fo_client_data = (char *)cd;
  new_fo->fo_object_size = hhdr->hb_sz;
  new_fo->fo_mark_proc = mp;
  new_fo->prolog.next = (struct hash_chain_entry *)GC_fo_head[(signed long int)index];
  GC_fo_entries = GC_fo_entries + 1ul;
  GC_fo_head[(signed long int)index] = new_fo;
  do
    if(!(GC_need_to_lock == 0))
      pthread_mutex_unlock(&GC_allocate_ml);

  while((_Bool)0);

__CPROVER_DUMP_L41:
  ;
}

// GC_register_finalizer_no_order
// file ./include/private/../gc.h line 983
extern void GC_register_finalizer_no_order(void *obj, void (*fn)(void *, void *), void *cd, void (**ofn)(void *, void *), void **ocd)
{
  GC_register_finalizer_inner(obj, fn, cd, ofn, ocd, GC_null_finalize_mark_proc);
}

// GC_register_finalizer_unreachable
// file ./include/private/../gc.h line 1008
extern void GC_register_finalizer_unreachable(void *obj, void (*fn)(void *, void *), void *cd, void (**ofn)(void *, void *), void **ocd)
{
  need_unreachable_finalization = 1;
  GC_register_finalizer_inner(obj, fn, cd, ofn, ocd, GC_unreachable_finalize_mark_proc);
}

// GC_register_has_static_roots_callback
// file dyn_load.c line 1503
extern void GC_register_has_static_roots_callback(signed int (*callback)(const char *, void *, unsigned long int))
{
  GC_has_static_roots = callback;
}

// GC_register_long_link
// file finalize.c line 267
extern signed int GC_register_long_link(void **link, const void *obj)
{
  if(link == ((void **)NULL) || !((7ul & (unsigned long int)link) == 0ul))
  {
    GC_on_abort("Bad arg to GC_register_long_link");
    abort();
  }

  signed int return_value_GC_register_disappearing_link_inner$1;
  return_value_GC_register_disappearing_link_inner$1=GC_register_disappearing_link_inner(&GC_ll_hashtbl, link, obj);
  return return_value_GC_register_disappearing_link_inner$1;
}

// GC_register_main_static_data
// file dyn_load.c line 556
signed int GC_register_main_static_data(void)
{
  return (signed int)(dl_iterate_phdr == ((signed int (*)(signed int (*)(struct dl_phdr_info *, unsigned long int, void *), void *))NULL));
}

// GC_register_my_thread
// file pthread_support.c line 1550
extern signed int GC_register_my_thread(struct GC_stack_base *sb)
{
  unsigned long int self;
  self=pthread_self();
  struct GC_Thread_Rep *me;
  if(GC_need_to_lock == 0)
  {
    GC_on_abort("Threads explicit registering is not previously enabled");
    abort();
  }

  do
    if(!(GC_need_to_lock == 0))
    {
      signed int return_value_pthread_mutex_trylock$1;
      return_value_pthread_mutex_trylock$1=pthread_mutex_trylock(&GC_allocate_ml);
      if(!(return_value_pthread_mutex_trylock$1 == 0))
        GC_lock();

    }

  while((_Bool)0);
  me=GC_lookup_thread(self);
  if(me == ((struct GC_Thread_Rep *)NULL))
  {
    me=GC_register_my_thread_inner(sb, self);
    me->flags = me->flags | (unsigned char)2;
    GC_init_thread_local(&me->tlfs);
    do
      if(!(GC_need_to_lock == 0))
        pthread_mutex_unlock(&GC_allocate_ml);

    while((_Bool)0);
    return 0;
  }

  else
    if(!((1 & (signed int)me->flags) == 0))
    {
      GC_record_stack_base(me, sb);
      me->flags = me->flags & (unsigned char)~1;
      GC_init_thread_local(&me->tlfs);
      do
        if(!(GC_need_to_lock == 0))
          pthread_mutex_unlock(&GC_allocate_ml);

      while((_Bool)0);
      return 0;
    }

    else
    {
      do
        if(!(GC_need_to_lock == 0))
          pthread_mutex_unlock(&GC_allocate_ml);

      while((_Bool)0);
      return 1;
    }
}

// GC_register_my_thread_inner
// file pthread_support.c line 1520
struct GC_Thread_Rep * GC_register_my_thread_inner(struct GC_stack_base *sb, unsigned long int my_pthread)
{
  struct GC_Thread_Rep *me;
  GC_in_thread_creation = 1;
  me=GC_new_thread(my_pthread);
  GC_in_thread_creation = 0;
  if(me == ((struct GC_Thread_Rep *)NULL))
  {
    GC_on_abort("Failed to allocate memory for thread registering");
    abort();
  }

  GC_record_stack_base(me, sb);
  return me;
}

// GC_release_mark_lock
// file ./include/private/gc_priv.h line 2372
void GC_release_mark_lock(void)
{
  signed int return_value_pthread_mutex_unlock$1;
  return_value_pthread_mutex_unlock$1=pthread_mutex_unlock(&mark_mutex);
  if(!(return_value_pthread_mutex_unlock$1 == 0))
  {
    GC_on_abort("pthread_mutex_unlock failed");
    abort();
  }

}

// GC_remove_all_threads_but_me
// file pthread_support.c line 664
void GC_remove_all_threads_but_me(void)
{
  unsigned long int self;
  self=pthread_self();
  signed int hv;
  struct GC_Thread_Rep *p;
  struct GC_Thread_Rep *next;
  struct GC_Thread_Rep *me;
  hv = 0;
  for( ; !(hv >= 256); hv = hv + 1)
  {
    me = ((struct GC_Thread_Rep *)NULL);
    p = GC_threads[(signed long int)hv];
    for( ; !(p == ((struct GC_Thread_Rep *)NULL)); p = next)
    {
      next = p->next;
      if(p->id == self)
      {
        me = p;
        p->next = ((struct GC_Thread_Rep *)NULL);
        GC_thread_key = (void *)&me->tlfs;
      }

      else
      {
        if((1 & (signed int)p->flags) == 0)
          GC_destroy_thread_local(&p->tlfs);

        if(!(p == &first_thread))
          GC_free_inner((void *)p);

      }
    }
    GC_threads[(signed long int)hv] = me;
  }
}

// GC_remove_allowed_signals
// file pthread_stop_world.c line 82
void GC_remove_allowed_signals(struct anonymous$6 *set)
{
  signed int return_value_sigdelset$1;
  return_value_sigdelset$1=sigdelset(set, 2);
  _Bool tmp_if_expr$3;
  signed int return_value_sigdelset$2;
  if(!(return_value_sigdelset$1 == 0))
    tmp_if_expr$3 = (_Bool)1;

  else
  {
    return_value_sigdelset$2=sigdelset(set, 3);
    tmp_if_expr$3 = return_value_sigdelset$2 != 0 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr$5;
  signed int return_value_sigdelset$4;
  if(tmp_if_expr$3)
    tmp_if_expr$5 = (_Bool)1;

  else
  {
    return_value_sigdelset$4=sigdelset(set, 6);
    tmp_if_expr$5 = return_value_sigdelset$4 != 0 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr$7;
  signed int return_value_sigdelset$6;
  if(tmp_if_expr$5)
    tmp_if_expr$7 = (_Bool)1;

  else
  {
    return_value_sigdelset$6=sigdelset(set, 15);
    tmp_if_expr$7 = return_value_sigdelset$6 != 0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$7)
  {
    GC_on_abort("sigdelset failed");
    abort();
  }

  signed int return_value_sigdelset$8;
  return_value_sigdelset$8=sigdelset(set, 11);
  _Bool tmp_if_expr$10;
  signed int return_value_sigdelset$9;
  if(!(return_value_sigdelset$8 == 0))
    tmp_if_expr$10 = (_Bool)1;

  else
  {
    return_value_sigdelset$9=sigdelset(set, 7);
    tmp_if_expr$10 = return_value_sigdelset$9 != 0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$10)
  {
    GC_on_abort("sigdelset failed");
    abort();
  }

}

// GC_remove_counts
// file ./include/private/gc_priv.h line 1893
void GC_remove_counts(struct hblk *h, unsigned long int sz)
{
  struct hblk *hbp = h + (signed long int)1;
  for( ; !((unsigned long int)hbp >= sz + (unsigned long int)h); hbp = hbp + (signed long int)1)
    do
    {
      struct hblkhdr **_ha;
      do
      {
        struct bi *bi;
        do
        {
          unsigned long int hi = (unsigned long int)hbp >> (unsigned long int)10 + (unsigned long int)12;
          struct bi *_bi = GC_arrays._top_index[(signed long int)(hi & (unsigned long int)((1 << 11) - 1))];
          for( ; !(_bi->key == hi); _bi = _bi->hash_link)
            if(_bi == GC_arrays._all_nils)
              break;

          bi = _bi;
        }
        while((_Bool)0);
        _ha = &bi->index[(signed long int)((unsigned long int)hbp >> (unsigned long int)12 & (unsigned long int)((1 << 10) - 1))];
      }
      while((_Bool)0);
      *_ha = ((struct hblkhdr *)NULL);
    }
    while((_Bool)0);
}

// GC_remove_dangling_disappearing_links
// file finalize.c line 719
static inline void GC_remove_dangling_disappearing_links(struct dl_hashtbl_s *dl_hashtbl)
{
  struct disappearing_link *curr;
  struct disappearing_link *prev;
  struct disappearing_link *next;
  char *real_link;
  unsigned long int i;
  unsigned long int dl_size;
  signed int tmp_if_expr$1;
  if(dl_hashtbl->log_size == -1l)
    tmp_if_expr$1 = 0;

  else
    tmp_if_expr$1 = 1 << dl_hashtbl->log_size;
  dl_size = (unsigned long int)tmp_if_expr$1;
  i = (unsigned long int)0;
  signed int return_value_GC_is_marked$3;
  for( ; !(i >= dl_size); i = i + 1ul)
  {
    curr = dl_hashtbl->head[(signed long int)i];
    prev = (struct disappearing_link *)(void *)0;
    while(!(curr == ((struct disappearing_link *)NULL)))
    {
      void *return_value_GC_base$2;
      return_value_GC_base$2=GC_base((void *)~((unsigned long int)curr->prolog.hidden_key));
      real_link = (char *)return_value_GC_base$2;
      if(!(real_link == ((char *)NULL)))
      {
        return_value_GC_is_marked$3=GC_is_marked((const void *)real_link);
        if(return_value_GC_is_marked$3 == 0)
        {
          GC_clear_mark_bit((const void *)curr);
          next = (struct disappearing_link *)curr->prolog.next;
          if(prev == ((struct disappearing_link *)NULL))
            dl_hashtbl->head[(signed long int)i] = next;

          else
            prev->prolog.next = (struct hash_chain_entry *)next;
          GC_clear_mark_bit((const void *)curr);
          dl_hashtbl->entries = dl_hashtbl->entries - 1ul;
          curr = next;
          continue;
        }

      }

      prev = curr;
      curr = (struct disappearing_link *)curr->prolog.next;
    }
  }
}

// GC_remove_dangling_disappearing_links$link1
// file finalize.c line 719
static inline void GC_remove_dangling_disappearing_links$link1(struct dl_hashtbl_s *dl_hashtbl$link1)
{
  struct disappearing_link *curr$link1;
  struct disappearing_link *prev$link1;
  struct disappearing_link *next$link1;
  char *real_link$link1;
  unsigned long int i$link1;
  unsigned long int dl_size$link1;
  signed int tmp_if_expr$1$link1;
  if(dl_hashtbl$link1->log_size == -1l)
    tmp_if_expr$1$link1 = 0;

  else
    tmp_if_expr$1$link1 = 1 << dl_hashtbl$link1->log_size;
  dl_size$link1 = (unsigned long int)tmp_if_expr$1$link1;
  i$link1 = (unsigned long int)0;
  signed int return_value_GC_is_marked$3$link1;
  for( ; !(i$link1 >= dl_size$link1); i$link1 = i$link1 + 1ul)
  {
    curr$link1 = dl_hashtbl$link1->head[(signed long int)i$link1];
    prev$link1 = (struct disappearing_link *)(void *)0;
    while(!(curr$link1 == ((struct disappearing_link *)NULL)))
    {
      void *return_value_GC_base$2$link1;
      return_value_GC_base$2$link1=GC_base((void *)~((unsigned long int)curr$link1->prolog.hidden_key));
      real_link$link1 = (char *)return_value_GC_base$2$link1;
      if(!(real_link$link1 == ((char *)NULL)))
      {
        return_value_GC_is_marked$3$link1=GC_is_marked((const void *)real_link$link1);
        if(return_value_GC_is_marked$3$link1 == 0)
        {
          GC_clear_mark_bit((const void *)curr$link1);
          next$link1 = (struct disappearing_link *)curr$link1->prolog.next;
          if(prev$link1 == ((struct disappearing_link *)NULL))
            dl_hashtbl$link1->head[(signed long int)i$link1] = next$link1;

          else
            prev$link1->prolog.next = (struct hash_chain_entry *)next$link1;
          GC_clear_mark_bit((const void *)curr$link1);
          dl_hashtbl$link1->entries = dl_hashtbl$link1->entries - 1ul;
          curr$link1 = next$link1;
          continue;
        }

      }

      prev$link1 = curr$link1;
      curr$link1 = (struct disappearing_link *)curr$link1->prolog.next;
    }
  }
}

// GC_remove_from_fl
// file allchblk.c line 317
static inline void GC_remove_from_fl(struct hblkhdr *hhdr)
{
  signed int return_value_GC_hblk_fl_from_blocks$1;
  return_value_GC_hblk_fl_from_blocks$1=GC_hblk_fl_from_blocks(hhdr->hb_sz >> (unsigned long int)12);
  GC_remove_from_fl_at(hhdr, return_value_GC_hblk_fl_from_blocks$1);
}

// GC_remove_from_fl$link1
// file allchblk.c line 317
static inline void GC_remove_from_fl$link1(struct hblkhdr *hhdr$link1)
{
  signed int return_value_GC_hblk_fl_from_blocks$1$link1;
  return_value_GC_hblk_fl_from_blocks$1$link1=GC_hblk_fl_from_blocks(hhdr$link1->hb_sz >> (unsigned long int)12);
  GC_remove_from_fl_at(hhdr$link1, return_value_GC_hblk_fl_from_blocks$1$link1);
}

// GC_remove_from_fl_at
// file allchblk.c line 293
void GC_remove_from_fl_at(struct hblkhdr *hhdr, signed int index)
{
  if(hhdr->hb_prev == ((struct hblk *)NULL))
    GC_hblkfreelist[(signed long int)index] = hhdr->hb_next;

  else
  {
    struct hblkhdr *phdr;
    do
    {
      struct hblkhdr **GC_remove_from_fl_at$$1$$2$$1$$_ha;
      do
      {
        struct bi *bi;
        do
        {
          unsigned long int hi = (unsigned long int)hhdr->hb_prev >> (unsigned long int)10 + (unsigned long int)12;
          struct bi *_bi = GC_arrays._top_index[(signed long int)(hi & (unsigned long int)((1 << 11) - 1))];
          for( ; !(_bi->key == hi); _bi = _bi->hash_link)
            if(_bi == GC_arrays._all_nils)
              break;

          bi = _bi;
        }
        while((_Bool)0);
        GC_remove_from_fl_at$$1$$2$$1$$_ha = &bi->index[(signed long int)((unsigned long int)hhdr->hb_prev >> (unsigned long int)12 & (unsigned long int)((1 << 10) - 1))];
      }
      while((_Bool)0);
      phdr = *GC_remove_from_fl_at$$1$$2$$1$$_ha;
    }
    while((_Bool)0);
    phdr->hb_next = hhdr->hb_next;
  }
  GC_free_bytes[(signed long int)index] = GC_free_bytes[(signed long int)index] - hhdr->hb_sz;
  if(!(hhdr->hb_next == ((struct hblk *)NULL)))
  {
    struct hblkhdr *nhdr;
    do
    {
      struct hblkhdr **_ha;
      do
      {
        struct bi *GC_remove_from_fl_at$$1$$3$$1$$1$$bi;
        do
        {
          unsigned long int GC_remove_from_fl_at$$1$$3$$1$$1$$1$$hi = (unsigned long int)hhdr->hb_next >> (unsigned long int)10 + (unsigned long int)12;
          struct bi *GC_remove_from_fl_at$$1$$3$$1$$1$$1$$_bi = GC_arrays._top_index[(signed long int)(GC_remove_from_fl_at$$1$$3$$1$$1$$1$$hi & (unsigned long int)((1 << 11) - 1))];
          for( ; !(GC_remove_from_fl_at$$1$$3$$1$$1$$1$$_bi->key == GC_remove_from_fl_at$$1$$3$$1$$1$$1$$hi); GC_remove_from_fl_at$$1$$3$$1$$1$$1$$_bi = GC_remove_from_fl_at$$1$$3$$1$$1$$1$$_bi->hash_link)
            if(GC_remove_from_fl_at$$1$$3$$1$$1$$1$$_bi == GC_arrays._all_nils)
              break;

          GC_remove_from_fl_at$$1$$3$$1$$1$$bi = GC_remove_from_fl_at$$1$$3$$1$$1$$1$$_bi;
        }
        while((_Bool)0);
        _ha = &GC_remove_from_fl_at$$1$$3$$1$$1$$bi->index[(signed long int)((unsigned long int)hhdr->hb_next >> (unsigned long int)12 & (unsigned long int)((1 << 10) - 1))];
      }
      while((_Bool)0);
      nhdr = *_ha;
    }
    while((_Bool)0);
    nhdr->hb_prev = hhdr->hb_prev;
  }

}

// GC_remove_header
// file ./include/private/gc_priv.h line 1891
void GC_remove_header(struct hblk *h)
{
  struct hblkhdr **ha;
  do
  {
    struct bi *bi;
    do
    {
      unsigned long int hi = (unsigned long int)h >> (unsigned long int)10 + (unsigned long int)12;
      struct bi *_bi = GC_arrays._top_index[(signed long int)(hi & (unsigned long int)((1 << 11) - 1))];
      for( ; !(_bi->key == hi); _bi = _bi->hash_link)
        if(_bi == GC_arrays._all_nils)
          break;

      bi = _bi;
    }
    while((_Bool)0);
    ha = &bi->index[(signed long int)((unsigned long int)h >> (unsigned long int)12 & (unsigned long int)((1 << 10) - 1))];
  }
  while((_Bool)0);
  free_hdr(*ha);
  *ha = ((struct hblkhdr *)NULL);
}

// GC_remove_protection
// file ./include/private/gc_priv.h line 2033
void GC_remove_protection(struct hblk *h, unsigned long int nblocks, signed int is_ptrfree)
{
  struct hblk *h_trunc;
  struct hblk *h_end;
  struct hblk *current;
  if(!(GC_dirty_maintained == 0))
  {
    h_trunc = (struct hblk *)((unsigned long int)h & ~(GC_page_size - (unsigned long int)1));
    h_end = (struct hblk *)(((unsigned long int)(h + (signed long int)nblocks) + GC_page_size) - (unsigned long int)1 & ~(GC_page_size - (unsigned long int)1));
    if(h_end == h_trunc + 1l)
    {
      if((1ul & GC_arrays._dirty_pages[(signed long int)((262143ul & (unsigned long int)h_trunc >> 12ul) >> 6ul)] >> (63ul & (unsigned long int)h_trunc >> 12ul)) == 0ul)
        goto __CPROVER_DUMP_L2;

    }

    else
    {

    __CPROVER_DUMP_L2:
      ;
      current = h_trunc;
      for( ; !((unsigned long int)current >= (unsigned long int)h_end); current = current + 1l)
      {
        unsigned long int index = (unsigned long int)current >> (unsigned long int)12 & ((unsigned long int)1 << 18) - (unsigned long int)1;
        if(is_ptrfree == 0 || (unsigned long int)current >= (unsigned long int)(h + (signed long int)nblocks) || !((unsigned long int)current >= (unsigned long int)h))
          async_set_pht_entry_from_index(GC_arrays._dirty_pages, index);

      }
      signed int return_value_mprotect$1;
      return_value_mprotect$1=mprotect((void *)(char *)h_trunc, (unsigned long int)((char *)h_end - (char *)h_trunc), 0x1 | 0x2 | (GC_pages_executable != 0 ? 0x4 : 0));
      if(!(return_value_mprotect$1 >= 0))
      {
        GC_on_abort(GC_pages_executable != 0 ? "un-mprotect executable page failed (probably disabled by OS)" : "un-mprotect failed");
        abort();
      }

    }
  }

}

// GC_remove_root_at_pos
// file mark_rts.c line 284
void GC_remove_root_at_pos(signed int i)
{
  GC_root_size = GC_root_size - (unsigned long int)(GC_arrays._static_roots[(signed long int)i].r_end - GC_arrays._static_roots[(signed long int)i].r_start);
  GC_arrays._static_roots[(signed long int)i].r_start = GC_arrays._static_roots[(signed long int)(n_root_sets - 1)].r_start;
  GC_arrays._static_roots[(signed long int)i].r_end = GC_arrays._static_roots[(signed long int)(n_root_sets - 1)].r_end;
  GC_arrays._static_roots[(signed long int)i].r_tmp = GC_arrays._static_roots[(signed long int)(n_root_sets - 1)].r_tmp;
  n_root_sets = n_root_sets - 1;
}

// GC_remove_roots
// file mark_rts.c line 331
extern void GC_remove_roots(void *b, void *e)
{
  if(!((7ul + (unsigned long int)b & 18446744073709551608ul) >= (18446744073709551608ul & (unsigned long int)e)))
  {
    do
      if(!(GC_need_to_lock == 0))
      {
        signed int return_value_pthread_mutex_trylock$1;
        return_value_pthread_mutex_trylock$1=pthread_mutex_trylock(&GC_allocate_ml);
        if(!(return_value_pthread_mutex_trylock$1 == 0))
          GC_lock();

      }

    while((_Bool)0);
    GC_remove_roots_inner((char *)b, (char *)e);
    do
      if(!(GC_need_to_lock == 0))
        pthread_mutex_unlock(&GC_allocate_ml);

    while((_Bool)0);
  }

}

// GC_remove_roots_inner
// file mark_rts.c line 346
void GC_remove_roots_inner(char *b, char *e)
{
  signed int i = 0;
  while(!(i >= n_root_sets))
  {
    _Bool tmp_if_expr$1;
    if((unsigned long int)GC_arrays._static_roots[(signed long int)i].r_start >= (unsigned long int)b)
      tmp_if_expr$1 = (unsigned long int)GC_arrays._static_roots[(signed long int)i].r_end <= (unsigned long int)e ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$1 = (_Bool)0;
    if(tmp_if_expr$1)
      GC_remove_root_at_pos(i);

    else
      i = i + 1;
  }
  GC_rebuild_root_index();
}

// GC_remove_tmp_roots
// file mark_rts.c line 311
void GC_remove_tmp_roots(void)
{
  signed int i = 0;
  while(!(i >= n_root_sets))
    if(!(GC_arrays._static_roots[(signed long int)i].r_tmp == 0))
      GC_remove_root_at_pos(i);

    else
      i = i + 1;
  GC_rebuild_root_index();
}

// GC_repeat_read
// file os_dep.c line 145
signed long int GC_repeat_read(signed int fd, char *buf, unsigned long int count)
{
  unsigned long int num_read = (unsigned long int)0;
  signed long int result;
  for( ; !(num_read >= count); num_read = num_read + (unsigned long int)result)
  {
    result=read(fd, (void *)(buf + (signed long int)num_read), count - num_read);
    if(!(result >= 0l))
      return result;

    if(result == 0l)
      break;

  }
  return (signed long int)num_read;
}

// GC_reset_fault_handler
// file os_dep.c line 935
void GC_reset_fault_handler(void)
{
  signal(11, old_segv_handler);
  signal(7, old_bus_handler);
}

// GC_reset_finalizer_nested
// file ./include/private/gc_priv.h line 2269
void GC_reset_finalizer_nested(void)
{
  struct GC_Thread_Rep *me;
  unsigned long int return_value_pthread_self$1;
  return_value_pthread_self$1=pthread_self();
  me=GC_lookup_thread(return_value_pthread_self$1);
  me->finalizer_nested = (unsigned char)0;
}

// GC_restart_handler
// file pthread_stop_world.c line 311
void GC_restart_handler(signed int sig)
{
  if(!(sig == GC_sig_thr_restart))
  {
    GC_on_abort("Bad signal in restart handler");
    abort();
  }

}

// GC_return_mark_stack
// file mark.c line 931
void GC_return_mark_stack(struct GC_ms_entry *low, struct GC_ms_entry *high)
{
  struct GC_ms_entry *my_top;
  struct GC_ms_entry *my_start;
  unsigned long int stack_size;
  if((unsigned long int)high >= (unsigned long int)low)
  {
    stack_size = (unsigned long int)((high - low) + (signed long int)1);
    GC_acquire_mark_lock();
    my_top = GC_arrays._mark_stack_top;
    my_start = my_top + (signed long int)1;
    if(!(GC_mark_stack_size >= stack_size + (unsigned long int)(my_start - GC_arrays._mark_stack)))
    {
      if(!(GC_print_stats == 0))
        GC_log_printf("No room to copy back mark stack\n");

      GC_mark_state = 5;
      GC_mark_stack_too_small = 1;
    }

    else
    {
      memcpy((void *)my_start, (const void *)low, (unsigned long int)(stack_size * sizeof(struct GC_ms_entry) /*16ul*/ ));
      AO_nop_write();
      AO_store((volatile unsigned long int *)&GC_arrays._mark_stack_top, (unsigned long int)(my_top + (signed long int)stack_size));
    }
    GC_release_mark_lock();
    GC_notify_all_marker();
  }

}

// GC_roots_present
// file mark_rts.c line 127
void * GC_roots_present(char *b)
{
  signed int h;
  h=rt_hash(b);
  struct roots *p = GC_arrays._root_index[(signed long int)h];
  for( ; !(p == ((struct roots *)NULL)); p = p->r_next)
    if(p->r_start == b)
      return (void *)p;

  return (void *)0;
}

// GC_same_obj
// file ptr_chck.c line 39
extern void * GC_same_obj(void *p, void *q)
{
  struct hblk *h;
  struct hblkhdr *hhdr;
  char *base;
  char *limit;
  unsigned long int sz;
  if((signed long int)GC_is_initialized == 0l)
    GC_init();

  hhdr=GC_find_header((char *)(unsigned long int)p);
  struct hblkhdr *return_value_GC_find_header$1;
  if(hhdr == ((struct hblkhdr *)NULL))
  {
    if(!((unsigned long int)p >> 12ul == (unsigned long int)q >> 12ul))
    {
      return_value_GC_find_header$1=GC_find_header((char *)(unsigned long int)q);
      if(!(return_value_GC_find_header$1 == ((struct hblkhdr *)NULL)))
        goto fail;

    }

    return p;
  }

  if(!((unsigned long int)hhdr >= 4096ul))
  {
    h = (struct hblk *)((unsigned long int)p & ~((unsigned long int)(1 << 12) - (unsigned long int)1)) - (signed long int)(unsigned long int)hhdr;
    hhdr=GC_find_header((char *)h);
    while(!((unsigned long int)hhdr >= 4096ul))
    {
      h = (struct hblk *)h - (signed long int)(unsigned long int)hhdr;
      hhdr=GC_find_header((char *)h);
    }
    limit = (char *)h + (signed long int)hhdr->hb_sz;
    if((unsigned long int)p >= (unsigned long int)limit || (unsigned long int)q >= (unsigned long int)limit || !((unsigned long int)q >= (unsigned long int)h))
      goto fail;

    return p;
  }

  else
  {
    sz = hhdr->hb_sz;
    if(sz >= 2049ul)
    {
      base = (char *)(struct hblk *)((unsigned long int)p & ~((unsigned long int)(1 << 12) - (unsigned long int)1));
      limit = base + (signed long int)sz;
      if((unsigned long int)p >= (unsigned long int)limit)
        goto fail;

    }

    else
    {
      unsigned long int offset;
      unsigned long int pdispl = (unsigned long int)p & (unsigned long int)(1 << 12) - (unsigned long int)1;
      offset = pdispl % sz;
      if(!((struct hblk *)(18446744073709547520ul & (unsigned long int)p) == (struct hblk *)(18446744073709547520ul & (unsigned long int)q)))
        goto fail;

      base = (char *)p - (signed long int)offset;
      limit = base + (signed long int)sz;
    }
    if(!((unsigned long int)q >= (unsigned long int)limit) && (unsigned long int)q >= (unsigned long int)base)
      return p;

    else
    {

    fail:
      ;
      GC_same_obj_print_proc((void *)(char *)p, (void *)(char *)q);
      return p;
    }
  }
}

// GC_scratch_alloc
// file ./include/private/gc_priv.h line 1728
char * GC_scratch_alloc(unsigned long int bytes)
{
  char *result = scratch_free_ptr;
  bytes = bytes + (unsigned long int)(16 - 1);
  bytes = bytes & (unsigned long int)~(16 - 1);
  scratch_free_ptr = scratch_free_ptr + (signed long int)bytes;
  if((unsigned long int)GC_arrays._scratch_end_ptr >= (unsigned long int)scratch_free_ptr)
    return result;

  else
  {
    unsigned long int bytes_to_get = (unsigned long int)16 * (unsigned long int)(1 << 12);
    if(bytes >= bytes_to_get)
    {
      bytes_to_get = (bytes + GC_page_size) - (unsigned long int)1 & ~(GC_page_size - (unsigned long int)1);
      char *return_value_GC_unix_get_mem$1;
      return_value_GC_unix_get_mem$1=GC_unix_get_mem(bytes_to_get);
      result = (char *)(struct hblk *)return_value_GC_unix_get_mem$1;
      scratch_free_ptr = scratch_free_ptr - (signed long int)bytes;
      if(!(result == ((char *)NULL)))
        GC_arrays._scratch_last_end_ptr = result + (signed long int)bytes;

      return result;
    }

    bytes_to_get = (bytes_to_get + GC_page_size) - (unsigned long int)1 & ~(GC_page_size - (unsigned long int)1);
    char *return_value_GC_unix_get_mem$2;
    return_value_GC_unix_get_mem$2=GC_unix_get_mem(bytes_to_get);
    result = (char *)(struct hblk *)return_value_GC_unix_get_mem$2;
    if(result == ((char *)NULL))
    {
      GC_current_warn_proc("GC Warning: Out of memory - trying to allocate less\n", (unsigned long int)0);
      scratch_free_ptr = scratch_free_ptr - (signed long int)bytes;
      bytes_to_get = (bytes + GC_page_size) - (unsigned long int)1 & ~(GC_page_size - (unsigned long int)1);
      char *return_value_GC_unix_get_mem$3;
      return_value_GC_unix_get_mem$3=GC_unix_get_mem(bytes_to_get);
      result = (char *)(struct hblk *)return_value_GC_unix_get_mem$3;
      return result;
    }

    scratch_free_ptr = result;
    GC_arrays._scratch_end_ptr = scratch_free_ptr + (signed long int)bytes_to_get;
    GC_arrays._scratch_last_end_ptr = GC_arrays._scratch_end_ptr;
    char *return_value_GC_scratch_alloc$4;
    return_value_GC_scratch_alloc$4=GC_scratch_alloc(bytes);
    return return_value_GC_scratch_alloc$4;
  }
}

// GC_set_abort_func
// file misc.c line 1695
extern void GC_set_abort_func(void (*fn)(const char *))
{
  do
    if(!(GC_need_to_lock == 0))
    {
      signed int return_value_pthread_mutex_trylock$1;
      return_value_pthread_mutex_trylock$1=pthread_mutex_trylock(&GC_allocate_ml);
      if(!(return_value_pthread_mutex_trylock$1 == 0))
        GC_lock();

    }

  while((_Bool)0);
  GC_on_abort = fn;
  do
    if(!(GC_need_to_lock == 0))
      pthread_mutex_unlock(&GC_allocate_ml);

  while((_Bool)0);
}

// GC_set_all_interior_pointers
// file misc.c line 2061
extern void GC_set_all_interior_pointers(signed int value)
{
  GC_all_interior_pointers = value != 0 ? 1 : 0;
  if(!(GC_is_initialized == 0))
  {
    do
      if(!(GC_need_to_lock == 0))
      {
        signed int return_value_pthread_mutex_trylock$1;
        return_value_pthread_mutex_trylock$1=pthread_mutex_trylock(&GC_allocate_ml);
        if(!(return_value_pthread_mutex_trylock$1 == 0))
          GC_lock();

      }

    while((_Bool)0);
    GC_initialize_offsets();
    if(GC_all_interior_pointers == 0)
      GC_bl_init_no_interiors();

    do
      if(!(GC_need_to_lock == 0))
        pthread_mutex_unlock(&GC_allocate_ml);

    while((_Bool)0);
  }

}

// GC_set_and_save_fault_handler
// file ./include/private/gc_priv.h line 2297
void GC_set_and_save_fault_handler(void (*h)(signed int))
{
  old_segv_handler=signal(11, h);
  old_bus_handler=signal(7, h);
}

// GC_set_dont_expand
// file misc.c line 2107
extern void GC_set_dont_expand(signed int value)
{
  GC_dont_expand = value;
}

// GC_set_dont_precollect
// file misc.c line 2163
extern void GC_set_dont_precollect(signed int value)
{
  GC_dont_precollect = value;
}

// GC_set_finalize_on_demand
// file misc.c line 2083
extern void GC_set_finalize_on_demand(signed int value)
{
  GC_finalize_on_demand = value;
}

// GC_set_finalizer_notifier
// file misc.c line 2024
extern void GC_set_finalizer_notifier(void (*fn)(void))
{
  do
    if(!(GC_need_to_lock == 0))
    {
      signed int return_value_pthread_mutex_trylock$1;
      return_value_pthread_mutex_trylock$1=pthread_mutex_trylock(&GC_allocate_ml);
      if(!(return_value_pthread_mutex_trylock$1 == 0))
        GC_lock();

    }

  while((_Bool)0);
  GC_finalizer_notifier = fn;
  do
    if(!(GC_need_to_lock == 0))
      pthread_mutex_unlock(&GC_allocate_ml);

  while((_Bool)0);
}

// GC_set_find_leak
// file misc.c line 2050
extern void GC_set_find_leak(signed int value)
{
  GC_find_leak = value;
}

// GC_set_fl_marks
// file alloc.c line 687
void GC_set_fl_marks(char *q)
{
  struct hblk *h;
  struct hblk *last_h;
  struct hblkhdr *hhdr;
  unsigned int bit_no;
  if(!(q == ((char *)NULL)))
  {
    h = (struct hblk *)((unsigned long int)q & ~((unsigned long int)(1 << 12) - (unsigned long int)1));
    last_h = h;
    hhdr=GC_find_header((char *)h);
    do
    {
      bit_no = (unsigned int)((char *)q - (char *)h) >> 4;
      if(hhdr->_mark_byte_union._hb_marks[(signed long int)bit_no] == 0)
      {
        hhdr->_mark_byte_union._hb_marks[(signed long int)bit_no] = (char)1;
        hhdr->hb_n_marks = hhdr->hb_n_marks + 1ul;
      }

      q = (char *)*((void **)q);
      if(q == ((char *)NULL))
        break;

      h = (struct hblk *)((unsigned long int)q & ~((unsigned long int)(1 << 12) - (unsigned long int)1));
      if(!(h == last_h))
      {
        last_h = h;
        hhdr=GC_find_header((char *)h);
      }

    }
    while((_Bool)1);
  }

}

// GC_set_force_unmap_on_gcollect
// file misc.c line 2197
extern void GC_set_force_unmap_on_gcollect(signed int value)
{
  GC_force_unmap_on_gcollect = (signed int)value;
}

// GC_set_free_space_divisor
// file misc.c line 2141
extern void GC_set_free_space_divisor(unsigned long int value)
{
  GC_free_space_divisor = value;
}

// GC_set_full_freq
// file misc.c line 2175
extern void GC_set_full_freq(signed int value)
{
  GC_full_freq = value;
}

// GC_set_handle_fork
// file misc.c line 204
extern void GC_set_handle_fork(signed int value)
{
  if(GC_is_initialized == 0)
    GC_handle_fork = value >= -1 ? value : 1;

}

// GC_set_hdr_marks
// file ./include/private/gc_priv.h line 1649
void GC_set_hdr_marks(struct hblkhdr *hhdr)
{
  unsigned int i;
  unsigned long int sz = hhdr->hb_sz;
  unsigned int n_marks = (unsigned int)(sz > (unsigned long int)((1 << 12) / 2) ? (unsigned long int)(1 << 12) / (unsigned long int)16 : sz * ((unsigned long int)(1 << 12) / sz) >> 4);
  i = (unsigned int)0;
  for( ; n_marks >= i; i = i + (unsigned int)(sz >> 4))
    hhdr->_mark_byte_union._hb_marks[(signed long int)i] = (char)1;
  hhdr->hb_n_marks = (unsigned long int)(1 << 12) / sz;
}

// GC_set_java_finalization
// file misc.c line 2095
extern void GC_set_java_finalization(signed int value)
{
  GC_java_finalization = value;
}

// GC_set_mark_bit
// file ./include/private/../gc_mark.h line 247
extern void GC_set_mark_bit(const void *p)
{
  struct hblk *h = (struct hblk *)((unsigned long int)p & ~((unsigned long int)(1 << 12) - (unsigned long int)1));
  struct hblkhdr *hhdr;
  hhdr=GC_find_header((char *)h);
  unsigned long int bit_no = (unsigned long int)((unsigned int)((char *)p - (char *)h) >> 4);
  if(hhdr->_mark_byte_union._hb_marks[(signed long int)bit_no] == 0)
  {
    hhdr->_mark_byte_union._hb_marks[(signed long int)bit_no] = (char)1;
    hhdr->hb_n_marks = hhdr->hb_n_marks + 1ul;
  }

}

// GC_set_max_heap_size
// file alloc.c line 1144
extern void GC_set_max_heap_size(unsigned long int n)
{
  GC_max_heapsize = n;
}

// GC_set_max_retries
// file misc.c line 2152
extern void GC_set_max_retries(unsigned long int value)
{
  GC_max_retries = value;
}

// GC_set_no_dls
// file misc.c line 2119
extern void GC_set_no_dls(signed int value)
{
  GC_no_dls = value;
}

// GC_set_non_gc_bytes
// file misc.c line 2131
extern void GC_set_non_gc_bytes(unsigned long int value)
{
  GC_non_gc_bytes = value;
}

// GC_set_on_heap_resize
// file misc.c line 2005
extern void GC_set_on_heap_resize(void (*fn)(unsigned long int))
{
  do
    if(!(GC_need_to_lock == 0))
    {
      signed int return_value_pthread_mutex_trylock$1;
      return_value_pthread_mutex_trylock$1=pthread_mutex_trylock(&GC_allocate_ml);
      if(!(return_value_pthread_mutex_trylock$1 == 0))
        GC_lock();

    }

  while((_Bool)0);
  GC_on_heap_resize = fn;
  do
    if(!(GC_need_to_lock == 0))
      pthread_mutex_unlock(&GC_allocate_ml);

  while((_Bool)0);
}

// GC_set_oom_fn
// file misc.c line 1986
extern void GC_set_oom_fn(void * (*fn)(unsigned long int))
{
  do
    if(!(GC_need_to_lock == 0))
    {
      signed int return_value_pthread_mutex_trylock$1;
      return_value_pthread_mutex_trylock$1=pthread_mutex_trylock(&GC_allocate_ml);
      if(!(return_value_pthread_mutex_trylock$1 == 0))
        GC_lock();

    }

  while((_Bool)0);
  GC_oom_fn = fn;
  do
    if(!(GC_need_to_lock == 0))
      pthread_mutex_unlock(&GC_allocate_ml);

  while((_Bool)0);
}

// GC_set_pages_executable
// file os_dep.c line 4435
extern void GC_set_pages_executable(signed int value)
{
  GC_pages_executable = (signed int)(value != 0);
}

// GC_set_push_other_roots
// file os_dep.c line 2610
extern void GC_set_push_other_roots(void (*fn)(void))
{
  GC_push_other_roots = fn;
}

// GC_set_start_callback
// file alloc.c line 316
extern void GC_set_start_callback(void (*fn)(void))
{
  do
    if(!(GC_need_to_lock == 0))
    {
      signed int return_value_pthread_mutex_trylock$1;
      return_value_pthread_mutex_trylock$1=pthread_mutex_trylock(&GC_allocate_ml);
      if(!(return_value_pthread_mutex_trylock$1 == 0))
        GC_lock();

    }

  while((_Bool)0);
  GC_start_call_back = fn;
  do
    if(!(GC_need_to_lock == 0))
      pthread_mutex_unlock(&GC_allocate_ml);

  while((_Bool)0);
}

// GC_set_stop_func
// file alloc.c line 149
extern void GC_set_stop_func(signed int (*stop_func)(void))
{
  do
    if(!(GC_need_to_lock == 0))
    {
      signed int return_value_pthread_mutex_trylock$1;
      return_value_pthread_mutex_trylock$1=pthread_mutex_trylock(&GC_allocate_ml);
      if(!(return_value_pthread_mutex_trylock$1 == 0))
        GC_lock();

    }

  while((_Bool)0);
  GC_default_stop_func = stop_func;
  do
    if(!(GC_need_to_lock == 0))
      pthread_mutex_unlock(&GC_allocate_ml);

  while((_Bool)0);
}

// GC_set_suspend_signal
// file pthread_stop_world.c line 153
extern void GC_set_suspend_signal(signed int sig)
{
  if(GC_is_initialized == 0)
    GC_sig_suspend = sig;

}

// GC_set_thr_restart_signal
// file pthread_stop_world.c line 160
extern void GC_set_thr_restart_signal(signed int sig)
{
  if(GC_is_initialized == 0)
    GC_sig_thr_restart = sig;

}

// GC_set_time_limit
// file misc.c line 2186
extern void GC_set_time_limit(unsigned long int value)
{
  GC_time_limit = value;
}

// GC_set_warn_proc
// file misc.c line 1607
extern void GC_set_warn_proc(void (*p)(char *, unsigned long int))
{
  do
    if(!(GC_need_to_lock == 0))
    {
      signed int return_value_pthread_mutex_trylock$1;
      return_value_pthread_mutex_trylock$1=pthread_mutex_trylock(&GC_allocate_ml);
      if(!(return_value_pthread_mutex_trylock$1 == 0))
        GC_lock();

    }

  while((_Bool)0);
  GC_current_warn_proc = p;
  do
    if(!(GC_need_to_lock == 0))
      pthread_mutex_unlock(&GC_allocate_ml);

  while((_Bool)0);
}

// GC_setpagesize
// file ./include/private/gc_priv.h line 2222
void GC_setpagesize(void)
{
  signed int return_value_getpagesize$1;
  return_value_getpagesize$1=getpagesize();
  GC_page_size = (unsigned long int)return_value_getpagesize$1;
  if(GC_page_size == 0ul)
  {
    GC_on_abort("getpagesize failed");
    abort();
  }

}

// GC_setup_temporary_fault_handler
// file os_dep.c line 927
void GC_setup_temporary_fault_handler(void)
{
  GC_set_and_save_fault_handler(GC_fault_handler);
}

// GC_should_collect
// file ./include/private/gc_priv.h line 1540
signed int GC_should_collect(void)
{
  static unsigned long int last_min_bytes_allocd;
  static unsigned long int last_gc_no;
  if(!(last_gc_no == GC_gc_no))
  {
    last_gc_no = GC_gc_no;
    last_min_bytes_allocd=min_bytes_allocd();
  }

  unsigned long int return_value_GC_adj_bytes_allocd$1;
  return_value_GC_adj_bytes_allocd$1=GC_adj_bytes_allocd();
  return (signed int)(return_value_GC_adj_bytes_allocd$1 >= last_min_bytes_allocd ? (_Bool)1 : (GC_arrays._heapsize >= GC_collect_at_heapsize ? (_Bool)1 : (_Bool)0));
}

// GC_should_invoke_finalizers
// file finalize.c line 959
extern signed int GC_should_invoke_finalizers(void)
{
  return (signed int)(GC_finalize_now != ((struct finalizable_object *)NULL));
}

// GC_signal_mark_stack_overflow
// file ./include/private/gc_pmark.h line 113
struct GC_ms_entry * GC_signal_mark_stack_overflow(struct GC_ms_entry *msp)
{
  GC_mark_state = 5;
  if(GC_parallel == 0)
    GC_mark_stack_too_small = 1;

  if(!(GC_print_stats == 0))
    GC_log_printf("Mark stack overflow; current size = %lu entries\n", (unsigned long int)GC_mark_stack_size);

  return msp - (signed long int)(((unsigned long int)1 * (unsigned long int)(1 << 12)) / (unsigned long int)8);
}

// GC_size
// file ./include/private/../gc.h line 475
extern unsigned long int GC_size(const void *p)
{
  struct hblkhdr *hhdr;
  hhdr=GC_find_header((char *)p);
  return hhdr->hb_sz;
}

// GC_split_block
// file allchblk.c line 530
void GC_split_block(struct hblk *h, struct hblkhdr *hhdr, struct hblk *n, struct hblkhdr *nhdr, signed int index)
{
  unsigned long int total_size = hhdr->hb_sz;
  unsigned long int h_size = (unsigned long int)n - (unsigned long int)h;
  struct hblk *prev = hhdr->hb_prev;
  struct hblk *next = hhdr->hb_next;
  nhdr->hb_prev = prev;
  nhdr->hb_next = next;
  nhdr->hb_sz = total_size - h_size;
  nhdr->hb_flags = (unsigned char)0;
  if(!(prev == ((struct hblk *)NULL)))
  {
    struct hblkhdr *return_value_GC_find_header$1;
    return_value_GC_find_header$1=GC_find_header((char *)prev);
    return_value_GC_find_header$1->hb_next = n;
  }

  else
    GC_hblkfreelist[(signed long int)index] = n;
  if(!(next == ((struct hblk *)NULL)))
  {
    struct hblkhdr *return_value_GC_find_header$2;
    return_value_GC_find_header$2=GC_find_header((char *)next);
    return_value_GC_find_header$2->hb_prev = n;
  }

  GC_free_bytes[(signed long int)index] = GC_free_bytes[(signed long int)index] - h_size;
  hhdr->hb_sz = h_size;
  GC_add_to_fl(h, hhdr);
  nhdr->hb_flags = nhdr->hb_flags | (unsigned char)4;
}

// GC_start_debugging
// file dbg_mlc.c line 467
void GC_start_debugging(void)
{
  do
    if(!(GC_need_to_lock == 0))
    {
      signed int return_value_pthread_mutex_trylock$1;
      return_value_pthread_mutex_trylock$1=pthread_mutex_trylock(&GC_allocate_ml);
      if(!(return_value_pthread_mutex_trylock$1 == 0))
        GC_lock();

    }

  while((_Bool)0);
  GC_start_debugging_inner();
  do
    if(!(GC_need_to_lock == 0))
      pthread_mutex_unlock(&GC_allocate_ml);

  while((_Bool)0);
}

// GC_start_debugging_inner
// file dbg_mlc.c line 452
void GC_start_debugging_inner(void)
{
  GC_check_heap = GC_check_heap_proc;
  GC_print_all_smashed = GC_print_all_smashed_proc;
  GC_print_heap_obj = GC_debug_print_heap_obj_proc;
  GC_debugging_started = 1;
  GC_register_displacement_inner((unsigned long int)sizeof(struct anonymous$17) /*32ul*/ );
}

// GC_start_mark_threads
// file pthread_support.c line 403
extern void GC_start_mark_threads(void)
{
  signed int i;
  union pthread_attr_t attr;
  if(GC_parallel == 0 && available_markers_m1 >= 1)
  {
    signed int return_value_pthread_attr_init$1;
    return_value_pthread_attr_init$1=pthread_attr_init(&attr);
    if(!(return_value_pthread_attr_init$1 == 0))
    {
      GC_on_abort("pthread_attr_init failed");
      abort();
    }

    signed int return_value_pthread_attr_setdetachstate$2;
    return_value_pthread_attr_setdetachstate$2=pthread_attr_setdetachstate(&attr, 1);
    if(!(return_value_pthread_attr_setdetachstate$2 == 0))
    {
      GC_on_abort("pthread_attr_setdetachstate failed");
      abort();
    }

    i = 0;
    for( ; !(i >= available_markers_m1); i = i + 1)
    {
      signed int return_value_pthread_create$4;
      return_value_pthread_create$4=pthread_create(GC_mark_threads + (signed long int)i, &attr, GC_mark_thread, (void *)(unsigned long int)i);
      if(!(return_value_pthread_create$4 == 0))
      {
        signed int *return_value___errno_location$3;
        return_value___errno_location$3=__errno_location();
        GC_current_warn_proc("GC Warning: Marker thread creation failed, errno = %ld\n", (unsigned long int)*return_value___errno_location$3);
        break;
      }

    }
    GC_parallel = i;
    pthread_attr_destroy(&attr);
    if(!(GC_print_stats == 0))
      GC_log_printf("Started %d mark helper threads\n", GC_parallel);

  }

}

// GC_start_reclaim
// file ./include/private/gc_priv.h line 1778
void GC_start_reclaim(signed int report_if_found)
{
  unsigned int kind;
  GC_arrays._composite_in_use = (unsigned long int)0;
  GC_arrays._atomic_in_use = (unsigned long int)0;
  kind = (unsigned int)0;
  for( ; !(kind >= GC_n_kinds); kind = kind + 1u)
  {
    void **fop;
    void **lim;
    struct hblk **rlist = GC_obj_kinds[(signed long int)kind].ok_reclaim_list;
    signed int should_clobber = (signed int)(GC_obj_kinds[(signed long int)kind].ok_descriptor != (unsigned long int)0);
    if(!(rlist == ((struct hblk **)NULL)))
    {
      if(report_if_found == 0)
      {
        lim = &GC_obj_kinds[(signed long int)kind].ok_freelist[(signed long int)((unsigned long int)((1 << 12) / 2 >> 4) + (unsigned long int)1)];
        fop = GC_obj_kinds[(signed long int)kind].ok_freelist;
        for( ; !((unsigned long int)fop >= (unsigned long int)lim); fop = fop + 1l)
          if(!(*fop == NULL))
          {
            if(!(should_clobber == 0))
              GC_clear_fl_links(fop);

            else
              *fop = NULL;
          }

      }

      memset((void *)rlist, 0, (unsigned long int)(((unsigned long int)((1 << 12) / 2 >> 4) + (unsigned long int)1) * sizeof(void *) /*8ul*/ ));
    }

  }
  GC_apply_to_all_blocks(GC_reclaim_block, (unsigned long int)report_if_found);
  GC_reclaim_unconditionally_marked();
}

// GC_start_routine
// file pthread_support.c line 1638
void * GC_start_routine(void *arg)
{
  void *return_value_GC_call_with_stack_base$1;
  return_value_GC_call_with_stack_base$1=GC_call_with_stack_base(GC_inner_start_routine, arg);
  return return_value_GC_call_with_stack_base$1;
}

// GC_start_rtn_prepare_thread
// file ./include/private/pthread_support.h line 145
struct GC_Thread_Rep * GC_start_rtn_prepare_thread(void * (**pstart)(void *), void **pstart_arg, struct GC_stack_base *sb, void *arg)
{
  struct start_info *si = (struct start_info *)arg;
  unsigned long int self;
  self=pthread_self();
  struct GC_Thread_Rep *me;
  do
    if(!(GC_need_to_lock == 0))
    {
      signed int return_value_pthread_mutex_trylock$1;
      return_value_pthread_mutex_trylock$1=pthread_mutex_trylock(&GC_allocate_ml);
      if(!(return_value_pthread_mutex_trylock$1 == 0))
        GC_lock();

    }

  while((_Bool)0);
  me=GC_register_my_thread_inner(sb, self);
  me->flags = (unsigned char)si->flags;
  GC_init_thread_local(&me->tlfs);
  do
    if(!(GC_need_to_lock == 0))
      pthread_mutex_unlock(&GC_allocate_ml);

  while((_Bool)0);
  *pstart = si->start_routine;
  *pstart_arg = si->arg;
  sem_post(&si->registered);
  return me;
}

// GC_start_world
// file ./include/private/gc_priv.h line 448
void GC_start_world(void)
{
  unsigned long int self;
  self=pthread_self();
  signed int i;
  struct GC_Thread_Rep *p;
  signed int n_live_threads = 0;
  signed int result;
  AO_store$link2(&GC_world_is_stopped, (unsigned long int)0);
  i = 0;
  for( ; !(i >= 256); i = i + 1)
  {
    p = GC_threads[(signed long int)i];
    for( ; !(p == ((struct GC_Thread_Rep *)NULL)); p = p->next)
      if(!(p->id == self))
      {
        if((1 & (signed int)p->flags) == 0)
        {
          if(p->thread_blocked == 0)
          {
            n_live_threads = n_live_threads + 1;
            result=pthread_kill(p->id, GC_sig_thr_restart);
            switch(result)
            {
              case 3:
              {
                n_live_threads = n_live_threads - 1;
                break;
              }
              case 0:
                break;
              default:
              {
                if(!(GC_print_stats == 0))
                  GC_log_printf("pthread_kill failed at resume: errcode= %d", result);

                GC_on_abort("pthread_kill failed at resume");
              }
            }
            abort();
          }

        }

      }

  }
}

// GC_steal_mark_stack
// file mark.c line 897
struct GC_ms_entry * GC_steal_mark_stack(struct GC_ms_entry *low, struct GC_ms_entry *high, struct GC_ms_entry *local, unsigned int max, struct GC_ms_entry **next)
{
  struct GC_ms_entry *p;
  struct GC_ms_entry *top = local - (signed long int)1;
  unsigned int i = (unsigned int)0;
  p = low;
  for( ; max >= i && (unsigned long int)high >= (unsigned long int)p; p = p + 1l)
  {
    unsigned long int descr;
    unsigned long int return_value_AO_load$1;
    return_value_AO_load$1=AO_load$link1(&p->mse_descr.ao);
    descr = (unsigned long int)return_value_AO_load$1;
    if(!(descr == 0ul))
    {
      AO_nop_write();
      AO_store(&p->mse_descr.ao, (unsigned long int)0);
      top = top + 1l;
      top->mse_descr.w = descr;
      top->mse_start = p->mse_start;
      i = i + 1u;
      if((3ul & descr) == 0ul)
        i = i + (unsigned int)(signed int)(descr >> 8);

    }

  }
  *next = p;
  return top;
}

// GC_stop_init
// file ./include/private/pthread_stop_world.h line 42
void GC_stop_init(void)
{
  struct sigaction act;
  if(GC_sig_suspend == -1)
    GC_sig_suspend = 30;

  if(GC_sig_thr_restart == -1)
    GC_sig_thr_restart = 24;

  if(GC_sig_suspend == GC_sig_thr_restart)
  {
    GC_on_abort("Cannot use same signal for thread suspend and resume");
    abort();
  }

  signed int return_value_sem_init$1;
  return_value_sem_init$1=sem_init(&GC_suspend_ack_sem, 0, (unsigned int)0);
  if(!(return_value_sem_init$1 == 0))
  {
    GC_on_abort("sem_init failed");
    abort();
  }

  act.sa_flags = 0x10000000 | 4;
  signed int return_value_sigfillset$2;
  return_value_sigfillset$2=sigfillset(&act.sa_mask);
  if(!(return_value_sigfillset$2 == 0))
  {
    GC_on_abort("sigfillset failed");
    abort();
  }

  GC_remove_allowed_signals(&act.sa_mask);
  act.__sigaction_handler.sa_sigaction = GC_suspend_handler;
  signed int return_value_sigaction$3;
  return_value_sigaction$3=sigaction(GC_sig_suspend, &act, (struct sigaction *)(void *)0);
  if(!(return_value_sigaction$3 == 0))
  {
    GC_on_abort("Cannot set SIG_SUSPEND handler");
    abort();
  }

  act.sa_flags = act.sa_flags & ~4;
  act.__sigaction_handler.sa_handler = GC_restart_handler;
  signed int return_value_sigaction$4;
  return_value_sigaction$4=sigaction(GC_sig_thr_restart, &act, (struct sigaction *)(void *)0);
  if(!(return_value_sigaction$4 == 0))
  {
    GC_on_abort("Cannot set SIG_THR_RESTART handler");
    abort();
  }

  signed int return_value_sigfillset$5;
  return_value_sigfillset$5=sigfillset(&suspend_handler_mask);
  if(!(return_value_sigfillset$5 == 0))
  {
    GC_on_abort("sigfillset failed");
    abort();
  }

  GC_remove_allowed_signals(&suspend_handler_mask);
  signed int return_value_sigdelset$6;
  return_value_sigdelset$6=sigdelset(&suspend_handler_mask, GC_sig_thr_restart);
  if(!(return_value_sigdelset$6 == 0))
  {
    GC_on_abort("sigdelset failed");
    abort();
  }

  char *return_value_getenv$7;
  return_value_getenv$7=getenv("GC_RETRY_SIGNALS");
  if(!(return_value_getenv$7 == ((char *)NULL)))
    GC_retry_signals = 1;

  char *return_value_getenv$8;
  return_value_getenv$8=getenv("GC_NO_RETRY_SIGNALS");
  if(!(return_value_getenv$8 == ((char *)NULL)))
    GC_retry_signals = 0;

  if(!(GC_retry_signals == 0))
  {
    if(!(GC_print_stats == 0))
      GC_log_printf("Will retry suspend signal if necessary\n");

  }

}

// GC_stop_world
// file ./include/private/gc_priv.h line 447
void GC_stop_world(void)
{
  signed int i;
  signed int n_live_threads;
  signed int code;
  if(!(GC_parallel == 0))
    GC_acquire_mark_lock();

  AO_store$link2(&GC_stop_count, GC_stop_count + (unsigned long int)1);
  AO_nop_write$link2();
  AO_store$link2(&GC_world_is_stopped, (unsigned long int)1);
  n_live_threads=GC_suspend_all();
  if(!(GC_retry_signals == 0))
  {
    unsigned long int wait_usecs = (unsigned long int)0;
    do
    {
      signed int ack_count;
      sem_getvalue(&GC_suspend_ack_sem, &ack_count);
      if(ack_count == n_live_threads)
        break;

      if(wait_usecs >= 100001ul)
      {
        signed int newly_sent;
        newly_sent=GC_suspend_all();
        if(!(GC_print_stats == 0))
          GC_log_printf("Resent %d signals after timeout\n", newly_sent);

        sem_getvalue(&GC_suspend_ack_sem, &ack_count);
        if(!(newly_sent >= n_live_threads + -ack_count))
        {
          GC_current_warn_proc("GC Warning: Lost some threads during GC_stop_world?!\n", (unsigned long int)0);
          n_live_threads = ack_count + newly_sent;
        }

        wait_usecs = (unsigned long int)0;
      }

      usleep((unsigned int)3000);
      wait_usecs = wait_usecs + (unsigned long int)3000;
    }
    while((_Bool)1);
  }

  i = 0;
  signed int *return_value___errno_location$1;
  for( ; !(i >= n_live_threads); i = i + 1)
  {
    do
    {

    retry:
      ;
      code=sem_wait(&GC_suspend_ack_sem);
      if(code == 0)
        goto __CPROVER_DUMP_L11;

      return_value___errno_location$1=__errno_location();
    }
    while(*return_value___errno_location$1 == 4);
    GC_on_abort("sem_wait for handler failed");
    abort();

  __CPROVER_DUMP_L11:
    ;
  }
  if(!(GC_parallel == 0))
    GC_release_mark_lock();

}

// GC_stopped_mark
// file alloc.c line 586
signed int GC_stopped_mark(signed int (*stop_func)(void))
{
  unsigned int i;
  signed long int start_time = (signed long int)0;
  signed long int current_time;
  GC_cond_register_dynamic_libraries();
  if(!(GC_print_stats == 0))
    start_time=clock();

  GC_stop_world();
  GC_world_stopped = 1;
  if(!(GC_print_stats == 0))
    GC_log_printf("\n--> Marking for collection #%lu after %lu allocated bytes\n", (unsigned long int)GC_gc_no + (unsigned long int)1, (unsigned long int)GC_arrays._bytes_allocd);

  GC_clear_a_few_frames();
  GC_noop6((unsigned long int)0, (unsigned long int)0, (unsigned long int)0, (unsigned long int)0, (unsigned long int)0, (unsigned long int)0);
  GC_initiate_gc();
  i = (unsigned int)0;
  signed int return_value;
  return_value=stop_func();
  if(!(return_value == 0))
  {
    if(!(GC_print_stats == 0))
      GC_log_printf("Abandoned stopped marking after %u iterations\n", i);

    GC_deficit = (signed int)i;
    GC_world_stopped = 0;
    GC_start_world();
    return 0;
  }

  else
  {
    char *return_value_GC_approx_sp$1;
    return_value_GC_approx_sp$1=GC_approx_sp();
    signed int return_value_GC_mark_some$2;
    return_value_GC_mark_some$2=GC_mark_some(return_value_GC_approx_sp$1);
    if(return_value_GC_mark_some$2 == 0)
      i = i + 1u;

    GC_gc_no = GC_gc_no + 1ul;
    if(!(GC_print_stats == 0))
      GC_log_printf("GC #%lu freed %ld bytes, heap %lu KiB\n", (unsigned long int)GC_gc_no, (signed long int)GC_bytes_found, (unsigned long int)((GC_arrays._heapsize - (unsigned long int)0) + (unsigned long int)((1 << 9) - 1) >> 10));

    if(!(GC_debugging_started == 0))
      GC_check_heap();

    GC_world_stopped = 0;
    GC_start_world();
    if(!(GC_print_stats == 0))
    {
      unsigned long int time_diff;
      unsigned int total_time;
      unsigned int divisor;
      current_time=clock();
      time_diff = (signed long int)1000000 % (signed long int)1000 == (signed long int)0 ? (unsigned long int)(current_time - start_time) / (unsigned long int)((signed long int)1000000 / (signed long int)1000) : ((unsigned long int)(current_time - start_time) * (unsigned long int)1000) / (unsigned long int)(signed long int)1000000;
      total_time = world_stopped_total_time;
      divisor = world_stopped_total_divisor;
      if(divisor >= 1000u || !((signed int)total_time >= 0))
      {
        total_time = total_time >> 1;
        divisor = divisor >> 1;
      }

      total_time = total_time + (time_diff < (unsigned long int)((unsigned int)-1 >> 1) ? (unsigned int)time_diff : (unsigned int)-1 >> 1);
      world_stopped_total_time = total_time;
      divisor = divisor + 1u;
      world_stopped_total_divisor = divisor;
      GC_log_printf("World-stopped marking took %lu msecs (%u in average)\n", time_diff, total_time / divisor);
    }

    return 1;
  }
}

// GC_store_debug_info
// file dbg_mlc.c line 279
char * GC_store_debug_info(char *p, unsigned long int sz, const char *string, signed int linenum)
{
  char *result;
  do
    if(!(GC_need_to_lock == 0))
    {
      signed int return_value_pthread_mutex_trylock$1;
      return_value_pthread_mutex_trylock$1=pthread_mutex_trylock(&GC_allocate_ml);
      if(!(return_value_pthread_mutex_trylock$1 == 0))
        GC_lock();

    }

  while((_Bool)0);
  result=GC_store_debug_info_inner(p, sz, string, linenum);
  do
    if(!(GC_need_to_lock == 0))
      pthread_mutex_unlock(&GC_allocate_ml);

  while((_Bool)0);
  return result;
}

// GC_store_debug_info_inner
// file dbg_mlc.c line 255
char * GC_store_debug_info_inner(char *p, unsigned long int sz, const char *string, signed int linenum)
{
  unsigned long int *result = (unsigned long int *)((struct anonymous$17 *)p + (signed long int)1);
  ((struct anonymous$17 *)p)->oh_string = string;
  ((struct anonymous$17 *)p)->oh_int = (unsigned long int)linenum;
  ((struct anonymous$17 *)p)->oh_sz = sz;
  ((struct anonymous$17 *)p)->oh_sf = (unsigned long int)0xFEDCEDCBfedcedcbUL ^ (unsigned long int)result;
  unsigned long int return_value_GC_size$1;
  return_value_GC_size$1=GC_size((const void *)p);
  result[(signed long int)((sz + (unsigned long int)(1 << 3)) - (unsigned long int)1 >> 3)] = (unsigned long int)0xBCDECDEFbcdecdefUL ^ (unsigned long int)result;
  ((unsigned long int *)p)[(signed long int)((return_value_GC_size$1 >> 3) - (unsigned long int)1)] = result[(signed long int)((sz + (unsigned long int)(1 << 3)) - (unsigned long int)1 >> 3)];
  return (char *)result;
}

// GC_strdup
// file mallocx.c line 563
extern char * GC_strdup(const char *s)
{
  char *copy;
  unsigned long int lb;
  if(s == ((const char *)NULL))
    return (char *)(void *)0;

  else
  {
    unsigned long int return_value_strlen$1;
    return_value_strlen$1=strlen(s);
    lb = return_value_strlen$1 + (unsigned long int)1;
    void *return_value_GC_malloc_atomic$3;
    return_value_GC_malloc_atomic$3=GC_malloc_atomic(lb);
    copy = (char *)return_value_GC_malloc_atomic$3;
    if(copy == ((char *)NULL))
    {
      signed int *return_value___errno_location$2;
      return_value___errno_location$2=__errno_location();
      *return_value___errno_location$2 = 12;
      return (char *)(void *)0;
    }

    memcpy((void *)copy, (const void *)s, (unsigned long int)lb);
    return copy;
  }
}

// GC_strndup
// file mallocx.c line 579
extern char * GC_strndup(const char *str, unsigned long int size)
{
  char *copy;
  unsigned long int len;
  len=strlen(str);
  if(!(size >= len))
    len = size;

  void *return_value_GC_malloc_atomic$1;
  return_value_GC_malloc_atomic$1=GC_malloc_atomic(len + (unsigned long int)1);
  copy = (char *)return_value_GC_malloc_atomic$1;
  if(copy == ((char *)NULL))
  {
    signed int *return_value___errno_location$2;
    return_value___errno_location$2=__errno_location();
    *return_value___errno_location$2 = 12;
    return (char *)(void *)0;
  }

  memcpy((void *)copy, (const void *)str, (unsigned long int)len);
  copy[(signed long int)len] = (char)0;
  return copy;
}

// GC_suspend_all
// file pthread_stop_world.c line 465
signed int GC_suspend_all(void)
{
  signed int n_live_threads = 0;
  signed int i;
  struct GC_Thread_Rep *p;
  signed int result;
  unsigned long int self;
  self=pthread_self();
  i = 0;
  for( ; !(i >= 256); i = i + 1)
  {
    p = GC_threads[(signed long int)i];
    for( ; !(p == ((struct GC_Thread_Rep *)NULL)); p = p->next)
      if(!(p->id == self))
      {
        if((1 & (signed int)p->flags) == 0)
        {
          if(p->thread_blocked == 0)
          {
            if(!(p->stop_info.last_stop_count == GC_stop_count))
            {
              n_live_threads = n_live_threads + 1;
              result=pthread_kill(p->id, GC_sig_suspend);
              switch(result)
              {
                case 3:
                {
                  n_live_threads = n_live_threads - 1;
                  break;
                }
                case 0:
                  break;
                default:
                {
                  if(!(GC_print_stats == 0))
                    GC_log_printf("pthread_kill failed at suspend: errcode= %d", result);

                  GC_on_abort("pthread_kill failed at suspend");
                }
              }
              abort();
            }

          }

        }

      }

  }
  return n_live_threads;
}

// GC_suspend_handler
// file pthread_stop_world.c line 206
void GC_suspend_handler(signed int sig, struct anonymous$13 *info, void *context)
{
  signed int old_errno;
  signed int *return_value___errno_location$1;
  return_value___errno_location$1=__errno_location();
  old_errno = *return_value___errno_location$1;
  GC_suspend_handler_inner((char *)(unsigned long int)sig, context);
  signed int *return_value___errno_location$2;
  return_value___errno_location$2=__errno_location();
  *return_value___errno_location$2 = old_errno;
}

// GC_suspend_handler_inner
// file pthread_stop_world.c line 227
void GC_suspend_handler_inner(char *sig_arg, void *context)
{
  unsigned long int self;
  self=pthread_self();
  struct GC_Thread_Rep *me;
  signed int cancel_state;
  unsigned long int my_stop_count;
  my_stop_count=AO_load$link3(&GC_stop_count);
  if(!((signed long int)sig_arg == (signed long int)GC_sig_suspend))
  {
    GC_on_abort("Bad signal in suspend_handler");
    abort();
  }

  do
    pthread_setcancelstate(1, &cancel_state);
  while((_Bool)0);
  me=GC_lookup_thread(self);
  unsigned long int return_value_AO_load_read$1;
  _Bool tmp_if_expr$3;
  unsigned long int return_value_AO_load$2;
  if(me->stop_info.last_stop_count == my_stop_count)
  {
    if(GC_retry_signals == 0)
      GC_current_warn_proc("GC Warning: Duplicate suspend signal in thread %p\n", (unsigned long int)self);

    do
      pthread_setcancelstate(cancel_state, (signed int *)(void *)0);
    while((_Bool)0);
  }

  else
  {
    me->stop_info.stack_ptr=GC_approx_sp();
    sem_post(&GC_suspend_ack_sem);
    me->stop_info.last_stop_count = my_stop_count;
    do
    {
      sigsuspend(&suspend_handler_mask);
      return_value_AO_load_read$1=AO_load_read$link1(&GC_world_is_stopped);
      if(!(return_value_AO_load_read$1 == 0ul))
      {
        return_value_AO_load$2=AO_load$link3(&GC_stop_count);
        tmp_if_expr$3 = return_value_AO_load$2 == my_stop_count ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$3 = (_Bool)0;
    }
    while(tmp_if_expr$3);
    do
      pthread_setcancelstate(cancel_state, (signed int *)(void *)0);
    while((_Bool)0);
  }
}

// GC_thr_init
// file ./include/private/gc_priv.h line 1680
void GC_thr_init(void)
{
  if(GC_thr_initialized == 0)
  {
    GC_thr_initialized = 1;
    if(!(GC_handle_fork == 0))
    {
      signed int return_value_pthread_atfork$1;
      return_value_pthread_atfork$1=pthread_atfork(fork_prepare_proc, fork_parent_proc, fork_child_proc);
      if(return_value_pthread_atfork$1 == 0)
        GC_handle_fork = 1;

      else
        if(!(GC_handle_fork == -1))
        {
          GC_on_abort("pthread_atfork failed");
          abort();
        }

    }

    struct GC_Thread_Rep *t;
    unsigned long int return_value_pthread_self$2;
    return_value_pthread_self$2=pthread_self();
    t=GC_new_thread(return_value_pthread_self$2);
    if(t == ((struct GC_Thread_Rep *)NULL))
    {
      GC_on_abort("Failed to allocate memory for the initial thread");
      abort();
    }

    t->stop_info.stack_ptr=GC_approx_sp();
    t->flags = (unsigned char)(2 | 4);
    GC_stop_init();
    char *nprocs_string;
    nprocs_string=getenv("GC_NPROCS");
    GC_nprocs = -1;
    if(!(nprocs_string == ((char *)NULL)))
      GC_nprocs=atoi$link1(nprocs_string);

    if(!(GC_nprocs >= 1))
      GC_nprocs=GC_get_nprocs();

    if(!(GC_nprocs >= 1))
    {
      GC_current_warn_proc("GC Warning: GC_get_nprocs() returned %ld\n", (unsigned long int)GC_nprocs);
      GC_nprocs = 2;
      available_markers_m1 = 0;
    }

    else
    {
      char *markers_string;
      markers_string=getenv("GC_MARKERS");
      signed int markers_m1;
      if(!(markers_string == ((char *)NULL)))
      {
        signed int return_value_atoi$3;
        return_value_atoi$3=atoi$link1(markers_string);
        markers_m1 = return_value_atoi$3 - 1;
        if(markers_m1 >= 16)
        {
          GC_current_warn_proc("GC Warning: Limiting number of mark threads\n", (unsigned long int)0);
          markers_m1 = 16 - 1;
        }

      }

      else
      {
        markers_m1 = GC_nprocs - 1;
        if(markers_m1 >= 16)
          markers_m1 = 16 - 1;

      }
      available_markers_m1 = markers_m1;
    }
    if(!(GC_print_stats == 0))
      GC_log_printf("Number of processors = %d\n", GC_nprocs);

    if(!(available_markers_m1 >= 1))
    {
      GC_parallel = 0;
      if(!(GC_print_stats == 0))
        GC_log_printf("Single marker thread, turning off parallel marking\n");

    }

    else
    {
      GC_time_limit = (unsigned long int)999999;
      GC_start_mark_threads();
    }
  }

}

// GC_thread_exit_proc
// file ./include/private/pthread_support.h line 149
void GC_thread_exit_proc(void *arg)
{
  signed int cancel_state;
  do
    if(!(GC_need_to_lock == 0))
    {
      signed int return_value_pthread_mutex_trylock$1;
      return_value_pthread_mutex_trylock$1=pthread_mutex_trylock(&GC_allocate_ml);
      if(!(return_value_pthread_mutex_trylock$1 == 0))
        GC_lock();

    }

  while((_Bool)0);
  do
    pthread_setcancelstate(1, &cancel_state);
  while((_Bool)0);
  GC_wait_for_gc_completion(0);
  GC_unregister_my_thread_inner((struct GC_Thread_Rep *)arg);
  do
    pthread_setcancelstate(cancel_state, (signed int *)(void *)0);
  while((_Bool)0);
  do
    if(!(GC_need_to_lock == 0))
      pthread_mutex_unlock(&GC_allocate_ml);

  while((_Bool)0);
}

// GC_thread_is_registered
// file pthread_support.c line 647
extern signed int GC_thread_is_registered(void)
{
  unsigned long int self;
  self=pthread_self();
  struct GC_Thread_Rep *me;
  do
    if(!(GC_need_to_lock == 0))
    {
      signed int return_value_pthread_mutex_trylock$1;
      return_value_pthread_mutex_trylock$1=pthread_mutex_trylock(&GC_allocate_ml);
      if(!(return_value_pthread_mutex_trylock$1 == 0))
        GC_lock();

    }

  while((_Bool)0);
  me=GC_lookup_thread(self);
  do
    if(!(GC_need_to_lock == 0))
      pthread_mutex_unlock(&GC_allocate_ml);

  while((_Bool)0);
  return (signed int)(me != (struct GC_Thread_Rep *)(void *)0);
}

// GC_timeout_stop_func
// file alloc.c line 171
signed int GC_timeout_stop_func(void)
{
  signed long int current_time;
  unsigned long int time_diff;
  signed int return_value;
  return_value=GC_default_stop_func();
  if(!(return_value == 0))
    return 1;

  else
  {
    static unsigned int GC_timeout_stop_func$$1$$count = (unsigned int)0;
    unsigned int tmp_post$1 = GC_timeout_stop_func$$1$$count;
    GC_timeout_stop_func$$1$$count = GC_timeout_stop_func$$1$$count + 1u;
    if(!((3u & tmp_post$1) == 0u))
      return 0;

    else
    {
      current_time=clock();
      time_diff = (signed long int)1000000 % (signed long int)1000 == (signed long int)0 ? (unsigned long int)(current_time - GC_start_time) / (unsigned long int)((signed long int)1000000 / (signed long int)1000) : ((unsigned long int)(current_time - GC_start_time) * (unsigned long int)1000) / (unsigned long int)(signed long int)1000000;
      if(time_diff >= GC_time_limit)
      {
        if(!(GC_print_stats == 0))
          GC_log_printf("Abandoning stopped marking after %lu msecs (attempt %d)\n", time_diff, GC_n_attempts);

        return 1;
      }

      else
        return 0;
    }
  }
}

// GC_try_to_collect
// file alloc.c line 1000
extern signed int GC_try_to_collect(signed int (*stop_func)(void))
{
  signed int return_value_GC_try_to_collect_general$1;
  return_value_GC_try_to_collect_general$1=GC_try_to_collect_general(stop_func, 0);
  return (signed int)return_value_GC_try_to_collect_general$1;
}

// GC_try_to_collect_general
// file alloc.c line 964
signed int GC_try_to_collect_general(signed int (*stop_func)(void), signed int force_unmap)
{
  signed int result;
  signed int cancel_state;
  if((signed long int)GC_is_initialized == 0l)
    GC_init();

  if(!(GC_debugging_started == 0))
    GC_print_all_smashed();

  GC_notify_or_invoke_finalizers();
  do
    if(!(GC_need_to_lock == 0))
    {
      signed int return_value_pthread_mutex_trylock$1;
      return_value_pthread_mutex_trylock$1=pthread_mutex_trylock(&GC_allocate_ml);
      if(!(return_value_pthread_mutex_trylock$1 == 0))
        GC_lock();

    }

  while((_Bool)0);
  do
    pthread_setcancelstate(1, &cancel_state);
  while((_Bool)0);
  GC_collecting = 1;
  GC_noop6((unsigned long int)0, (unsigned long int)0, (unsigned long int)0, (unsigned long int)0, (unsigned long int)0, (unsigned long int)0);
  result=GC_try_to_collect_inner(stop_func != ((signed int (*)(void))NULL) ? stop_func : GC_default_stop_func);
  GC_collecting = 0;
  do
    pthread_setcancelstate(cancel_state, (signed int *)(void *)0);
  while((_Bool)0);
  do
    if(!(GC_need_to_lock == 0))
      pthread_mutex_unlock(&GC_allocate_ml);

  while((_Bool)0);
  if(!(result == 0))
  {
    if(!(GC_debugging_started == 0))
      GC_print_all_smashed();

    GC_notify_or_invoke_finalizers();
  }

  return result;
}

// GC_try_to_collect_inner
// file alloc.c line 411
signed int GC_try_to_collect_inner(signed int (*stop_func)(void))
{
  signed long int start_time = (signed long int)0;
  signed long int current_time;
  _Bool tmp_if_expr$1;
  signed int return_value;
  if(!(GC_dont_gc == 0))
    tmp_if_expr$1 = (_Bool)1;

  else
  {
    return_value=stop_func();
    tmp_if_expr$1 = return_value != 0 ? (_Bool)1 : (_Bool)0;
  }
  signed int return_value_GC_collection_in_progress$3;
  signed int return_value_GC_reclaim_all$4;
  if(tmp_if_expr$1)
    return 0;

  else
  {
    if(!(GC_incremental == 0))
    {
      return_value_GC_collection_in_progress$3=GC_collection_in_progress();
      if(!(return_value_GC_collection_in_progress$3 == 0))
      {
        if(!(GC_print_stats == 0))
          GC_log_printf("GC_try_to_collect_inner: finishing collection in progress\n");

        signed int return_value_GC_collection_in_progress$2;
        return_value_GC_collection_in_progress$2=GC_collection_in_progress();
        if(!(return_value_GC_collection_in_progress$2 == 0))
        {
          signed int return_value_1;
          return_value_1=stop_func();
          if(!(return_value_1 == 0))
            return 0;

          GC_collect_a_little_inner(1);
        }

      }

    }

    GC_notify_full_gc();
    if(!(GC_print_stats == 0))
    {
      start_time=clock();
      GC_log_printf("Initiating full world-stop collection!\n");
    }

    GC_promote_black_lists();
    if(!(GC_parallel == 0))
      GC_wait_for_reclaim();

    if(!(stop_func == GC_never_stop_func) || !(GC_find_leak == 0))
    {
      return_value_GC_reclaim_all$4=GC_reclaim_all(stop_func, 0);
      if(return_value_GC_reclaim_all$4 == 0)
        return 0;

    }

    GC_invalidate_mark_state();
    GC_clear_marks();
    GC_is_full_gc = 1;
    signed int return_value_GC_stopped_mark$5;
    return_value_GC_stopped_mark$5=GC_stopped_mark(stop_func);
    if(return_value_GC_stopped_mark$5 == 0)
    {
      if(GC_incremental == 0)
      {
        GC_invalidate_mark_state();
        GC_unpromote_black_lists();
      }

      return 0;
    }

    else
    {
      GC_finish_collection();
      if(!(GC_print_stats == 0))
      {
        current_time=clock();
        GC_log_printf("Complete collection took %lu msecs\n", (signed long int)1000000 % (signed long int)1000 == (signed long int)0 ? (unsigned long int)(current_time - start_time) / (unsigned long int)((signed long int)1000000 / (signed long int)1000) : ((unsigned long int)(current_time - start_time) * (unsigned long int)1000) / (unsigned long int)(signed long int)1000000);
      }

      return 1;
    }
  }
}

// GC_typed_mark_proc
// file typd_mlc.c line 381
struct GC_ms_entry * GC_typed_mark_proc(unsigned long int *addr, struct GC_ms_entry *mark_stack_ptr, struct GC_ms_entry *mark_stack_limit, unsigned long int env)
{
  unsigned long int bm = (GC_ext_descriptors + (signed long int)env)->ed_bitmap;
  unsigned long int *current_p = addr;
  unsigned long int current;
  char *greatest_ha = (char *)GC_greatest_plausible_heap_addr;
  char *least_ha = (char *)GC_least_plausible_heap_addr;
  struct hce hdr_cache[8l];
  memset((void *)hdr_cache, 0, (unsigned long int)sizeof(struct hce [8l]) /*128ul*/ );
  for( ; !(bm == 0ul); current_p = current_p + 1l)
  {
    if(!((1ul & bm) == 0ul))
    {
      current = *current_p;
      if(current >= (unsigned long int)least_ha && (unsigned long int)greatest_ha >= current)
        do
        {
          struct hblkhdr *my_hhdr;
          do
          {
            struct hce *hce = hdr_cache + (signed long int)((unsigned long int)(char *)current >> (unsigned long int)12 & (unsigned long int)(8 - 1));
            if(hce->block_addr == current >> 12ul)
              my_hhdr = hce->hce_hdr;

            else
            {
              my_hhdr=GC_header_cache_miss((char *)current, hce);
              if(my_hhdr == ((struct hblkhdr *)NULL))
                goto exit1;

            }
          }
          while((_Bool)0);
          do
          {
            unsigned long int displ = (unsigned long int)(char *)current & (unsigned long int)(1 << 12) - (unsigned long int)1;
            unsigned long int gran_displ = displ >> 4;
            unsigned long int gran_offset = (unsigned long int)my_hhdr->hb_map[(signed long int)gran_displ];
            unsigned long int byte_offset = displ & (unsigned long int)(16 - 1);
            char *base = (char *)current;
            if(!((byte_offset | gran_offset) == 0ul))
            {
              if(!(my_hhdr->hb_large_block == 0))
              {
                unsigned long int obj_displ;
                base = (char *)my_hhdr->hb_block;
                obj_displ = (unsigned long int)((char *)current - base);
                if(obj_displ == displ)
                {
                  if(GC_arrays._valid_offsets[(signed long int)obj_displ] == 0)
                  {
                    if(!(GC_all_interior_pointers == 0))
                      GC_add_to_black_list_stack((unsigned long int)(char *)current);

                    else
                      GC_add_to_black_list_normal((unsigned long int)(char *)current);
                    break;
                  }

                }

                gran_displ = (unsigned long int)0;
              }

              else
              {
                unsigned long int GC_typed_mark_proc$$1$$1$$1$$1$$1$$1$$2$$1$$2$$obj_displ = (gran_offset << 4) + byte_offset;
                if(GC_arrays._valid_offsets[(signed long int)GC_typed_mark_proc$$1$$1$$1$$1$$1$$1$$2$$1$$2$$obj_displ] == 0)
                {
                  if(!(GC_all_interior_pointers == 0))
                    GC_add_to_black_list_stack((unsigned long int)(char *)current);

                  else
                    GC_add_to_black_list_normal((unsigned long int)(char *)current);
                  break;
                }

                gran_displ = gran_displ - gran_offset;
                base = base - (signed long int)GC_typed_mark_proc$$1$$1$$1$$1$$1$$1$$2$$1$$2$$obj_displ;
              }
            }

            do
            {
              char *mark_byte_addr = (char *)my_hhdr->_mark_byte_union._hb_marks + (signed long int)gran_displ;
              if(!(*mark_byte_addr == 0))
                goto exit1;

              *mark_byte_addr = (char)1;
            }
            while((_Bool)0);
            unsigned long int return_value_AO_load$1;
            return_value_AO_load$1=AO_load$link2(&my_hhdr->hb_n_marks);
            AO_store$link1(&my_hhdr->hb_n_marks, return_value_AO_load$1 + (unsigned long int)1);
            do
            {
              unsigned long int _descr = my_hhdr->hb_descr;
              if(!(_descr == 0ul))
              {
                mark_stack_ptr = mark_stack_ptr + 1l;
                if((unsigned long int)mark_stack_ptr >= (unsigned long int)mark_stack_limit)
                  mark_stack_ptr=GC_signal_mark_stack_overflow(mark_stack_ptr);

                mark_stack_ptr->mse_start = base;
                mark_stack_ptr->mse_descr.w = _descr;
              }

            }
            while((_Bool)0);
          }
          while((_Bool)0);

        exit1:
          ;
        }
        while((_Bool)0);

    }

    bm = bm >> 1;
  }
  if(!((GC_ext_descriptors + (signed long int)env)->ed_continued == 0))
  {
    mark_stack_ptr = mark_stack_ptr + 1l;
    if((unsigned long int)mark_stack_ptr >= (unsigned long int)mark_stack_limit)
      mark_stack_ptr=GC_signal_mark_stack_overflow(mark_stack_ptr);

    mark_stack_ptr->mse_start = (char *)(addr + (signed long int)(unsigned long int)64);
    mark_stack_ptr->mse_descr.w = (env + (unsigned long int)1 << 6 | (unsigned long int)GC_typed_mark_proc_index) << 2 | (unsigned long int)2;
  }

  return mark_stack_ptr;
}

// GC_unix_get_mem
// file ./include/private/gcconfig.h line 2963
char * GC_unix_get_mem(unsigned long int bytes)
{
  char *result = ((char *)NULL);
  static signed int sbrk_failed = 0;
  if(sbrk_failed == 0)
    result=GC_unix_sbrk_get_mem(bytes);

  if(result == ((char *)NULL))
  {
    sbrk_failed = 1;
    result=GC_unix_mmap_get_mem(bytes);
  }

  if(result == ((char *)NULL))
    result=GC_unix_sbrk_get_mem(bytes);

  return result;
}

// GC_unix_mmap_get_mem
// file os_dep.c line 2040
char * GC_unix_mmap_get_mem(unsigned long int bytes)
{
  void *result;
  static signed int initialized = 0;
  if((signed long int)initialized == 0l)
  {
    zero_fd=open("/dev/zero", 00);
    if(zero_fd == -1)
    {
      GC_on_abort("Could not open /dev/zero");
      abort();
    }

    fcntl(zero_fd, 2, 1);
    initialized = 1;
  }

  if(!((GC_page_size + 18446744073709551615ul & bytes) == 0ul))
  {
    GC_on_abort("Bad GET_MEM arg");
    abort();
  }

  static char *last_addr = (char *)0;
  result=mmap((void *)last_addr, bytes, 0x1 | 0x2 | (GC_pages_executable != 0 ? 0x4 : 0), 0x02 | 0, zero_fd, (signed long int)0);
  if(result == (void *)-1)
    return ((char *)NULL);

  else
  {
    last_addr = ((char *)result + (signed long int)bytes + (signed long int)GC_page_size) - (signed long int)1;
    last_addr = (char *)((unsigned long int)last_addr & ~(GC_page_size - (unsigned long int)1));
    if(!((unsigned long int)result % 4096ul == 0ul))
    {
      GC_on_abort("GC_unix_get_mem: Memory returned by mmap is not aligned to HBLKSIZE.");
      abort();
    }

    return (char *)result;
  }
}

// GC_unix_sbrk_get_mem
// file os_dep.c line 2100
char * GC_unix_sbrk_get_mem(unsigned long int bytes)
{
  char *result;
  char *cur_brk;
  void *return_value_sbrk$1;
  return_value_sbrk$1=sbrk((signed long int)0);
  cur_brk = (char *)return_value_sbrk$1;
  signed long int lsbs = (signed long int)((unsigned long int)cur_brk & GC_page_size - (unsigned long int)1);
  if(!((signed long int)bytes >= 0l))
    result = ((char *)NULL);

  else
  {
    if(!(lsbs == 0l))
    {
      void *return_value_sbrk$2;
      return_value_sbrk$2=sbrk((signed long int)(GC_page_size - (unsigned long int)lsbs));
      if((char *)return_value_sbrk$2 == (char *)-1)
      {
        result = ((char *)NULL);
        goto out;
      }

    }

    void *return_value_sbrk$3;
    return_value_sbrk$3=sbrk((signed long int)bytes);
    result = (char *)return_value_sbrk$3;
    if(result == (char *)-1)
      result = ((char *)NULL);

  }

out:
  ;
  return result;
}

// GC_unpromote_black_lists
// file ./include/private/gc_priv.h line 1723
void GC_unpromote_black_lists(void)
{
  if(GC_all_interior_pointers == 0)
    GC_copy_bl(GC_old_normal_bl, GC_incomplete_normal_bl);

  GC_copy_bl(GC_old_stack_bl, GC_incomplete_stack_bl);
}

// GC_unreachable_finalize_mark_proc
// file finalize.c line 423
void GC_unreachable_finalize_mark_proc(char *p)
{
  GC_normal_finalize_mark_proc(p);
}

// GC_unregister_disappearing_link
// file finalize.c line 251
extern signed int GC_unregister_disappearing_link(void **link)
{
  struct disappearing_link *curr_dl;
  if(!((7ul & (unsigned long int)link) == 0ul))
    return 0;

  else
  {
    do
      if(!(GC_need_to_lock == 0))
      {
        signed int return_value_pthread_mutex_trylock$1;
        return_value_pthread_mutex_trylock$1=pthread_mutex_trylock(&GC_allocate_ml);
        if(!(return_value_pthread_mutex_trylock$1 == 0))
          GC_lock();

      }

    while((_Bool)0);
    curr_dl=GC_unregister_disappearing_link_inner(&GC_dl_hashtbl, link);
    do
      if(!(GC_need_to_lock == 0))
        pthread_mutex_unlock(&GC_allocate_ml);

    while((_Bool)0);
    if(curr_dl == ((struct disappearing_link *)NULL))
      return 0;

    else
    {
      GC_free((void *)curr_dl);
      return 1;
    }
  }
}

// GC_unregister_disappearing_link_inner
// file finalize.c line 227
static inline struct disappearing_link * GC_unregister_disappearing_link_inner(struct dl_hashtbl_s *dl_hashtbl, void **link)
{
  struct disappearing_link *curr_dl;
  struct disappearing_link *prev_dl = (struct disappearing_link *)(void *)0;
  unsigned long int index = ((unsigned long int)link >> 3 ^ (unsigned long int)link >> (signed long int)3 + dl_hashtbl->log_size) & (unsigned long int)((1 << dl_hashtbl->log_size) - 1);
  curr_dl = dl_hashtbl->head[(signed long int)index];
  for( ; !(curr_dl == ((struct disappearing_link *)NULL)); curr_dl = (struct disappearing_link *)curr_dl->prolog.next)
  {
    if(curr_dl->prolog.hidden_key == ~((unsigned long int)link))
    {
      if(prev_dl == ((struct disappearing_link *)NULL))
        dl_hashtbl->head[(signed long int)index] = (struct disappearing_link *)curr_dl->prolog.next;

      else
        prev_dl->prolog.next = (struct hash_chain_entry *)(struct disappearing_link *)curr_dl->prolog.next;
      dl_hashtbl->entries = dl_hashtbl->entries - 1ul;
      break;
    }

    prev_dl = curr_dl;
  }
  return curr_dl;
}

// GC_unregister_disappearing_link_inner$link1
// file finalize.c line 227
static inline struct disappearing_link * GC_unregister_disappearing_link_inner$link1(struct dl_hashtbl_s *dl_hashtbl$link1, void **link$link1)
{
  struct disappearing_link *curr_dl$link1;
  struct disappearing_link *prev_dl$link1 = (struct disappearing_link *)(void *)0;
  unsigned long int index$link1 = ((unsigned long int)link$link1 >> 3 ^ (unsigned long int)link$link1 >> (signed long int)3 + dl_hashtbl$link1->log_size) & (unsigned long int)((1 << dl_hashtbl$link1->log_size) - 1);
  curr_dl$link1 = dl_hashtbl$link1->head[(signed long int)index$link1];
  for( ; !(curr_dl$link1 == ((struct disappearing_link *)NULL)); curr_dl$link1 = (struct disappearing_link *)curr_dl$link1->prolog.next)
  {
    if(curr_dl$link1->prolog.hidden_key == ~((unsigned long int)link$link1))
    {
      if(prev_dl$link1 == ((struct disappearing_link *)NULL))
        dl_hashtbl$link1->head[(signed long int)index$link1] = (struct disappearing_link *)curr_dl$link1->prolog.next;

      else
        prev_dl$link1->prolog.next = (struct hash_chain_entry *)(struct disappearing_link *)curr_dl$link1->prolog.next;
      dl_hashtbl$link1->entries = dl_hashtbl$link1->entries - 1ul;
      break;
    }

    prev_dl$link1 = curr_dl$link1;
  }
  return curr_dl$link1;
}

// GC_unregister_long_link
// file finalize.c line 274
extern signed int GC_unregister_long_link(void **link)
{
  struct disappearing_link *curr_dl;
  if(!((7ul & (unsigned long int)link) == 0ul))
    return 0;

  else
  {
    do
      if(!(GC_need_to_lock == 0))
      {
        signed int return_value_pthread_mutex_trylock$1;
        return_value_pthread_mutex_trylock$1=pthread_mutex_trylock(&GC_allocate_ml);
        if(!(return_value_pthread_mutex_trylock$1 == 0))
          GC_lock();

      }

    while((_Bool)0);
    curr_dl=GC_unregister_disappearing_link_inner(&GC_ll_hashtbl, link);
    do
      if(!(GC_need_to_lock == 0))
        pthread_mutex_unlock(&GC_allocate_ml);

    while((_Bool)0);
    if(curr_dl == ((struct disappearing_link *)NULL))
      return 0;

    else
    {
      GC_free((void *)curr_dl);
      return 1;
    }
  }
}

// GC_unregister_my_thread
// file pthread_support.c line 1337
extern signed int GC_unregister_my_thread(void)
{
  unsigned long int self;
  self=pthread_self();
  struct GC_Thread_Rep *me;
  signed int cancel_state;
  do
    if(!(GC_need_to_lock == 0))
    {
      signed int return_value_pthread_mutex_trylock$1;
      return_value_pthread_mutex_trylock$1=pthread_mutex_trylock(&GC_allocate_ml);
      if(!(return_value_pthread_mutex_trylock$1 == 0))
        GC_lock();

    }

  while((_Bool)0);
  do
    pthread_setcancelstate(1, &cancel_state);
  while((_Bool)0);
  GC_wait_for_gc_completion(0);
  me=GC_lookup_thread(self);
  GC_unregister_my_thread_inner(me);
  do
    pthread_setcancelstate(cancel_state, (signed int *)(void *)0);
  while((_Bool)0);
  do
    if(!(GC_need_to_lock == 0))
      pthread_mutex_unlock(&GC_allocate_ml);

  while((_Bool)0);
  return 0;
}

// GC_unregister_my_thread_inner
// file pthread_support.c line 1307
void GC_unregister_my_thread_inner(struct GC_Thread_Rep *me)
{
  GC_destroy_thread_local(&me->tlfs);
  if(!((0x10 & (signed int)me->flags) == 0))
    GC_dont_gc = GC_dont_gc - 1;

  if(!((2 & (signed int)me->flags) == 0))
  {
    unsigned long int return_value_pthread_self$1;
    return_value_pthread_self$1=pthread_self();
    GC_delete_thread(return_value_pthread_self$1);
  }

  else
    me->flags = me->flags | (unsigned char)1;
}

// GC_wait_builder
// file pthread_support.c line 2002
void GC_wait_builder(void)
{
  signed int return_value_pthread_cond_wait$1;
  return_value_pthread_cond_wait$1=pthread_cond_wait(&builder_cv, &mark_mutex);
  if(!(return_value_pthread_cond_wait$1 == 0))
  {
    GC_on_abort("pthread_cond_wait failed");
    abort();
  }

}

// GC_wait_for_gc_completion
// file pthread_support.c line 911
void GC_wait_for_gc_completion(signed int wait_for_all)
{
  signed int return_value_GC_collection_in_progress$3;
  signed int return_value_GC_collection_in_progress$1;
  if(!(GC_incremental == 0))
  {
    return_value_GC_collection_in_progress$3=GC_collection_in_progress();
    if(!(return_value_GC_collection_in_progress$3 == 0))
    {
      unsigned long int old_gc_no = GC_gc_no;
      while(!(GC_incremental == 0))
      {
        return_value_GC_collection_in_progress$1=GC_collection_in_progress();
        if(return_value_GC_collection_in_progress$1 == 0)
          break;

        if(!(old_gc_no == GC_gc_no) && wait_for_all == 0)
          break;

        GC_collecting = 1;
        GC_in_thread_creation = 1;
        GC_collect_a_little_inner(1);
        GC_in_thread_creation = 0;
        GC_collecting = 0;
        do
          if(!(GC_need_to_lock == 0))
            pthread_mutex_unlock(&GC_allocate_ml);

        while((_Bool)0);
        sched_yield();
        do
          if(!(GC_need_to_lock == 0))
          {
            signed int return_value_pthread_mutex_trylock$2;
            return_value_pthread_mutex_trylock$2=pthread_mutex_trylock(&GC_allocate_ml);
            if(!(return_value_pthread_mutex_trylock$2 == 0))
              GC_lock();

          }

        while((_Bool)0);
      }
    }

  }

}

// GC_wait_for_reclaim
// file ./include/private/gc_priv.h line 2374
void GC_wait_for_reclaim(void)
{
  GC_acquire_mark_lock();
  while(GC_fl_builder_count >= 1ul)
    GC_wait_builder();
  GC_release_mark_lock();
}

// GC_wait_marker
// file ./include/private/gc_priv.h line 2379
void GC_wait_marker(void)
{
  signed int return_value_pthread_cond_wait$1;
  return_value_pthread_cond_wait$1=pthread_cond_wait(&mark_cv, &mark_mutex);
  if(!(return_value_pthread_cond_wait$1 == 0))
  {
    GC_on_abort("pthread_cond_wait failed");
    abort();
  }

}

// GC_with_callee_saves_pushed
// file mach_dep.c line 213
void GC_with_callee_saves_pushed(void (*fn)(char *, void *), char *arg)
{
  volatile signed int dummy;
  void *context = NULL;
  struct ucontext ctxt;
  unsigned short int old_fcw;
  asm("fstcw %0" : "=m"(*(&old_fcw)) :  : );
  signed int return_value_getcontext$1;
  return_value_getcontext$1=getcontext(&ctxt);
  if(!(return_value_getcontext$1 >= 0))
  {
    GC_on_abort("getcontext failed: Use another register retrieval method?");
    abort();
  }

  asm("fldcw %0" :  : "m"(*(&old_fcw)) : );
  unsigned int mxcsr;
  asm("stmxcsr %0" : "=m"(*(&mxcsr)) :  : );
  mxcsr = mxcsr & (unsigned int)~((0x20 | 0x04 | 0x10 | 0x08 | 0x01) << 7) | (unsigned int)(((signed int)old_fcw & (0x20 | 0x04 | 0x10 | 0x08 | 0x01)) << 7);
  asm("ldmxcsr %0" :  : "m"(*(&mxcsr)) : );
  context = (void *)&ctxt;
  fn(arg, context);
  GC_noop1((unsigned long int)&dummy);
}

// GC_write
// file misc.c line 1456
signed int GC_write(signed int fd, const char *buf, unsigned long int len)
{
  signed int bytes_written = 0;
  signed int result;
  signed int cancel_state;
  do
    pthread_setcancelstate(1, &cancel_state);
  while((_Bool)0);
  while(!((unsigned long int)bytes_written >= len))
  {
    signed long int return_value_write$1;
    return_value_write$1=write(fd, (const void *)(buf + (signed long int)bytes_written), len - (unsigned long int)bytes_written);
    result = (signed int)return_value_write$1;
    if(result == -1)
    {
      do
        pthread_setcancelstate(cancel_state, (signed int *)(void *)0);
      while((_Bool)0);
      return result;
    }

    bytes_written = bytes_written + result;
  }
  do
    pthread_setcancelstate(cancel_state, (signed int *)(void *)0);
  while((_Bool)0);
  return bytes_written;
}

// GC_write_fault_handler
// file os_dep.c line 3124
void GC_write_fault_handler(signed int sig, struct anonymous$13 *si, void *raw_sc)
{
  char *addr = (char *)si->_sifields._sigfault.si_addr;
  unsigned int i;
  if(sig == 11)
  {
    struct hblk *h = (struct hblk *)((unsigned long int)addr & ~(GC_page_size - (unsigned long int)1));
    signed int in_allocd_block;
    struct hblkhdr *return_value_GC_find_header$1;
    return_value_GC_find_header$1=GC_find_header((char *)addr);
    in_allocd_block = (signed int)(return_value_GC_find_header$1 != ((struct hblkhdr *)NULL));
    if(in_allocd_block == 0)
    {
      void (*old_handler)(signed int, struct anonymous$13 *, void *);
      signed int used_si;
      old_handler = GC_old_segv_handler;
      used_si = GC_old_segv_handler_used_si;
      if(old_handler == ((void (*)(signed int, struct anonymous$13 *, void *))NULL))
      {
        if(!(GC_print_stats == 0))
          GC_log_printf("Unexpected bus error or segmentation fault at %p", addr);

        GC_on_abort("Unexpected bus error or segmentation fault");
        abort();
      }

      else
        if(!(used_si == 0))
          ((void (*)(signed int, struct anonymous$13 *, void *))old_handler)(sig, si, raw_sc);

        else
          ((void (*)(signed int))old_handler)(sig);
    }

    signed int return_value_mprotect$2;
    return_value_mprotect$2=mprotect((void *)(char *)h, (unsigned long int)GC_page_size, 0x1 | 0x2 | (GC_pages_executable != 0 ? 0x4 : 0));
    if(!(return_value_mprotect$2 >= 0))
    {
      GC_on_abort(GC_pages_executable != 0 ? "un-mprotect executable page failed (probably disabled by OS)" : "un-mprotect failed");
      abort();
    }

    i = (unsigned int)0;
    for( ; !((unsigned long int)i >= GC_page_size >> 12ul); i = i + 1u)
    {
      unsigned long int index = (unsigned long int)(h + (signed long int)i) >> (unsigned long int)12 & ((unsigned long int)1 << 18) - (unsigned long int)1;
      async_set_pht_entry_from_index(GC_arrays._dirty_pages, index);
    }
    goto __CPROVER_DUMP_L13;
  }

  if(!(GC_print_stats == 0))
    GC_log_printf("Unexpected bus error or segmentation fault at %p", addr);

  GC_on_abort("Unexpected bus error or segmentation fault");
  abort();

__CPROVER_DUMP_L13:
  ;
}

// add_roots_to_index
// file mark_rts.c line 140
static inline void add_roots_to_index(struct roots *p)
{
  signed int h;
  h=rt_hash(p->r_start);
  p->r_next = GC_arrays._root_index[(signed long int)h];
  GC_arrays._root_index[(signed long int)h] = p;
}

// add_roots_to_index$link1
// file mark_rts.c line 140
static inline void add_roots_to_index$link1(struct roots *p$link1)
{
  signed int h$link1;
  h$link1=rt_hash$link1(p$link1->r_start);
  p$link1->r_next = GC_arrays._root_index[(signed long int)h$link1];
  GC_arrays._root_index[(signed long int)h$link1] = p$link1;
}

// alloc_hdr
// file headers.c line 164
static struct hblkhdr * alloc_hdr(void)
{
  struct hblkhdr *result;
  if(hdr_free_list == ((struct hblkhdr *)NULL))
  {
    char *return_value_GC_scratch_alloc$1;
    return_value_GC_scratch_alloc$1=GC_scratch_alloc((unsigned long int)sizeof(struct hblkhdr) /*528ul*/ );
    result = (struct hblkhdr *)return_value_GC_scratch_alloc$1;
  }

  else
  {
    result = hdr_free_list;
    hdr_free_list = (struct hblkhdr *)result->hb_next;
  }
  return result;
}

// alloc_hdr$link1
// file headers.c line 164
static struct hblkhdr * alloc_hdr$link1(void)
{
  struct hblkhdr *result$link1;
  if(hdr_free_list$link1 == ((struct hblkhdr *)NULL))
  {
    char *return_value_GC_scratch_alloc$1$link1;
    return_value_GC_scratch_alloc$1$link1=GC_scratch_alloc((unsigned long int)sizeof(struct hblkhdr) /*528ul*/ );
    result$link1 = (struct hblkhdr *)return_value_GC_scratch_alloc$1$link1;
  }

  else
  {
    result$link1 = hdr_free_list$link1;
    hdr_free_list$link1 = (struct hblkhdr *)result$link1->hb_next;
  }
  return result$link1;
}

// alloc_mark_stack
// file mark.c line 1187
static void alloc_mark_stack(unsigned long int n)
{
  struct GC_ms_entry *new_stack;
  char *return_value_GC_scratch_alloc$1;
  return_value_GC_scratch_alloc$1=GC_scratch_alloc(n * sizeof(struct GC_ms_entry) /*16ul*/ );
  new_stack = (struct GC_ms_entry *)return_value_GC_scratch_alloc$1;
  GC_mark_stack_too_small = 0;
  if(!(GC_mark_stack_size == 0ul))
  {
    if(!(new_stack == ((struct GC_ms_entry *)NULL)))
    {
      {
        unsigned long int page_offset = (unsigned long int)GC_arrays._mark_stack & GC_page_size - (unsigned long int)1;
        unsigned long int size = GC_mark_stack_size * sizeof(struct GC_ms_entry) /*16ul*/ ;
        unsigned long int displ = (unsigned long int)0;
        if(!(page_offset == 0ul))
          displ = GC_page_size - page_offset;

        size = size - displ & ~(GC_page_size - (unsigned long int)1);
        if(size >= 1ul)
          GC_add_to_heap((struct hblk *)((unsigned long int)GC_arrays._mark_stack + displ), (unsigned long int)size);

      }
      GC_arrays._mark_stack = new_stack;
      GC_mark_stack_size = n;
      GC_arrays._mark_stack_limit = new_stack + (signed long int)n;
      if(!(GC_print_stats == 0))
        GC_log_printf("Grew mark stack to %lu frames\n", (unsigned long int)GC_mark_stack_size);

    }

    else
      GC_current_warn_proc("GC Warning: Failed to grow mark stack to %ld frames\n", (unsigned long int)n);
  }

  else
  {
    if(new_stack == ((struct GC_ms_entry *)NULL))
    {
      GC_err_printf("No space for mark stack\n");
      GC_on_abort((const char *)(void *)0);
      exit(1);
    }

    GC_arrays._mark_stack = new_stack;
    GC_mark_stack_size = n;
    GC_arrays._mark_stack_limit = new_stack + (signed long int)n;
  }
  GC_arrays._mark_stack_top = GC_arrays._mark_stack - (signed long int)1;
}

// alloc_mark_stack$link1
// file mark.c line 1187
static void alloc_mark_stack$link1(unsigned long int n$link1)
{
  struct GC_ms_entry *new_stack$link1;
  char *return_value_GC_scratch_alloc$1$link1;
  return_value_GC_scratch_alloc$1$link1=GC_scratch_alloc(n$link1 * sizeof(struct GC_ms_entry) /*16ul*/ );
  new_stack$link1 = (struct GC_ms_entry *)return_value_GC_scratch_alloc$1$link1;
  GC_mark_stack_too_small = 0;
  if(!(GC_mark_stack_size == 0ul))
  {
    if(!(new_stack$link1 == ((struct GC_ms_entry *)NULL)))
    {
      {
        unsigned long int page_offset$link1 = (unsigned long int)GC_arrays._mark_stack & GC_page_size - (unsigned long int)1;
        unsigned long int size$link1 = GC_mark_stack_size * sizeof(struct GC_ms_entry) /*16ul*/ ;
        unsigned long int displ$link1 = (unsigned long int)0;
        if(!(page_offset$link1 == 0ul))
          displ$link1 = GC_page_size - page_offset$link1;

        size$link1 = size$link1 - displ$link1 & ~(GC_page_size - (unsigned long int)1);
        if(size$link1 >= 1ul)
          GC_add_to_heap((struct hblk *)((unsigned long int)GC_arrays._mark_stack + displ$link1), (unsigned long int)size$link1);

      }
      GC_arrays._mark_stack = new_stack$link1;
      GC_mark_stack_size = n$link1;
      GC_arrays._mark_stack_limit = new_stack$link1 + (signed long int)n$link1;
      if(!(GC_print_stats == 0))
        GC_log_printf("Grew mark stack to %lu frames\n", (unsigned long int)GC_mark_stack_size);

    }

    else
      GC_current_warn_proc("GC Warning: Failed to grow mark stack to %ld frames\n", (unsigned long int)n$link1);
  }

  else
  {
    if(new_stack$link1 == ((struct GC_ms_entry *)NULL))
    {
      GC_err_printf("No space for mark stack\n");
      GC_on_abort((const char *)(void *)0);
      exit(1);
    }

    GC_arrays._mark_stack = new_stack$link1;
    GC_mark_stack_size = n$link1;
    GC_arrays._mark_stack_limit = new_stack$link1 + (signed long int)n$link1;
  }
  GC_arrays._mark_stack_top = GC_arrays._mark_stack - (signed long int)1;
}

// async_set_pht_entry_from_index
// file os_dep.c line 3028
static void async_set_pht_entry_from_index(unsigned long int * volatile db, unsigned long int index)
{
  enum anonymous$15 return_value_AO_test_and_set_full$1;
  do
  {
    return_value_AO_test_and_set_full$1=AO_test_and_set_full(&GC_fault_handler_lock);
    if(!((signed int)return_value_AO_test_and_set_full$1 == AO_BYTE_TS_set))
      break;

  }
  while((_Bool)1);
  db[(signed long int)(index >> (unsigned long int)6)] = db[(signed long int)(index >> (unsigned long int)6)] | (unsigned long int)1 << (index & (unsigned long int)0x3f);
  AO_nop_write$link1();
  AO_char_store((unsigned char *)&GC_fault_handler_lock, (unsigned char)AO_BYTE_TS_clear);
}

// async_set_pht_entry_from_index$link1
// file os_dep.c line 3028
static void async_set_pht_entry_from_index$link1(unsigned long int * volatile db$link1, unsigned long int index$link1)
{
  enum anonymous$15 return_value_AO_test_and_set_full$1$link1;
  do
  {
    return_value_AO_test_and_set_full$1$link1=AO_test_and_set_full$link1(&GC_fault_handler_lock);
    if(!((signed int)return_value_AO_test_and_set_full$1$link1 == AO_BYTE_TS_set))
      break;

  }
  while((_Bool)1);
  db$link1[(signed long int)(index$link1 >> (unsigned long int)6)] = db$link1[(signed long int)(index$link1 >> (unsigned long int)6)] | (unsigned long int)1 << (index$link1 & (unsigned long int)0x3f);
  AO_nop_write$link1$link1();
  AO_char_store$link1((unsigned char *)&GC_fault_handler_lock, (unsigned char)AO_BYTE_TS_clear);
}

// atoi
// file /usr/include/stdlib.h line 278
static inline signed int atoi(const char *__nptr)
{
  signed long int return_value_strtol$1;
  return_value_strtol$1=strtol(__nptr, (char **)(void *)0, 10);
  return (signed int)return_value_strtol$1;
}

// atoi$link1
// file /usr/include/stdlib.h line 278
static inline signed int atoi$link1(const char *__nptr$link1)
{
  signed long int return_value_strtol$1$link1;
  return_value_strtol$1$link1=strtol(__nptr$link1, (char **)(void *)0, 10);
  return (signed int)return_value_strtol$1$link1;
}

// atoi$link1$link1
// file /usr/include/stdlib.h line 278
static inline signed int atoi$link1$link1(const char *__nptr$link1$link1)
{
  signed long int return_value_strtol$1$link1$link1;
  return_value_strtol$1$link1$link1=strtol(__nptr$link1$link1, (char **)(void *)0, 10);
  return (signed int)return_value_strtol$1$link1$link1;
}

// atoi$link2
// file /usr/include/stdlib.h line 278
static inline signed int atoi$link2(const char *__nptr$link2)
{
  signed long int return_value_strtol$1$link2;
  return_value_strtol$1$link2=strtol(__nptr$link2, (char **)(void *)0, 10);
  return (signed int)return_value_strtol$1$link2;
}

// atol
// file /usr/include/stdlib.h line 283
static inline signed long int atol(const char *__nptr)
{
  signed long int return_value_strtol$1;
  return_value_strtol$1=strtol(__nptr, (char **)(void *)0, 10);
  return return_value_strtol$1;
}

// atol$link1
// file /usr/include/stdlib.h line 283
static inline signed long int atol$link1(const char *__nptr$link1)
{
  signed long int return_value_strtol$1$link1;
  return_value_strtol$1$link1=strtol(__nptr$link1, (char **)(void *)0, 10);
  return return_value_strtol$1$link1;
}

// clear_marks_for_block
// file mark.c line 166
static void clear_marks_for_block(struct hblk *h, unsigned long int dummy)
{
  struct hblkhdr *hhdr;
  hhdr=GC_find_header((char *)h);
  if(!((-2 & (signed int)hhdr->hb_obj_kind) == 2))
    GC_clear_hdr_marks(hhdr);

}

// clear_marks_for_block$link1
// file mark.c line 166
static void clear_marks_for_block$link1(struct hblk *h$link1, unsigned long int dummy$link1)
{
  struct hblkhdr *hhdr$link1;
  hhdr$link1=GC_find_header((char *)h$link1);
  if(!((-2 & (signed int)hhdr$link1->hb_obj_kind) == 2))
    GC_clear_hdr_marks(hhdr$link1);

}

// disable_gc_for_dlopen
// file gc_dlopen.c line 44
static void disable_gc_for_dlopen(void)
{
  do
    if(!(GC_need_to_lock == 0))
    {
      signed int return_value_pthread_mutex_trylock$1;
      return_value_pthread_mutex_trylock$1=pthread_mutex_trylock(&GC_allocate_ml);
      if(!(return_value_pthread_mutex_trylock$1 == 0))
        GC_lock();

    }

  while((_Bool)0);
  signed int return_value_GC_collection_in_progress$2;
  while(!(GC_incremental == 0))
  {
    return_value_GC_collection_in_progress$2=GC_collection_in_progress();
    if(return_value_GC_collection_in_progress$2 == 0)
      break;

    GC_collect_a_little_inner(1000);
  }
  GC_dont_gc = GC_dont_gc + 1;
  do
    if(!(GC_need_to_lock == 0))
      pthread_mutex_unlock(&GC_allocate_ml);

  while((_Bool)0);
}

// disable_gc_for_dlopen$link1
// file gc_dlopen.c line 44
static void disable_gc_for_dlopen$link1(void)
{
  do
    if(!(GC_need_to_lock == 0))
    {
      signed int return_value_pthread_mutex_trylock$1$link1;
      return_value_pthread_mutex_trylock$1$link1=pthread_mutex_trylock(&GC_allocate_ml);
      if(!(return_value_pthread_mutex_trylock$1$link1 == 0))
        GC_lock();

    }

  while((_Bool)0);
  signed int return_value_GC_collection_in_progress$2$link1;
  while(!(GC_incremental == 0))
  {
    return_value_GC_collection_in_progress$2$link1=GC_collection_in_progress();
    if(return_value_GC_collection_in_progress$2$link1 == 0)
      break;

    GC_collect_a_little_inner(1000);
  }
  GC_dont_gc = GC_dont_gc + 1;
  do
    if(!(GC_need_to_lock == 0))
      pthread_mutex_unlock(&GC_allocate_ml);

  while((_Bool)0);
}

// ec_len
// file cord/cordprnt.c line 45
static signed int ec_len(struct CORD_ec_struct *x)
{
  unsigned long int return_value_CORD_len$1;
  return_value_CORD_len$1=CORD_len((x + (signed long int)0)->ec_cord);
  return (signed int)(return_value_CORD_len$1 + (unsigned long int)((x + (signed long int)0)->ec_bufptr - (x + (signed long int)0)->ec_buf));
}

// extract_conv_spec
// file cord/cordprnt.c line 62
static signed int extract_conv_spec(struct CORD_Pos *source, char *buf, signed int *width, signed int *prec, signed int *left, signed int *long_arg)
{
  signed int result = 0;
  signed int current_number = 0;
  signed int saw_period = 0;
  signed int saw_number = 0;
  signed int chars_so_far = 0;
  char current;
  *width = -1;
  signed int tmp_post$1 = chars_so_far;
  chars_so_far = chars_so_far + 1;
  buf[(signed long int)tmp_post$1] = (char)37;
  char return_value_CORD__pos_fetch$2;
  while(!(source->path_len == 0x55555555))
  {
    if(chars_so_far >= 50)
      return -1;

    signed int tmp_if_expr$3;
    if(!(source->cur_end == 0ul))
      tmp_if_expr$3 = (signed int)(source + (signed long int)0)->cur_leaf[(signed long int)((source + (signed long int)0)->cur_pos - (source + (signed long int)0)->cur_start)];

    else
    {
      return_value_CORD__pos_fetch$2=CORD__pos_fetch(source);
      tmp_if_expr$3 = (signed int)return_value_CORD__pos_fetch$2;
    }
    current = (char)tmp_if_expr$3;
    signed int tmp_post$4 = chars_so_far;
    chars_so_far = chars_so_far + 1;
    buf[(signed long int)tmp_post$4] = current;
    switch((signed int)current)
    {
      case 42:
      {
        saw_number = 1;
        current_number = -2;
        break;
      }
      case 48:
        if(saw_number == 0)
          break;

      case 49:

      case 50:

      case 51:

      case 52:

      case 53:

      case 54:

      case 55:

      case 56:

      case 57:
      {
        saw_number = 1;
        current_number = current_number * 10;
        current_number = current_number + ((signed int)current - 48);
        break;
      }
      case 46:
      {
        saw_period = 1;
        if(!(saw_number == 0))
        {
          *width = current_number;
          saw_number = 0;
        }

        current_number = 0;
        break;
      }
      case 108:

      case 76:
      {
        *long_arg = 1;
        current_number = 0;
        break;
      }
      case 104:
      {
        *long_arg = -1;
        current_number = 0;
        break;
      }
      case 32:

      case 43:

      case 35:
      {
        current_number = 0;
        break;
      }
      case 45:
      {
        *left = 1;
        current_number = 0;
        break;
      }
      case 100:

      case 105:

      case 111:

      case 117:

      case 120:

      case 88:

      case 102:

      case 101:

      case 69:

      case 103:

      case 71:

      case 99:

      case 67:

      case 115:

      case 83:

      case 112:

      case 110:

      case 114:
        goto done;
      default:
        return -1;
    }
    if(!(1ul + source->cur_pos >= source->cur_end))
      (source + (signed long int)0)->cur_pos = (source + (signed long int)0)->cur_pos + 1ul;

    else
    {
      CORD__next(source);
      0;
    }
  }
  return -1;

done:
  ;
  if(!(saw_number == 0))
  {
    if(!(saw_period == 0))
      *prec = current_number;

    else
    {
      *prec = -1;
      *width = current_number;
    }
  }

  else
    *prec = -1;
  buf[(signed long int)chars_so_far] = (char)0;
  return result;
}

// fill_prof_stats
// file misc.c line 541
static void fill_prof_stats(struct GC_prof_stats_s *pstats)
{
  pstats->heapsize_full = GC_arrays._heapsize;
  pstats->free_bytes_full = GC_arrays._large_free_bytes;
  pstats->unmapped_bytes = (unsigned long int)0;
  pstats->bytes_allocd_since_gc = GC_arrays._bytes_allocd;
  pstats->allocd_bytes_before_gc = GC_arrays._bytes_allocd_before_gc;
  pstats->non_gc_bytes = GC_non_gc_bytes;
  pstats->gc_no = GC_gc_no;
  pstats->markers_m1 = (unsigned long int)GC_parallel;
  pstats->bytes_reclaimed_since_gc = GC_bytes_found > (signed long int)0 ? (unsigned long int)GC_bytes_found : (unsigned long int)0;
  pstats->reclaimed_bytes_before_gc = GC_reclaimed_bytes_before_gc;
}

// fill_prof_stats$link1
// file misc.c line 541
static void fill_prof_stats$link1(struct GC_prof_stats_s *pstats$link1)
{
  pstats$link1->heapsize_full = GC_arrays._heapsize;
  pstats$link1->free_bytes_full = GC_arrays._large_free_bytes;
  pstats$link1->unmapped_bytes = (unsigned long int)0;
  pstats$link1->bytes_allocd_since_gc = GC_arrays._bytes_allocd;
  pstats$link1->allocd_bytes_before_gc = GC_arrays._bytes_allocd_before_gc;
  pstats$link1->non_gc_bytes = GC_non_gc_bytes;
  pstats$link1->gc_no = GC_gc_no;
  pstats$link1->markers_m1 = (unsigned long int)GC_parallel;
  pstats$link1->bytes_reclaimed_since_gc = GC_bytes_found > (signed long int)0 ? (unsigned long int)GC_bytes_found : (unsigned long int)0;
  pstats$link1->reclaimed_bytes_before_gc = GC_reclaimed_bytes_before_gc;
}

// fork_child_proc
// file pthread_support.c line 983
static void fork_child_proc(void)
{
  if(!(GC_parallel == 0))
    GC_release_mark_lock();

  GC_remove_all_threads_but_me();
  GC_parallel = 0;
  do
    pthread_setcancelstate(fork_cancel_state, (signed int *)(void *)0);
  while((_Bool)0);
  do
    if(!(GC_need_to_lock == 0))
      pthread_mutex_unlock(&GC_allocate_ml);

  while((_Bool)0);
}

// fork_child_proc$link1
// file pthread_support.c line 983
static void fork_child_proc$link1(void)
{
  if(!(GC_parallel == 0))
    GC_release_mark_lock();

  GC_remove_all_threads_but_me();
  GC_parallel = 0;
  do
    pthread_setcancelstate(fork_cancel_state$link1, (signed int *)(void *)0);
  while((_Bool)0);
  do
    if(!(GC_need_to_lock == 0))
      pthread_mutex_unlock(&GC_allocate_ml);

  while((_Bool)0);
}

// fork_parent_proc
// file pthread_support.c line 972
static void fork_parent_proc(void)
{
  if(!(GC_parallel == 0))
    GC_release_mark_lock();

  do
    pthread_setcancelstate(fork_cancel_state, (signed int *)(void *)0);
  while((_Bool)0);
  do
    if(!(GC_need_to_lock == 0))
      pthread_mutex_unlock(&GC_allocate_ml);

  while((_Bool)0);
}

// fork_parent_proc$link1
// file pthread_support.c line 972
static void fork_parent_proc$link1(void)
{
  if(!(GC_parallel == 0))
    GC_release_mark_lock();

  do
    pthread_setcancelstate(fork_cancel_state$link1, (signed int *)(void *)0);
  while((_Bool)0);
  do
    if(!(GC_need_to_lock == 0))
      pthread_mutex_unlock(&GC_allocate_ml);

  while((_Bool)0);
}

// fork_prepare_proc
// file pthread_support.c line 948
static void fork_prepare_proc(void)
{
  do
    if(!(GC_need_to_lock == 0))
    {
      signed int return_value_pthread_mutex_trylock$1;
      return_value_pthread_mutex_trylock$1=pthread_mutex_trylock(&GC_allocate_ml);
      if(!(return_value_pthread_mutex_trylock$1 == 0))
        GC_lock();

    }

  while((_Bool)0);
  do
    pthread_setcancelstate(1, &fork_cancel_state);
  while((_Bool)0);
  if(!(GC_parallel == 0))
    GC_wait_for_reclaim();

  GC_wait_for_gc_completion(1);
  if(!(GC_parallel == 0))
    GC_acquire_mark_lock();

}

// fork_prepare_proc$link1
// file pthread_support.c line 948
static void fork_prepare_proc$link1(void)
{
  do
    if(!(GC_need_to_lock == 0))
    {
      signed int return_value_pthread_mutex_trylock$1$link1;
      return_value_pthread_mutex_trylock$1$link1=pthread_mutex_trylock(&GC_allocate_ml);
      if(!(return_value_pthread_mutex_trylock$1$link1 == 0))
        GC_lock();

    }

  while((_Bool)0);
  do
    pthread_setcancelstate(1, &fork_cancel_state$link1);
  while((_Bool)0);
  if(!(GC_parallel == 0))
    GC_wait_for_reclaim();

  GC_wait_for_gc_completion(1);
  if(!(GC_parallel == 0))
    GC_acquire_mark_lock();

}

// free_hdr
// file headers.c line 177
static inline void free_hdr(struct hblkhdr *hhdr)
{
  hhdr->hb_next = (struct hblk *)hdr_free_list;
  hdr_free_list = hhdr;
}

// free_hdr$link1
// file headers.c line 177
static inline void free_hdr$link1(struct hblkhdr *hhdr$link1)
{
  hhdr$link1->hb_next = (struct hblk *)hdr_free_list$link1;
  hdr_free_list$link1 = hhdr$link1;
}

// free_list_index_of
// file allchblk.c line 153
static signed int free_list_index_of(struct hblkhdr *wanted)
{
  struct hblk *h;
  struct hblkhdr *hhdr;
  signed int i = 0;
  for( ; !(i >= 61); i = i + 1)
  {
    h = GC_hblkfreelist[(signed long int)i];
    for( ; !(h == ((struct hblk *)NULL)); h = hhdr->hb_next)
    {
      hhdr=GC_find_header((char *)h);
      if(hhdr == wanted)
        return i;

    }
  }
  return -1;
}

// free_list_index_of$link1
// file allchblk.c line 153
static signed int free_list_index_of$link1(struct hblkhdr *wanted$link1)
{
  struct hblk *h$link1;
  struct hblkhdr *hhdr$link1;
  signed int i$link1 = 0;
  for( ; !(i$link1 >= 61); i$link1 = i$link1 + 1)
  {
    h$link1 = GC_hblkfreelist[(signed long int)i$link1];
    for( ; !(h$link1 == ((struct hblk *)NULL)); h$link1 = hhdr$link1->hb_next)
    {
      hhdr$link1=GC_find_header((char *)h$link1);
      if(hhdr$link1 == wanted$link1)
        return i$link1;

    }
  }
  return -1;
}

// get_index
// file headers.c line 206
static signed int get_index(unsigned long int addr)
{
  unsigned long int hi = (unsigned long int)addr >> (unsigned long int)10 + (unsigned long int)12;
  struct bi *r;
  struct bi *p;
  struct bi **prev;
  struct bi *pi;
  unsigned long int i = hi & (unsigned long int)((1 << 11) - 1);
  struct bi *old;
  p = GC_arrays._top_index[(signed long int)i];
  old = p;
  for( ; !(p == GC_arrays._all_nils); p = p->hash_link)
    if(p->key == hi)
      return 1;

  char *return_value_GC_scratch_alloc$1;
  return_value_GC_scratch_alloc$1=GC_scratch_alloc((unsigned long int)sizeof(struct bi) /*8224ul*/ );
  r = (struct bi *)return_value_GC_scratch_alloc$1;
  if(r == ((struct bi *)NULL))
    return 0;

  else
  {
    memset((void *)r, 0, (unsigned long int)sizeof(struct bi) /*8224ul*/ );
    r->hash_link = old;
    GC_arrays._top_index[(signed long int)i] = r;
    r->key = hi;
    prev = &GC_all_bottom_indices;
    pi = ((struct bi *)NULL);
    do
    {
      p = *prev;
      if(p == ((struct bi *)NULL))
        break;

      if(p->key >= hi)
        break;

      pi = p;
      prev = &p->asc_link;
    }
    while((_Bool)1);
    r->desc_link = pi;
    if(p == ((struct bi *)NULL))
      GC_all_bottom_indices_end = r;

    else
      p->desc_link = r;
    r->asc_link = p;
    *prev = r;
    return 1;
  }
}

// get_index$link1
// file headers.c line 206
static signed int get_index$link1(unsigned long int addr$link1)
{
  unsigned long int hi$link1 = (unsigned long int)addr$link1 >> (unsigned long int)10 + (unsigned long int)12;
  struct bi *r$link1;
  struct bi *p$link1;
  struct bi **prev$link1;
  struct bi *pi$link1;
  unsigned long int i$link1 = hi$link1 & (unsigned long int)((1 << 11) - 1);
  struct bi *old$link1;
  p$link1 = GC_arrays._top_index[(signed long int)i$link1];
  old$link1 = p$link1;
  for( ; !(p$link1 == GC_arrays._all_nils); p$link1 = p$link1->hash_link)
    if(p$link1->key == hi$link1)
      return 1;

  char *return_value_GC_scratch_alloc$1$link1;
  return_value_GC_scratch_alloc$1$link1=GC_scratch_alloc((unsigned long int)sizeof(struct bi) /*8224ul*/ );
  r$link1 = (struct bi *)return_value_GC_scratch_alloc$1$link1;
  if(r$link1 == ((struct bi *)NULL))
    return 0;

  else
  {
    memset((void *)r$link1, 0, (unsigned long int)sizeof(struct bi) /*8224ul*/ );
    r$link1->hash_link = old$link1;
    GC_arrays._top_index[(signed long int)i$link1] = r$link1;
    r$link1->key = hi$link1;
    prev$link1 = &GC_all_bottom_indices;
    pi$link1 = ((struct bi *)NULL);
    do
    {
      p$link1 = *prev$link1;
      if(p$link1 == ((struct bi *)NULL))
        break;

      if(p$link1->key >= hi$link1)
        break;

      pi$link1 = p$link1;
      prev$link1 = &p$link1->asc_link;
    }
    while((_Bool)1);
    r$link1->desc_link = pi$link1;
    if(p$link1 == ((struct bi *)NULL))
      GC_all_bottom_indices_end = r$link1;

    else
      p$link1->desc_link = r$link1;
    r$link1->asc_link = p$link1;
    *prev$link1 = r$link1;
    return 1;
  }
}

// id_cord_fn
// file cord/tests/cordtest.c line 46
char id_cord_fn(unsigned long int i, void *client_data)
{
  if(!(client_data == NULL))
  {
    signed int x = 0;
    fprintf(stderr, "FAILED: %s\n", (const void *)"id_cord_fn: bad client data");
    x = 1 / x;
    abort();
  }

  return (char)i;
}

// looping_handler
// file misc.c line 753
static void looping_handler(signed int sig)
{
  GC_err_printf("Caught signal %d: looping in handler\n", sig);

__CPROVER_DUMP_L1:
  ;
  goto __CPROVER_DUMP_L1;
}

// looping_handler$link1
// file misc.c line 753
static void looping_handler$link1(signed int sig$link1)
{
  GC_err_printf("Caught signal %d: looping in handler\n", sig$link1);

__CPROVER_DUMP_L1:
  ;
  goto __CPROVER_DUMP_L1;
}

// main
// file cord/tests/cordtest.c line 235
signed int main(void)
{
  GC_init();
  test_basics();
  test_extras();
  test_printf();
  CORD_fprintf(stdout, "SUCCEEDED\n");
  return 0;
}

// maybe_finalize
// file gcj_mlc.c line 142
static void maybe_finalize(void)
{
  static unsigned long int last_finalized_no = (unsigned long int)0;
  if(!(GC_gc_no == last_finalized_no) && !((signed long int)GC_is_initialized == 0l))
  {
    do
      if(!(GC_need_to_lock == 0))
        pthread_mutex_unlock(&GC_allocate_ml);

    while((_Bool)0);
    GC_notify_or_invoke_finalizers();
    do
      if(!(GC_need_to_lock == 0))
      {
        signed int return_value_pthread_mutex_trylock$1;
        return_value_pthread_mutex_trylock$1=pthread_mutex_trylock(&GC_allocate_ml);
        if(!(return_value_pthread_mutex_trylock$1 == 0))
          GC_lock();

      }

    while((_Bool)0);
    last_finalized_no = GC_gc_no;
  }

}

// maybe_finalize$link1
// file gcj_mlc.c line 142
static void maybe_finalize$link1(void)
{
  static unsigned long int last_finalized_no$link1 = (unsigned long int)0;
  if(!(GC_gc_no == last_finalized_no$link1) && !((signed long int)GC_is_initialized == 0l))
  {
    do
      if(!(GC_need_to_lock == 0))
        pthread_mutex_unlock(&GC_allocate_ml);

    while((_Bool)0);
    GC_notify_or_invoke_finalizers();
    do
      if(!(GC_need_to_lock == 0))
      {
        signed int return_value_pthread_mutex_trylock$1$link1;
        return_value_pthread_mutex_trylock$1$link1=pthread_mutex_trylock(&GC_allocate_ml);
        if(!(return_value_pthread_mutex_trylock$1$link1 == 0))
          GC_lock();

      }

    while((_Bool)0);
    last_finalized_no$link1 = GC_gc_no;
  }

}

// maybe_install_looping_handler
// file misc.c line 763
static void maybe_install_looping_handler(void)
{
  char *return_value_getenv$1;
  if(installed_looping_handler == 0)
  {
    return_value_getenv$1=getenv("GC_LOOP_ON_ABORT");
    if(!(return_value_getenv$1 == ((char *)NULL)))
    {
      GC_set_and_save_fault_handler(looping_handler);
      installed_looping_handler = 1;
    }

  }

}

// maybe_install_looping_handler$link1
// file misc.c line 763
static void maybe_install_looping_handler$link1(void)
{
  char *return_value_getenv$1$link1;
  if(installed_looping_handler$link1 == 0)
  {
    return_value_getenv$1$link1=getenv("GC_LOOP_ON_ABORT");
    if(!(return_value_getenv$1$link1 == ((char *)NULL)))
    {
      GC_set_and_save_fault_handler(looping_handler$link1);
      installed_looping_handler$link1 = 1;
    }

  }

}

// min_bytes_allocd
// file alloc.c line 199
static unsigned long int min_bytes_allocd(void)
{
  unsigned long int result;
  unsigned long int stack_size;
  char *return_value_GC_approx_sp$1;
  return_value_GC_approx_sp$1=GC_approx_sp();
  stack_size = (unsigned long int)(GC_stackbottom - return_value_GC_approx_sp$1);
  unsigned long int total_root_size;
  unsigned long int scan_size;
  if(!(GC_need_to_lock == 0))
    stack_size = GC_total_stacksize;

  total_root_size = (unsigned long int)2 * stack_size + GC_root_size;
  scan_size = (unsigned long int)2 * GC_arrays._composite_in_use + GC_arrays._atomic_in_use / (unsigned long int)4 + total_root_size;
  result = scan_size / GC_free_space_divisor;
  if(!(GC_incremental == 0))
    result = result / (unsigned long int)2;

  return result > (unsigned long int)0 ? result : (unsigned long int)1;
}

// min_bytes_allocd$link1
// file alloc.c line 199
static unsigned long int min_bytes_allocd$link1(void)
{
  unsigned long int result$link1;
  unsigned long int stack_size$link1;
  char *return_value_GC_approx_sp$1$link1;
  return_value_GC_approx_sp$1$link1=GC_approx_sp();
  stack_size$link1 = (unsigned long int)(GC_stackbottom - return_value_GC_approx_sp$1$link1);
  unsigned long int total_root_size$link1;
  unsigned long int scan_size$link1;
  if(!(GC_need_to_lock == 0))
    stack_size$link1 = GC_total_stacksize;

  total_root_size$link1 = (unsigned long int)2 * stack_size$link1 + GC_root_size;
  scan_size$link1 = (unsigned long int)2 * GC_arrays._composite_in_use + GC_arrays._atomic_in_use / (unsigned long int)4 + total_root_size$link1;
  result$link1 = scan_size$link1 / GC_free_space_divisor;
  if(!(GC_incremental == 0))
    result$link1 = result$link1 / (unsigned long int)2;

  return result$link1 > (unsigned long int)0 ? result$link1 : (unsigned long int)1;
}

// putchar
// file /usr/include/x86_64-linux-gnu/bits/stdio.h line 79
static inline signed int putchar(signed int __c)
{
  signed int return_value__IO_putc$1;
  return_value__IO_putc$1=_IO_putc(__c, stdout);
  return return_value__IO_putc$1;
}

// refill_cache
// file cord/cordxtra.c line 522
static char refill_cache(struct anonymous$4 *client_data)
{
  struct anonymous$2 *state = client_data->state;
  unsigned long int file_pos = client_data->file_pos;
  struct _IO_FILE *f = state->lf_file;
  unsigned long int line_start = file_pos & (unsigned long int)~((1 << 9) - 1);
  unsigned long int line_no = (file_pos & (unsigned long int)((1 << 14) - 1)) >> 9;
  struct anonymous$3 *new_cache = client_data->new_cache;
  signed int return_value_fseek$1;
  if(!(line_start == state->lf_current))
  {
    return_value_fseek$1=fseek(f, (signed long int)line_start, 0);
    if(!(return_value_fseek$1 == 0))
    {
      fprintf(stderr, "%s\n", (const void *)"fseek failed");
      abort();
    }

  }

  unsigned long int return_value_fread$2;
  return_value_fread$2=fread((void *)new_cache->data, sizeof(char) /*1ul*/ , (unsigned long int)(1 << 9), f);
  if(file_pos + -line_start >= return_value_fread$2)
  {
    fprintf(stderr, "%s\n", (const void *)"fread failed");
    abort();
  }

  new_cache->tag = file_pos >> 9;
  state->lf_cache[(signed long int)line_no] = new_cache;
  state->lf_current = line_start + (unsigned long int)(1 << 9);
  return new_cache->data[(signed long int)(file_pos & (unsigned long int)((1 << 9) - 1))];
}

// return_freelists
// file thread_local_alloc.c line 64
static void return_freelists(void **fl, void **gfl)
{
  signed int i = 1;
  for( ; !(i >= 25); i = i + 1)
  {
    if((unsigned long int)fl[(signed long int)i] >= 4096ul)
      return_single_freelist(fl[(signed long int)i], gfl + (signed long int)i);

    fl[(signed long int)i] = (void *)(char *)(unsigned long int)(1 << 12);
  }
  if(!(*fl == (void *)18446744073709551615ul))
  {
    if((unsigned long int)*fl >= 4096ul)
      return_single_freelist(fl[(signed long int)0], gfl + (signed long int)1);

  }

}

// return_freelists$link1
// file thread_local_alloc.c line 64
static void return_freelists$link1(void **fl$link1, void **gfl$link1)
{
  signed int i$link1 = 1;
  for( ; !(i$link1 >= 25); i$link1 = i$link1 + 1)
  {
    if((unsigned long int)fl$link1[(signed long int)i$link1] >= 4096ul)
      return_single_freelist$link1(fl$link1[(signed long int)i$link1], gfl$link1 + (signed long int)i$link1);

    fl$link1[(signed long int)i$link1] = (void *)(char *)(unsigned long int)(1 << 12);
  }
  if(!(*fl$link1 == (void *)18446744073709551615ul))
  {
    if((unsigned long int)*fl$link1 >= 4096ul)
      return_single_freelist$link1(fl$link1[(signed long int)0], gfl$link1 + (signed long int)1);

  }

}

// return_single_freelist
// file thread_local_alloc.c line 44
static void return_single_freelist(void *fl, void **gfl)
{
  void *q;
  void **qptr;
  if(*gfl == NULL)
    *gfl = fl;

  else
  {
    qptr = &(*((void **)fl));
    do
    {
      q = *qptr;
      if(!((unsigned long int)q >= 4096ul))
        break;

      qptr = &(*((void **)q));
    }
    while((_Bool)1);
    *qptr = *gfl;
    *gfl = fl;
  }
}

// return_single_freelist$link1
// file thread_local_alloc.c line 44
static void return_single_freelist$link1(void *fl$link1, void **gfl$link1)
{
  void *q$link1;
  void **qptr$link1;
  if(*gfl$link1 == NULL)
    *gfl$link1 = fl$link1;

  else
  {
    qptr$link1 = &(*((void **)fl$link1));
    do
    {
      q$link1 = *qptr$link1;
      if(!((unsigned long int)q$link1 >= 4096ul))
        break;

      qptr$link1 = &(*((void **)q$link1));
    }
    while((_Bool)1);
    *qptr$link1 = *gfl$link1;
    *gfl$link1 = fl$link1;
  }
}

// rt_hash
// file mark_rts.c line 110
static inline signed int rt_hash(char *addr)
{
  unsigned long int result = (unsigned long int)addr;
  result = result ^ result >> 8 * 6;
  result = result ^ result >> 4 * 6;
  result = result ^ result >> 2 * 6;
  result = result ^ result >> 6;
  result = result & (unsigned long int)((1 << 6) - 1);
  return (signed int)result;
}

// rt_hash$link1
// file mark_rts.c line 110
static inline signed int rt_hash$link1(char *addr$link1)
{
  unsigned long int result$link1 = (unsigned long int)addr$link1;
  result$link1 = result$link1 ^ result$link1 >> 8 * 6;
  result$link1 = result$link1 ^ result$link1 >> 4 * 6;
  result$link1 = result$link1 ^ result$link1 >> 2 * 6;
  result$link1 = result$link1 ^ result$link1 >> 6;
  result$link1 = result$link1 & (unsigned long int)((1 << 6) - 1);
  return (signed int)result$link1;
}

// setup_header
// file allchblk.c line 225
static signed int setup_header(struct hblkhdr *hhdr, struct hblk *block, unsigned long int byte_sz, signed int kind, unsigned int flags)
{
  unsigned long int descr;
  unsigned long int granules;
  if(!(GC_obj_kinds[(signed long int)kind].ok_disclaim_proc == ((signed int (*)(void *))NULL)))
    flags = flags | (unsigned int)8;

  if(!(GC_obj_kinds[(signed long int)kind].ok_mark_unconditionally == 0))
    flags = flags | (unsigned int)0x10;

  hhdr->hb_sz = byte_sz;
  hhdr->hb_obj_kind = (unsigned char)kind;
  hhdr->hb_flags = (unsigned char)flags;
  hhdr->hb_block = block;
  descr = GC_obj_kinds[(signed long int)kind].ok_descriptor;
  if(!(GC_obj_kinds[(signed long int)kind].ok_relocate_descr == 0))
    descr = descr + byte_sz;

  hhdr->hb_descr = descr;
  hhdr->hb_large_block = (unsigned char)(byte_sz > (unsigned long int)((1 << 12) / 2));
  granules = byte_sz >> 4;
  signed int return_value_GC_add_map_entry$1;
  return_value_GC_add_map_entry$1=GC_add_map_entry(granules);
  if(return_value_GC_add_map_entry$1 == 0)
  {
    hhdr->hb_sz = (unsigned long int)(1 << 12);
    hhdr->hb_descr = (unsigned long int)0;
    hhdr->hb_large_block = (unsigned char)1;
    hhdr->hb_map = ((signed short int *)NULL);
    return 0;
  }

  else
  {
    unsigned long int index = hhdr->hb_large_block != 0 ? (unsigned long int)0 : granules;
    hhdr->hb_map = GC_arrays._obj_map[(signed long int)index];
  }
  GC_clear_hdr_marks(hhdr);
  hhdr->hb_last_reclaimed = (unsigned short int)GC_gc_no;
  return 1;
}

// setup_header$link1
// file allchblk.c line 225
static signed int setup_header$link1(struct hblkhdr *hhdr$link1, struct hblk *block$link1, unsigned long int byte_sz$link1, signed int kind$link1, unsigned int flags$link1)
{
  unsigned long int descr$link1;
  unsigned long int granules$link1;
  if(!(GC_obj_kinds[(signed long int)kind$link1].ok_disclaim_proc == ((signed int (*)(void *))NULL)))
    flags$link1 = flags$link1 | (unsigned int)8;

  if(!(GC_obj_kinds[(signed long int)kind$link1].ok_mark_unconditionally == 0))
    flags$link1 = flags$link1 | (unsigned int)0x10;

  hhdr$link1->hb_sz = byte_sz$link1;
  hhdr$link1->hb_obj_kind = (unsigned char)kind$link1;
  hhdr$link1->hb_flags = (unsigned char)flags$link1;
  hhdr$link1->hb_block = block$link1;
  descr$link1 = GC_obj_kinds[(signed long int)kind$link1].ok_descriptor;
  if(!(GC_obj_kinds[(signed long int)kind$link1].ok_relocate_descr == 0))
    descr$link1 = descr$link1 + byte_sz$link1;

  hhdr$link1->hb_descr = descr$link1;
  hhdr$link1->hb_large_block = (unsigned char)(byte_sz$link1 > (unsigned long int)((1 << 12) / 2));
  granules$link1 = byte_sz$link1 >> 4;
  signed int return_value_GC_add_map_entry$1$link1;
  return_value_GC_add_map_entry$1$link1=GC_add_map_entry(granules$link1);
  if(return_value_GC_add_map_entry$1$link1 == 0)
  {
    hhdr$link1->hb_sz = (unsigned long int)(1 << 12);
    hhdr$link1->hb_descr = (unsigned long int)0;
    hhdr$link1->hb_large_block = (unsigned char)1;
    hhdr$link1->hb_map = ((signed short int *)NULL);
    return 0;
  }

  else
  {
    unsigned long int index$link1 = hhdr$link1->hb_large_block != 0 ? (unsigned long int)0 : granules$link1;
    hhdr$link1->hb_map = GC_arrays._obj_map[(signed long int)index$link1];
  }
  GC_clear_hdr_marks(hhdr$link1);
  hhdr$link1->hb_last_reclaimed = (unsigned short int)GC_gc_no;
  return 1;
}

// store_old
// file dbg_mlc.c line 1075
static void store_old(void *obj, void (*my_old_fn)(void *, void *), struct closure *my_old_cd, void (**ofn)(void *, void *), void **ocd)
{
  if(!(my_old_fn == ((void (*)(void *, void *))NULL)))
  {
    if(my_old_fn == (void (*)(void *, void *))-1l)
      goto __CPROVER_DUMP_L6;

    if(!(my_old_fn == GC_debug_invoke_finalizer))
      GC_err_printf("Debuggable object at %p had a non-debug finalizer\n", obj);

    else
    {
      if(!(ofn == ((void (**)(void *, void *))NULL)))
        *ofn = my_old_cd->cl_fn;

      if(!(ocd == ((void **)NULL)))
        *ocd = my_old_cd->cl_data;

    }
  }

  else
  {
    if(!(ofn == ((void (**)(void *, void *))NULL)))
      *ofn = ((void (*)(void *, void *))NULL);

    if(!(ocd == ((void **)NULL)))
      *ocd = NULL;

  }

__CPROVER_DUMP_L6:
  ;
}

// store_old$link1
// file dbg_mlc.c line 1075
static void store_old$link1(void *obj$link1, void (*my_old_fn$link1)(void *, void *), struct closure *my_old_cd$link1, void (**ofn$link1)(void *, void *), void **ocd$link1)
{
  if(!(my_old_fn$link1 == ((void (*)(void *, void *))NULL)))
  {
    if(my_old_fn$link1 == (void (*)(void *, void *))-1l)
      goto __CPROVER_DUMP_L6;

    if(!(my_old_fn$link1 == GC_debug_invoke_finalizer))
      GC_err_printf("Debuggable object at %p had a non-debug finalizer\n", obj$link1);

    else
    {
      if(!(ofn$link1 == ((void (**)(void *, void *))NULL)))
        *ofn$link1 = my_old_cd$link1->cl_fn;

      if(!(ocd$link1 == ((void **)NULL)))
        *ocd$link1 = my_old_cd$link1->cl_data;

    }
  }

  else
  {
    if(!(ofn$link1 == ((void (**)(void *, void *))NULL)))
      *ofn$link1 = ((void (*)(void *, void *))NULL);

    if(!(ocd$link1 == ((void **)NULL)))
      *ocd$link1 = NULL;

  }

__CPROVER_DUMP_L6:
  ;
}

// test_basics
// file cord/tests/cordtest.c line 52
void test_basics(void)
{
  const char *test_basics$$1$$x;
  test_basics$$1$$x=CORD_from_char_star("ab");
  signed int i;
  char c;
  const char *y;
  struct CORD_Pos p[1l];
  test_basics$$1$$x=CORD_cat(test_basics$$1$$x, test_basics$$1$$x);
  if(test_basics$$1$$x == ((const char *)NULL))
  {
    signed int test_basics$$1$$1$$x = 0;
    fprintf(stderr, "FAILED: %s\n", (const void *)"CORD_cat(x,x) returned empty cord");
    test_basics$$1$$1$$x = 1 / test_basics$$1$$1$$x;
    abort();
  }

  if((signed int)*test_basics$$1$$x == 0)
  {
    signed int test_basics$$1$$2$$x = 0;
    fprintf(stderr, "FAILED: %s\n", (const void *)"short cord should usually be a string");
    test_basics$$1$$2$$x = 1 / test_basics$$1$$2$$x;
    abort();
  }

  signed int tmp_statement_expression$1;
  unsigned long int test_basics$$1$$3$$__s1_len;
  unsigned long int test_basics$$1$$3$$__s2_len;
  signed int return_value___builtin_strcmp$2;
  return_value___builtin_strcmp$2=__builtin_strcmp(test_basics$$1$$x, "abab");
  tmp_statement_expression$1 = return_value___builtin_strcmp$2;
  if(!(tmp_statement_expression$1 == 0))
  {
    signed int test_basics$$1$$4$$x = 0;
    fprintf(stderr, "FAILED: %s\n", (const void *)"bad CORD_cat result");
    test_basics$$1$$4$$x = 1 / test_basics$$1$$4$$x;
    abort();
  }

  i = 1;
  for( ; !(i >= 16); i = i + 1)
    test_basics$$1$$x=CORD_cat(test_basics$$1$$x, test_basics$$1$$x);
  test_basics$$1$$x=CORD_cat(test_basics$$1$$x, "c");
  unsigned long int return_value_CORD_len$3;
  return_value_CORD_len$3=CORD_len(test_basics$$1$$x);
  if(!(return_value_CORD_len$3 == 131073ul))
  {
    signed int test_basics$$1$$6$$x = 0;
    fprintf(stderr, "FAILED: %s\n", (const void *)"bad length");
    test_basics$$1$$6$$x = 1 / test_basics$$1$$6$$x;
    abort();
  }

  count = 0;
  signed int return_value_CORD_iter5$4;
  return_value_CORD_iter5$4=CORD_iter5(test_basics$$1$$x, (unsigned long int)(64 * 1024 - 1), test_fn, (signed int (*)(const char *, void *))0, (void *)13);
  if(return_value_CORD_iter5$4 == 0)
  {
    signed int test_basics$$1$$7$$1$$x = 0;
    fprintf(stderr, "FAILED: %s\n", (const void *)"CORD_iter5 failed");
    test_basics$$1$$7$$1$$x = 1 / test_basics$$1$$7$$1$$x;
    abort();
  }

  if(!(count == 2))
  {
    signed int test_basics$$1$$8$$x = 0;
    fprintf(stderr, "FAILED: %s\n", (const void *)"CORD_iter5 failed");
    test_basics$$1$$8$$x = 1 / test_basics$$1$$8$$x;
    abort();
  }

  count = 0;
  CORD_set_pos(p, test_basics$$1$$x, (unsigned long int)(64 * 1024 - 1));
  char return_value_CORD__pos_fetch$5;
  while(!(p[0l].path_len == 0x55555555))
  {
    signed int tmp_if_expr$6;
    if(!(p[0l].cur_end == 0ul))
      tmp_if_expr$6 = (signed int)p[(signed long int)0].cur_leaf[(signed long int)(p[(signed long int)0].cur_pos - p[(signed long int)0].cur_start)];

    else
    {
      return_value_CORD__pos_fetch$5=CORD__pos_fetch(p);
      tmp_if_expr$6 = (signed int)return_value_CORD__pos_fetch$5;
    }
    test_fn((char)tmp_if_expr$6, (void *)13);
    if(!(1ul + p[0l].cur_pos >= p[0l].cur_end))
      p[(signed long int)0].cur_pos = p[(signed long int)0].cur_pos + 1ul;

    else
    {
      CORD__next(p);
      0;
    }
  }
  if(!(count == 2))
  {
    signed int test_basics$$1$$10$$x = 0;
    fprintf(stderr, "FAILED: %s\n", (const void *)"Position based iteration failed");
    test_basics$$1$$10$$x = 1 / test_basics$$1$$10$$x;
    abort();
  }

  y=CORD_substr(test_basics$$1$$x, (unsigned long int)1023, (unsigned long int)5);
  if(y == ((const char *)NULL))
  {
    signed int x = 0;
    fprintf(stderr, "FAILED: %s\n", (const void *)"CORD_substr returned NULL");
    x = 1 / x;
    abort();
  }

  if((signed int)*y == 0)
  {
    signed int test_basics$$1$$12$$x = 0;
    fprintf(stderr, "FAILED: %s\n", (const void *)"short cord should usually be a string");
    test_basics$$1$$12$$x = 1 / test_basics$$1$$12$$x;
    abort();
  }

  signed int tmp_statement_expression$7;
  unsigned long int test_basics$$1$$13$$__s1_len;
  unsigned long int test_basics$$1$$13$$__s2_len;
  signed int return_value___builtin_strcmp$8;
  return_value___builtin_strcmp$8=__builtin_strcmp(y, "babab");
  tmp_statement_expression$7 = return_value___builtin_strcmp$8;
  if(!(tmp_statement_expression$7 == 0))
  {
    signed int test_basics$$1$$14$$x = 0;
    fprintf(stderr, "FAILED: %s\n", (const void *)"bad CORD_substr result");
    test_basics$$1$$14$$x = 1 / test_basics$$1$$14$$x;
    abort();
  }

  y=CORD_substr(test_basics$$1$$x, (unsigned long int)1024, (unsigned long int)8);
  if(y == ((const char *)NULL))
  {
    signed int test_basics$$1$$15$$x = 0;
    fprintf(stderr, "FAILED: %s\n", (const void *)"CORD_substr returned NULL");
    test_basics$$1$$15$$x = 1 / test_basics$$1$$15$$x;
    abort();
  }

  if((signed int)*y == 0)
  {
    signed int test_basics$$1$$16$$x = 0;
    fprintf(stderr, "FAILED: %s\n", (const void *)"short cord should usually be a string");
    test_basics$$1$$16$$x = 1 / test_basics$$1$$16$$x;
    abort();
  }

  signed int tmp_statement_expression$9;
  unsigned long int test_basics$$1$$17$$__s1_len;
  unsigned long int test_basics$$1$$17$$__s2_len;
  signed int return_value___builtin_strcmp$10;
  return_value___builtin_strcmp$10=__builtin_strcmp(y, "abababab");
  tmp_statement_expression$9 = return_value___builtin_strcmp$10;
  if(!(tmp_statement_expression$9 == 0))
  {
    signed int test_basics$$1$$18$$x = 0;
    fprintf(stderr, "FAILED: %s\n", (const void *)"bad CORD_substr result");
    test_basics$$1$$18$$x = 1 / test_basics$$1$$18$$x;
    abort();
  }

  y=CORD_substr(test_basics$$1$$x, (unsigned long int)(128 * 1024 - 1), (unsigned long int)8);
  if(y == ((const char *)NULL))
  {
    signed int test_basics$$1$$19$$x = 0;
    fprintf(stderr, "FAILED: %s\n", (const void *)"CORD_substr returned NULL");
    test_basics$$1$$19$$x = 1 / test_basics$$1$$19$$x;
    abort();
  }

  if((signed int)*y == 0)
  {
    signed int test_basics$$1$$20$$x = 0;
    fprintf(stderr, "FAILED: %s\n", (const void *)"short cord should usually be a string");
    test_basics$$1$$20$$x = 1 / test_basics$$1$$20$$x;
    abort();
  }

  signed int tmp_statement_expression$11;
  unsigned long int test_basics$$1$$21$$__s1_len;
  unsigned long int test_basics$$1$$21$$__s2_len;
  signed int return_value___builtin_strcmp$12;
  return_value___builtin_strcmp$12=__builtin_strcmp(y, "bc");
  tmp_statement_expression$11 = return_value___builtin_strcmp$12;
  if(!(tmp_statement_expression$11 == 0))
  {
    signed int test_basics$$1$$22$$x = 0;
    fprintf(stderr, "FAILED: %s\n", (const void *)"bad CORD_substr result");
    test_basics$$1$$22$$x = 1 / test_basics$$1$$22$$x;
    abort();
  }

  test_basics$$1$$x=CORD_balance(test_basics$$1$$x);
  unsigned long int return_value_CORD_len$13;
  return_value_CORD_len$13=CORD_len(test_basics$$1$$x);
  if(!(return_value_CORD_len$13 == 131073ul))
  {
    signed int test_basics$$1$$23$$x = 0;
    fprintf(stderr, "FAILED: %s\n", (const void *)"bad length");
    test_basics$$1$$23$$x = 1 / test_basics$$1$$23$$x;
    abort();
  }

  count = 0;
  signed int return_value_CORD_iter5$14;
  return_value_CORD_iter5$14=CORD_iter5(test_basics$$1$$x, (unsigned long int)(64 * 1024 - 1), test_fn, (signed int (*)(const char *, void *))0, (void *)13);
  if(return_value_CORD_iter5$14 == 0)
  {
    signed int test_basics$$1$$24$$1$$x = 0;
    fprintf(stderr, "FAILED: %s\n", (const void *)"CORD_iter5 failed");
    test_basics$$1$$24$$1$$x = 1 / test_basics$$1$$24$$1$$x;
    abort();
  }

  if(!(count == 2))
  {
    signed int test_basics$$1$$25$$x = 0;
    fprintf(stderr, "FAILED: %s\n", (const void *)"CORD_iter5 failed");
    test_basics$$1$$25$$x = 1 / test_basics$$1$$25$$x;
    abort();
  }

  y=CORD_substr(test_basics$$1$$x, (unsigned long int)1023, (unsigned long int)5);
  if(y == ((const char *)NULL))
  {
    signed int test_basics$$1$$26$$x = 0;
    fprintf(stderr, "FAILED: %s\n", (const void *)"CORD_substr returned NULL");
    test_basics$$1$$26$$x = 1 / test_basics$$1$$26$$x;
    abort();
  }

  if((signed int)*y == 0)
  {
    signed int test_basics$$1$$27$$x = 0;
    fprintf(stderr, "FAILED: %s\n", (const void *)"short cord should usually be a string");
    test_basics$$1$$27$$x = 1 / test_basics$$1$$27$$x;
    abort();
  }

  signed int tmp_statement_expression$15;
  unsigned long int __s1_len;
  unsigned long int __s2_len;
  signed int return_value___builtin_strcmp$16;
  return_value___builtin_strcmp$16=__builtin_strcmp(y, "babab");
  tmp_statement_expression$15 = return_value___builtin_strcmp$16;
  if(!(tmp_statement_expression$15 == 0))
  {
    signed int test_basics$$1$$29$$x = 0;
    fprintf(stderr, "FAILED: %s\n", (const void *)"bad CORD_substr result");
    test_basics$$1$$29$$x = 1 / test_basics$$1$$29$$x;
    abort();
  }

  y=CORD_from_fn(id_cord_fn, NULL, (unsigned long int)13);
  i = 0;
  CORD_set_pos(p, y, (unsigned long int)i);
  char return_value_CORD__pos_fetch$17;
  while(!(p[0l].path_len == 0x55555555))
  {
    signed int tmp_if_expr$18;
    if(!(p[0l].cur_end == 0ul))
      tmp_if_expr$18 = (signed int)p[(signed long int)0].cur_leaf[(signed long int)(p[(signed long int)0].cur_pos - p[(signed long int)0].cur_start)];

    else
    {
      return_value_CORD__pos_fetch$17=CORD__pos_fetch(p);
      tmp_if_expr$18 = (signed int)return_value_CORD__pos_fetch$17;
    }
    c = (char)tmp_if_expr$18;
    if(!((signed int)c == i))
    {
      signed int test_basics$$1$$30$$1$$x = 0;
      fprintf(stderr, "FAILED: %s\n", (const void *)"Traversal of function node failed");
      test_basics$$1$$30$$1$$x = 1 / test_basics$$1$$30$$1$$x;
      abort();
    }

    if(!(1ul + p[0l].cur_pos >= p[0l].cur_end))
      p[(signed long int)0].cur_pos = p[(signed long int)0].cur_pos + 1ul;

    else
    {
      CORD__next(p);
      0;
    }
    i = i + 1;
  }
  if(!(i == 13))
  {
    signed int test_basics$$1$$31$$x = 0;
    fprintf(stderr, "FAILED: %s\n", (const void *)"Bad apparent length for function node");
    test_basics$$1$$31$$x = 1 / test_basics$$1$$31$$x;
    abort();
  }

}

// test_extras
// file cord/tests/cordtest.c line 124
void test_extras(void)
{
  signed int i;
  const char *y = "abcdefghijklmnopqrstuvwxyz0123456789";
  const char *test_extras$$1$$x = "{}";
  const char *w;
  const char *z;
  struct _IO_FILE *f;
  struct _IO_FILE *f1a;
  struct _IO_FILE *f1b;
  struct _IO_FILE *f2;
  const char *return_value_CORD_cat$1;
  return_value_CORD_cat$1=CORD_cat(y, y);
  w=CORD_cat(return_value_CORD_cat$1, y);
  z=CORD_catn(3, y, y, y);
  signed int return_value_CORD_cmp$2;
  return_value_CORD_cmp$2=CORD_cmp(w, z);
  if(!(return_value_CORD_cmp$2 == 0))
  {
    signed int test_extras$$1$$1$$x = 0;
    fprintf(stderr, "FAILED: %s\n", (const void *)"CORD_catn comparison wrong");
    test_extras$$1$$1$$x = 1 / test_extras$$1$$1$$x;
    abort();
  }

  i = 1;
  for( ; !(i >= 100); i = i + 1)
    test_extras$$1$$x=CORD_cat(test_extras$$1$$x, y);
  z=CORD_balance(test_extras$$1$$x);
  signed int return_value_CORD_cmp$3;
  return_value_CORD_cmp$3=CORD_cmp(test_extras$$1$$x, z);
  if(!(return_value_CORD_cmp$3 == 0))
  {
    signed int test_extras$$1$$3$$x = 0;
    fprintf(stderr, "FAILED: %s\n", (const void *)"balanced string comparison wrong");
    test_extras$$1$$3$$x = 1 / test_extras$$1$$3$$x;
    abort();
  }

  const char *return_value_CORD_chars$4;
  return_value_CORD_chars$4=CORD_chars((char)0, (unsigned long int)13);
  const char *return_value_CORD_cat$5;
  return_value_CORD_cat$5=CORD_cat(z, return_value_CORD_chars$4);
  signed int return_value_CORD_cmp$6;
  return_value_CORD_cmp$6=CORD_cmp(test_extras$$1$$x, return_value_CORD_cat$5);
  if(return_value_CORD_cmp$6 >= 0)
  {
    signed int test_extras$$1$$4$$x = 0;
    fprintf(stderr, "FAILED: %s\n", (const void *)"comparison 2");
    test_extras$$1$$4$$x = 1 / test_extras$$1$$4$$x;
    abort();
  }

  const char *return_value_CORD_chars$7;
  return_value_CORD_chars$7=CORD_chars((char)0, (unsigned long int)13);
  const char *return_value_CORD_cat$8;
  return_value_CORD_cat$8=CORD_cat(test_extras$$1$$x, return_value_CORD_chars$7);
  signed int return_value_CORD_cmp$9;
  return_value_CORD_cmp$9=CORD_cmp(return_value_CORD_cat$8, z);
  if(!(return_value_CORD_cmp$9 >= 1))
  {
    signed int test_extras$$1$$5$$x = 0;
    fprintf(stderr, "FAILED: %s\n", (const void *)"comparison 3");
    test_extras$$1$$5$$x = 1 / test_extras$$1$$5$$x;
    abort();
  }

  const char *return_value_CORD_cat$10;
  return_value_CORD_cat$10=CORD_cat(z, "13");
  signed int return_value_CORD_cmp$11;
  return_value_CORD_cmp$11=CORD_cmp(test_extras$$1$$x, return_value_CORD_cat$10);
  if(return_value_CORD_cmp$11 >= 0)
  {
    signed int test_extras$$1$$6$$x = 0;
    fprintf(stderr, "FAILED: %s\n", (const void *)"comparison 4");
    test_extras$$1$$6$$x = 1 / test_extras$$1$$6$$x;
    abort();
  }

  f=fopen("cordtst1.tmp", "w");
  if(f == ((struct _IO_FILE *)NULL))
  {
    signed int test_extras$$1$$7$$x = 0;
    fprintf(stderr, "FAILED: %s\n", (const void *)"open failed");
    test_extras$$1$$7$$x = 1 / test_extras$$1$$7$$x;
    abort();
  }

  signed int return_value_CORD_put$12;
  return_value_CORD_put$12=CORD_put(z, f);
  if(return_value_CORD_put$12 == -1)
  {
    signed int test_extras$$1$$8$$x = 0;
    fprintf(stderr, "FAILED: %s\n", (const void *)"CORD_put failed");
    test_extras$$1$$8$$x = 1 / test_extras$$1$$8$$x;
    abort();
  }

  signed int return_value_fclose$13;
  return_value_fclose$13=fclose(f);
  if(return_value_fclose$13 == -1)
  {
    signed int test_extras$$1$$9$$x = 0;
    fprintf(stderr, "FAILED: %s\n", (const void *)"fclose failed");
    test_extras$$1$$9$$x = 1 / test_extras$$1$$9$$x;
    abort();
  }

  f1a=fopen("cordtst1.tmp", "rb");
  if(f1a == ((struct _IO_FILE *)NULL))
  {
    signed int test_extras$$1$$10$$x = 0;
    fprintf(stderr, "FAILED: %s\n", (const void *)"Unable to open cordtst1.tmp");
    test_extras$$1$$10$$x = 1 / test_extras$$1$$10$$x;
    abort();
  }

  w=CORD_from_file(f1a);
  unsigned long int return_value_CORD_len$14;
  return_value_CORD_len$14=CORD_len(w);
  unsigned long int return_value_CORD_len$15;
  return_value_CORD_len$15=CORD_len(z);
  if(!(return_value_CORD_len$14 == return_value_CORD_len$15))
  {
    signed int test_extras$$1$$11$$x = 0;
    fprintf(stderr, "FAILED: %s\n", (const void *)"file length wrong");
    test_extras$$1$$11$$x = 1 / test_extras$$1$$11$$x;
    abort();
  }

  signed int return_value_CORD_cmp$16;
  return_value_CORD_cmp$16=CORD_cmp(w, z);
  if(!(return_value_CORD_cmp$16 == 0))
  {
    signed int test_extras$$1$$12$$x = 0;
    fprintf(stderr, "FAILED: %s\n", (const void *)"file comparison wrong");
    test_extras$$1$$12$$x = 1 / test_extras$$1$$12$$x;
    abort();
  }

  const char *return_value_CORD_substr$17;
  return_value_CORD_substr$17=CORD_substr(w, (unsigned long int)(50 * 36 + 2), (unsigned long int)36);
  signed int return_value_CORD_cmp$18;
  return_value_CORD_cmp$18=CORD_cmp(return_value_CORD_substr$17, y);
  if(!(return_value_CORD_cmp$18 == 0))
  {
    signed int test_extras$$1$$13$$x = 0;
    fprintf(stderr, "FAILED: %s\n", (const void *)"file substr wrong");
    test_extras$$1$$13$$x = 1 / test_extras$$1$$13$$x;
    abort();
  }

  f1b=fopen("cordtst1.tmp", "rb");
  if(f1b == ((struct _IO_FILE *)NULL))
  {
    signed int test_extras$$1$$14$$x = 0;
    fprintf(stderr, "FAILED: %s\n", (const void *)"2nd open failed: cordtst1.tmp");
    test_extras$$1$$14$$x = 1 / test_extras$$1$$14$$x;
    abort();
  }

  z=CORD_from_file_lazy(f1b);
  signed int return_value_CORD_cmp$19;
  return_value_CORD_cmp$19=CORD_cmp(w, z);
  if(!(return_value_CORD_cmp$19 == 0))
  {
    signed int test_extras$$1$$15$$x = 0;
    fprintf(stderr, "FAILED: %s\n", (const void *)"File conversions differ");
    test_extras$$1$$15$$x = 1 / test_extras$$1$$15$$x;
    abort();
  }

  unsigned long int return_value_CORD_chr$20;
  return_value_CORD_chr$20=CORD_chr(w, (unsigned long int)0, 57);
  if(!(return_value_CORD_chr$20 == 37ul))
  {
    signed int test_extras$$1$$16$$x = 0;
    fprintf(stderr, "FAILED: %s\n", (const void *)"CORD_chr failed 1");
    test_extras$$1$$16$$x = 1 / test_extras$$1$$16$$x;
    abort();
  }

  unsigned long int return_value_CORD_chr$21;
  return_value_CORD_chr$21=CORD_chr(w, (unsigned long int)3, 97);
  if(!(return_value_CORD_chr$21 == 38ul))
  {
    signed int x = 0;
    fprintf(stderr, "FAILED: %s\n", (const void *)"CORD_chr failed 2");
    x = 1 / x;
    abort();
  }

  unsigned long int return_value_CORD_len$22;
  return_value_CORD_len$22=CORD_len(w);
  unsigned long int return_value_CORD_rchr$23;
  return_value_CORD_rchr$23=CORD_rchr(w, return_value_CORD_len$22 - (unsigned long int)1, 125);
  if(!(return_value_CORD_rchr$23 == 1ul))
  {
    signed int test_extras$$1$$18$$x = 0;
    fprintf(stderr, "FAILED: %s\n", (const void *)"CORD_rchr failed");
    test_extras$$1$$18$$x = 1 / test_extras$$1$$18$$x;
    abort();
  }

  test_extras$$1$$x = y;
  i = 1;
  for( ; !(i >= 14); i = i + 1)
    test_extras$$1$$x=CORD_cat(test_extras$$1$$x, test_extras$$1$$x);
  f=fopen("cordtst2.tmp", "w");
  if(f == ((struct _IO_FILE *)NULL))
  {
    signed int test_extras$$1$$20$$x = 0;
    fprintf(stderr, "FAILED: %s\n", (const void *)"2nd open failed");
    test_extras$$1$$20$$x = 1 / test_extras$$1$$20$$x;
    abort();
  }

  signed int return_value_CORD_put$24;
  return_value_CORD_put$24=CORD_put(test_extras$$1$$x, f);
  if(return_value_CORD_put$24 == -1)
  {
    signed int test_extras$$1$$21$$x = 0;
    fprintf(stderr, "FAILED: %s\n", (const void *)"CORD_put failed");
    test_extras$$1$$21$$x = 1 / test_extras$$1$$21$$x;
    abort();
  }

  signed int return_value_fclose$25;
  return_value_fclose$25=fclose(f);
  if(return_value_fclose$25 == -1)
  {
    signed int test_extras$$1$$22$$x = 0;
    fprintf(stderr, "FAILED: %s\n", (const void *)"fclose failed");
    test_extras$$1$$22$$x = 1 / test_extras$$1$$22$$x;
    abort();
  }

  f2=fopen("cordtst2.tmp", "rb");
  if(f2 == ((struct _IO_FILE *)NULL))
  {
    signed int test_extras$$1$$23$$x = 0;
    fprintf(stderr, "FAILED: %s\n", (const void *)"Unable to open cordtst2.tmp");
    test_extras$$1$$23$$x = 1 / test_extras$$1$$23$$x;
    abort();
  }

  w=CORD_from_file(f2);
  unsigned long int return_value_CORD_len$26;
  return_value_CORD_len$26=CORD_len(w);
  unsigned long int return_value_CORD_len$27;
  return_value_CORD_len$27=CORD_len(test_extras$$1$$x);
  if(!(return_value_CORD_len$26 == return_value_CORD_len$27))
  {
    signed int test_extras$$1$$24$$x = 0;
    fprintf(stderr, "FAILED: %s\n", (const void *)"file length wrong");
    test_extras$$1$$24$$x = 1 / test_extras$$1$$24$$x;
    abort();
  }

  signed int return_value_CORD_cmp$28;
  return_value_CORD_cmp$28=CORD_cmp(w, test_extras$$1$$x);
  if(!(return_value_CORD_cmp$28 == 0))
  {
    signed int test_extras$$1$$25$$x = 0;
    fprintf(stderr, "FAILED: %s\n", (const void *)"file comparison wrong");
    test_extras$$1$$25$$x = 1 / test_extras$$1$$25$$x;
    abort();
  }

  const char *return_value_CORD_substr$29;
  return_value_CORD_substr$29=CORD_substr(w, (unsigned long int)(1000 * 36), (unsigned long int)36);
  signed int return_value_CORD_cmp$30;
  return_value_CORD_cmp$30=CORD_cmp(return_value_CORD_substr$29, y);
  if(!(return_value_CORD_cmp$30 == 0))
  {
    signed int test_extras$$1$$26$$x = 0;
    fprintf(stderr, "FAILED: %s\n", (const void *)"file substr wrong");
    test_extras$$1$$26$$x = 1 / test_extras$$1$$26$$x;
    abort();
  }

  signed int tmp_statement_expression$31;
  unsigned long int __s1_len;
  unsigned long int __s2_len;
  const char *return_value_CORD_substr$32;
  return_value_CORD_substr$32=CORD_substr(w, (unsigned long int)(1000 * 36), (unsigned long int)36);
  char *return_value_CORD_to_char_star$33;
  return_value_CORD_to_char_star$33=CORD_to_char_star(return_value_CORD_substr$32);
  signed int return_value___builtin_strcmp$34;
  return_value___builtin_strcmp$34=__builtin_strcmp(return_value_CORD_to_char_star$33, y);
  tmp_statement_expression$31 = return_value___builtin_strcmp$34;
  if(!(tmp_statement_expression$31 == 0))
  {
    signed int test_extras$$1$$28$$x = 0;
    fprintf(stderr, "FAILED: %s\n", (const void *)"char * file substr wrong");
    test_extras$$1$$28$$x = 1 / test_extras$$1$$28$$x;
    abort();
  }

  signed int tmp_statement_expression$35;
  unsigned long int test_extras$$1$$29$$__s1_len;
  unsigned long int test_extras$$1$$29$$__s2_len;
  const char *return_value_CORD_substr$36;
  return_value_CORD_substr$36=CORD_substr(w, (unsigned long int)(1000 * 36), (unsigned long int)2);
  signed int return_value___builtin_strcmp$37;
  return_value___builtin_strcmp$37=__builtin_strcmp(return_value_CORD_substr$36, "ab");
  tmp_statement_expression$35 = return_value___builtin_strcmp$37;
  if(!(tmp_statement_expression$35 == 0))
  {
    signed int test_extras$$1$$30$$x = 0;
    fprintf(stderr, "FAILED: %s\n", (const void *)"short file substr wrong");
    test_extras$$1$$30$$x = 1 / test_extras$$1$$30$$x;
    abort();
  }

  unsigned long int return_value_CORD_str$38;
  return_value_CORD_str$38=CORD_str(test_extras$$1$$x, (unsigned long int)1, "9a");
  if(!(return_value_CORD_str$38 == 35ul))
  {
    signed int test_extras$$1$$31$$x = 0;
    fprintf(stderr, "FAILED: %s\n", (const void *)"CORD_str failed 1");
    test_extras$$1$$31$$x = 1 / test_extras$$1$$31$$x;
    abort();
  }

  unsigned long int return_value_CORD_str$39;
  return_value_CORD_str$39=CORD_str(test_extras$$1$$x, (unsigned long int)0, "9abcdefghijk");
  if(!(return_value_CORD_str$39 == 35ul))
  {
    signed int test_extras$$1$$32$$x = 0;
    fprintf(stderr, "FAILED: %s\n", (const void *)"CORD_str failed 2");
    test_extras$$1$$32$$x = 1 / test_extras$$1$$32$$x;
    abort();
  }

  unsigned long int return_value_CORD_str$40;
  return_value_CORD_str$40=CORD_str(test_extras$$1$$x, (unsigned long int)0, "9abcdefghijx");
  if(!(return_value_CORD_str$40 == 18446744073709551615ul))
  {
    signed int test_extras$$1$$33$$x = 0;
    fprintf(stderr, "FAILED: %s\n", (const void *)"CORD_str failed 3");
    test_extras$$1$$33$$x = 1 / test_extras$$1$$33$$x;
    abort();
  }

  unsigned long int return_value_CORD_str$41;
  return_value_CORD_str$41=CORD_str(test_extras$$1$$x, (unsigned long int)0, "9>");
  if(!(return_value_CORD_str$41 == 18446744073709551615ul))
  {
    signed int test_extras$$1$$34$$x = 0;
    fprintf(stderr, "FAILED: %s\n", (const void *)"CORD_str failed 4");
    test_extras$$1$$34$$x = 1 / test_extras$$1$$34$$x;
    abort();
  }

  *((const char * volatile *)&w) = ((const char *)NULL);
  *((const char * volatile *)&z) = ((const char *)NULL);
  GC_gcollect();
  GC_invoke_finalizers();
  signed int return_value_remove$42;
  return_value_remove$42=remove("cordtst1.tmp");
  if(!(return_value_remove$42 == 0))
    fprintf(stderr, "WARNING: remove(FNAME1) failed\n");

  signed int return_value_remove$43;
  return_value_remove$43=remove("cordtst2.tmp");
  if(!(return_value_remove$43 == 0))
    fprintf(stderr, "WARNING: remove(FNAME2) failed\n");

}

// test_fn
// file cord/tests/cordtest.c line 28
signed int test_fn(char c, void *client_data)
{
  if(!(client_data == (void *)13))
  {
    signed int test_fn$$1$$1$$x = 0;
    fprintf(stderr, "FAILED: %s\n", (const void *)"bad client data");
    test_fn$$1$$1$$x = 1 / test_fn$$1$$1$$x;
    abort();
  }

  if(!(count >= 1))
  {
    if((1 & count) == 0)
    {
      if(!((signed int)c == 98))
      {
        signed int test_fn$$1$$2$$1$$1$$x = 0;
        fprintf(stderr, "FAILED: %s\n", (const void *)"bad char");
        test_fn$$1$$2$$1$$1$$x = 1 / test_fn$$1$$2$$1$$1$$x;
        abort();
      }

    }

    else
      if(!((signed int)c == 97))
      {
        signed int x = 0;
        fprintf(stderr, "FAILED: %s\n", (const void *)"bad char");
        x = 1 / x;
        abort();
      }

    count = count + 1;
    return 0;
  }

  else
  {
    if(!((signed int)c == 99))
    {
      signed int test_fn$$1$$3$$1$$x = 0;
      fprintf(stderr, "FAILED: %s\n", (const void *)"bad char");
      test_fn$$1$$3$$1$$x = 1 / test_fn$$1$$3$$1$$x;
      abort();
    }

    count = count + 1;
    return 1;
  }
}

// test_printf
// file cord/tests/cordtest.c line 207
void test_printf(void)
{
  const char *result;
  char result2[200l];
  signed long int l = (signed long int)-1;
  signed short int s = (signed short int)-1;
  const char *test_printf$$1$$x;
  signed int return_value_CORD_sprintf$1;
  return_value_CORD_sprintf$1=CORD_sprintf(&result, "%7.2f%ln", 3.14159F, &l);
  if(!(return_value_CORD_sprintf$1 == 7))
  {
    signed int test_printf$$1$$1$$x = 0;
    fprintf(stderr, "FAILED: %s\n", (const void *)"CORD_sprintf failed 1");
    test_printf$$1$$1$$x = 1 / test_printf$$1$$1$$x;
    abort();
  }

  signed int return_value_CORD_cmp$2;
  return_value_CORD_cmp$2=CORD_cmp(result, "   3.14");
  if(!(return_value_CORD_cmp$2 == 0))
  {
    signed int test_printf$$1$$2$$x = 0;
    fprintf(stderr, "FAILED: %s\n", (const void *)"CORD_sprintf goofed 1");
    test_printf$$1$$2$$x = 1 / test_printf$$1$$2$$x;
    abort();
  }

  if(!(l == 7l))
  {
    signed int test_printf$$1$$3$$x = 0;
    fprintf(stderr, "FAILED: %s\n", (const void *)"CORD_sprintf goofed 2");
    test_printf$$1$$3$$x = 1 / test_printf$$1$$3$$x;
    abort();
  }

  signed int return_value_CORD_sprintf$3;
  return_value_CORD_sprintf$3=CORD_sprintf(&result, "%-7.2s%hn%c%s", (const void *)"abcd", &s, 120, (const void *)"yz");
  if(!(return_value_CORD_sprintf$3 == 10))
  {
    signed int test_printf$$1$$4$$x = 0;
    fprintf(stderr, "FAILED: %s\n", (const void *)"CORD_sprintf failed 2");
    test_printf$$1$$4$$x = 1 / test_printf$$1$$4$$x;
    abort();
  }

  signed int return_value_CORD_cmp$4;
  return_value_CORD_cmp$4=CORD_cmp(result, "ab     xyz");
  if(!(return_value_CORD_cmp$4 == 0))
  {
    signed int test_printf$$1$$5$$x = 0;
    fprintf(stderr, "FAILED: %s\n", (const void *)"CORD_sprintf goofed 3");
    test_printf$$1$$5$$x = 1 / test_printf$$1$$5$$x;
    abort();
  }

  if(!((signed int)s == 7))
  {
    signed int x = 0;
    fprintf(stderr, "FAILED: %s\n", (const void *)"CORD_sprintf goofed 4");
    x = 1 / x;
    abort();
  }

  test_printf$$1$$x = "abcdefghij";
  test_printf$$1$$x=CORD_cat(test_printf$$1$$x, test_printf$$1$$x);
  test_printf$$1$$x=CORD_cat(test_printf$$1$$x, test_printf$$1$$x);
  test_printf$$1$$x=CORD_cat(test_printf$$1$$x, test_printf$$1$$x);
  signed int return_value_CORD_sprintf$5;
  return_value_CORD_sprintf$5=CORD_sprintf(&result, "->%-120.78r!\n", test_printf$$1$$x);
  if(!(return_value_CORD_sprintf$5 == 124))
  {
    signed int test_printf$$1$$7$$x = 0;
    fprintf(stderr, "FAILED: %s\n", (const void *)"CORD_sprintf failed 3");
    test_printf$$1$$7$$x = 1 / test_printf$$1$$7$$x;
    abort();
  }

  char *return_value_CORD_to_char_star$6;
  return_value_CORD_to_char_star$6=CORD_to_char_star(test_printf$$1$$x);
  snprintf(result2, sizeof(char [200l]) /*200ul*/ , "->%-120.78s!\n", return_value_CORD_to_char_star$6);
  result2[(signed long int)(sizeof(char [200l]) /*200ul*/  - (unsigned long int)1)] = (char)0;
  signed int return_value_CORD_cmp$7;
  return_value_CORD_cmp$7=CORD_cmp(result, result2);
  if(!(return_value_CORD_cmp$7 == 0))
  {
    signed int test_printf$$1$$8$$x = 0;
    fprintf(stderr, "FAILED: %s\n", (const void *)"CORD_sprintf goofed 5");
    test_printf$$1$$8$$x = 1 / test_printf$$1$$8$$x;
    abort();
  }

}

// total_stack_black_listed
// file blacklst.c line 277
static unsigned long int total_stack_black_listed(void)
{
  unsigned int i;
  unsigned long int total = (unsigned long int)0;
  i = (unsigned int)0;
  for( ; !((unsigned long int)i >= GC_n_heap_sects); i = i + 1u)
  {
    struct hblk *start = (struct hblk *)GC_arrays._heap_sects[(signed long int)i].hs_start;
    struct hblk *endp1 = start + (signed long int)(GC_arrays._heap_sects[(signed long int)i].hs_bytes / (unsigned long int)(1 << 12));
    unsigned long int return_value_GC_number_stack_black_listed$1;
    return_value_GC_number_stack_black_listed$1=GC_number_stack_black_listed(start, endp1);
    total = total + return_value_GC_number_stack_black_listed$1;
  }
  return total * (unsigned long int)(1 << 12);
}

// total_stack_black_listed$link1
// file blacklst.c line 277
static unsigned long int total_stack_black_listed$link1(void)
{
  unsigned int i$link1;
  unsigned long int total$link1 = (unsigned long int)0;
  i$link1 = (unsigned int)0;
  for( ; !((unsigned long int)i$link1 >= GC_n_heap_sects); i$link1 = i$link1 + 1u)
  {
    struct hblk *start$link1 = (struct hblk *)GC_arrays._heap_sects[(signed long int)i$link1].hs_start;
    struct hblk *endp1$link1 = start$link1 + (signed long int)(GC_arrays._heap_sects[(signed long int)i$link1].hs_bytes / (unsigned long int)(1 << 12));
    unsigned long int return_value_GC_number_stack_black_listed$1$link1;
    return_value_GC_number_stack_black_listed$1$link1=GC_number_stack_black_listed(start$link1, endp1$link1);
    total$link1 = total$link1 + return_value_GC_number_stack_black_listed$1$link1;
  }
  return total$link1 * (unsigned long int)(1 << 12);
}

