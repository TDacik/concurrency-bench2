// #anon_enum_OC_CS_UNSPECIFIED=0_OC_CS_ITU_REC_470M=1_OC_CS_ITU_REC_470BG=2_OC_CS_NSPACES=3
// file /usr/include/theora/theora.h line 164
enum anonymous_143 { OC_CS_UNSPECIFIED=0, OC_CS_ITU_REC_470M=1, OC_CS_ITU_REC_470BG=2, OC_CS_NSPACES=3 };

// #anon_enum_OC_PF_420=0_OC_PF_RSVD=1_OC_PF_422=2_OC_PF_444=3
// file /usr/include/theora/theora.h line 178
enum anonymous_144 { OC_PF_420=0, OC_PF_RSVD=1, OC_PF_422=2, OC_PF_444=3 };

// tag-#anon#ST[*{S8}_S8_'buf'||vU64'write_ptr'||vU64'read_ptr'||U64'size'||U64'size_mask'||S32'mlocked'||U32'_pad0'|]
// file /usr/include/jack/ringbuffer.h line 51
struct anonymous_85;

// tag-#anon#ST[*{S8}_S8_'defaultCCCs'||*{S8}_S8_'clientCmaps'||*{S8}_S8_'perVisualIntensityMaps'|]
// file /usr/include/X11/Xlibint.h line 171
struct anonymous_122;

// tag-#anon#ST[*{SYM#tag-#anon#ST[U32'width'||U32'height'||U32'frame_width'||U32'frame_height'||U32'offset_x'||U32'offset_y'||U32'fps_numerator'||U32'fps_denominator'||U32'aspect_numerator'||U32'aspect_denominator'||EN#anon_enum_OC_CS_UNSPECIFIED=0_OC_CS_ITU_REC_470M=1_OC_CS_ITU_REC_470BG=2_OC_CS_NSPACES=3#{U32}_U32_'colorspace'||S32'target_bitrate'||S32'quality'||S32'quick_p'||U8'version_major'||U8'version_minor'||U8'version_subminor'||U40'_pad0'||*{V}_V_'codec_setup'||S32'dropframes_p'||S32'keyframe_auto_p'||U32'keyframe_frequency'||U32'keyframe_frequency_force'||U32'keyframe_data_target_bitrate'||S32'keyframe_auto_threshold'||U32'keyframe_mindistance'||S32'noise_sensitivity'||S32'sharpness'||EN#anon_enum_OC_PF_420=0_OC_PF_RSVD=1_OC_PF_422=2_OC_PF_444=3#{U32}_U32_'pixelformat'|]#}_SYM#tag-#anon#ST[U32'width'||U32'height'||U32'frame_width'||U32'frame_height'||U32'offset_x'||U32'offset_y'||U32'fps_numerator'||U32'fps_denominator'||U32'aspect_numerator'||U32'aspect_denominator'||EN#anon_enum_OC_CS_UNSPECIFIED=0_OC_CS_ITU_REC_470M=1_OC_CS_ITU_REC_470BG=2_OC_CS_NSPACES=3#{U32}_U32_'colorspace'||S32'target_bitrate'||S32'quality'||S32'quick_p'||U8'version_major'||U8'version_minor'||U8'version_subminor'||U40'_pad0'||*{V}_V_'codec_setup'||S32'dropframes_p'||S32'keyframe_auto_p'||U32'keyframe_frequency'||U32'keyframe_frequency_force'||U32'keyframe_data_target_bitrate'||S32'keyframe_auto_threshold'||U32'keyframe_mindistance'||S32'noise_sensitivity'||S32'sharpness'||EN#anon_enum_OC_PF_420=0_OC_PF_RSVD=1_OC_PF_422=2_OC_PF_444=3#{U32}_U32_'pixelformat'|]#_'i'||S64'granulepos'||*{V}_V_'internal_encode'||*{V}_V_'internal_decode'|]
// file /usr/include/theora/theora.h line 247
struct anonymous_13;

// tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'||*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'||U64'root'||S32'width'||S32'height'||S32'mwidth'||S32'mheight'||S32'ndepths'||U32'_pad0'||*{SYM#tag-#anon#ST[S32'depth'||S32'nvisuals'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'||U64'visualid'||S32'class'||U32'_pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'||U64'visualid'||S32'class'||U32'_pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#_'visuals'|]#}_SYM#tag-#anon#ST[S32'depth'||S32'nvisuals'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'||U64'visualid'||S32'class'||U32'_pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'||U64'visualid'||S32'class'||U32'_pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#_'visuals'|]#_'depths'||S32'root_depth'||U32'_pad1'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'||U64'visualid'||S32'class'||U32'_pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'||U64'visualid'||S32'class'||U32'_pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#_'root_visual'||*{SYM#tag-_XGC#}_SYM#tag-_XGC#_'default_gc'||U64'cmap'||U64'white_pixel'||U64'black_pixel'||S32'max_maps'||S32'min_maps'||S32'backing_store'||S32'save_unders'||S64'root_input_mask'|]
// file /usr/include/X11/Xlib.h line 257
struct anonymous_93;

// tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'||*{SYM#tag-_XPrivate#}_SYM#tag-_XPrivate#_'private1'||S32'fd'||S32'private2'||S32'proto_major_version'||S32'proto_minor_version'||*{S8}_S8_'vendor'||U64'private3'||U64'private4'||U64'private5'||S32'private6'||U32'_pad0'||*{U64(*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_)->U64}_U64(*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_)->U64_'resource_alloc'||S32'byte_order'||S32'bitmap_unit'||S32'bitmap_pad'||S32'bitmap_bit_order'||S32'nformats'||U32'_pad1'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'||S32'depth'||S32'bits_per_pixel'||S32'scanline_pad'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'||S32'depth'||S32'bits_per_pixel'||S32'scanline_pad'||U32'_pad0'|]#_'pixmap_format'||S32'private8'||S32'release'||*{SYM#tag-_XPrivate#}_SYM#tag-_XPrivate#_'private9'||*{SYM#tag-_XPrivate#}_SYM#tag-_XPrivate#_'private10'||S32'qlen'||U32'_pad2'||U64'last_request_read'||U64'request'||*{S8}_S8_'private11'||*{S8}_S8_'private12'||*{S8}_S8_'private13'||*{S8}_S8_'private14'||U32'max_request_size'||U32'_pad3'||*{SYM#tag-_XrmHashBucketRec#}_SYM#tag-_XrmHashBucketRec#_'db'||*{S32(*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_)->S32}_S32(*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_)->S32_'private15'||*{S8}_S8_'display_name'||S32'default_screen'||S32'nscreens'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'||*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'||U64'root'||S32'width'||S32'height'||S32'mwidth'||S32'mheight'||S32'ndepths'||U32'_pad0'||*{SYM#tag-#anon#ST[S32'depth'||S32'nvisuals'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'||U64'visualid'||S32'class'||U32'_pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'||U64'visualid'||S32'class'||U32'_pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#_'visuals'|]#}_SYM#tag-#anon#ST[S32'depth'||S32'nvisuals'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'||U64'visualid'||S32'class'||U32'_pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'||U64'visualid'||S32'class'||U32'_pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#_'visuals'|]#_'depths'||S32'root_depth'||U32'_pad1'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'||U64'visualid'||S32'class'||U32'_pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'||U64'visualid'||S32'class'||U32'_pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#_'root_visual'||*{SYM#tag-_XGC#}_SYM#tag-_XGC#_'default_gc'||U64'cmap'||U64'white_pixel'||U64'black_pixel'||S32'max_maps'||S32'min_maps'||S32'backing_store'||S32'save_unders'||S64'root_input_mask'|]#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'||*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'||U64'root'||S32'width'||S32'height'||S32'mwidth'||S32'mheight'||S32'ndepths'||U32'_pad0'||*{SYM#tag-#anon#ST[S32'depth'||S32'nvisuals'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'||U64'visualid'||S32'class'||U32'_pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'||U64'visualid'||S32'class'||U32'_pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#_'visuals'|]#}_SYM#tag-#anon#ST[S32'depth'||S32'nvisuals'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'||U64'visualid'||S32'class'||U32'_pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'||U64'visualid'||S32'class'||U32'_pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#_'visuals'|]#_'depths'||S32'root_depth'||U32'_pad1'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'||U64'visualid'||S32'class'||U32'_pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'||U64'visualid'||S32'class'||U32'_pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#_'root_visual'||*{SYM#tag-_XGC#}_SYM#tag-_XGC#_'default_gc'||U64'cmap'||U64'white_pixel'||U64'black_pixel'||S32'max_maps'||S32'min_maps'||S32'backing_store'||S32'save_unders'||S64'root_input_mask'|]#_'screens'||U64'motion_buffer'||U64'private16'||S32'min_keycode'||S32'max_keycode'||*{S8}_S8_'private17'||*{S8}_S8_'private18'||S32'private19'||U32'_pad4'||*{S8}_S8_'xdefaults'|]
// file /usr/include/X11/Xlib.h line 493
struct anonymous_146;

// tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'||S32'depth'||S32'bits_per_pixel'||S32'scanline_pad'||U32'_pad0'|]
// file /usr/include/X11/Xlib.h line 280
struct anonymous_90;

// tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'||U64'fid'||U32'direction'||U32'min_char_or_byte2'||U32'max_char_or_byte2'||U32'min_byte1'||U32'max_byte1'||S32'all_chars_exist'||U32'default_char'||S32'n_properties'||*{SYM#tag-#anon#ST[U64'name'||U64'card32'|]#}_SYM#tag-#anon#ST[U64'name'||U64'card32'|]#_'properties'||SYM#tag-#anon#ST[S16'lbearing'||S16'rbearing'||S16'width'||S16'ascent'||S16'descent'||U16'attributes'|]#'min_bounds'||SYM#tag-#anon#ST[S16'lbearing'||S16'rbearing'||S16'width'||S16'ascent'||S16'descent'||U16'attributes'|]#'max_bounds'||*{SYM#tag-#anon#ST[S16'lbearing'||S16'rbearing'||S16'width'||S16'ascent'||S16'descent'||U16'attributes'|]#}_SYM#tag-#anon#ST[S16'lbearing'||S16'rbearing'||S16'width'||S16'ascent'||S16'descent'||U16'attributes'|]#_'per_char'||S32'ascent'||S32'descent'|]
// file /usr/include/X11/Xlib.h line 1035
struct anonymous_92;

// tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'||U64'visualid'||S32'class'||U32'_pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]
// file /usr/include/X11/Xlib.h line 227
struct anonymous_21;

// tag-#anon#ST[*{U8}_U8_'body_data'||S64'body_storage'||S64'body_fill'||S64'body_returned'||*{S32}_S32_'lacing_vals'||*{S64}_S64_'granule_vals'||S64'lacing_storage'||S64'lacing_fill'||S64'lacing_packet'||S64'lacing_returned'||ARR282{U8}_U8_'header'||U16'_pad0'||S32'header_fill'||S32'e_o_s'||S32'b_o_s'||S64'serialno'||S64'pageno'||S64'packetno'||S64'granulepos'|]
// file /usr/include/ogg/ogg.h line 53
struct anonymous_14;

// tag-#anon#ST[*{U8}_U8_'header'||S64'header_len'||*{U8}_U8_'body'||S64'body_len'|]
// file /usr/include/ogg/ogg.h line 43
struct anonymous_15;

// tag-#anon#ST[*{U8}_U8_'packet'||S64'bytes'||S64'b_o_s'||S64'e_o_s'||S64'granulepos'||S64'packetno'|]
// file /usr/include/ogg/ogg.h line 90
struct anonymous_126;

// tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 121
struct anonymous_9;

// tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 107
struct anonymous_7;

// tag-#anon#ST[ARR16{U64}_U64_'__val'|]
// file /usr/include/x86_64-linux-gnu/bits/sigset.h line 27
struct anonymous_2;

// tag-#anon#ST[S16'lbearing'||S16'rbearing'||S16'width'||S16'ascent'||S16'descent'||U16'attributes'|]
// file /usr/include/X11/Xlib.h line 1017
struct anonymous_130;

// tag-#anon#ST[S16'x'||S16'y'||U16'width'||U16'height'|]
// file /usr/include/X11/Xlib.h line 430
struct anonymous_17;

// tag-#anon#ST[S16'x'||S16'y'||U16'width'||U16'height'||U16'xhot'||U16'yhot'||U32'_pad0'||U64'cursor_serial'||*{U64}_U64_'pixels'||U64'atom'||*{cS8}_cS8_'name'|]
// file /usr/include/X11/extensions/Xfixes.h line 86
struct anonymous_31;

// tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}_V_'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 141
struct anonymous_131;

// tag-#anon#ST[S32'depth'||S32'nvisuals'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'||U64'visualid'||S32'class'||U32'_pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'||U64'visualid'||S32'class'||U32'_pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#_'visuals'|]
// file /usr/include/X11/Xlib.h line 243
struct anonymous_142;

// tag-#anon#ST[S32'extension'||S32'major_opcode'||S32'first_event'||S32'first_error'|]
// file /usr/include/X11/Xlib.h line 160
struct anonymous_91;

// tag-#anon#ST[S32'function'||U32'_pad0'||U64'plane_mask'||U64'foreground'||U64'background'||S32'line_width'||S32'line_style'||S32'cap_style'||S32'join_style'||S32'fill_style'||S32'fill_rule'||S32'arc_mode'||U32'_pad1'||U64'tile'||U64'stipple'||S32'ts_x_origin'||S32'ts_y_origin'||U64'font'||S32'subwindow_mode'||S32'graphics_exposures'||S32'clip_x_origin'||S32'clip_y_origin'||U64'clip_mask'||S32'dash_offset'||S8'dashes'||U24'_pad2'|]
// file /usr/include/X11/Xlib.h line 181
struct anonymous_16;

// tag-#anon#ST[S32'max_keypermod'||U32'_pad0'||*{U8}_U8_'modifiermap'|]
// file /usr/include/X11/Xlib.h line 475
struct anonymous_95;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 74
struct anonymous_3;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 97
struct anonymous_6;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 89
struct anonymous_5;

// tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'_pad0'||SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 62
struct anonymous_11;

// tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 81
struct anonymous_4;

// tag-#anon#ST[S32'type'||U32'_pad0'||*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'||U64'resourceid'||U64'serial'||U8'error_code'||U8'request_code'||U8'minor_code'||U40'_pad1'|]
// file /usr/include/X11/Xlib.h line 924
struct anonymous_118;

// tag-#anon#ST[S32'type'||U32'_pad0'||U64'serial'||S32'send_event'||U32'_pad1'||*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'||S32'extension'||S32'evtype'|]
// file /usr/include/X11/Xlib.h line 948
struct anonymous_124;

// tag-#anon#ST[S32'type'||U32'_pad0'||U64'serial'||S32'send_event'||U32'_pad1'||*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'||S32'extension'||S32'evtype'||U32'cookie'||U32'_pad2'||*{V}_V_'data'|]
// file /usr/include/X11/Xlib.h line 958
struct anonymous_125;

// tag-#anon#ST[S32'type'||U32'_pad0'||U64'serial'||S32'send_event'||U32'_pad1'||*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'||U64'drawable'||S32'major_code'||S32'minor_code'|]
// file /usr/include/X11/Xlib.h line 686
struct anonymous_99;

// tag-#anon#ST[S32'type'||U32'_pad0'||U64'serial'||S32'send_event'||U32'_pad1'||*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'||U64'drawable'||S32'x'||S32'y'||S32'width'||S32'height'||S32'count'||S32'major_code'||S32'minor_code'||U32'_pad2'|]
// file /usr/include/X11/Xlib.h line 673
struct anonymous_98;

// tag-#anon#ST[S32'type'||U32'_pad0'||U64'serial'||S32'send_event'||U32'_pad1'||*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'||U64'drawable'||U64'damage'||S32'level'||S32'more'||U64'timestamp'||SYM#tag-#anon#ST[S16'x'||S16'y'||U16'width'||U16'height'|]#'area'||SYM#tag-#anon#ST[S16'x'||S16'y'||U16'width'||U16'height'|]#'geometry'|]
// file /usr/include/X11/extensions/Xdamage.h line 34
struct anonymous_1;

// tag-#anon#ST[S32'type'||U32'_pad0'||U64'serial'||S32'send_event'||U32'_pad1'||*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'||U64'event'||U64'window'|]
// file /usr/include/X11/Xlib.h line 718
struct anonymous_102;

// tag-#anon#ST[S32'type'||U32'_pad0'||U64'serial'||S32'send_event'||U32'_pad1'||*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'||U64'event'||U64'window'||S32'from_configure'||U32'_pad2'|]
// file /usr/include/X11/Xlib.h line 727
struct anonymous_103;

// tag-#anon#ST[S32'type'||U32'_pad0'||U64'serial'||S32'send_event'||U32'_pad1'||*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'||U64'event'||U64'window'||S32'override_redirect'||U32'_pad2'|]
// file /usr/include/X11/Xlib.h line 737
struct anonymous_104;

// tag-#anon#ST[S32'type'||U32'_pad0'||U64'serial'||S32'send_event'||U32'_pad1'||*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'||U64'event'||U64'window'||S32'place'||U32'_pad2'|]
// file /usr/include/X11/Xlib.h line 816
struct anonymous_111;

// tag-#anon#ST[S32'type'||U32'_pad0'||U64'serial'||S32'send_event'||U32'_pad1'||*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'||U64'event'||U64'window'||S32'x'||S32'y'|]
// file /usr/include/X11/Xlib.h line 782
struct anonymous_108;

// tag-#anon#ST[S32'type'||U32'_pad0'||U64'serial'||S32'send_event'||U32'_pad1'||*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'||U64'event'||U64'window'||S32'x'||S32'y'||S32'width'||S32'height'||S32'border_width'||U32'_pad2'||U64'above'||S32'override_redirect'||U32'_pad3'|]
// file /usr/include/X11/Xlib.h line 768
struct anonymous_107;

// tag-#anon#ST[S32'type'||U32'_pad0'||U64'serial'||S32'send_event'||U32'_pad1'||*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'||U64'event'||U64'window'||U64'parent'||S32'x'||S32'y'||S32'override_redirect'||U32'_pad2'|]
// file /usr/include/X11/Xlib.h line 756
struct anonymous_106;

// tag-#anon#ST[S32'type'||U32'_pad0'||U64'serial'||S32'send_event'||U32'_pad1'||*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'||U64'owner'||U64'requestor'||U64'selection'||U64'target'||U64'property'||U64'time'|]
// file /usr/include/X11/Xlib.h line 857
struct anonymous_115;

// tag-#anon#ST[S32'type'||U32'_pad0'||U64'serial'||S32'send_event'||U32'_pad1'||*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'||U64'parent'||U64'window'|]
// file /usr/include/X11/Xlib.h line 747
struct anonymous_105;

// tag-#anon#ST[S32'type'||U32'_pad0'||U64'serial'||S32'send_event'||U32'_pad1'||*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'||U64'parent'||U64'window'||S32'place'||U32'_pad2'|]
// file /usr/include/X11/Xlib.h line 826
struct anonymous_112;

// tag-#anon#ST[S32'type'||U32'_pad0'||U64'serial'||S32'send_event'||U32'_pad1'||*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'||U64'parent'||U64'window'||S32'x'||S32'y'||S32'width'||S32'height'||S32'border_width'||S32'override_redirect'|]
// file /usr/include/X11/Xlib.h line 705
struct anonymous_101;

// tag-#anon#ST[S32'type'||U32'_pad0'||U64'serial'||S32'send_event'||U32'_pad1'||*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'||U64'parent'||U64'window'||S32'x'||S32'y'||S32'width'||S32'height'||S32'border_width'||U32'_pad2'||U64'above'||S32'detail'||U32'_pad3'||U64'value_mask'|]
// file /usr/include/X11/Xlib.h line 801
struct anonymous_110;

// tag-#anon#ST[S32'type'||U32'_pad0'||U64'serial'||S32'send_event'||U32'_pad1'||*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'||U64'requestor'||U64'selection'||U64'target'||U64'property'||U64'time'|]
// file /usr/include/X11/Xlib.h line 870
struct anonymous_116;

// tag-#anon#ST[S32'type'||U32'_pad0'||U64'serial'||S32'send_event'||U32'_pad1'||*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'||U64'window'|]
// file /usr/include/X11/Xlib.h line 934
struct anonymous_94;

// tag-#anon#ST[S32'type'||U32'_pad0'||U64'serial'||S32'send_event'||U32'_pad1'||*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'||U64'window'||ARR32{S8}_S8_'key_vector'|]
// file /usr/include/X11/Xlib.h line 653
struct anonymous_123;

// tag-#anon#ST[S32'type'||U32'_pad0'||U64'serial'||S32'send_event'||U32'_pad1'||*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'||U64'window'||S32'mode'||S32'detail'|]
// file /usr/include/X11/Xlib.h line 634
struct anonymous_96;

// tag-#anon#ST[S32'type'||U32'_pad0'||U64'serial'||S32'send_event'||U32'_pad1'||*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'||U64'window'||S32'request'||S32'first_keycode'||S32'count'||U32'_pad2'|]
// file /usr/include/X11/Xlib.h line 912
struct anonymous_120;

// tag-#anon#ST[S32'type'||U32'_pad0'||U64'serial'||S32'send_event'||U32'_pad1'||*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'||U64'window'||S32'state'||U32'_pad2'|]
// file /usr/include/X11/Xlib.h line 696
struct anonymous_100;

// tag-#anon#ST[S32'type'||U32'_pad0'||U64'serial'||S32'send_event'||U32'_pad1'||*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'||U64'window'||S32'width'||S32'height'|]
// file /usr/include/X11/Xlib.h line 792
struct anonymous_109;

// tag-#anon#ST[S32'type'||U32'_pad0'||U64'serial'||S32'send_event'||U32'_pad1'||*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'||U64'window'||S32'x'||S32'y'||S32'width'||S32'height'||S32'count'||U32'_pad2'|]
// file /usr/include/X11/Xlib.h line 662
struct anonymous_97;

// tag-#anon#ST[S32'type'||U32'_pad0'||U64'serial'||S32'send_event'||U32'_pad1'||*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'||U64'window'||U64'atom'||U64'time'||S32'state'||U32'_pad2'|]
// file /usr/include/X11/Xlib.h line 836
struct anonymous_113;

// tag-#anon#ST[S32'type'||U32'_pad0'||U64'serial'||S32'send_event'||U32'_pad1'||*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'||U64'window'||U64'colormap'||S32'new'||S32'state'|]
// file /usr/include/X11/Xlib.h line 882
struct anonymous_117;

// tag-#anon#ST[S32'type'||U32'_pad0'||U64'serial'||S32'send_event'||U32'_pad1'||*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'||U64'window'||U64'message_type'||S32'format'||U32'_pad2'||SYM#tag-#anon#UN[ARR20{S8}_S8_'b'||ARR10{S16}_S16_'s'||ARR5{S64}_S64_'l'|]#'data'|]
// file /usr/include/X11/Xlib.h line 897
struct anonymous_119;

// tag-#anon#ST[S32'type'||U32'_pad0'||U64'serial'||S32'send_event'||U32'_pad1'||*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'||U64'window'||U64'root'||U64'subwindow'||U64'time'||S32'x'||S32'y'||S32'x_root'||S32'y_root'||S32'mode'||S32'detail'||S32'same_screen'||S32'focus'||U32'state'||U32'_pad2'|]
// file /usr/include/X11/Xlib.h line 610
struct anonymous_89;

// tag-#anon#ST[S32'type'||U32'_pad0'||U64'serial'||S32'send_event'||U32'_pad1'||*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'||U64'window'||U64'root'||U64'subwindow'||U64'time'||S32'x'||S32'y'||S32'x_root'||S32'y_root'||U32'state'||S8'is_hint'||U24'_pad2'||S32'same_screen'||U32'_pad3'|]
// file /usr/include/X11/Xlib.h line 593
struct anonymous_88;

// tag-#anon#ST[S32'type'||U32'_pad0'||U64'serial'||S32'send_event'||U32'_pad1'||*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'||U64'window'||U64'root'||U64'subwindow'||U64'time'||S32'x'||S32'y'||S32'x_root'||S32'y_root'||U32'state'||U32'button'||S32'same_screen'||U32'_pad2'|]
// file /usr/include/X11/Xlib.h line 575
struct anonymous_87;

// tag-#anon#ST[S32'type'||U32'_pad0'||U64'serial'||S32'send_event'||U32'_pad1'||*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'||U64'window'||U64'root'||U64'subwindow'||U64'time'||S32'x'||S32'y'||S32'x_root'||S32'y_root'||U32'state'||U32'keycode'||S32'same_screen'||U32'_pad2'|]
// file /usr/include/X11/Xlib.h line 557
struct anonymous_0;

// tag-#anon#ST[S32'type'||U32'_pad0'||U64'serial'||S32'send_event'||U32'_pad1'||*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'||U64'window'||U64'selection'||U64'time'|]
// file /usr/include/X11/Xlib.h line 847
struct anonymous_114;

// tag-#anon#ST[S32'x'||S32'y'||S32'width'||S32'height'||S32'border_width'||S32'depth'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'||U64'visualid'||S32'class'||U32'_pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'||U64'visualid'||S32'class'||U32'_pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#_'visual'||U64'root'||S32'class'||S32'bit_gravity'||S32'win_gravity'||S32'backing_store'||U64'backing_planes'||U64'backing_pixel'||S32'save_under'||U32'_pad0'||U64'colormap'||S32'map_installed'||S32'map_state'||S64'all_event_masks'||S64'your_event_mask'||S64'do_not_propagate_mask'||S32'override_redirect'||U32'_pad1'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'||*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'||U64'root'||S32'width'||S32'height'||S32'mwidth'||S32'mheight'||S32'ndepths'||U32'_pad0'||*{SYM#tag-#anon#ST[S32'depth'||S32'nvisuals'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'||U64'visualid'||S32'class'||U32'_pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'||U64'visualid'||S32'class'||U32'_pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#_'visuals'|]#}_SYM#tag-#anon#ST[S32'depth'||S32'nvisuals'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'||U64'visualid'||S32'class'||U32'_pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'||U64'visualid'||S32'class'||U32'_pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#_'visuals'|]#_'depths'||S32'root_depth'||U32'_pad1'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'||U64'visualid'||S32'class'||U32'_pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'||U64'visualid'||S32'class'||U32'_pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#_'root_visual'||*{SYM#tag-_XGC#}_SYM#tag-_XGC#_'default_gc'||U64'cmap'||U64'white_pixel'||U64'black_pixel'||S32'max_maps'||S32'min_maps'||S32'backing_store'||S32'save_unders'||S64'root_input_mask'|]#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'||*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'||U64'root'||S32'width'||S32'height'||S32'mwidth'||S32'mheight'||S32'ndepths'||U32'_pad0'||*{SYM#tag-#anon#ST[S32'depth'||S32'nvisuals'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'||U64'visualid'||S32'class'||U32'_pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'||U64'visualid'||S32'class'||U32'_pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#_'visuals'|]#}_SYM#tag-#anon#ST[S32'depth'||S32'nvisuals'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'||U64'visualid'||S32'class'||U32'_pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'||U64'visualid'||S32'class'||U32'_pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#_'visuals'|]#_'depths'||S32'root_depth'||U32'_pad1'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'||U64'visualid'||S32'class'||U32'_pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'||U64'visualid'||S32'class'||U32'_pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#_'root_visual'||*{SYM#tag-_XGC#}_SYM#tag-_XGC#_'default_gc'||U64'cmap'||U64'white_pixel'||U64'black_pixel'||S32'max_maps'||S32'min_maps'||S32'backing_store'||S32'save_unders'||S64'root_input_mask'|]#_'screen'|]
// file /usr/include/X11/Xlib.h line 308
struct anonymous;

// tag-#anon#ST[S32'y_width'||S32'y_height'||S32'y_stride'||S32'uv_width'||S32'uv_height'||S32'uv_stride'||*{U8}_U8_'y'||*{U8}_U8_'u'||*{U8}_U8_'v'|]
// file /usr/include/theora/theora.h line 147
struct anonymous_45;

// tag-#anon#ST[S64'endbyte'||S32'endbit'||U32'_pad0'||*{U8}_U8_'buffer'||*{U8}_U8_'ptr'||S64'storage'|]
// file /usr/include/ogg/ogg.h line 32
struct anonymous_145;

// tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 114
struct anonymous_8;

// tag-#anon#ST[U16'version_major'||U16'version_minor'||U32'_pad0'||S64'ptime_n'||S64'ptime_d'||S64'btime_n'||S64'btime_d'||ARR20{U8}_U8_'UTC'||U32'_pad1'|]
// file skeleton.h line 25
struct anonymous_140;

// tag-#anon#ST[U32'pad00'||U32'drawable'||U16'minorEvent'||U8'majorEvent'||U8'bpad'|]
// file /usr/include/X11/Xproto.h line 1045
struct anonymous_64;

// tag-#anon#ST[U32'pad00'||U32'drawable'||U16'x'||U16'y'||U16'width'||U16'height'||U16'minorEvent'||U16'count'||U8'majorEvent'||U8'pad1'||U8'pad2'||U8'pad3'|]
// file /usr/include/X11/Xproto.h line 1036
struct anonymous_63;

// tag-#anon#ST[U32'pad00'||U32'event'||U32'window'|]
// file /usr/include/X11/Xproto.h line 1074
struct anonymous_67;

// tag-#anon#ST[U32'pad00'||U32'event'||U32'window'||S16'x'||S16'y'||U32'pad1'||U32'pad2'||U32'pad3'||U32'pad4'|]
// file /usr/include/X11/Xproto.h line 1117
struct anonymous_74;

// tag-#anon#ST[U32'pad00'||U32'event'||U32'window'||U32'aboveSibling'||S16'x'||S16'y'||U16'width'||U16'height'||U16'borderWidth'||U8'override'||U8'bpad'|]
// file /usr/include/X11/Xproto.h line 1101
struct anonymous_72;

// tag-#anon#ST[U32'pad00'||U32'event'||U32'window'||U32'parent'||S16'x'||S16'y'||U8'override'||U8'pad1'||U8'pad2'||U8'pad3'|]
// file /usr/include/X11/Xproto.h line 1094
struct anonymous_71;

// tag-#anon#ST[U32'pad00'||U32'event'||U32'window'||U32'parent'||U8'place'||U8'pad1'||U8'pad2'||U8'pad3'|]
// file /usr/include/X11/Xproto.h line 1128
struct anonymous_76;

// tag-#anon#ST[U32'pad00'||U32'event'||U32'window'||U8'fromConfigure'||U8'pad1'||U8'pad2'||U8'pad3'|]
// file /usr/include/X11/Xproto.h line 1078
struct anonymous_68;

// tag-#anon#ST[U32'pad00'||U32'event'||U32'window'||U8'override'||U8'pad1'||U8'pad2'||U8'pad3'|]
// file /usr/include/X11/Xproto.h line 1084
struct anonymous_69;

// tag-#anon#ST[U32'pad00'||U32'parent'||U32'window'|]
// file /usr/include/X11/Xproto.h line 1090
struct anonymous_70;

// tag-#anon#ST[U32'pad00'||U32'parent'||U32'window'||S16'x'||S16'y'||U16'width'||U16'height'||U16'borderWidth'||U8'override'||U8'bpad'|]
// file /usr/include/X11/Xproto.h line 1058
struct anonymous_66;

// tag-#anon#ST[U32'pad00'||U32'parent'||U32'window'||U32'sibling'||S16'x'||S16'y'||U16'width'||U16'height'||U16'borderWidth'||U16'valueMask'||U32'pad1'|]
// file /usr/include/X11/Xproto.h line 1109
struct anonymous_73;

// tag-#anon#ST[U32'pad00'||U32'time'||U32'owner'||U32'requestor'||U32'selection'||U32'target'||U32'property'|]
// file /usr/include/X11/Xproto.h line 1151
struct anonymous_79;

// tag-#anon#ST[U32'pad00'||U32'time'||U32'requestor'||U32'selection'||U32'target'||U32'property'|]
// file /usr/include/X11/Xproto.h line 1157
struct anonymous_80;

// tag-#anon#ST[U32'pad00'||U32'time'||U32'root'||U32'event'||U32'child'||S16'rootX'||S16'rootY'||S16'eventX'||S16'eventY'||U16'state'||U8'mode'||U8'flags'|]
// file /usr/include/X11/Xproto.h line 1012
struct anonymous_60;

// tag-#anon#ST[U32'pad00'||U32'time'||U32'root'||U32'event'||U32'child'||S16'rootX'||S16'rootY'||S16'eventX'||S16'eventY'||U16'state'||U8'sameScreen'||U8'pad1'|]
// file /usr/include/X11/Xproto.h line 1003
struct anonymous_59;

// tag-#anon#ST[U32'pad00'||U32'time'||U32'window'||U32'atom'|]
// file /usr/include/X11/Xproto.h line 1145
struct anonymous_78;

// tag-#anon#ST[U32'pad00'||U32'window'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[U32'type'||S32'longs0'||S32'longs1'||S32'longs2'||S32'longs3'||S32'longs4'|]#'l'||SYM#tag-#anon#ST[U32'type'||S16'shorts0'||S16'shorts1'||S16'shorts2'||S16'shorts3'||S16'shorts4'||S16'shorts5'||S16'shorts6'||S16'shorts7'||S16'shorts8'||S16'shorts9'|]#'s'||SYM#tag-#anon#ST[U32'type'||ARR20{S8}_S8_'bytes'|]#'b'|]#'u'|]
// file /usr/include/X11/Xproto.h line 1182
struct anonymous_84;

// tag-#anon#ST[U32'pad00'||U32'window'||U16'width'||U16'height'|]
// file /usr/include/X11/Xproto.h line 1123
struct anonymous_75;

// tag-#anon#ST[U32'pad00'||U32'window'||U16'x'||U16'y'||U16'width'||U16'height'||U16'count'||U16'pad2'|]
// file /usr/include/X11/Xproto.h line 1029
struct anonymous_62;

// tag-#anon#ST[U32'pad00'||U32'window'||U32'atom'||U32'time'||U8'state'||U8'pad1'||U16'pad2'|]
// file /usr/include/X11/Xproto.h line 1136
struct anonymous_77;

// tag-#anon#ST[U32'pad00'||U32'window'||U32'colormap'||U8'new'||U8'state'||U8'pad1'||U8'pad2'|]
// file /usr/include/X11/Xproto.h line 1163
struct anonymous_81;

// tag-#anon#ST[U32'pad00'||U32'window'||U8'mode'||U8'pad1'||U8'pad2'||U8'pad3'|]
// file /usr/include/X11/Xproto.h line 1023
struct anonymous_61;

// tag-#anon#ST[U32'pad00'||U32'window'||U8'state'||U8'pad1'||U8'pad2'||U8'pad3'|]
// file /usr/include/X11/Xproto.h line 1052
struct anonymous_65;

// tag-#anon#ST[U32'pad00'||U8'request'||U8'firstKeyCode'||U8'count'||U8'pad1'|]
// file /usr/include/X11/Xproto.h line 1175
struct anonymous_82;

// tag-#anon#ST[U32'serial_no'||U32'nr_header_packet'||S64'granule_rate_n'||S64'granule_rate_d'||S64'start_granule'||U32'preroll'||U8'granule_shift'||U24'_pad0'||*{S8}_S8_'message_header_fields'||U32'current_header_size'||U32'_pad1'|]
// file skeleton.h line 39
struct anonymous_139;

// tag-#anon#ST[U32'type'||ARR20{S8}_S8_'bytes'|]
// file /usr/include/X11/Xproto.h line 1207
struct anonymous_137;

// tag-#anon#ST[U32'type'||S16'shorts0'||S16'shorts1'||S16'shorts2'||S16'shorts3'||S16'shorts4'||S16'shorts5'||S16'shorts6'||S16'shorts7'||S16'shorts8'||S16'shorts9'|]
// file /usr/include/X11/Xproto.h line 1194
struct anonymous_136;

// tag-#anon#ST[U32'type'||S32'longs0'||S32'longs1'||S32'longs2'||S32'longs3'||S32'longs4'|]
// file /usr/include/X11/Xproto.h line 1186
struct anonymous_135;

// tag-#anon#ST[U32'width'||U32'height'||U32'frame_width'||U32'frame_height'||U32'offset_x'||U32'offset_y'||U32'fps_numerator'||U32'fps_denominator'||U32'aspect_numerator'||U32'aspect_denominator'||EN#anon_enum_OC_CS_UNSPECIFIED=0_OC_CS_ITU_REC_470M=1_OC_CS_ITU_REC_470BG=2_OC_CS_NSPACES=3#{U32}_U32_'colorspace'||S32'target_bitrate'||S32'quality'||S32'quick_p'||U8'version_major'||U8'version_minor'||U8'version_subminor'||U40'_pad0'||*{V}_V_'codec_setup'||S32'dropframes_p'||S32'keyframe_auto_p'||U32'keyframe_frequency'||U32'keyframe_frequency_force'||U32'keyframe_data_target_bitrate'||S32'keyframe_auto_threshold'||U32'keyframe_mindistance'||S32'noise_sensitivity'||S32'sharpness'||EN#anon_enum_OC_PF_420=0_OC_PF_RSVD=1_OC_PF_422=2_OC_PF_444=3#{U32}_U32_'pixelformat'|]
// file /usr/include/theora/theora.h line 206
struct anonymous_127;

// tag-#anon#ST[U64'background_pixmap'||U64'background_pixel'||U64'border_pixmap'||U64'border_pixel'||S32'bit_gravity'||S32'win_gravity'||S32'backing_store'||U32'_pad0'||U64'backing_planes'||U64'backing_pixel'||S32'save_under'||U32'_pad1'||S64'event_mask'||S64'do_not_propagate_mask'||S32'override_redirect'||U32'_pad2'||U64'colormap'||U64'cursor'|]
// file /usr/include/X11/Xlib.h line 290
struct anonymous_19;

// tag-#anon#ST[U64'name'||U64'card32'|]
// file /usr/include/X11/Xlib.h line 1030
struct anonymous_129;

// tag-#anon#ST[U64'pixel'||U16'red'||U16'green'||U16'blue'||S8'flags'||S8'pad'|]
// file /usr/include/X11/Xlib.h line 410
struct anonymous_18;

// tag-#anon#ST[U64'shmseg'||S32'shmid'||U32'_pad0'||*{S8}_S8_'shmaddr'||S32'readOnly'||U32'_pad1'|]
// file /usr/include/X11/extensions/XShm.h line 50
struct anonymous_34;

// tag-#anon#ST[U8'reqType'||U8'format'||U16'length'||U32'drawable'||S16'x'||S16'y'||U16'width'||U16'height'||U32'planeMask'|]
// file /usr/include/X11/Xproto.h line 1739
struct anonymous_133;

// tag-#anon#ST[U8'type'||U8'data1'||U16'sequenceNumber'||U32'length'||U32'data00'||U32'data01'||U32'data02'||U32'data03'||U32'data04'||U32'data05'|]
// file /usr/include/X11/Xproto.h line 425
struct anonymous_20;

// tag-#anon#ST[U8'type'||U8'depth'||U16'sequenceNumber'||U32'length'||U32'root'||S16'x'||S16'y'||U16'width'||U16'height'||U16'borderWidth'||U16'pad1'||U32'pad2'||U32'pad3'|]
// file /usr/include/X11/Xproto.h line 466
struct anonymous_22;

// tag-#anon#ST[U8'type'||U8'depth'||U16'sequenceNumber'||U32'length'||U32'visual'||U32'pad3'||U32'pad4'||U32'pad5'||U32'pad6'||U32'pad7'|]
// file /usr/include/X11/Xproto.h line 713
struct anonymous_132;

// tag-#anon#ST[U8'type'||U8'detail'||U16'sequenceNumber'|]
// file /usr/include/X11/Xproto.h line 998
struct anonymous_58;

// tag-#anon#ST[U8'type'||U8'drawDirection'||U16'sequenceNumber'||U32'length'||S16'fontAscent'||S16'fontDescent'||S16'overallAscent'||S16'overallDescent'||S32'overallWidth'||S32'overallLeft'||S32'overallRight'||U32'pad'|]
// file /usr/include/X11/Xproto.h line 654
struct anonymous_36;

// tag-#anon#ST[U8'type'||U8'enabled'||U16'sequenceNumber'||U32'length'||U16'nHosts'||U16'pad1'||U32'pad3'||U32'pad4'||U32'pad5'||U32'pad6'||U32'pad7'|]
// file /usr/include/X11/Xproto.h line 954
struct anonymous_56;

// tag-#anon#ST[U8'type'||U8'errorCode'||U16'sequenceNumber'||U32'resourceID'||U16'minorCode'||U8'majorCode'||U8'pad1'||U32'pad3'||U32'pad4'||U32'pad5'||U32'pad6'||U32'pad7'|]
// file /usr/include/X11/Xproto.h line 976
struct anonymous_121;

// tag-#anon#ST[U8'type'||U8'format'||U16'sequenceNumber'||U32'length'||U32'propertyType'||U32'bytesAfter'||U32'nItems'||U32'pad1'||U32'pad2'||U32'pad3'|]
// file /usr/include/X11/Xproto.h line 520
struct anonymous_26;

// tag-#anon#ST[U8'type'||U8'keySymsPerKeyCode'||U16'sequenceNumber'||U32'length'||U32'pad2'||U32'pad3'||U32'pad4'||U32'pad5'||U32'pad6'||U32'pad7'|]
// file /usr/include/X11/Xproto.h line 887
struct anonymous_52;

// tag-#anon#ST[U8'type'||U8'nElts'||U16'sequenceNumber'||U32'length'||U32'pad2'||U32'pad3'||U32'pad4'||U32'pad5'||U32'pad6'||U32'pad7'|]
// file /usr/include/X11/Xproto.h line 874
struct anonymous_53;

// tag-#anon#ST[U8'type'||U8'nExtensions'||U16'sequenceNumber'||U32'length'||U32'pad2'||U32'pad3'||U32'pad4'||U32'pad5'||U32'pad6'||U32'pad7'|]
// file /usr/include/X11/Xproto.h line 845
struct anonymous_49;

// tag-#anon#ST[U8'type'||U8'numKeyPerModifier'||U16'sequenceNumber'||U32'length'||U32'pad1'||U32'pad2'||U32'pad3'||U32'pad4'||U32'pad5'||U32'pad6'|]
// file /usr/include/X11/Xproto.h line 900
struct anonymous_51;

// tag-#anon#ST[U8'type'||U8'pad1'||U16'sequenceNumber'||U32'length'||U16'accelNumerator'||U16'accelDenominator'||U16'threshold'||U16'pad2'||U32'pad3'||U32'pad4'||U32'pad5'||U32'pad6'|]
// file /usr/include/X11/Xproto.h line 925
struct anonymous_54;

// tag-#anon#ST[U8'type'||U8'pad1'||U16'sequenceNumber'||U32'length'||U16'exactRed'||U16'exactGreen'||U16'exactBlue'||U16'screenRed'||U16'screenGreen'||U16'screenBlue'||U32'pad3'||U32'pad4'||U32'pad5'|]
// file /usr/include/X11/Xproto.h line 804
struct anonymous_46;

// tag-#anon#ST[U8'type'||U8'pad1'||U16'sequenceNumber'||U32'length'||U16'nColormaps'||U16'pad2'||U32'pad3'||U32'pad4'||U32'pad5'||U32'pad6'||U32'pad7'|]
// file /usr/include/X11/Xproto.h line 726
struct anonymous_39;

// tag-#anon#ST[U8'type'||U8'pad1'||U16'sequenceNumber'||U32'length'||U16'nColors'||U16'pad2'||U32'pad3'||U32'pad4'||U32'pad5'||U32'pad6'||U32'pad7'|]
// file /usr/include/X11/Xproto.h line 790
struct anonymous_44;

// tag-#anon#ST[U8'type'||U8'pad1'||U16'sequenceNumber'||U32'length'||U16'nFonts'||U16'pad2'||U32'pad3'||U32'pad4'||U32'pad5'||U32'pad6'||U32'pad7'|]
// file /usr/include/X11/Xproto.h line 665
struct anonymous_37;

// tag-#anon#ST[U8'type'||U8'pad1'||U16'sequenceNumber'||U32'length'||U16'nPaths'||U16'pad2'||U32'pad3'||U32'pad4'||U32'pad5'||U32'pad6'||U32'pad7'|]
// file /usr/include/X11/Xproto.h line 699
struct anonymous_38;

// tag-#anon#ST[U8'type'||U8'pad1'||U16'sequenceNumber'||U32'length'||U16'nPixels'||U16'nMasks'||U32'pad3'||U32'pad4'||U32'pad5'||U32'pad6'||U32'pad7'|]
// file /usr/include/X11/Xproto.h line 765
struct anonymous_42;

// tag-#anon#ST[U8'type'||U8'pad1'||U16'sequenceNumber'||U32'length'||U16'nPixels'||U16'pad2'||U32'redMask'||U32'greenMask'||U32'blueMask'||U32'pad3'||U32'pad4'|]
// file /usr/include/X11/Xproto.h line 778
struct anonymous_43;

// tag-#anon#ST[U8'type'||U8'pad1'||U16'sequenceNumber'||U32'length'||U16'nProperties'||U16'pad2'||U32'pad3'||U32'pad4'||U32'pad5'||U32'pad6'||U32'pad7'|]
// file /usr/include/X11/Xproto.h line 533
struct anonymous_27;

// tag-#anon#ST[U8'type'||U8'pad1'||U16'sequenceNumber'||U32'length'||U16'nameLength'||U16'pad2'||U32'pad3'||U32'pad4'||U32'pad5'||U32'pad6'||U32'pad7'|]
// file /usr/include/X11/Xproto.h line 506
struct anonymous_25;

// tag-#anon#ST[U8'type'||U8'pad1'||U16'sequenceNumber'||U32'length'||U16'red'||U16'green'||U16'blue'||U16'pad2'||U32'pixel'||U32'pad3'||U32'pad4'||U32'pad5'|]
// file /usr/include/X11/Xproto.h line 740
struct anonymous_40;

// tag-#anon#ST[U8'type'||U8'pad1'||U16'sequenceNumber'||U32'length'||U16'timeout'||U16'interval'||U8'preferBlanking'||U8'allowExposures'||U16'pad2'||U32'pad3'||U32'pad4'||U32'pad5'||U32'pad6'|]
// file /usr/include/X11/Xproto.h line 939
struct anonymous_55;

// tag-#anon#ST[U8'type'||U8'pad1'||U16'sequenceNumber'||U32'length'||U16'width'||U16'height'||U32'pad3'||U32'pad4'||U32'pad5'||U32'pad6'||U32'pad7'|]
// file /usr/include/X11/Xproto.h line 816
struct anonymous_47;

// tag-#anon#ST[U8'type'||U8'pad1'||U16'sequenceNumber'||U32'length'||U32'atom'||U32'pad2'||U32'pad3'||U32'pad4'||U32'pad5'||U32'pad6'|]
// file /usr/include/X11/Xproto.h line 493
struct anonymous_24;

// tag-#anon#ST[U8'type'||U8'pad1'||U16'sequenceNumber'||U32'length'||U32'nEvents'||U32'pad2'||U32'pad3'||U32'pad4'||U32'pad5'||U32'pad6'|]
// file /usr/include/X11/Xproto.h line 587
struct anonymous_32;

// tag-#anon#ST[U8'type'||U8'pad1'||U16'sequenceNumber'||U32'length'||U32'owner'||U32'pad2'||U32'pad3'||U32'pad4'||U32'pad5'||U32'pad6'|]
// file /usr/include/X11/Xproto.h line 547
struct anonymous_28;

// tag-#anon#ST[U8'type'||U8'pad1'||U16'sequenceNumber'||U32'length'||U32'pixel'||U16'exactRed'||U16'exactGreen'||U16'exactBlue'||U16'screenRed'||U16'screenGreen'||U16'screenBlue'||U32'pad2'||U32'pad3'|]
// file /usr/include/X11/Xproto.h line 753
struct anonymous_41;

// tag-#anon#ST[U8'type'||U8'pad1'||U16'sequenceNumber'||U32'length'||U32'root'||U32'parent'||U16'nChildren'||U16'pad2'||U32'pad3'||U32'pad4'||U32'pad5'|]
// file /usr/include/X11/Xproto.h line 480
struct anonymous_23;

// tag-#anon#ST[U8'type'||U8'pad1'||U16'sequenceNumber'||U32'length'||U8'present'||U8'major_opcode'||U8'first_event'||U8'first_error'||U32'pad3'||U32'pad4'||U32'pad5'||U32'pad6'||U32'pad7'|]
// file /usr/include/X11/Xproto.h line 829
struct anonymous_48;

// tag-#anon#ST[U8'type'||U8'revertTo'||U16'sequenceNumber'||U32'length'||U32'focus'||U32'pad1'||U32'pad2'||U32'pad3'||U32'pad4'||U32'pad5'|]
// file /usr/include/X11/Xproto.h line 613
struct anonymous_35;

// tag-#anon#ST[U8'type'||U8'sameScreen'||U16'sequenceNumber'||U32'length'||U32'child'||S16'dstX'||S16'dstY'||U32'pad2'||U32'pad3'||U32'pad4'||U32'pad5'|]
// file /usr/include/X11/Xproto.h line 600
struct anonymous_33;

// tag-#anon#ST[U8'type'||U8'sameScreen'||U16'sequenceNumber'||U32'length'||U32'root'||U32'child'||S16'rootX'||S16'rootY'||S16'winX'||S16'winY'||U16'mask'||U16'pad1'||U32'pad'|]
// file /usr/include/X11/Xproto.h line 575
struct anonymous_30;

// tag-#anon#ST[U8'type'||U8'status'||U16'sequenceNumber'||U32'length'||U32'pad1'||U32'pad2'||U32'pad3'||U32'pad4'||U32'pad5'||U32'pad6'|]
// file /usr/include/X11/Xproto.h line 560
struct anonymous_29;

// tag-#anon#ST[U8'type'||U8'success'||U16'sequenceNumber'||U32'length'||U32'pad2'||U32'pad3'||U32'pad4'||U32'pad5'||U32'pad6'||U32'pad7'|]
// file /usr/include/X11/Xproto.h line 859
struct anonymous_50;

// tag-#anon#UN[*{V(S32)->V}_V(S32)->V_'sa_handler'||*{V(S32|*{SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'_pad0'||SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#}_SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'_pad0'||SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#_|*{V}_V_)->V}_V(S32|*{SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'_pad0'||SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#}_SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'_pad0'||SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#_|*{V}_V_)->V_'sa_sigaction'|]
// file /usr/include/x86_64-linux-gnu/bits/sigaction.h line 28
union anonymous_12;

// tag-#anon#UN[ARR20{S8}_S8_'b'||ARR10{S16}_S16_'s'||ARR5{S64}_S64_'l'|]
// file /usr/include/X11/Xlib.h line 905
union anonymous_128;

// tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 69
union anonymous_10;

// tag-#anon#UN[ARR4{S8}_S8_'__size'||S32'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 130
union anonymous_141;

// tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}_V_'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 139
union anonymous_83;

// tag-#anon#UN[SYM#tag-#anon#ST[U32'type'||S32'longs0'||S32'longs1'||S32'longs2'||S32'longs3'||S32'longs4'|]#'l'||SYM#tag-#anon#ST[U32'type'||S16'shorts0'||S16'shorts1'||S16'shorts2'||S16'shorts3'||S16'shorts4'||S16'shorts5'||S16'shorts6'||S16'shorts7'||S16'shorts8'||S16'shorts9'|]#'s'||SYM#tag-#anon#ST[U32'type'||ARR20{S8}_S8_'bytes'|]#'b'|]
// file /usr/include/X11/Xproto.h line 1185
union anonymous_138;

// tag-#anon#UN[SYM#tag-#anon#ST[U8'type'||U8'data1'||U16'sequenceNumber'||U32'length'||U32'data00'||U32'data01'||U32'data02'||U32'data03'||U32'data04'||U32'data05'|]#'generic'||SYM#tag-#anon#ST[U8'type'||U8'depth'||U16'sequenceNumber'||U32'length'||U32'root'||S16'x'||S16'y'||U16'width'||U16'height'||U16'borderWidth'||U16'pad1'||U32'pad2'||U32'pad3'|]#'geom'||SYM#tag-#anon#ST[U8'type'||U8'pad1'||U16'sequenceNumber'||U32'length'||U32'root'||U32'parent'||U16'nChildren'||U16'pad2'||U32'pad3'||U32'pad4'||U32'pad5'|]#'tree'||SYM#tag-#anon#ST[U8'type'||U8'pad1'||U16'sequenceNumber'||U32'length'||U32'atom'||U32'pad2'||U32'pad3'||U32'pad4'||U32'pad5'||U32'pad6'|]#'atom'||SYM#tag-#anon#ST[U8'type'||U8'pad1'||U16'sequenceNumber'||U32'length'||U16'nameLength'||U16'pad2'||U32'pad3'||U32'pad4'||U32'pad5'||U32'pad6'||U32'pad7'|]#'atomName'||SYM#tag-#anon#ST[U8'type'||U8'format'||U16'sequenceNumber'||U32'length'||U32'propertyType'||U32'bytesAfter'||U32'nItems'||U32'pad1'||U32'pad2'||U32'pad3'|]#'property'||SYM#tag-#anon#ST[U8'type'||U8'pad1'||U16'sequenceNumber'||U32'length'||U16'nProperties'||U16'pad2'||U32'pad3'||U32'pad4'||U32'pad5'||U32'pad6'||U32'pad7'|]#'listProperties'||SYM#tag-#anon#ST[U8'type'||U8'pad1'||U16'sequenceNumber'||U32'length'||U32'owner'||U32'pad2'||U32'pad3'||U32'pad4'||U32'pad5'||U32'pad6'|]#'selection'||SYM#tag-#anon#ST[U8'type'||U8'status'||U16'sequenceNumber'||U32'length'||U32'pad1'||U32'pad2'||U32'pad3'||U32'pad4'||U32'pad5'||U32'pad6'|]#'grabPointer'||SYM#tag-#anon#ST[U8'type'||U8'status'||U16'sequenceNumber'||U32'length'||U32'pad1'||U32'pad2'||U32'pad3'||U32'pad4'||U32'pad5'||U32'pad6'|]#'grabKeyboard'||SYM#tag-#anon#ST[U8'type'||U8'sameScreen'||U16'sequenceNumber'||U32'length'||U32'root'||U32'child'||S16'rootX'||S16'rootY'||S16'winX'||S16'winY'||U16'mask'||U16'pad1'||U32'pad'|]#'pointer'||SYM#tag-#anon#ST[U8'type'||U8'pad1'||U16'sequenceNumber'||U32'length'||U32'nEvents'||U32'pad2'||U32'pad3'||U32'pad4'||U32'pad5'||U32'pad6'|]#'motionEvents'||SYM#tag-#anon#ST[U8'type'||U8'sameScreen'||U16'sequenceNumber'||U32'length'||U32'child'||S16'dstX'||S16'dstY'||U32'pad2'||U32'pad3'||U32'pad4'||U32'pad5'|]#'coords'||SYM#tag-#anon#ST[U8'type'||U8'revertTo'||U16'sequenceNumber'||U32'length'||U32'focus'||U32'pad1'||U32'pad2'||U32'pad3'||U32'pad4'||U32'pad5'|]#'inputFocus'||SYM#tag-#anon#ST[U8'type'||U8'drawDirection'||U16'sequenceNumber'||U32'length'||S16'fontAscent'||S16'fontDescent'||S16'overallAscent'||S16'overallDescent'||S32'overallWidth'||S32'overallLeft'||S32'overallRight'||U32'pad'|]#'textExtents'||SYM#tag-#anon#ST[U8'type'||U8'pad1'||U16'sequenceNumber'||U32'length'||U16'nFonts'||U16'pad2'||U32'pad3'||U32'pad4'||U32'pad5'||U32'pad6'||U32'pad7'|]#'fonts'||SYM#tag-#anon#ST[U8'type'||U8'pad1'||U16'sequenceNumber'||U32'length'||U16'nPaths'||U16'pad2'||U32'pad3'||U32'pad4'||U32'pad5'||U32'pad6'||U32'pad7'|]#'fontPath'||SYM#tag-#anon#ST[U8'type'||U8'depth'||U16'sequenceNumber'||U32'length'||U32'visual'||U32'pad3'||U32'pad4'||U32'pad5'||U32'pad6'||U32'pad7'|]#'image'||SYM#tag-#anon#ST[U8'type'||U8'pad1'||U16'sequenceNumber'||U32'length'||U16'nColormaps'||U16'pad2'||U32'pad3'||U32'pad4'||U32'pad5'||U32'pad6'||U32'pad7'|]#'colormaps'||SYM#tag-#anon#ST[U8'type'||U8'pad1'||U16'sequenceNumber'||U32'length'||U16'red'||U16'green'||U16'blue'||U16'pad2'||U32'pixel'||U32'pad3'||U32'pad4'||U32'pad5'|]#'allocColor'||SYM#tag-#anon#ST[U8'type'||U8'pad1'||U16'sequenceNumber'||U32'length'||U32'pixel'||U16'exactRed'||U16'exactGreen'||U16'exactBlue'||U16'screenRed'||U16'screenGreen'||U16'screenBlue'||U32'pad2'||U32'pad3'|]#'allocNamedColor'||SYM#tag-#anon#ST[U8'type'||U8'pad1'||U16'sequenceNumber'||U32'length'||U16'nPixels'||U16'nMasks'||U32'pad3'||U32'pad4'||U32'pad5'||U32'pad6'||U32'pad7'|]#'colorCells'||SYM#tag-#anon#ST[U8'type'||U8'pad1'||U16'sequenceNumber'||U32'length'||U16'nPixels'||U16'pad2'||U32'redMask'||U32'greenMask'||U32'blueMask'||U32'pad3'||U32'pad4'|]#'colorPlanes'||SYM#tag-#anon#ST[U8'type'||U8'pad1'||U16'sequenceNumber'||U32'length'||U16'nColors'||U16'pad2'||U32'pad3'||U32'pad4'||U32'pad5'||U32'pad6'||U32'pad7'|]#'colors'||SYM#tag-#anon#ST[U8'type'||U8'pad1'||U16'sequenceNumber'||U32'length'||U16'exactRed'||U16'exactGreen'||U16'exactBlue'||U16'screenRed'||U16'screenGreen'||U16'screenBlue'||U32'pad3'||U32'pad4'||U32'pad5'|]#'lookupColor'||SYM#tag-#anon#ST[U8'type'||U8'pad1'||U16'sequenceNumber'||U32'length'||U16'width'||U16'height'||U32'pad3'||U32'pad4'||U32'pad5'||U32'pad6'||U32'pad7'|]#'bestSize'||SYM#tag-#anon#ST[U8'type'||U8'pad1'||U16'sequenceNumber'||U32'length'||U8'present'||U8'major_opcode'||U8'first_event'||U8'first_error'||U32'pad3'||U32'pad4'||U32'pad5'||U32'pad6'||U32'pad7'|]#'extension'||SYM#tag-#anon#ST[U8'type'||U8'nExtensions'||U16'sequenceNumber'||U32'length'||U32'pad2'||U32'pad3'||U32'pad4'||U32'pad5'||U32'pad6'||U32'pad7'|]#'extensions'||SYM#tag-#anon#ST[U8'type'||U8'success'||U16'sequenceNumber'||U32'length'||U32'pad2'||U32'pad3'||U32'pad4'||U32'pad5'||U32'pad6'||U32'pad7'|]#'setModifierMapping'||SYM#tag-#anon#ST[U8'type'||U8'numKeyPerModifier'||U16'sequenceNumber'||U32'length'||U32'pad1'||U32'pad2'||U32'pad3'||U32'pad4'||U32'pad5'||U32'pad6'|]#'getModifierMapping'||SYM#tag-#anon#ST[U8'type'||U8'success'||U16'sequenceNumber'||U32'length'||U32'pad2'||U32'pad3'||U32'pad4'||U32'pad5'||U32'pad6'||U32'pad7'|]#'setPointerMapping'||SYM#tag-#anon#ST[U8'type'||U8'keySymsPerKeyCode'||U16'sequenceNumber'||U32'length'||U32'pad2'||U32'pad3'||U32'pad4'||U32'pad5'||U32'pad6'||U32'pad7'|]#'getKeyboardMapping'||SYM#tag-#anon#ST[U8'type'||U8'nElts'||U16'sequenceNumber'||U32'length'||U32'pad2'||U32'pad3'||U32'pad4'||U32'pad5'||U32'pad6'||U32'pad7'|]#'getPointerMapping'||SYM#tag-#anon#ST[U8'type'||U8'pad1'||U16'sequenceNumber'||U32'length'||U16'accelNumerator'||U16'accelDenominator'||U16'threshold'||U16'pad2'||U32'pad3'||U32'pad4'||U32'pad5'||U32'pad6'|]#'pointerControl'||SYM#tag-#anon#ST[U8'type'||U8'pad1'||U16'sequenceNumber'||U32'length'||U16'timeout'||U16'interval'||U8'preferBlanking'||U8'allowExposures'||U16'pad2'||U32'pad3'||U32'pad4'||U32'pad5'||U32'pad6'|]#'screenSaver'||SYM#tag-#anon#ST[U8'type'||U8'enabled'||U16'sequenceNumber'||U32'length'||U16'nHosts'||U16'pad1'||U32'pad3'||U32'pad4'||U32'pad5'||U32'pad6'||U32'pad7'|]#'hosts'||SYM#tag-#anon#ST[U8'type'||U8'errorCode'||U16'sequenceNumber'||U32'resourceID'||U16'minorCode'||U8'majorCode'||U8'pad1'||U32'pad3'||U32'pad4'||U32'pad5'||U32'pad6'||U32'pad7'|]#'error'||SYM#tag-_xEvent#'event'|]
// file /usr/include/X11/Xproto.h line 1264
union anonymous_134;

// tag-#anon#UN[SYM#tag-#anon#ST[U8'type'||U8'detail'||U16'sequenceNumber'|]#'u'||SYM#tag-#anon#ST[U32'pad00'||U32'time'||U32'root'||U32'event'||U32'child'||S16'rootX'||S16'rootY'||S16'eventX'||S16'eventY'||U16'state'||U8'sameScreen'||U8'pad1'|]#'keyButtonPointer'||SYM#tag-#anon#ST[U32'pad00'||U32'time'||U32'root'||U32'event'||U32'child'||S16'rootX'||S16'rootY'||S16'eventX'||S16'eventY'||U16'state'||U8'mode'||U8'flags'|]#'enterLeave'||SYM#tag-#anon#ST[U32'pad00'||U32'window'||U8'mode'||U8'pad1'||U8'pad2'||U8'pad3'|]#'focus'||SYM#tag-#anon#ST[U32'pad00'||U32'window'||U16'x'||U16'y'||U16'width'||U16'height'||U16'count'||U16'pad2'|]#'expose'||SYM#tag-#anon#ST[U32'pad00'||U32'drawable'||U16'x'||U16'y'||U16'width'||U16'height'||U16'minorEvent'||U16'count'||U8'majorEvent'||U8'pad1'||U8'pad2'||U8'pad3'|]#'graphicsExposure'||SYM#tag-#anon#ST[U32'pad00'||U32'drawable'||U16'minorEvent'||U8'majorEvent'||U8'bpad'|]#'noExposure'||SYM#tag-#anon#ST[U32'pad00'||U32'window'||U8'state'||U8'pad1'||U8'pad2'||U8'pad3'|]#'visibility'||SYM#tag-#anon#ST[U32'pad00'||U32'parent'||U32'window'||S16'x'||S16'y'||U16'width'||U16'height'||U16'borderWidth'||U8'override'||U8'bpad'|]#'createNotify'||SYM#tag-#anon#ST[U32'pad00'||U32'event'||U32'window'|]#'destroyNotify'||SYM#tag-#anon#ST[U32'pad00'||U32'event'||U32'window'||U8'fromConfigure'||U8'pad1'||U8'pad2'||U8'pad3'|]#'unmapNotify'||SYM#tag-#anon#ST[U32'pad00'||U32'event'||U32'window'||U8'override'||U8'pad1'||U8'pad2'||U8'pad3'|]#'mapNotify'||SYM#tag-#anon#ST[U32'pad00'||U32'parent'||U32'window'|]#'mapRequest'||SYM#tag-#anon#ST[U32'pad00'||U32'event'||U32'window'||U32'parent'||S16'x'||S16'y'||U8'override'||U8'pad1'||U8'pad2'||U8'pad3'|]#'reparent'||SYM#tag-#anon#ST[U32'pad00'||U32'event'||U32'window'||U32'aboveSibling'||S16'x'||S16'y'||U16'width'||U16'height'||U16'borderWidth'||U8'override'||U8'bpad'|]#'configureNotify'||SYM#tag-#anon#ST[U32'pad00'||U32'parent'||U32'window'||U32'sibling'||S16'x'||S16'y'||U16'width'||U16'height'||U16'borderWidth'||U16'valueMask'||U32'pad1'|]#'configureRequest'||SYM#tag-#anon#ST[U32'pad00'||U32'event'||U32'window'||S16'x'||S16'y'||U32'pad1'||U32'pad2'||U32'pad3'||U32'pad4'|]#'gravity'||SYM#tag-#anon#ST[U32'pad00'||U32'window'||U16'width'||U16'height'|]#'resizeRequest'||SYM#tag-#anon#ST[U32'pad00'||U32'event'||U32'window'||U32'parent'||U8'place'||U8'pad1'||U8'pad2'||U8'pad3'|]#'circulate'||SYM#tag-#anon#ST[U32'pad00'||U32'window'||U32'atom'||U32'time'||U8'state'||U8'pad1'||U16'pad2'|]#'property'||SYM#tag-#anon#ST[U32'pad00'||U32'time'||U32'window'||U32'atom'|]#'selectionClear'||SYM#tag-#anon#ST[U32'pad00'||U32'time'||U32'owner'||U32'requestor'||U32'selection'||U32'target'||U32'property'|]#'selectionRequest'||SYM#tag-#anon#ST[U32'pad00'||U32'time'||U32'requestor'||U32'selection'||U32'target'||U32'property'|]#'selectionNotify'||SYM#tag-#anon#ST[U32'pad00'||U32'window'||U32'colormap'||U8'new'||U8'state'||U8'pad1'||U8'pad2'|]#'colormap'||SYM#tag-#anon#ST[U32'pad00'||U8'request'||U8'firstKeyCode'||U8'count'||U8'pad1'|]#'mappingNotify'||SYM#tag-#anon#ST[U32'pad00'||U32'window'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[U32'type'||S32'longs0'||S32'longs1'||S32'longs2'||S32'longs3'||S32'longs4'|]#'l'||SYM#tag-#anon#ST[U32'type'||S16'shorts0'||S16'shorts1'||S16'shorts2'||S16'shorts3'||S16'shorts4'||S16'shorts5'||S16'shorts6'||S16'shorts7'||S16'shorts8'||S16'shorts9'|]#'s'||SYM#tag-#anon#ST[U32'type'||ARR20{S8}_S8_'bytes'|]#'b'|]#'u'|]#'clientMessage'|]
// file /usr/include/X11/Xproto.h line 997
union anonymous_57;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous_86;

// tag-_BRWindow
// file rmd_types.h line 105
struct _BRWindow;

// tag-_CacheData
// file rmd_types.h line 187
struct _CacheData;

// tag-_CachedFrame
// file rmd_load_cache.c line 58
struct _CachedFrame;

// tag-_DisplaySpecs
// file rmd_types.h line 91
struct _DisplaySpecs;

// tag-_EncData
// file rmd_types.h line 160
struct _EncData;

// tag-_FrameHeader
// file rmd_types.h line 356
struct _FrameHeader;

// tag-_HotKey
// file rmd_types.h line 238
struct _HotKey;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-_JackData
// file rmd_types.h line 221
struct _JackData;

// tag-_ProgArgs
// file rmd_types.h line 114
struct _ProgArgs;

// tag-_ProgData
// file rmd_types.h line 89
struct _ProgData;

// tag-_RectArea
// file rmd_types.h line 100
struct _RectArea;

// tag-_ShmGetImage
// file /usr/include/X11/extensions/shmproto.h line 117
struct _ShmGetImage;

// tag-_ShmGetImageReply
// file /usr/include/X11/extensions/shmproto.h line 136
struct _ShmGetImageReply;

// tag-_SndBuffer
// file rmd_types.h line 215
struct _SndBuffer;

// tag-_X11XCBPrivate
// file /usr/include/X11/Xlibint.h line 193
struct _X11XCBPrivate;

// tag-_XConnWatchInfo
// file /usr/include/X11/Xlibint.h line 183
struct _XConnWatchInfo;

// tag-_XConnectionInfo
// file /usr/include/X11/Xlibint.h line 181
struct _XConnectionInfo;

// tag-_XContextDB
// file /usr/include/X11/Xlibint.h line 162
struct _XContextDB;

// tag-_XDisplay
// file /usr/include/X11/Xlib.h line 255
struct _XDisplay;

// tag-_XDisplayAtoms
// file /usr/include/X11/Xlibint.h line 159
struct _XDisplayAtoms;

// tag-_XEvent
// file /usr/include/X11/Xlib.h line 973
union _XEvent;

// tag-_XExtData
// file /usr/include/X11/Xlib.h line 148
struct _XExtData;

// tag-_XExten
// file /usr/include/X11/Xlibint.h line 127
struct _XExten;

// tag-_XFreeFuncs
// file /usr/include/X11/Xlibint.h line 78
struct _XFreeFuncs;

// tag-_XGC
// file /usr/include/X11/Xlib.h line 214
struct _XGC;

// tag-_XIMFilter
// file /usr/include/X11/Xlibint.h line 177
struct _XIMFilter;

// tag-_XImage
// file /usr/include/X11/Xlib.h line 360
struct _XImage;

// tag-_XInternalAsync
// file /usr/include/X11/Xlibint.h line 148
struct _XInternalAsync;

// tag-_XKeytrans
// file /usr/include/X11/Xlibint.h line 157
struct _XKeytrans;

// tag-_XLockInfo
// file /usr/include/X11/Xlibint.h line 147
struct _XLockInfo;

// tag-_XLockPtrs
// file /usr/include/X11/Xlibint.h line 150
struct _XLockPtrs;

// tag-_XPrivate
// file /usr/include/X11/Xlib.h line 490
struct _XPrivate;

// tag-_XSQEvent
// file /usr/include/X11/Xlibint.h line 99
struct _XSQEvent;

// tag-_XkbInfoRec
// file /usr/include/X11/Xlibint.h line 191
struct _XkbInfoRec;

// tag-_XrmHashBucketRec
// file /usr/include/X11/Xlib.h line 491
struct _XrmHashBucketRec;

// tag-_XtransConnInfo
// file /usr/include/X11/Xlibint.h line 192
struct _XtransConnInfo;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-_jack_client
// file /usr/include/jack/types.h line 72
struct _jack_client;

// tag-_jack_port
// file /usr/include/jack/types.h line 66
struct _jack_port;

// tag-_snd_pcm
// file /usr/include/alsa/pcm.h line 354
struct _snd_pcm;

// tag-_snd_pcm_access
// file /usr/include/alsa/pcm.h line 108
enum _snd_pcm_access { SND_PCM_ACCESS_MMAP_INTERLEAVED=0, SND_PCM_ACCESS_MMAP_NONINTERLEAVED=1, SND_PCM_ACCESS_MMAP_COMPLEX=2, SND_PCM_ACCESS_RW_INTERLEAVED=3, SND_PCM_ACCESS_RW_NONINTERLEAVED=4, SND_PCM_ACCESS_LAST=4 };

// tag-_snd_pcm_format
// file /usr/include/alsa/pcm.h line 123
enum _snd_pcm_format { SND_PCM_FORMAT_UNKNOWN=-1, SND_PCM_FORMAT_S8=0, SND_PCM_FORMAT_U8=1, SND_PCM_FORMAT_S16_LE=2, SND_PCM_FORMAT_S16_BE=3, SND_PCM_FORMAT_U16_LE=4, SND_PCM_FORMAT_U16_BE=5, SND_PCM_FORMAT_S24_LE=6, SND_PCM_FORMAT_S24_BE=7, SND_PCM_FORMAT_U24_LE=8, SND_PCM_FORMAT_U24_BE=9, SND_PCM_FORMAT_S32_LE=10, SND_PCM_FORMAT_S32_BE=11, SND_PCM_FORMAT_U32_LE=12, SND_PCM_FORMAT_U32_BE=13, SND_PCM_FORMAT_FLOAT_LE=14, SND_PCM_FORMAT_FLOAT_BE=15, SND_PCM_FORMAT_FLOAT64_LE=16, SND_PCM_FORMAT_FLOAT64_BE=17, SND_PCM_FORMAT_IEC958_SUBFRAME_LE=18, SND_PCM_FORMAT_IEC958_SUBFRAME_BE=19, SND_PCM_FORMAT_MU_LAW=20, SND_PCM_FORMAT_A_LAW=21, SND_PCM_FORMAT_IMA_ADPCM=22, SND_PCM_FORMAT_MPEG=23, SND_PCM_FORMAT_GSM=24, SND_PCM_FORMAT_SPECIAL=31, SND_PCM_FORMAT_S24_3LE=32, SND_PCM_FORMAT_S24_3BE=33, SND_PCM_FORMAT_U24_3LE=34, SND_PCM_FORMAT_U24_3BE=35, SND_PCM_FORMAT_S20_3LE=36, SND_PCM_FORMAT_S20_3BE=37, SND_PCM_FORMAT_U20_3LE=38, SND_PCM_FORMAT_U20_3BE=39, SND_PCM_FORMAT_S18_3LE=40, SND_PCM_FORMAT_S18_3BE=41, SND_PCM_FORMAT_U18_3LE=42, SND_PCM_FORMAT_U18_3BE=43, SND_PCM_FORMAT_G723_24=44, SND_PCM_FORMAT_G723_24_1B=45, SND_PCM_FORMAT_G723_40=46, SND_PCM_FORMAT_G723_40_1B=47, SND_PCM_FORMAT_DSD_U8=48, SND_PCM_FORMAT_DSD_U16_LE=49, SND_PCM_FORMAT_DSD_U32_LE=50, SND_PCM_FORMAT_DSD_U16_BE=51, SND_PCM_FORMAT_DSD_U32_BE=52, SND_PCM_FORMAT_LAST=52, SND_PCM_FORMAT_S16=2, SND_PCM_FORMAT_U16=4, SND_PCM_FORMAT_S24=6, SND_PCM_FORMAT_U24=8, SND_PCM_FORMAT_S32=10, SND_PCM_FORMAT_U32=12, SND_PCM_FORMAT_FLOAT=14, SND_PCM_FORMAT_FLOAT64=16, SND_PCM_FORMAT_IEC958_SUBFRAME=18 };

// tag-_snd_pcm_hw_params
// file /usr/include/alsa/pcm.h line 62
struct _snd_pcm_hw_params;

// tag-_snd_pcm_stream
// file /usr/include/alsa/pcm.h line 99
enum _snd_pcm_stream { SND_PCM_STREAM_PLAYBACK=0, SND_PCM_STREAM_CAPTURE=1, SND_PCM_STREAM_LAST=1 };

// tag-_xEvent
// file /usr/include/X11/Xproto.h line 996
struct _xEvent;

// tag-alloc_chain
// file /usr/include/vorbis/codec.h line 110
struct alloc_chain;

// tag-funcs
// file /usr/include/X11/Xlib.h line 376
struct funcs;

// tag-gzFile_s
// file /usr/include/zlib.h line 1224
struct gzFile_s;

// tag-ipc_perm
// file /usr/include/x86_64-linux-gnu/bits/ipc.h line 42
struct ipc_perm;

// tag-poptCallbackReason
// file /usr/include/popt.h line 214
enum poptCallbackReason { POPT_CALLBACK_REASON_PRE=0, POPT_CALLBACK_REASON_POST=1, POPT_CALLBACK_REASON_OPTION=2 };

// tag-poptContext_s
// file /usr/include/popt.h line 200
struct poptContext_s;

// tag-poptOption
// file /usr/include/popt.h line 125
struct poptOption;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-shmid_ds
// file /usr/include/x86_64-linux-gnu/bits/shm.h line 49
struct shmid_ds;

// tag-sigaction
// file /usr/include/x86_64-linux-gnu/bits/sigaction.h line 24
struct sigaction;

// tag-sigval
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 32
union sigval;

// tag-stat
// file /usr/include/x86_64-linux-gnu/bits/stat.h line 46
struct stat;

// tag-theora_comment
// file /usr/include/theora/theora.h line 275
struct theora_comment;

// tag-timespec
// file /usr/include/time.h line 120
struct timespec;

// tag-vorbis_block
// file /usr/include/vorbis/codec.h line 88
struct vorbis_block;

// tag-vorbis_comment
// file /usr/include/vorbis/codec.h line 140
struct vorbis_comment;

// tag-vorbis_dsp_state
// file /usr/include/vorbis/codec.h line 59
struct vorbis_dsp_state;

// tag-vorbis_info
// file /usr/include/vorbis/codec.h line 28
struct vorbis_info;

#ifndef NULL
#define NULL ((void*)0)
#endif

// XAllocNamedColor
// file /usr/include/X11/Xlib.h line 1988
extern signed int XAllocNamedColor(struct _XDisplay *, unsigned long int, const char *, struct anonymous_18 *, struct anonymous_18 *);
// XBlackPixel
// file /usr/include/X11/Xlib.h line 1789
extern unsigned long int XBlackPixel(struct _XDisplay *, signed int);
// XChangeGC
// file /usr/include/X11/Xlib.h line 2038
extern signed int XChangeGC(struct _XDisplay *, struct _XGC *, unsigned long int, struct anonymous_16 *);
// XCloseDisplay
// file /usr/include/X11/Xlib.h line 2160
extern signed int XCloseDisplay(struct _XDisplay *);
// XCreateGC
// file /usr/include/X11/Xlib.h line 1584
extern struct _XGC * XCreateGC(struct _XDisplay *, unsigned long int, unsigned long int, struct anonymous_16 *);
// XCreateImage
// file /usr/include/X11/Xlib.h line 1441
extern struct _XImage * XCreateImage(struct _XDisplay *, struct anonymous_21 *, unsigned int, signed int, signed int, char *, unsigned int, unsigned int, signed int, signed int);
// XCreateWindow
// file /usr/include/X11/Xlib.h line 1636
extern unsigned long int XCreateWindow(struct _XDisplay *, unsigned long int, signed int, signed int, unsigned int, unsigned int, unsigned int, signed int, unsigned int, struct anonymous_21 *, unsigned long int, struct anonymous_19 *);
// XDamageCreate
// file /usr/include/X11/extensions/Xdamage.h line 59
unsigned long int XDamageCreate(struct _XDisplay *, unsigned long int, signed int);
// XDamageQueryExtension
// file /usr/include/X11/extensions/Xdamage.h line 50
signed int XDamageQueryExtension(struct _XDisplay *, signed int *, signed int *);
// XDestroyWindow
// file /usr/include/X11/Xlib.h line 2243
extern signed int XDestroyWindow(struct _XDisplay *, unsigned long int);
// XFillRectangle
// file /usr/include/X11/Xlib.h line 2489
extern signed int XFillRectangle(struct _XDisplay *, unsigned long int, struct _XGC *, signed int, signed int, unsigned int, unsigned int);
// XFixesGetCursorImage
// file /usr/include/X11/extensions/Xfixes.h line 145
struct anonymous_31 * XFixesGetCursorImage(struct _XDisplay *);
// XFixesQueryExtension
// file /usr/include/X11/extensions/Xfixes.h line 117
signed int XFixesQueryExtension(struct _XDisplay *, signed int *, signed int *);
// XFree
// file /usr/include/X11/Xlib.h line 2516
extern signed int XFree(void *);
// XFreeGC
// file /usr/include/X11/Xlib.h line 2561
extern signed int XFreeGC(struct _XDisplay *, struct _XGC *);
// XFreeModifiermap
// file /usr/include/X11/Xlib.h line 2566
extern signed int XFreeModifiermap(struct anonymous_95 *);
// XGetErrorText
// file /usr/include/X11/Xlib.h line 2600
extern signed int XGetErrorText(struct _XDisplay *, signed int, char *, signed int);
// XGetModifierMapping
// file /usr/include/X11/Xlib.h line 1423
extern struct anonymous_95 * XGetModifierMapping(struct _XDisplay *);
// XGetSelectionOwner
// file /usr/include/X11/Xlib.h line 1632
extern unsigned long int XGetSelectionOwner(struct _XDisplay *, unsigned long int);
// XGetWindowAttributes
// file /usr/include/X11/Xlib.h line 2691
extern signed int XGetWindowAttributes(struct _XDisplay *, unsigned long int, struct anonymous *);
// XGetWindowProperty
// file /usr/include/X11/Xlib.h line 2676
extern signed int XGetWindowProperty(struct _XDisplay *, unsigned long int, unsigned long int, signed long int, signed long int, signed int, unsigned long int, unsigned long int *, signed int *, unsigned long int *, unsigned long int *, unsigned char **);
// XGrabKey
// file /usr/include/X11/Xlib.h line 2710
extern signed int XGrabKey(struct _XDisplay *, signed int, unsigned int, unsigned long int, signed int, signed int, signed int);
// XInitImage
// file /usr/include/X11/Xlib.h line 1453
extern signed int XInitImage(struct _XImage *);
// XInitThreads
// file /usr/include/X11/Xlib.h line 1734
extern signed int XInitThreads(void);
// XInternAtom
// file /usr/include/X11/Xlib.h line 1536
extern unsigned long int XInternAtom(struct _XDisplay *, const char *, signed int);
// XKeysymToKeycode
// file /usr/include/X11/Xlib.h line 2773
extern unsigned char XKeysymToKeycode(struct _XDisplay *, unsigned long int);
// XMapWindow
// file /usr/include/X11/Xlib.h line 2806
extern signed int XMapWindow(struct _XDisplay *, unsigned long int);
// XMoveWindow
// file /usr/include/X11/Xlib.h line 2834
extern signed int XMoveWindow(struct _XDisplay *, unsigned long int, signed int, signed int);
// XNextEvent
// file /usr/include/X11/Xlib.h line 2841
extern signed int XNextEvent(struct _XDisplay *, union _XEvent *);
// XOpenDisplay
// file /usr/include/X11/Xlib.h line 1483
extern struct _XDisplay * XOpenDisplay(const char *);
// XPending
// file /usr/include/X11/Xlib.h line 2881
extern signed int XPending(struct _XDisplay *);
// XQueryExtension
// file /usr/include/X11/Xlib.h line 2970
extern signed int XQueryExtension(struct _XDisplay *, const char *, signed int *, signed int *, signed int *);
// XQueryPointer
// file /usr/include/X11/Xlib.h line 2983
extern signed int XQueryPointer(struct _XDisplay *, unsigned long int, unsigned long int *, unsigned long int *, signed int *, signed int *, signed int *, signed int *, unsigned int *);
// XQueryTree
// file /usr/include/X11/Xlib.h line 3017
extern signed int XQueryTree(struct _XDisplay *, unsigned long int, unsigned long int *, unsigned long int *, unsigned long int **, unsigned int *);
// XSelectInput
// file /usr/include/X11/Xlib.h line 3129
extern signed int XSelectInput(struct _XDisplay *, unsigned long int, signed long int);
// XSetErrorHandler
// file /usr/include/X11/Xlib.h line 1848
extern signed int (*XSetErrorHandler(signed int (*)(struct _XDisplay *, struct anonymous_118 *)))(struct _XDisplay *, struct anonymous_118 *);
// XShapeCombineRectangles
// file /usr/include/X11/extensions/shape.h line 73
extern void XShapeCombineRectangles(struct _XDisplay *, unsigned long int, signed int, signed int, signed int, struct anonymous_17 *, signed int, signed int, signed int);
// XShapeQueryExtension
// file /usr/include/X11/extensions/shape.h line 51
extern signed int XShapeQueryExtension(struct _XDisplay *, signed int *, signed int *);
// XShmAttach
// file /usr/include/X11/extensions/XShm.h line 78
signed int XShmAttach(struct _XDisplay *, struct anonymous_34 *);
// XShmCreateImage
// file /usr/include/X11/extensions/XShm.h line 111
struct _XImage * XShmCreateImage(struct _XDisplay *, struct anonymous_21 *, unsigned int, signed int, char *, struct anonymous_34 *, unsigned int, unsigned int);
// XShmDetach
// file /usr/include/X11/extensions/XShm.h line 83
signed int XShmDetach(struct _XDisplay *, struct anonymous_34 *);
// XShmGetImage
// file /usr/include/X11/extensions/XShm.h line 102
signed int XShmGetImage(struct _XDisplay *, unsigned long int, struct _XImage *, signed int, signed int, unsigned long int);
// XStringToKeysym
// file /usr/include/X11/Xlib.h line 1710
extern unsigned long int XStringToKeysym(const char *);
// XTranslateCoordinates
// file /usr/include/X11/Xlib.h line 3446
extern signed int XTranslateCoordinates(struct _XDisplay *, unsigned long int, unsigned long int, signed int, signed int, signed int *, signed int *, unsigned long int *);
// XWhitePixel
// file /usr/include/X11/Xlib.h line 1793
extern unsigned long int XWhitePixel(struct _XDisplay *, signed int);
// _XGetRequest
// file /usr/include/X11/Xlibint.h line 418
extern void * _XGetRequest(struct _XDisplay *, unsigned char, unsigned long int);
// _XReadPad
// file /usr/include/X11/Xlibint.h line 916
extern void _XReadPad(struct _XDisplay *, char *, signed long int);
// _XReply
// file /usr/include/X11/Xlibint.h line 926
extern signed int _XReply(struct _XDisplay *, union anonymous_134 *, signed int, signed int);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// _le_16
// file skeleton.c line 29
static unsigned short int _le_16(unsigned short int s);
// _le_32
// file skeleton.c line 40
static unsigned int _le_32(unsigned int i);
// _le_64
// file skeleton.c line 53
static signed long int _le_64(signed long int l);
// add_eos_packet_to_stream
// file skeleton.h line 65
extern signed int add_eos_packet_to_stream(struct anonymous_14 *os);
// add_fisbone_to_stream
// file skeleton.h line 64
extern signed int add_fisbone_to_stream(struct anonymous_14 *os, struct anonymous_139 *fp);
// add_fishead_to_stream
// file skeleton.h line 63
extern signed int add_fishead_to_stream(struct anonymous_14 *os, struct anonymous_140 *fp);
// add_message_header_field
// file skeleton.h line 54
extern signed int add_message_header_field(struct anonymous_139 *fp, char *header_key, char *header_value);
// atof
// file /usr/include/stdlib.h line 144
extern double atof(const char *);
// calloc
// file /usr/include/stdlib.h line 468
extern void * calloc(unsigned long int, unsigned long int);
// ceilf
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 178
extern float ceilf(float);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// fclose
// file /usr/include/stdio.h line 237
extern signed int fclose(struct _IO_FILE *);
// fflush
// file /usr/include/stdio.h line 242
extern signed int fflush(struct _IO_FILE *);
// fisbone_clear
// file skeleton.c line 238
extern signed int fisbone_clear(struct anonymous_139 *fp);
// fisbone_from_data
// file skeleton.c line 206
static signed int fisbone_from_data(const unsigned char *data, signed int len, struct anonymous_139 *fp);
// fisbone_from_ogg
// file skeleton.c line 229
extern signed int fisbone_from_ogg(struct anonymous_126 *op, struct anonymous_139 *fp);
// fisbone_from_ogg_page
// file skeleton.c line 234
extern signed int fisbone_from_ogg_page(const struct anonymous_15 *og, struct anonymous_139 *fp);
// fishead_from_data
// file skeleton.c line 178
static signed int fishead_from_data(const unsigned char *data, signed int len, struct anonymous_140 *fp);
// fishead_from_ogg
// file skeleton.c line 196
extern signed int fishead_from_ogg(struct anonymous_126 *op, struct anonymous_140 *fp);
// fishead_from_ogg_page
// file skeleton.c line 201
extern signed int fishead_from_ogg_page(const struct anonymous_15 *og, struct anonymous_140 *fp);
// floorf
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 184
extern float floorf(float);
// flush_ogg_stream_to_file
// file skeleton.c line 282
extern signed int flush_ogg_stream_to_file(struct anonymous_14 *os, struct _IO_FILE *out);
// fopen
// file /usr/include/stdio.h line 272
extern struct _IO_FILE * fopen(const char *, const char *);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// fread
// file /usr/include/stdio.h line 709
extern unsigned long int fread(void *, unsigned long int, unsigned long int, struct _IO_FILE *);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// fscanf
// file /usr/include/stdio.h line 425
extern signed int fscanf(struct _IO_FILE *, const char *, ...);
// fwrite
// file /usr/include/stdio.h line 715
extern unsigned long int fwrite(const void *, unsigned long int, unsigned long int, struct _IO_FILE *);
// getenv
// file /usr/include/stdlib.h line 564
extern char * getenv(const char *);
// getpid
// file /usr/include/unistd.h line 628
extern signed int getpid(void);
// gzclose
// file /usr/include/zlib.h line 1511
extern signed int gzclose(struct gzFile_s *);
// gzflush
// file /usr/include/zlib.h line 1412
extern signed int gzflush(struct gzFile_s *, signed int);
// gzopen
// file /usr/include/zlib.h line 1725
extern struct gzFile_s * gzopen(const char *, const char *);
// gzread
// file /usr/include/zlib.h line 1313
extern signed int gzread(struct gzFile_s *, void *, unsigned int);
// gzsetparams
// file /usr/include/zlib.h line 1304
extern signed int gzsetparams(struct gzFile_s *, signed int, signed int);
// gzwrite
// file /usr/include/zlib.h line 1341
extern signed int gzwrite(struct gzFile_s *, const void *, unsigned int);
// jack_activate
// file /usr/include/jack/jack.h line 183
signed int jack_activate(struct _jack_client *);
// jack_client_close
// file /usr/include/jack/jack.h line 104
signed int jack_client_close(struct _jack_client *);
// jack_client_new
// file /usr/include/jack/jack.h line 97
struct _jack_client * jack_client_new(const char *);
// jack_connect
// file /usr/include/jack/jack.h line 848
signed int jack_connect(struct _jack_client *, const char *, const char *);
// jack_get_buffer_size
// file /usr/include/jack/jack.h line 565
unsigned int jack_get_buffer_size(struct _jack_client *);
// jack_get_sample_rate
// file /usr/include/jack/jack.h line 554
unsigned int jack_get_sample_rate(struct _jack_client *);
// jack_on_shutdown
// file /usr/include/jack/jack.h line 300
void jack_on_shutdown(struct _jack_client *, void (*)(void *), void *);
// jack_port_get_buffer
// file /usr/include/jack/jack.h line 649
void * jack_port_get_buffer(struct _jack_port *, unsigned int);
// jack_port_name
// file /usr/include/jack/jack.h line 657
const char * jack_port_name(const struct _jack_port *);
// jack_port_register
// file /usr/include/jack/jack.h line 624
struct _jack_port * jack_port_register(struct _jack_client *, const char *, const char *, unsigned long int, unsigned long int);
// jack_ringbuffer_create
// file /usr/include/jack/ringbuffer.h line 72
struct anonymous_85 * jack_ringbuffer_create(unsigned long int);
// jack_ringbuffer_free
// file /usr/include/jack/ringbuffer.h line 80
void jack_ringbuffer_free(struct anonymous_85 *);
// jack_ringbuffer_read
// file /usr/include/jack/ringbuffer.h line 137
unsigned long int jack_ringbuffer_read(struct anonymous_85 *, char *, unsigned long int);
// jack_ringbuffer_read_space
// file /usr/include/jack/ringbuffer.h line 176
unsigned long int jack_ringbuffer_read_space(const struct anonymous_85 *);
// jack_ringbuffer_write
// file /usr/include/jack/ringbuffer.h line 205
unsigned long int jack_ringbuffer_write(struct anonymous_85 *, const char *, unsigned long int);
// jack_set_process_callback
// file /usr/include/jack/jack.h line 342
signed int jack_set_process_callback(struct _jack_client *, signed int (*)(unsigned int, void *), void *);
// m_add_fishead_packet
// file rmd_init_encoder.c line 43
static void m_add_fishead_packet(struct anonymous_14 *m_ogg_state);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// memcmp
// file /usr/include/string.h line 69
extern signed int memcmp(const void *, const void *, unsigned long int);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// mkdir
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 320
extern signed int mkdir(const char *, unsigned int);
// ogg_from_fisbone
// file skeleton.c line 144
extern signed int ogg_from_fisbone(struct anonymous_139 *fp, struct anonymous_126 *op);
// ogg_from_fishead
// file skeleton.c line 114
extern signed int ogg_from_fishead(struct anonymous_140 *fp, struct anonymous_126 *op);
// ogg_page_cp
// file rmd_flush_to_ogg.c line 47
static void ogg_page_cp(struct anonymous_15 *new, struct anonymous_15 *old);
// ogg_page_cp_free
// file rmd_flush_to_ogg.c line 67
static void ogg_page_cp_free(struct anonymous_15 *pg);
// ogg_page_eos
// file /usr/include/ogg/ogg.h line 197
extern signed int ogg_page_eos(const struct anonymous_15 *);
// ogg_page_granulepos
// file /usr/include/ogg/ogg.h line 198
extern signed long int ogg_page_granulepos(const struct anonymous_15 *);
// ogg_stream_clear
// file /usr/include/ogg/ogg.h line 185
extern signed int ogg_stream_clear(struct anonymous_14 *);
// ogg_stream_flush
// file /usr/include/ogg/ogg.h line 163
extern signed int ogg_stream_flush(struct anonymous_14 *, struct anonymous_15 *);
// ogg_stream_init
// file /usr/include/ogg/ogg.h line 184
extern signed int ogg_stream_init(struct anonymous_14 *, signed int);
// ogg_stream_packetin
// file /usr/include/ogg/ogg.h line 158
extern signed int ogg_stream_packetin(struct anonymous_14 *, struct anonymous_126 *);
// ogg_stream_pageout
// file /usr/include/ogg/ogg.h line 161
extern signed int ogg_stream_pageout(struct anonymous_14 *, struct anonymous_15 *);
// perror
// file /usr/include/stdio.h line 846
extern void perror(const char *);
// poptBadOption
// file /usr/include/popt.h line 354
const char * poptBadOption(struct poptContext_s *, unsigned int);
// poptFreeContext
// file /usr/include/popt.h line 248
struct poptContext_s * poptFreeContext(struct poptContext_s *);
// poptGetArg
// file /usr/include/popt.h line 326
const char * poptGetArg(struct poptContext_s *);
// poptGetContext
// file /usr/include/popt.h line 261
struct poptContext_s * poptGetContext(const char *, signed int, const char **, struct poptOption *, unsigned int);
// poptGetNextOpt
// file /usr/include/popt.h line 307
signed int poptGetNextOpt(struct poptContext_s *);
// poptGetOptArg
// file /usr/include/popt.h line 317
char * poptGetOptArg(struct poptContext_s *);
// poptPrintHelp
// file /usr/include/popt.h line 558
void poptPrintHelp(struct poptContext_s *, struct _IO_FILE *, signed int);
// poptSetOtherOptionHelp
// file /usr/include/popt.h line 578
void poptSetOtherOptionHelp(struct poptContext_s *, const char *);
// pow
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 153
extern double pow(double, double);
// pthread_cond_broadcast
// file /usr/include/pthread.h line 983
extern signed int pthread_cond_broadcast(union anonymous_83 *);
// pthread_cond_init
// file /usr/include/pthread.h line 970
extern signed int pthread_cond_init(union anonymous_83 *, const union anonymous_141 *);
// pthread_cond_signal
// file /usr/include/pthread.h line 979
extern signed int pthread_cond_signal(union anonymous_83 *);
// pthread_cond_wait
// file /usr/include/pthread.h line 991
extern signed int pthread_cond_wait(union anonymous_83 *, union anonymous_86 *);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_exit
// file /usr/include/pthread.h line 244
extern void pthread_exit(void *);
// pthread_join
// file /usr/include/pthread.h line 252
extern signed int pthread_join(unsigned long int, void **);
// pthread_mutex_init
// file /usr/include/pthread.h line 751
extern signed int pthread_mutex_init(union anonymous_86 *, const union anonymous_141 *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous_86 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous_86 *);
// raise
// file /usr/include/signal.h line 139
extern signed int raise(signed int);
// rand
// file /usr/include/stdlib.h line 374
extern signed int rand(void);
// realloc
// file /usr/include/stdlib.h line 480
extern void * realloc(void *, unsigned long int);
// remove
// file /usr/include/stdio.h line 178
extern signed int remove(const char *);
// rindex
// file /usr/include/string.h line 516
extern char * rindex(const char *, signed int);
// rmdBRWinCpy
// file rmd_get_frame.c line 269
static void rmdBRWinCpy(struct _BRWindow *target, struct _BRWindow *source);
// rmdBlocksFromList
// file rmd_get_frame.c line 316
static void rmdBlocksFromList(struct _RectArea **root, unsigned int x_offset, unsigned int y_offset, unsigned int blocknum_x, unsigned int blocknum_y);
// rmdCacheFileN
// file rmd_cache.c line 51
static void rmdCacheFileN(char *name, char **newname, signed int n);
// rmdCacheImageBuffer
// file rmd_cache_frame.c line 87
void * rmdCacheImageBuffer(struct _ProgData *pdata);
// rmdCacheSoundBuffer
// file rmd_cache_audio.c line 41
void * rmdCacheSoundBuffer(struct _ProgData *pdata);
// rmdCaptureSound
// file rmd_capture_sound.c line 43
void * rmdCaptureSound(struct _ProgData *pdata);
// rmdCleanUp
// file rmd_initialize_data.h line 59
void rmdCleanUp(void);
// rmdClearList
// file rmd_rectinsert.h line 52
void rmdClearList(struct _RectArea **root);
// rmdCollideRects
// file rmd_rectinsert.c line 59
static signed int rmdCollideRects(struct anonymous_17 *xrect1, struct anonymous_17 *xrect2, struct anonymous_17 *xrect_return, signed int *nrects);
// rmdDrawFrame
// file rmd_frame.c line 41
void rmdDrawFrame(struct _XDisplay *dpy, signed int screen, unsigned long int win, signed int width, signed int height);
// rmdEncodeCache
// file rmd_encode_cache.h line 38
void rmdEncodeCache(struct _ProgData *pdata);
// rmdEncodeImageBuffer
// file rmd_encode_image_buffer.c line 35
void * rmdEncodeImageBuffer(struct _ProgData *pdata);
// rmdEncodeSoundBuffer
// file rmd_encode_sound_buffer.c line 39
void * rmdEncodeSoundBuffer(struct _ProgData *pdata);
// rmdErrorHandler
// file rmd_error.h line 46
signed int rmdErrorHandler(struct _XDisplay *dpy, struct anonymous_118 *e);
// rmdEventLoop
// file rmd_poll_events.h line 46
void rmdEventLoop(struct _ProgData *pdata);
// rmdFirstFrame
// file rmd_get_frame.c line 199
static signed int rmdFirstFrame(struct _ProgData *pdata, struct _XImage **image, struct anonymous_34 *shminfo, char **pxl_data);
// rmdFixBufferSize
// file rmd_initialize_data.c line 45
static void rmdFixBufferSize(unsigned long int *buffsize);
// rmdFlushBlock
// file rmd_cache_frame.c line 47
static signed int rmdFlushBlock(unsigned char *buf, signed int blockno, signed int width, signed int height, signed int blockwidth, struct gzFile_s **fp, struct _IO_FILE *ucfp, signed int flush);
// rmdFlushToOgg
// file rmd_flush_to_ogg.h line 38
void * rmdFlushToOgg(struct _ProgData *pdata);
// rmdFrameInit
// file rmd_frame.c line 94
unsigned long int rmdFrameInit(struct _XDisplay *dpy, signed int screen, unsigned long int root, signed int x, signed int y, signed int width, signed int height);
// rmdGetFrame
// file rmd_get_frame.c line 357
void * rmdGetFrame(struct _ProgData *pdata);
// rmdGetZPixmap
// file rmd_getzpixmap.h line 55
signed int rmdGetZPixmap(struct _XDisplay *dpy, unsigned long int root, char *data, signed int x, signed int y, signed int width, signed int height);
// rmdGetZPixmapSHM
// file rmd_getzpixmap.c line 72
signed int rmdGetZPixmapSHM(struct _XDisplay *dpy, unsigned long int root, struct anonymous_34 *shminfo, signed int shm_opcode, char *data, signed int x, signed int y, signed int width, signed int height);
// rmdIncrementalNaming
// file rmd_init_encoder.c line 56
static signed int rmdIncrementalNaming(char **name);
// rmdInitCacheData
// file rmd_cache.c line 130
void rmdInitCacheData(struct _ProgData *pdata, struct _EncData *enc_data_t, struct _CacheData *cache_data_t);
// rmdInitEncoder
// file rmd_init_encoder.h line 44
void rmdInitEncoder(struct _ProgData *pdata, struct _EncData *enc_data_t, signed int buffer_ready);
// rmdInitEventsPolling
// file rmd_poll_events.h line 38
void rmdInitEventsPolling(struct _ProgData *pdata);
// rmdInitializeData
// file rmd_initialize_data.h line 45
signed int rmdInitializeData(struct _ProgData *pdata, struct _EncData *enc_data, struct _CacheData *cache_data);
// rmdJackCapture
// file rmd_jack.c line 49
static signed int rmdJackCapture(unsigned int nframes, void *jdata_t);
// rmdJackShutdown
// file rmd_jack.c line 129
static void rmdJackShutdown(void *jdata_t);
// rmdLoadBlock
// file rmd_load_cache.c line 69
static void rmdLoadBlock(unsigned char *dest, unsigned char *source, signed int blockno, signed int width, signed int height, signed int blockwidth);
// rmdLoadCache
// file rmd_load_cache.h line 39
void * rmdLoadCache(struct _ProgData *pdata);
// rmdMakeDummyPointer
// file rmd_make_dummy_pointer.h line 51
unsigned char * rmdMakeDummyPointer(struct _XDisplay *display, struct _DisplaySpecs *specs, signed int size, signed int color, signed int type, unsigned char *npxl);
// rmdMakeMatrices
// file rmd_yuv_utils.h line 377
void rmdMakeMatrices(void);
// rmdMoveCaptureArea
// file rmd_get_frame.c line 286
static void rmdMoveCaptureArea(struct _BRWindow *brwin, signed int cursor_x, signed int cursor_y, signed int width, signed int height);
// rmdMoveFrame
// file rmd_frame.c line 80
void rmdMoveFrame(struct _XDisplay *dpy, unsigned long int win, signed int x, signed int y);
// rmdOpenDev
// file rmd_opendev.h line 57
struct _snd_pcm * rmdOpenDev(const char *pcm_dev, unsigned int *channels, unsigned int *frequency, unsigned long int *buffsize, unsigned long int *periodsize, unsigned int *periodtime, signed int *hard_pause);
// rmdParseArgs
// file rmd_parseargs.h line 44
signed int rmdParseArgs(signed int argc, char **argv, struct _ProgArgs *arg_return);
// rmdPrintAndExit
// file rmd_parseargs.c line 487
static void rmdPrintAndExit(struct poptContext_s *con, enum poptCallbackReason reason, struct poptOption *opt, const char *arg, const void *data);
// rmdPurgeCache
// file rmd_cache.h line 77
signed int rmdPurgeCache(struct _CacheData *cache_data_t, signed int sound);
// rmdQueryExtensions
// file rmd_queryextensions.h line 46
void rmdQueryExtensions(struct _XDisplay *dpy, struct _ProgArgs *args, signed int *damage_event, signed int *damage_error, signed int *shm_opcode);
// rmdReadFrame
// file rmd_load_cache.c line 96
static signed int rmdReadFrame(struct _CachedFrame *frame, struct _IO_FILE *ucfp, struct gzFile_s **ifp);
// rmdReadSpecsFile
// file rmd_specsfile.h line 56
signed int rmdReadSpecsFile(struct _ProgData *pdata);
// rmdReadZF
// file rmd_load_cache.c line 85
static signed int rmdReadZF(void *buffer, unsigned long int size, unsigned long int nmemb, struct _IO_FILE *ucfp, struct gzFile_s **ifp);
// rmdRectInsert
// file rmd_rectinsert.h line 46
signed int rmdRectInsert(struct _RectArea **root, struct anonymous_17 *xrect);
// rmdRegisterCallbacks
// file rmd_register_callbacks.c line 60
void rmdRegisterCallbacks(struct _ProgData *pdata);
// rmdRegisterShortcut
// file rmd_shortcuts.h line 51
signed int rmdRegisterShortcut(struct _XDisplay *dpy, unsigned long int root, const char *shortcut, struct _HotKey *hotkey);
// rmdRescue
// file rmd_rescue.h line 39
signed int rmdRescue(const char *path);
// rmdRoundf
// file rmd_math.c line 31
double rmdRoundf(double val);
// rmdSetBRWindow
// file rmd_setbrwindow.h line 47
signed int rmdSetBRWindow(struct _XDisplay *dpy, struct _BRWindow *brwin, struct _DisplaySpecs *specs, struct _ProgArgs *args);
// rmdSetPaused
// file rmd_register_callbacks.c line 43
static void rmdSetPaused(signed int signum);
// rmdSetRunning
// file rmd_register_callbacks.c line 48
static void rmdSetRunning(signed int signum);
// rmdSetupDefaultArgs
// file rmd_initialize_data.h line 52
void rmdSetupDefaultArgs(struct _ProgArgs *args);
// rmdSetupPorts
// file rmd_jack.c line 90
static signed int rmdSetupPorts(struct _JackData *jdata);
// rmdSizePack2_8_16
// file rmd_setbrwindow.c line 45
static void rmdSizePack2_8_16(signed short int *start, unsigned short int *size, unsigned short int limit);
// rmdStartJackClient
// file rmd_jack.h line 44
signed int rmdStartJackClient(struct _JackData *jdata);
// rmdStopJackClient
// file rmd_jack.c line 194
signed int rmdStopJackClient(struct _JackData *jdata);
// rmdSwapCacheFilesRead
// file rmd_cache.c line 76
signed int rmdSwapCacheFilesRead(char *name, signed int n, struct gzFile_s ***fp, struct _IO_FILE **ucfp);
// rmdSwapCacheFilesWrite
// file rmd_cache.c line 59
signed int rmdSwapCacheFilesWrite(char *name, signed int n, struct gzFile_s ***fp, struct _IO_FILE **ucfp);
// rmdSyncEncodeImageBuffer
// file rmd_encode_image_buffer.c line 80
void rmdSyncEncodeImageBuffer(struct _ProgData *pdata);
// rmdSyncEncodeSoundBuffer
// file rmd_encode_sound_buffer.c line 146
void rmdSyncEncodeSoundBuffer(struct _ProgData *pdata, signed char *buff);
// rmdThreads
// file rmd_threads.h line 40
void rmdThreads(struct _ProgData *pdata);
// rmdTimer
// file rmd_timer.h line 41
void * rmdTimer(struct _ProgData *pdata);
// rmdUpdateImage
// file rmd_update_image.h line 58
void rmdUpdateImage(struct _XDisplay *dpy, struct anonymous_45 *yuv, struct _DisplaySpecs *specs, struct _RectArea **root, struct _BRWindow *brwin, struct _EncData *enc, char *datatemp, signed int noshmem, struct anonymous_34 *shminfo, signed int shm_opcode, signed int no_quick_subsample);
// rmdValidateArguments
// file rmd_parseargs.c line 435
static signed int rmdValidateArguments(const struct _ProgArgs *args);
// rmdWMCheck
// file rmd_wm_check.c line 36
char * rmdWMCheck(struct _XDisplay *dpy, unsigned long int root);
// rmdWMIsCompositing
// file rmd_wm_is_compositing.h line 46
signed int rmdWMIsCompositing(struct _XDisplay *dpy, signed int screen);
// rmdWriteSpecsFile
// file rmd_specsfile.h line 42
signed int rmdWriteSpecsFile(struct _ProgData *pdata);
// shmat
// file /usr/include/x86_64-linux-gnu/sys/shm.h line 56
extern void * shmat(signed int, const void *, signed int);
// shmctl
// file /usr/include/x86_64-linux-gnu/sys/shm.h line 50
extern signed int shmctl(signed int, signed int, struct shmid_ds *);
// shmdt
// file /usr/include/x86_64-linux-gnu/sys/shm.h line 60
extern signed int shmdt(const void *);
// shmget
// file /usr/include/x86_64-linux-gnu/sys/shm.h line 53
extern signed int shmget(signed int, unsigned long int, signed int);
// sigaction
// file /usr/include/signal.h line 259
extern signed int sigaction(signed int, struct sigaction *, struct sigaction *);
// sigfillset
// file /usr/include/signal.h line 218
extern signed int sigfillset(struct anonymous_2 *);
// sleep
// file /usr/include/unistd.h line 444
extern unsigned int sleep(unsigned int);
// snd_pcm_close
// file /usr/include/alsa/pcm.h line 459
signed int snd_pcm_close(struct _snd_pcm *);
// snd_pcm_format_width
// file /usr/include/alsa/pcm.h line 1062
signed int snd_pcm_format_width(enum _snd_pcm_format);
// snd_pcm_hw_params
// file /usr/include/alsa/pcm.h line 473
signed int snd_pcm_hw_params(struct _snd_pcm *, struct _snd_pcm_hw_params *);
// snd_pcm_hw_params_any
// file /usr/include/alsa/pcm.h line 657
signed int snd_pcm_hw_params_any(struct _snd_pcm *, struct _snd_pcm_hw_params *);
// snd_pcm_hw_params_can_pause
// file /usr/include/alsa/pcm.h line 665
signed int snd_pcm_hw_params_can_pause(const struct _snd_pcm_hw_params *);
// snd_pcm_hw_params_get_period_size
// file /usr/include/alsa/pcm.h line 782
signed int snd_pcm_hw_params_get_period_size(const struct _snd_pcm_hw_params *, unsigned long int *, signed int *);
// snd_pcm_hw_params_get_period_time
// file /usr/include/alsa/pcm.h line 770
signed int snd_pcm_hw_params_get_period_time(const struct _snd_pcm_hw_params *, unsigned int *, signed int *);
// snd_pcm_hw_params_set_access
// file /usr/include/alsa/pcm.h line 718
signed int snd_pcm_hw_params_set_access(struct _snd_pcm *, struct _snd_pcm_hw_params *, enum _snd_pcm_access);
// snd_pcm_hw_params_set_buffer_size_near
// file /usr/include/alsa/pcm.h line 828
signed int snd_pcm_hw_params_set_buffer_size_near(struct _snd_pcm *, struct _snd_pcm_hw_params *, unsigned long int *);
// snd_pcm_hw_params_set_channels_near
// file /usr/include/alsa/pcm.h line 748
signed int snd_pcm_hw_params_set_channels_near(struct _snd_pcm *, struct _snd_pcm_hw_params *, unsigned int *);
// snd_pcm_hw_params_set_format
// file /usr/include/alsa/pcm.h line 726
signed int snd_pcm_hw_params_set_format(struct _snd_pcm *, struct _snd_pcm_hw_params *, enum _snd_pcm_format);
// snd_pcm_hw_params_set_periods_near
// file /usr/include/alsa/pcm.h line 803
signed int snd_pcm_hw_params_set_periods_near(struct _snd_pcm *, struct _snd_pcm_hw_params *, unsigned int *, signed int *);
// snd_pcm_hw_params_set_rate_near
// file /usr/include/alsa/pcm.h line 760
signed int snd_pcm_hw_params_set_rate_near(struct _snd_pcm *, struct _snd_pcm_hw_params *, unsigned int *, signed int *);
// snd_pcm_hw_params_sizeof
// file /usr/include/alsa/pcm.h line 704
unsigned long int snd_pcm_hw_params_sizeof(void);
// snd_pcm_open
// file /usr/include/alsa/pcm.h line 450
signed int snd_pcm_open(struct _snd_pcm **, const char *, enum _snd_pcm_stream, signed int);
// snd_pcm_pause
// file /usr/include/alsa/pcm.h line 483
signed int snd_pcm_pause(struct _snd_pcm *, signed int);
// snd_pcm_prepare
// file /usr/include/alsa/pcm.h line 477
signed int snd_pcm_prepare(struct _snd_pcm *);
// snd_pcm_readi
// file /usr/include/alsa/pcm.h line 497
signed long int snd_pcm_readi(struct _snd_pcm *, void *, unsigned long int);
// snd_strerror
// file /usr/include/alsa/error.h line 45
const char * snd_strerror(signed int);
// snprintf
// file /usr/include/stdio.h line 386
extern signed int snprintf(char *, unsigned long int, const char *, ...);
// srand
// file /usr/include/stdlib.h line 376
extern void srand(unsigned int);
// stat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 208
extern signed int stat(const char *, struct stat *);
// strcat
// file /usr/include/string.h line 137
extern char * strcat(char *, const char *);
// strcmp
// file /usr/include/string.h line 144
extern signed int strcmp(const char *, const char *);
// strcpy
// file /usr/include/string.h line 129
extern char * strcpy(char *, const char *);
// strdup
// file /usr/include/string.h line 175
extern char * strdup(const char *);
// strlen
// file /usr/include/string.h line 398
extern unsigned long int strlen(const char *);
// strncpy
// file /usr/include/string.h line 132
extern char * strncpy(char *, const char *, unsigned long int);
// strstr
// file /usr/include/string.h line 341
extern char * strstr(const char *, const char *);
// theora_comment_add_tag
// file /usr/include/theora/theora.h line 732
extern void theora_comment_add_tag(struct theora_comment *, char *, char *);
// theora_comment_init
// file /usr/include/theora/theora.h line 704
extern void theora_comment_init(struct theora_comment *);
// theora_encode_YUVin
// file /usr/include/theora/theora.h line 462
extern signed int theora_encode_YUVin(struct anonymous_13 *, struct anonymous_45 *);
// theora_encode_comment
// file /usr/include/theora/theora.h line 502
extern signed int theora_encode_comment(struct theora_comment *, struct anonymous_126 *);
// theora_encode_header
// file /usr/include/theora/theora.h line 489
extern signed int theora_encode_header(struct anonymous_13 *, struct anonymous_126 *);
// theora_encode_init
// file /usr/include/theora/theora.h line 450
extern signed int theora_encode_init(struct anonymous_13 *, struct anonymous_127 *);
// theora_encode_packetout
// file /usr/include/theora/theora.h line 476
extern signed int theora_encode_packetout(struct anonymous_13 *, signed int, struct anonymous_126 *);
// theora_encode_tables
// file /usr/include/theora/theora.h line 514
extern signed int theora_encode_tables(struct anonymous_13 *, struct anonymous_126 *);
// theora_granule_shift
// file /usr/include/theora/theora.h line 642
signed int theora_granule_shift(struct anonymous_127 *);
// theora_granule_time
// file /usr/include/theora/theora.h line 677
extern double theora_granule_time(struct anonymous_13 *, signed long int);
// theora_info_clear
// file /usr/include/theora/theora.h line 692
extern void theora_info_clear(struct anonymous_127 *);
// theora_info_init
// file /usr/include/theora/theora.h line 685
extern void theora_info_init(struct anonymous_127 *);
// time
// file /usr/include/time.h line 192
extern signed long int time(signed long int *);
// usleep
// file /usr/include/unistd.h line 460
extern signed int usleep(unsigned int);
// vorbis_analysis
// file /usr/include/vorbis/codec.h line 196
extern signed int vorbis_analysis(struct vorbis_block *, struct anonymous_126 *);
// vorbis_analysis_blockout
// file /usr/include/vorbis/codec.h line 195
extern signed int vorbis_analysis_blockout(struct vorbis_dsp_state *, struct vorbis_block *);
// vorbis_analysis_buffer
// file /usr/include/vorbis/codec.h line 193
extern float ** vorbis_analysis_buffer(struct vorbis_dsp_state *, signed int);
// vorbis_analysis_headerout
// file /usr/include/vorbis/codec.h line 188
extern signed int vorbis_analysis_headerout(struct vorbis_dsp_state *, struct vorbis_comment *, struct anonymous_126 *, struct anonymous_126 *, struct anonymous_126 *);
// vorbis_analysis_init
// file /usr/include/vorbis/codec.h line 186
extern signed int vorbis_analysis_init(struct vorbis_dsp_state *, struct vorbis_info *);
// vorbis_analysis_wrote
// file /usr/include/vorbis/codec.h line 194
extern signed int vorbis_analysis_wrote(struct vorbis_dsp_state *, signed int);
// vorbis_bitrate_addblock
// file /usr/include/vorbis/codec.h line 198
extern signed int vorbis_bitrate_addblock(struct vorbis_block *);
// vorbis_bitrate_flushpacket
// file /usr/include/vorbis/codec.h line 199
extern signed int vorbis_bitrate_flushpacket(struct vorbis_dsp_state *, struct anonymous_126 *);
// vorbis_block_init
// file /usr/include/vorbis/codec.h line 176
extern signed int vorbis_block_init(struct vorbis_dsp_state *, struct vorbis_block *);
// vorbis_comment_init
// file /usr/include/vorbis/codec.h line 168
extern void vorbis_comment_init(struct vorbis_comment *);
// vorbis_encode_init_vbr
// file /usr/include/vorbis/vorbisenc.h line 158
extern signed int vorbis_encode_init_vbr(struct vorbis_info *, signed long int, signed long int, float);
// vorbis_granule_time
// file /usr/include/vorbis/codec.h line 179
extern double vorbis_granule_time(struct vorbis_dsp_state *, signed long int);
// vorbis_info_init
// file /usr/include/vorbis/codec.h line 165
extern void vorbis_info_init(struct vorbis_info *);
// write_ogg_page_to_file
// file skeleton.c line 81
extern signed int write_ogg_page_to_file(struct anonymous_15 *og, struct _IO_FILE *out);

struct anonymous_85
{
  // buf
  char *buf;
  // write_ptr
  volatile unsigned long int write_ptr;
  // read_ptr
  volatile unsigned long int read_ptr;
  // size
  unsigned long int size;
  // size_mask
  unsigned long int size_mask;
  // mlocked
  signed int mlocked;
};

struct anonymous_122
{
  // defaultCCCs
  char *defaultCCCs;
  // clientCmaps
  char *clientCmaps;
  // perVisualIntensityMaps
  char *perVisualIntensityMaps;
};

struct anonymous_13
{
  // i
  struct anonymous_127 *i;
  // granulepos
  signed long int granulepos;
  // internal_encode
  void *internal_encode;
  // internal_decode
  void *internal_decode;
};

struct anonymous_93
{
  // ext_data
  struct _XExtData *ext_data;
  // display
  struct _XDisplay *display;
  // root
  unsigned long int root;
  // width
  signed int width;
  // height
  signed int height;
  // mwidth
  signed int mwidth;
  // mheight
  signed int mheight;
  // ndepths
  signed int ndepths;
  // depths
  struct anonymous_142 *depths;
  // root_depth
  signed int root_depth;
  // root_visual
  struct anonymous_21 *root_visual;
  // default_gc
  struct _XGC *default_gc;
  // cmap
  unsigned long int cmap;
  // white_pixel
  unsigned long int white_pixel;
  // black_pixel
  unsigned long int black_pixel;
  // max_maps
  signed int max_maps;
  // min_maps
  signed int min_maps;
  // backing_store
  signed int backing_store;
  // save_unders
  signed int save_unders;
  // root_input_mask
  signed long int root_input_mask;
};

struct anonymous_146
{
  // ext_data
  struct _XExtData *ext_data;
  // private1
  struct _XPrivate *private1;
  // fd
  signed int fd;
  // private2
  signed int private2;
  // proto_major_version
  signed int proto_major_version;
  // proto_minor_version
  signed int proto_minor_version;
  // vendor
  char *vendor;
  // private3
  unsigned long int private3;
  // private4
  unsigned long int private4;
  // private5
  unsigned long int private5;
  // private6
  signed int private6;
  // resource_alloc
  unsigned long int (*resource_alloc)(struct _XDisplay *);
  // byte_order
  signed int byte_order;
  // bitmap_unit
  signed int bitmap_unit;
  // bitmap_pad
  signed int bitmap_pad;
  // bitmap_bit_order
  signed int bitmap_bit_order;
  // nformats
  signed int nformats;
  // pixmap_format
  struct anonymous_90 *pixmap_format;
  // private8
  signed int private8;
  // release
  signed int release;
  // private9
  struct _XPrivate *private9;
  // private10
  struct _XPrivate *private10;
  // qlen
  signed int qlen;
  // last_request_read
  unsigned long int last_request_read;
  // request
  unsigned long int request;
  // private11
  char *private11;
  // private12
  char *private12;
  // private13
  char *private13;
  // private14
  char *private14;
  // max_request_size
  unsigned int max_request_size;
  // db
  struct _XrmHashBucketRec *db;
  // private15
  signed int (*private15)(struct _XDisplay *);
  // display_name
  char *display_name;
  // default_screen
  signed int default_screen;
  // nscreens
  signed int nscreens;
  // screens
  struct anonymous_93 *screens;
  // motion_buffer
  unsigned long int motion_buffer;
  // private16
  unsigned long int private16;
  // min_keycode
  signed int min_keycode;
  // max_keycode
  signed int max_keycode;
  // private17
  char *private17;
  // private18
  char *private18;
  // private19
  signed int private19;
  // xdefaults
  char *xdefaults;
};

struct anonymous_90
{
  // ext_data
  struct _XExtData *ext_data;
  // depth
  signed int depth;
  // bits_per_pixel
  signed int bits_per_pixel;
  // scanline_pad
  signed int scanline_pad;
};

struct anonymous_130
{
  // lbearing
  signed short int lbearing;
  // rbearing
  signed short int rbearing;
  // width
  signed short int width;
  // ascent
  signed short int ascent;
  // descent
  signed short int descent;
  // attributes
  unsigned short int attributes;
};

struct anonymous_92
{
  // ext_data
  struct _XExtData *ext_data;
  // fid
  unsigned long int fid;
  // direction
  unsigned int direction;
  // min_char_or_byte2
  unsigned int min_char_or_byte2;
  // max_char_or_byte2
  unsigned int max_char_or_byte2;
  // min_byte1
  unsigned int min_byte1;
  // max_byte1
  unsigned int max_byte1;
  // all_chars_exist
  signed int all_chars_exist;
  // default_char
  unsigned int default_char;
  // n_properties
  signed int n_properties;
  // properties
  struct anonymous_129 *properties;
  // min_bounds
  struct anonymous_130 min_bounds;
  // max_bounds
  struct anonymous_130 max_bounds;
  // per_char
  struct anonymous_130 *per_char;
  // ascent
  signed int ascent;
  // descent
  signed int descent;
};

struct anonymous_21
{
  // ext_data
  struct _XExtData *ext_data;
  // visualid
  unsigned long int visualid;
  // class
  signed int class;
  // red_mask
  unsigned long int red_mask;
  // green_mask
  unsigned long int green_mask;
  // blue_mask
  unsigned long int blue_mask;
  // bits_per_rgb
  signed int bits_per_rgb;
  // map_entries
  signed int map_entries;
};

struct anonymous_14
{
  // body_data
  unsigned char *body_data;
  // body_storage
  signed long int body_storage;
  // body_fill
  signed long int body_fill;
  // body_returned
  signed long int body_returned;
  // lacing_vals
  signed int *lacing_vals;
  // granule_vals
  signed long int *granule_vals;
  // lacing_storage
  signed long int lacing_storage;
  // lacing_fill
  signed long int lacing_fill;
  // lacing_packet
  signed long int lacing_packet;
  // lacing_returned
  signed long int lacing_returned;
  // header
  unsigned char header[282l];
  // header_fill
  signed int header_fill;
  // e_o_s
  signed int e_o_s;
  // b_o_s
  signed int b_o_s;
  // serialno
  signed long int serialno;
  // pageno
  signed long int pageno;
  // packetno
  signed long int packetno;
  // granulepos
  signed long int granulepos;
};

struct anonymous_15
{
  // header
  unsigned char *header;
  // header_len
  signed long int header_len;
  // body
  unsigned char *body;
  // body_len
  signed long int body_len;
};

struct anonymous_126
{
  // packet
  unsigned char *packet;
  // bytes
  signed long int bytes;
  // b_o_s
  signed long int b_o_s;
  // e_o_s
  signed long int e_o_s;
  // granulepos
  signed long int granulepos;
  // packetno
  signed long int packetno;
};

struct anonymous_9
{
  // _call_addr
  void *_call_addr;
  // _syscall
  signed int _syscall;
  // _arch
  unsigned int _arch;
};

struct anonymous_7
{
  // si_addr
  void *si_addr;
  // si_addr_lsb
  signed short int si_addr_lsb;
};

struct anonymous_2
{
  // __val
  unsigned long int __val[16l];
};

struct anonymous_17
{
  // x
  signed short int x;
  // y
  signed short int y;
  // width
  unsigned short int width;
  // height
  unsigned short int height;
};

struct anonymous_31
{
  // x
  signed short int x;
  // y
  signed short int y;
  // width
  unsigned short int width;
  // height
  unsigned short int height;
  // xhot
  unsigned short int xhot;
  // yhot
  unsigned short int yhot;
  // cursor_serial
  unsigned long int cursor_serial;
  // pixels
  unsigned long int *pixels;
  // atom
  unsigned long int atom;
  // name
  const char *name;
};

struct anonymous_131
{
  // __lock
  signed int __lock;
  // __futex
  unsigned int __futex;
  // __total_seq
  unsigned long long int __total_seq;
  // __wakeup_seq
  unsigned long long int __wakeup_seq;
  // __woken_seq
  unsigned long long int __woken_seq;
  // __mutex
  void *__mutex;
  // __nwaiters
  unsigned int __nwaiters;
  // __broadcast_seq
  unsigned int __broadcast_seq;
};

struct anonymous_142
{
  // depth
  signed int depth;
  // nvisuals
  signed int nvisuals;
  // visuals
  struct anonymous_21 *visuals;
};

struct anonymous_91
{
  // extension
  signed int extension;
  // major_opcode
  signed int major_opcode;
  // first_event
  signed int first_event;
  // first_error
  signed int first_error;
};

struct anonymous_16
{
  // function
  signed int function;
  // plane_mask
  unsigned long int plane_mask;
  // foreground
  unsigned long int foreground;
  // background
  unsigned long int background;
  // line_width
  signed int line_width;
  // line_style
  signed int line_style;
  // cap_style
  signed int cap_style;
  // join_style
  signed int join_style;
  // fill_style
  signed int fill_style;
  // fill_rule
  signed int fill_rule;
  // arc_mode
  signed int arc_mode;
  // tile
  unsigned long int tile;
  // stipple
  unsigned long int stipple;
  // ts_x_origin
  signed int ts_x_origin;
  // ts_y_origin
  signed int ts_y_origin;
  // font
  unsigned long int font;
  // subwindow_mode
  signed int subwindow_mode;
  // graphics_exposures
  signed int graphics_exposures;
  // clip_x_origin
  signed int clip_x_origin;
  // clip_y_origin
  signed int clip_y_origin;
  // clip_mask
  unsigned long int clip_mask;
  // dash_offset
  signed int dash_offset;
  // dashes
  char dashes;
};

struct anonymous_95
{
  // max_keypermod
  signed int max_keypermod;
  // modifiermap
  unsigned char *modifiermap;
};

struct anonymous_3
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
};

struct anonymous_6
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
  // si_status
  signed int si_status;
  // si_utime
  signed long int si_utime;
  // si_stime
  signed long int si_stime;
};

union sigval
{
  // sival_int
  signed int sival_int;
  // sival_ptr
  void *sival_ptr;
};

struct anonymous_5
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
  // si_sigval
  union sigval si_sigval;
};

struct anonymous_4
{
  // si_tid
  signed int si_tid;
  // si_overrun
  signed int si_overrun;
  // si_sigval
  union sigval si_sigval;
};

struct anonymous_8
{
  // si_band
  signed long int si_band;
  // si_fd
  signed int si_fd;
};

union anonymous_10
{
  // _pad
  signed int _pad[28l];
  // _kill
  struct anonymous_3 _kill;
  // _timer
  struct anonymous_4 _timer;
  // _rt
  struct anonymous_5 _rt;
  // _sigchld
  struct anonymous_6 _sigchld;
  // _sigfault
  struct anonymous_7 _sigfault;
  // _sigpoll
  struct anonymous_8 _sigpoll;
  // _sigsys
  struct anonymous_9 _sigsys;
};

struct anonymous_11
{
  // si_signo
  signed int si_signo;
  // si_errno
  signed int si_errno;
  // si_code
  signed int si_code;
  // _sifields
  union anonymous_10 _sifields;
};

struct anonymous_118
{
  // type
  signed int type;
  // display
  struct _XDisplay *display;
  // resourceid
  unsigned long int resourceid;
  // serial
  unsigned long int serial;
  // error_code
  unsigned char error_code;
  // request_code
  unsigned char request_code;
  // minor_code
  unsigned char minor_code;
};

struct anonymous_124
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // extension
  signed int extension;
  // evtype
  signed int evtype;
};

struct anonymous_125
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // extension
  signed int extension;
  // evtype
  signed int evtype;
  // cookie
  unsigned int cookie;
  // data
  void *data;
};

struct anonymous_99
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // drawable
  unsigned long int drawable;
  // major_code
  signed int major_code;
  // minor_code
  signed int minor_code;
};

struct anonymous_98
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // drawable
  unsigned long int drawable;
  // x
  signed int x;
  // y
  signed int y;
  // width
  signed int width;
  // height
  signed int height;
  // count
  signed int count;
  // major_code
  signed int major_code;
  // minor_code
  signed int minor_code;
};

struct anonymous_1
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // drawable
  unsigned long int drawable;
  // damage
  unsigned long int damage;
  // level
  signed int level;
  // more
  signed int more;
  // timestamp
  unsigned long int timestamp;
  // area
  struct anonymous_17 area;
  // geometry
  struct anonymous_17 geometry;
};

struct anonymous_102
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // event
  unsigned long int event;
  // window
  unsigned long int window;
};

struct anonymous_103
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // event
  unsigned long int event;
  // window
  unsigned long int window;
  // from_configure
  signed int from_configure;
};

struct anonymous_104
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // event
  unsigned long int event;
  // window
  unsigned long int window;
  // override_redirect
  signed int override_redirect;
};

struct anonymous_111
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // event
  unsigned long int event;
  // window
  unsigned long int window;
  // place
  signed int place;
};

struct anonymous_108
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // event
  unsigned long int event;
  // window
  unsigned long int window;
  // x
  signed int x;
  // y
  signed int y;
};

struct anonymous_107
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // event
  unsigned long int event;
  // window
  unsigned long int window;
  // x
  signed int x;
  // y
  signed int y;
  // width
  signed int width;
  // height
  signed int height;
  // border_width
  signed int border_width;
  // above
  unsigned long int above;
  // override_redirect
  signed int override_redirect;
};

struct anonymous_106
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // event
  unsigned long int event;
  // window
  unsigned long int window;
  // parent
  unsigned long int parent;
  // x
  signed int x;
  // y
  signed int y;
  // override_redirect
  signed int override_redirect;
};

struct anonymous_115
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // owner
  unsigned long int owner;
  // requestor
  unsigned long int requestor;
  // selection
  unsigned long int selection;
  // target
  unsigned long int target;
  // property
  unsigned long int property;
  // time
  unsigned long int time;
};

struct anonymous_105
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // parent
  unsigned long int parent;
  // window
  unsigned long int window;
};

struct anonymous_112
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // parent
  unsigned long int parent;
  // window
  unsigned long int window;
  // place
  signed int place;
};

struct anonymous_101
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // parent
  unsigned long int parent;
  // window
  unsigned long int window;
  // x
  signed int x;
  // y
  signed int y;
  // width
  signed int width;
  // height
  signed int height;
  // border_width
  signed int border_width;
  // override_redirect
  signed int override_redirect;
};

struct anonymous_110
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // parent
  unsigned long int parent;
  // window
  unsigned long int window;
  // x
  signed int x;
  // y
  signed int y;
  // width
  signed int width;
  // height
  signed int height;
  // border_width
  signed int border_width;
  // above
  unsigned long int above;
  // detail
  signed int detail;
  // value_mask
  unsigned long int value_mask;
};

struct anonymous_116
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // requestor
  unsigned long int requestor;
  // selection
  unsigned long int selection;
  // target
  unsigned long int target;
  // property
  unsigned long int property;
  // time
  unsigned long int time;
};

struct anonymous_94
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
};

struct anonymous_123
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // key_vector
  char key_vector[32l];
};

struct anonymous_96
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // mode
  signed int mode;
  // detail
  signed int detail;
};

struct anonymous_120
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // request
  signed int request;
  // first_keycode
  signed int first_keycode;
  // count
  signed int count;
};

struct anonymous_100
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // state
  signed int state;
};

struct anonymous_109
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // width
  signed int width;
  // height
  signed int height;
};

struct anonymous_97
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // x
  signed int x;
  // y
  signed int y;
  // width
  signed int width;
  // height
  signed int height;
  // count
  signed int count;
};

struct anonymous_113
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // atom
  unsigned long int atom;
  // time
  unsigned long int time;
  // state
  signed int state;
};

struct anonymous_117
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // colormap
  unsigned long int colormap;
  // new
  signed int new;
  // state
  signed int state;
};

union anonymous_128
{
  // b
  char b[20l];
  // s
  signed short int s[10l];
  // l
  signed long int l[5l];
};

struct anonymous_119
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // message_type
  unsigned long int message_type;
  // format
  signed int format;
  // data
  union anonymous_128 data;
};

struct anonymous_89
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // root
  unsigned long int root;
  // subwindow
  unsigned long int subwindow;
  // time
  unsigned long int time;
  // x
  signed int x;
  // y
  signed int y;
  // x_root
  signed int x_root;
  // y_root
  signed int y_root;
  // mode
  signed int mode;
  // detail
  signed int detail;
  // same_screen
  signed int same_screen;
  // focus
  signed int focus;
  // state
  unsigned int state;
};

struct anonymous_88
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // root
  unsigned long int root;
  // subwindow
  unsigned long int subwindow;
  // time
  unsigned long int time;
  // x
  signed int x;
  // y
  signed int y;
  // x_root
  signed int x_root;
  // y_root
  signed int y_root;
  // state
  unsigned int state;
  // is_hint
  char is_hint;
  // same_screen
  signed int same_screen;
};

struct anonymous_87
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // root
  unsigned long int root;
  // subwindow
  unsigned long int subwindow;
  // time
  unsigned long int time;
  // x
  signed int x;
  // y
  signed int y;
  // x_root
  signed int x_root;
  // y_root
  signed int y_root;
  // state
  unsigned int state;
  // button
  unsigned int button;
  // same_screen
  signed int same_screen;
};

struct anonymous_0
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // root
  unsigned long int root;
  // subwindow
  unsigned long int subwindow;
  // time
  unsigned long int time;
  // x
  signed int x;
  // y
  signed int y;
  // x_root
  signed int x_root;
  // y_root
  signed int y_root;
  // state
  unsigned int state;
  // keycode
  unsigned int keycode;
  // same_screen
  signed int same_screen;
};

struct anonymous_114
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // selection
  unsigned long int selection;
  // time
  unsigned long int time;
};

struct anonymous
{
  // x
  signed int x;
  // y
  signed int y;
  // width
  signed int width;
  // height
  signed int height;
  // border_width
  signed int border_width;
  // depth
  signed int depth;
  // visual
  struct anonymous_21 *visual;
  // root
  unsigned long int root;
  // class
  signed int class;
  // bit_gravity
  signed int bit_gravity;
  // win_gravity
  signed int win_gravity;
  // backing_store
  signed int backing_store;
  // backing_planes
  unsigned long int backing_planes;
  // backing_pixel
  unsigned long int backing_pixel;
  // save_under
  signed int save_under;
  // colormap
  unsigned long int colormap;
  // map_installed
  signed int map_installed;
  // map_state
  signed int map_state;
  // all_event_masks
  signed long int all_event_masks;
  // your_event_mask
  signed long int your_event_mask;
  // do_not_propagate_mask
  signed long int do_not_propagate_mask;
  // override_redirect
  signed int override_redirect;
  // screen
  struct anonymous_93 *screen;
};

struct anonymous_45
{
  // y_width
  signed int y_width;
  // y_height
  signed int y_height;
  // y_stride
  signed int y_stride;
  // uv_width
  signed int uv_width;
  // uv_height
  signed int uv_height;
  // uv_stride
  signed int uv_stride;
  // y
  unsigned char *y;
  // u
  unsigned char *u;
  // v
  unsigned char *v;
};

struct anonymous_145
{
  // endbyte
  signed long int endbyte;
  // endbit
  signed int endbit;
  // buffer
  unsigned char *buffer;
  // ptr
  unsigned char *ptr;
  // storage
  signed long int storage;
};

struct anonymous_140
{
  // version_major
  unsigned short int version_major;
  // version_minor
  unsigned short int version_minor;
  // ptime_n
  signed long int ptime_n;
  // ptime_d
  signed long int ptime_d;
  // btime_n
  signed long int btime_n;
  // btime_d
  signed long int btime_d;
  // UTC
  unsigned char UTC[20l];
};

struct anonymous_64
{
  // pad00
  unsigned int pad00;
  // drawable
  unsigned int drawable;
  // minorEvent
  unsigned short int minorEvent;
  // majorEvent
  unsigned char majorEvent;
  // bpad
  unsigned char bpad;
};

struct anonymous_63
{
  // pad00
  unsigned int pad00;
  // drawable
  unsigned int drawable;
  // x
  unsigned short int x;
  // y
  unsigned short int y;
  // width
  unsigned short int width;
  // height
  unsigned short int height;
  // minorEvent
  unsigned short int minorEvent;
  // count
  unsigned short int count;
  // majorEvent
  unsigned char majorEvent;
  // pad1
  unsigned char pad1;
  // pad2
  unsigned char pad2;
  // pad3
  unsigned char pad3;
};

struct anonymous_67
{
  // pad00
  unsigned int pad00;
  // event
  unsigned int event;
  // window
  unsigned int window;
};

struct anonymous_74
{
  // pad00
  unsigned int pad00;
  // event
  unsigned int event;
  // window
  unsigned int window;
  // x
  signed short int x;
  // y
  signed short int y;
  // pad1
  unsigned int pad1;
  // pad2
  unsigned int pad2;
  // pad3
  unsigned int pad3;
  // pad4
  unsigned int pad4;
};

struct anonymous_72
{
  // pad00
  unsigned int pad00;
  // event
  unsigned int event;
  // window
  unsigned int window;
  // aboveSibling
  unsigned int aboveSibling;
  // x
  signed short int x;
  // y
  signed short int y;
  // width
  unsigned short int width;
  // height
  unsigned short int height;
  // borderWidth
  unsigned short int borderWidth;
  // override
  unsigned char override;
  // bpad
  unsigned char bpad;
};

struct anonymous_71
{
  // pad00
  unsigned int pad00;
  // event
  unsigned int event;
  // window
  unsigned int window;
  // parent
  unsigned int parent;
  // x
  signed short int x;
  // y
  signed short int y;
  // override
  unsigned char override;
  // pad1
  unsigned char pad1;
  // pad2
  unsigned char pad2;
  // pad3
  unsigned char pad3;
};

struct anonymous_76
{
  // pad00
  unsigned int pad00;
  // event
  unsigned int event;
  // window
  unsigned int window;
  // parent
  unsigned int parent;
  // place
  unsigned char place;
  // pad1
  unsigned char pad1;
  // pad2
  unsigned char pad2;
  // pad3
  unsigned char pad3;
};

struct anonymous_68
{
  // pad00
  unsigned int pad00;
  // event
  unsigned int event;
  // window
  unsigned int window;
  // fromConfigure
  unsigned char fromConfigure;
  // pad1
  unsigned char pad1;
  // pad2
  unsigned char pad2;
  // pad3
  unsigned char pad3;
};

struct anonymous_69
{
  // pad00
  unsigned int pad00;
  // event
  unsigned int event;
  // window
  unsigned int window;
  // override
  unsigned char override;
  // pad1
  unsigned char pad1;
  // pad2
  unsigned char pad2;
  // pad3
  unsigned char pad3;
};

struct anonymous_70
{
  // pad00
  unsigned int pad00;
  // parent
  unsigned int parent;
  // window
  unsigned int window;
};

struct anonymous_66
{
  // pad00
  unsigned int pad00;
  // parent
  unsigned int parent;
  // window
  unsigned int window;
  // x
  signed short int x;
  // y
  signed short int y;
  // width
  unsigned short int width;
  // height
  unsigned short int height;
  // borderWidth
  unsigned short int borderWidth;
  // override
  unsigned char override;
  // bpad
  unsigned char bpad;
};

struct anonymous_73
{
  // pad00
  unsigned int pad00;
  // parent
  unsigned int parent;
  // window
  unsigned int window;
  // sibling
  unsigned int sibling;
  // x
  signed short int x;
  // y
  signed short int y;
  // width
  unsigned short int width;
  // height
  unsigned short int height;
  // borderWidth
  unsigned short int borderWidth;
  // valueMask
  unsigned short int valueMask;
  // pad1
  unsigned int pad1;
};

struct anonymous_79
{
  // pad00
  unsigned int pad00;
  // time
  unsigned int time;
  // owner
  unsigned int owner;
  // requestor
  unsigned int requestor;
  // selection
  unsigned int selection;
  // target
  unsigned int target;
  // property
  unsigned int property;
};

struct anonymous_80
{
  // pad00
  unsigned int pad00;
  // time
  unsigned int time;
  // requestor
  unsigned int requestor;
  // selection
  unsigned int selection;
  // target
  unsigned int target;
  // property
  unsigned int property;
};

struct anonymous_60
{
  // pad00
  unsigned int pad00;
  // time
  unsigned int time;
  // root
  unsigned int root;
  // event
  unsigned int event;
  // child
  unsigned int child;
  // rootX
  signed short int rootX;
  // rootY
  signed short int rootY;
  // eventX
  signed short int eventX;
  // eventY
  signed short int eventY;
  // state
  unsigned short int state;
  // mode
  unsigned char mode;
  // flags
  unsigned char flags;
};

struct anonymous_59
{
  // pad00
  unsigned int pad00;
  // time
  unsigned int time;
  // root
  unsigned int root;
  // event
  unsigned int event;
  // child
  unsigned int child;
  // rootX
  signed short int rootX;
  // rootY
  signed short int rootY;
  // eventX
  signed short int eventX;
  // eventY
  signed short int eventY;
  // state
  unsigned short int state;
  // sameScreen
  unsigned char sameScreen;
  // pad1
  unsigned char pad1;
};

struct anonymous_78
{
  // pad00
  unsigned int pad00;
  // time
  unsigned int time;
  // window
  unsigned int window;
  // atom
  unsigned int atom;
};

struct anonymous_135
{
  // type
  unsigned int type;
  // longs0
  signed int longs0;
  // longs1
  signed int longs1;
  // longs2
  signed int longs2;
  // longs3
  signed int longs3;
  // longs4
  signed int longs4;
};

struct anonymous_136
{
  // type
  unsigned int type;
  // shorts0
  signed short int shorts0;
  // shorts1
  signed short int shorts1;
  // shorts2
  signed short int shorts2;
  // shorts3
  signed short int shorts3;
  // shorts4
  signed short int shorts4;
  // shorts5
  signed short int shorts5;
  // shorts6
  signed short int shorts6;
  // shorts7
  signed short int shorts7;
  // shorts8
  signed short int shorts8;
  // shorts9
  signed short int shorts9;
};

struct anonymous_137
{
  // type
  unsigned int type;
  // bytes
  signed char bytes[20l];
};

union anonymous_138
{
  // l
  struct anonymous_135 l;
  // s
  struct anonymous_136 s;
  // b
  struct anonymous_137 b;
};

struct anonymous_84
{
  // pad00
  unsigned int pad00;
  // window
  unsigned int window;
  // u
  union anonymous_138 u;
};

struct anonymous_75
{
  // pad00
  unsigned int pad00;
  // window
  unsigned int window;
  // width
  unsigned short int width;
  // height
  unsigned short int height;
};

struct anonymous_62
{
  // pad00
  unsigned int pad00;
  // window
  unsigned int window;
  // x
  unsigned short int x;
  // y
  unsigned short int y;
  // width
  unsigned short int width;
  // height
  unsigned short int height;
  // count
  unsigned short int count;
  // pad2
  unsigned short int pad2;
};

struct anonymous_77
{
  // pad00
  unsigned int pad00;
  // window
  unsigned int window;
  // atom
  unsigned int atom;
  // time
  unsigned int time;
  // state
  unsigned char state;
  // pad1
  unsigned char pad1;
  // pad2
  unsigned short int pad2;
};

struct anonymous_81
{
  // pad00
  unsigned int pad00;
  // window
  unsigned int window;
  // colormap
  unsigned int colormap;
  // new
  unsigned char new;
  // state
  unsigned char state;
  // pad1
  unsigned char pad1;
  // pad2
  unsigned char pad2;
};

struct anonymous_61
{
  // pad00
  unsigned int pad00;
  // window
  unsigned int window;
  // mode
  unsigned char mode;
  // pad1
  unsigned char pad1;
  // pad2
  unsigned char pad2;
  // pad3
  unsigned char pad3;
};

struct anonymous_65
{
  // pad00
  unsigned int pad00;
  // window
  unsigned int window;
  // state
  unsigned char state;
  // pad1
  unsigned char pad1;
  // pad2
  unsigned char pad2;
  // pad3
  unsigned char pad3;
};

struct anonymous_82
{
  // pad00
  unsigned int pad00;
  // request
  unsigned char request;
  // firstKeyCode
  unsigned char firstKeyCode;
  // count
  unsigned char count;
  // pad1
  unsigned char pad1;
};

struct anonymous_139
{
  // serial_no
  unsigned int serial_no;
  // nr_header_packet
  unsigned int nr_header_packet;
  // granule_rate_n
  signed long int granule_rate_n;
  // granule_rate_d
  signed long int granule_rate_d;
  // start_granule
  signed long int start_granule;
  // preroll
  unsigned int preroll;
  // granule_shift
  unsigned char granule_shift;
  // message_header_fields
  char *message_header_fields;
  // current_header_size
  unsigned int current_header_size;
};

struct anonymous_127
{
  // width
  unsigned int width;
  // height
  unsigned int height;
  // frame_width
  unsigned int frame_width;
  // frame_height
  unsigned int frame_height;
  // offset_x
  unsigned int offset_x;
  // offset_y
  unsigned int offset_y;
  // fps_numerator
  unsigned int fps_numerator;
  // fps_denominator
  unsigned int fps_denominator;
  // aspect_numerator
  unsigned int aspect_numerator;
  // aspect_denominator
  unsigned int aspect_denominator;
  // colorspace
  enum anonymous_143 colorspace;
  // target_bitrate
  signed int target_bitrate;
  // quality
  signed int quality;
  // quick_p
  signed int quick_p;
  // version_major
  unsigned char version_major;
  // version_minor
  unsigned char version_minor;
  // version_subminor
  unsigned char version_subminor;
  // codec_setup
  void *codec_setup;
  // dropframes_p
  signed int dropframes_p;
  // keyframe_auto_p
  signed int keyframe_auto_p;
  // keyframe_frequency
  unsigned int keyframe_frequency;
  // keyframe_frequency_force
  unsigned int keyframe_frequency_force;
  // keyframe_data_target_bitrate
  unsigned int keyframe_data_target_bitrate;
  // keyframe_auto_threshold
  signed int keyframe_auto_threshold;
  // keyframe_mindistance
  unsigned int keyframe_mindistance;
  // noise_sensitivity
  signed int noise_sensitivity;
  // sharpness
  signed int sharpness;
  // pixelformat
  enum anonymous_144 pixelformat;
};

struct anonymous_19
{
  // background_pixmap
  unsigned long int background_pixmap;
  // background_pixel
  unsigned long int background_pixel;
  // border_pixmap
  unsigned long int border_pixmap;
  // border_pixel
  unsigned long int border_pixel;
  // bit_gravity
  signed int bit_gravity;
  // win_gravity
  signed int win_gravity;
  // backing_store
  signed int backing_store;
  // backing_planes
  unsigned long int backing_planes;
  // backing_pixel
  unsigned long int backing_pixel;
  // save_under
  signed int save_under;
  // event_mask
  signed long int event_mask;
  // do_not_propagate_mask
  signed long int do_not_propagate_mask;
  // override_redirect
  signed int override_redirect;
  // colormap
  unsigned long int colormap;
  // cursor
  unsigned long int cursor;
};

struct anonymous_129
{
  // name
  unsigned long int name;
  // card32
  unsigned long int card32;
};

struct anonymous_18
{
  // pixel
  unsigned long int pixel;
  // red
  unsigned short int red;
  // green
  unsigned short int green;
  // blue
  unsigned short int blue;
  // flags
  char flags;
  // pad
  char pad;
};

struct anonymous_34
{
  // shmseg
  unsigned long int shmseg;
  // shmid
  signed int shmid;
  // shmaddr
  char *shmaddr;
  // readOnly
  signed int readOnly;
};

struct anonymous_133
{
  // reqType
  unsigned char reqType;
  // format
  unsigned char format;
  // length
  unsigned short int length;
  // drawable
  unsigned int drawable;
  // x
  signed short int x;
  // y
  signed short int y;
  // width
  unsigned short int width;
  // height
  unsigned short int height;
  // planeMask
  unsigned int planeMask;
};

struct anonymous_20
{
  // type
  unsigned char type;
  // data1
  unsigned char data1;
  // sequenceNumber
  unsigned short int sequenceNumber;
  // length
  unsigned int length;
  // data00
  unsigned int data00;
  // data01
  unsigned int data01;
  // data02
  unsigned int data02;
  // data03
  unsigned int data03;
  // data04
  unsigned int data04;
  // data05
  unsigned int data05;
};

struct anonymous_22
{
  // type
  unsigned char type;
  // depth
  unsigned char depth;
  // sequenceNumber
  unsigned short int sequenceNumber;
  // length
  unsigned int length;
  // root
  unsigned int root;
  // x
  signed short int x;
  // y
  signed short int y;
  // width
  unsigned short int width;
  // height
  unsigned short int height;
  // borderWidth
  unsigned short int borderWidth;
  // pad1
  unsigned short int pad1;
  // pad2
  unsigned int pad2;
  // pad3
  unsigned int pad3;
};

struct anonymous_132
{
  // type
  unsigned char type;
  // depth
  unsigned char depth;
  // sequenceNumber
  unsigned short int sequenceNumber;
  // length
  unsigned int length;
  // visual
  unsigned int visual;
  // pad3
  unsigned int pad3;
  // pad4
  unsigned int pad4;
  // pad5
  unsigned int pad5;
  // pad6
  unsigned int pad6;
  // pad7
  unsigned int pad7;
};

struct anonymous_58
{
  // type
  unsigned char type;
  // detail
  unsigned char detail;
  // sequenceNumber
  unsigned short int sequenceNumber;
};

struct anonymous_36
{
  // type
  unsigned char type;
  // drawDirection
  unsigned char drawDirection;
  // sequenceNumber
  unsigned short int sequenceNumber;
  // length
  unsigned int length;
  // fontAscent
  signed short int fontAscent;
  // fontDescent
  signed short int fontDescent;
  // overallAscent
  signed short int overallAscent;
  // overallDescent
  signed short int overallDescent;
  // overallWidth
  signed int overallWidth;
  // overallLeft
  signed int overallLeft;
  // overallRight
  signed int overallRight;
  // pad
  unsigned int pad;
};

struct anonymous_56
{
  // type
  unsigned char type;
  // enabled
  unsigned char enabled;
  // sequenceNumber
  unsigned short int sequenceNumber;
  // length
  unsigned int length;
  // nHosts
  unsigned short int nHosts;
  // pad1
  unsigned short int pad1;
  // pad3
  unsigned int pad3;
  // pad4
  unsigned int pad4;
  // pad5
  unsigned int pad5;
  // pad6
  unsigned int pad6;
  // pad7
  unsigned int pad7;
};

struct anonymous_121
{
  // type
  unsigned char type;
  // errorCode
  unsigned char errorCode;
  // sequenceNumber
  unsigned short int sequenceNumber;
  // resourceID
  unsigned int resourceID;
  // minorCode
  unsigned short int minorCode;
  // majorCode
  unsigned char majorCode;
  // pad1
  unsigned char pad1;
  // pad3
  unsigned int pad3;
  // pad4
  unsigned int pad4;
  // pad5
  unsigned int pad5;
  // pad6
  unsigned int pad6;
  // pad7
  unsigned int pad7;
};

struct anonymous_26
{
  // type
  unsigned char type;
  // format
  unsigned char format;
  // sequenceNumber
  unsigned short int sequenceNumber;
  // length
  unsigned int length;
  // propertyType
  unsigned int propertyType;
  // bytesAfter
  unsigned int bytesAfter;
  // nItems
  unsigned int nItems;
  // pad1
  unsigned int pad1;
  // pad2
  unsigned int pad2;
  // pad3
  unsigned int pad3;
};

struct anonymous_52
{
  // type
  unsigned char type;
  // keySymsPerKeyCode
  unsigned char keySymsPerKeyCode;
  // sequenceNumber
  unsigned short int sequenceNumber;
  // length
  unsigned int length;
  // pad2
  unsigned int pad2;
  // pad3
  unsigned int pad3;
  // pad4
  unsigned int pad4;
  // pad5
  unsigned int pad5;
  // pad6
  unsigned int pad6;
  // pad7
  unsigned int pad7;
};

struct anonymous_53
{
  // type
  unsigned char type;
  // nElts
  unsigned char nElts;
  // sequenceNumber
  unsigned short int sequenceNumber;
  // length
  unsigned int length;
  // pad2
  unsigned int pad2;
  // pad3
  unsigned int pad3;
  // pad4
  unsigned int pad4;
  // pad5
  unsigned int pad5;
  // pad6
  unsigned int pad6;
  // pad7
  unsigned int pad7;
};

struct anonymous_49
{
  // type
  unsigned char type;
  // nExtensions
  unsigned char nExtensions;
  // sequenceNumber
  unsigned short int sequenceNumber;
  // length
  unsigned int length;
  // pad2
  unsigned int pad2;
  // pad3
  unsigned int pad3;
  // pad4
  unsigned int pad4;
  // pad5
  unsigned int pad5;
  // pad6
  unsigned int pad6;
  // pad7
  unsigned int pad7;
};

struct anonymous_51
{
  // type
  unsigned char type;
  // numKeyPerModifier
  unsigned char numKeyPerModifier;
  // sequenceNumber
  unsigned short int sequenceNumber;
  // length
  unsigned int length;
  // pad1
  unsigned int pad1;
  // pad2
  unsigned int pad2;
  // pad3
  unsigned int pad3;
  // pad4
  unsigned int pad4;
  // pad5
  unsigned int pad5;
  // pad6
  unsigned int pad6;
};

struct anonymous_54
{
  // type
  unsigned char type;
  // pad1
  unsigned char pad1;
  // sequenceNumber
  unsigned short int sequenceNumber;
  // length
  unsigned int length;
  // accelNumerator
  unsigned short int accelNumerator;
  // accelDenominator
  unsigned short int accelDenominator;
  // threshold
  unsigned short int threshold;
  // pad2
  unsigned short int pad2;
  // pad3
  unsigned int pad3;
  // pad4
  unsigned int pad4;
  // pad5
  unsigned int pad5;
  // pad6
  unsigned int pad6;
};

struct anonymous_46
{
  // type
  unsigned char type;
  // pad1
  unsigned char pad1;
  // sequenceNumber
  unsigned short int sequenceNumber;
  // length
  unsigned int length;
  // exactRed
  unsigned short int exactRed;
  // exactGreen
  unsigned short int exactGreen;
  // exactBlue
  unsigned short int exactBlue;
  // screenRed
  unsigned short int screenRed;
  // screenGreen
  unsigned short int screenGreen;
  // screenBlue
  unsigned short int screenBlue;
  // pad3
  unsigned int pad3;
  // pad4
  unsigned int pad4;
  // pad5
  unsigned int pad5;
};

struct anonymous_39
{
  // type
  unsigned char type;
  // pad1
  unsigned char pad1;
  // sequenceNumber
  unsigned short int sequenceNumber;
  // length
  unsigned int length;
  // nColormaps
  unsigned short int nColormaps;
  // pad2
  unsigned short int pad2;
  // pad3
  unsigned int pad3;
  // pad4
  unsigned int pad4;
  // pad5
  unsigned int pad5;
  // pad6
  unsigned int pad6;
  // pad7
  unsigned int pad7;
};

struct anonymous_44
{
  // type
  unsigned char type;
  // pad1
  unsigned char pad1;
  // sequenceNumber
  unsigned short int sequenceNumber;
  // length
  unsigned int length;
  // nColors
  unsigned short int nColors;
  // pad2
  unsigned short int pad2;
  // pad3
  unsigned int pad3;
  // pad4
  unsigned int pad4;
  // pad5
  unsigned int pad5;
  // pad6
  unsigned int pad6;
  // pad7
  unsigned int pad7;
};

struct anonymous_37
{
  // type
  unsigned char type;
  // pad1
  unsigned char pad1;
  // sequenceNumber
  unsigned short int sequenceNumber;
  // length
  unsigned int length;
  // nFonts
  unsigned short int nFonts;
  // pad2
  unsigned short int pad2;
  // pad3
  unsigned int pad3;
  // pad4
  unsigned int pad4;
  // pad5
  unsigned int pad5;
  // pad6
  unsigned int pad6;
  // pad7
  unsigned int pad7;
};

struct anonymous_38
{
  // type
  unsigned char type;
  // pad1
  unsigned char pad1;
  // sequenceNumber
  unsigned short int sequenceNumber;
  // length
  unsigned int length;
  // nPaths
  unsigned short int nPaths;
  // pad2
  unsigned short int pad2;
  // pad3
  unsigned int pad3;
  // pad4
  unsigned int pad4;
  // pad5
  unsigned int pad5;
  // pad6
  unsigned int pad6;
  // pad7
  unsigned int pad7;
};

struct anonymous_42
{
  // type
  unsigned char type;
  // pad1
  unsigned char pad1;
  // sequenceNumber
  unsigned short int sequenceNumber;
  // length
  unsigned int length;
  // nPixels
  unsigned short int nPixels;
  // nMasks
  unsigned short int nMasks;
  // pad3
  unsigned int pad3;
  // pad4
  unsigned int pad4;
  // pad5
  unsigned int pad5;
  // pad6
  unsigned int pad6;
  // pad7
  unsigned int pad7;
};

struct anonymous_43
{
  // type
  unsigned char type;
  // pad1
  unsigned char pad1;
  // sequenceNumber
  unsigned short int sequenceNumber;
  // length
  unsigned int length;
  // nPixels
  unsigned short int nPixels;
  // pad2
  unsigned short int pad2;
  // redMask
  unsigned int redMask;
  // greenMask
  unsigned int greenMask;
  // blueMask
  unsigned int blueMask;
  // pad3
  unsigned int pad3;
  // pad4
  unsigned int pad4;
};

struct anonymous_27
{
  // type
  unsigned char type;
  // pad1
  unsigned char pad1;
  // sequenceNumber
  unsigned short int sequenceNumber;
  // length
  unsigned int length;
  // nProperties
  unsigned short int nProperties;
  // pad2
  unsigned short int pad2;
  // pad3
  unsigned int pad3;
  // pad4
  unsigned int pad4;
  // pad5
  unsigned int pad5;
  // pad6
  unsigned int pad6;
  // pad7
  unsigned int pad7;
};

struct anonymous_25
{
  // type
  unsigned char type;
  // pad1
  unsigned char pad1;
  // sequenceNumber
  unsigned short int sequenceNumber;
  // length
  unsigned int length;
  // nameLength
  unsigned short int nameLength;
  // pad2
  unsigned short int pad2;
  // pad3
  unsigned int pad3;
  // pad4
  unsigned int pad4;
  // pad5
  unsigned int pad5;
  // pad6
  unsigned int pad6;
  // pad7
  unsigned int pad7;
};

struct anonymous_40
{
  // type
  unsigned char type;
  // pad1
  unsigned char pad1;
  // sequenceNumber
  unsigned short int sequenceNumber;
  // length
  unsigned int length;
  // red
  unsigned short int red;
  // green
  unsigned short int green;
  // blue
  unsigned short int blue;
  // pad2
  unsigned short int pad2;
  // pixel
  unsigned int pixel;
  // pad3
  unsigned int pad3;
  // pad4
  unsigned int pad4;
  // pad5
  unsigned int pad5;
};

struct anonymous_55
{
  // type
  unsigned char type;
  // pad1
  unsigned char pad1;
  // sequenceNumber
  unsigned short int sequenceNumber;
  // length
  unsigned int length;
  // timeout
  unsigned short int timeout;
  // interval
  unsigned short int interval;
  // preferBlanking
  unsigned char preferBlanking;
  // allowExposures
  unsigned char allowExposures;
  // pad2
  unsigned short int pad2;
  // pad3
  unsigned int pad3;
  // pad4
  unsigned int pad4;
  // pad5
  unsigned int pad5;
  // pad6
  unsigned int pad6;
};

struct anonymous_47
{
  // type
  unsigned char type;
  // pad1
  unsigned char pad1;
  // sequenceNumber
  unsigned short int sequenceNumber;
  // length
  unsigned int length;
  // width
  unsigned short int width;
  // height
  unsigned short int height;
  // pad3
  unsigned int pad3;
  // pad4
  unsigned int pad4;
  // pad5
  unsigned int pad5;
  // pad6
  unsigned int pad6;
  // pad7
  unsigned int pad7;
};

struct anonymous_24
{
  // type
  unsigned char type;
  // pad1
  unsigned char pad1;
  // sequenceNumber
  unsigned short int sequenceNumber;
  // length
  unsigned int length;
  // atom
  unsigned int atom;
  // pad2
  unsigned int pad2;
  // pad3
  unsigned int pad3;
  // pad4
  unsigned int pad4;
  // pad5
  unsigned int pad5;
  // pad6
  unsigned int pad6;
};

struct anonymous_32
{
  // type
  unsigned char type;
  // pad1
  unsigned char pad1;
  // sequenceNumber
  unsigned short int sequenceNumber;
  // length
  unsigned int length;
  // nEvents
  unsigned int nEvents;
  // pad2
  unsigned int pad2;
  // pad3
  unsigned int pad3;
  // pad4
  unsigned int pad4;
  // pad5
  unsigned int pad5;
  // pad6
  unsigned int pad6;
};

struct anonymous_28
{
  // type
  unsigned char type;
  // pad1
  unsigned char pad1;
  // sequenceNumber
  unsigned short int sequenceNumber;
  // length
  unsigned int length;
  // owner
  unsigned int owner;
  // pad2
  unsigned int pad2;
  // pad3
  unsigned int pad3;
  // pad4
  unsigned int pad4;
  // pad5
  unsigned int pad5;
  // pad6
  unsigned int pad6;
};

struct anonymous_41
{
  // type
  unsigned char type;
  // pad1
  unsigned char pad1;
  // sequenceNumber
  unsigned short int sequenceNumber;
  // length
  unsigned int length;
  // pixel
  unsigned int pixel;
  // exactRed
  unsigned short int exactRed;
  // exactGreen
  unsigned short int exactGreen;
  // exactBlue
  unsigned short int exactBlue;
  // screenRed
  unsigned short int screenRed;
  // screenGreen
  unsigned short int screenGreen;
  // screenBlue
  unsigned short int screenBlue;
  // pad2
  unsigned int pad2;
  // pad3
  unsigned int pad3;
};

struct anonymous_23
{
  // type
  unsigned char type;
  // pad1
  unsigned char pad1;
  // sequenceNumber
  unsigned short int sequenceNumber;
  // length
  unsigned int length;
  // root
  unsigned int root;
  // parent
  unsigned int parent;
  // nChildren
  unsigned short int nChildren;
  // pad2
  unsigned short int pad2;
  // pad3
  unsigned int pad3;
  // pad4
  unsigned int pad4;
  // pad5
  unsigned int pad5;
};

struct anonymous_48
{
  // type
  unsigned char type;
  // pad1
  unsigned char pad1;
  // sequenceNumber
  unsigned short int sequenceNumber;
  // length
  unsigned int length;
  // present
  unsigned char present;
  // major_opcode
  unsigned char major_opcode;
  // first_event
  unsigned char first_event;
  // first_error
  unsigned char first_error;
  // pad3
  unsigned int pad3;
  // pad4
  unsigned int pad4;
  // pad5
  unsigned int pad5;
  // pad6
  unsigned int pad6;
  // pad7
  unsigned int pad7;
};

struct anonymous_35
{
  // type
  unsigned char type;
  // revertTo
  unsigned char revertTo;
  // sequenceNumber
  unsigned short int sequenceNumber;
  // length
  unsigned int length;
  // focus
  unsigned int focus;
  // pad1
  unsigned int pad1;
  // pad2
  unsigned int pad2;
  // pad3
  unsigned int pad3;
  // pad4
  unsigned int pad4;
  // pad5
  unsigned int pad5;
};

struct anonymous_33
{
  // type
  unsigned char type;
  // sameScreen
  unsigned char sameScreen;
  // sequenceNumber
  unsigned short int sequenceNumber;
  // length
  unsigned int length;
  // child
  unsigned int child;
  // dstX
  signed short int dstX;
  // dstY
  signed short int dstY;
  // pad2
  unsigned int pad2;
  // pad3
  unsigned int pad3;
  // pad4
  unsigned int pad4;
  // pad5
  unsigned int pad5;
};

struct anonymous_30
{
  // type
  unsigned char type;
  // sameScreen
  unsigned char sameScreen;
  // sequenceNumber
  unsigned short int sequenceNumber;
  // length
  unsigned int length;
  // root
  unsigned int root;
  // child
  unsigned int child;
  // rootX
  signed short int rootX;
  // rootY
  signed short int rootY;
  // winX
  signed short int winX;
  // winY
  signed short int winY;
  // mask
  unsigned short int mask;
  // pad1
  unsigned short int pad1;
  // pad
  unsigned int pad;
};

struct anonymous_29
{
  // type
  unsigned char type;
  // status
  unsigned char status;
  // sequenceNumber
  unsigned short int sequenceNumber;
  // length
  unsigned int length;
  // pad1
  unsigned int pad1;
  // pad2
  unsigned int pad2;
  // pad3
  unsigned int pad3;
  // pad4
  unsigned int pad4;
  // pad5
  unsigned int pad5;
  // pad6
  unsigned int pad6;
};

struct anonymous_50
{
  // type
  unsigned char type;
  // success
  unsigned char success;
  // sequenceNumber
  unsigned short int sequenceNumber;
  // length
  unsigned int length;
  // pad2
  unsigned int pad2;
  // pad3
  unsigned int pad3;
  // pad4
  unsigned int pad4;
  // pad5
  unsigned int pad5;
  // pad6
  unsigned int pad6;
  // pad7
  unsigned int pad7;
};

union anonymous_12
{
  // sa_handler
  void (*sa_handler)(signed int);
  // sa_sigaction
  void (*sa_sigaction)(signed int, struct anonymous_11 *, void *);
};

union anonymous_141
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

union anonymous_83
{
  // __data
  struct anonymous_131 __data;
  // __size
  char __size[48l];
  // __align
  signed long long int __align;
};

union anonymous_57
{
  // u
  struct anonymous_58 u;
  // keyButtonPointer
  struct anonymous_59 keyButtonPointer;
  // enterLeave
  struct anonymous_60 enterLeave;
  // focus
  struct anonymous_61 focus;
  // expose
  struct anonymous_62 expose;
  // graphicsExposure
  struct anonymous_63 graphicsExposure;
  // noExposure
  struct anonymous_64 noExposure;
  // visibility
  struct anonymous_65 visibility;
  // createNotify
  struct anonymous_66 createNotify;
  // destroyNotify
  struct anonymous_67 destroyNotify;
  // unmapNotify
  struct anonymous_68 unmapNotify;
  // mapNotify
  struct anonymous_69 mapNotify;
  // mapRequest
  struct anonymous_70 mapRequest;
  // reparent
  struct anonymous_71 reparent;
  // configureNotify
  struct anonymous_72 configureNotify;
  // configureRequest
  struct anonymous_73 configureRequest;
  // gravity
  struct anonymous_74 gravity;
  // resizeRequest
  struct anonymous_75 resizeRequest;
  // circulate
  struct anonymous_76 circulate;
  // property
  struct anonymous_77 property;
  // selectionClear
  struct anonymous_78 selectionClear;
  // selectionRequest
  struct anonymous_79 selectionRequest;
  // selectionNotify
  struct anonymous_80 selectionNotify;
  // colormap
  struct anonymous_81 colormap;
  // mappingNotify
  struct anonymous_82 mappingNotify;
  // clientMessage
  struct anonymous_84 clientMessage;
};

struct _xEvent
{
  // u
  union anonymous_57 u;
};

union anonymous_134
{
  // generic
  struct anonymous_20 generic;
  // geom
  struct anonymous_22 geom;
  // tree
  struct anonymous_23 tree;
  // atom
  struct anonymous_24 atom;
  // atomName
  struct anonymous_25 atomName;
  // property
  struct anonymous_26 property;
  // listProperties
  struct anonymous_27 listProperties;
  // selection
  struct anonymous_28 selection;
  // grabPointer
  struct anonymous_29 grabPointer;
  // grabKeyboard
  struct anonymous_29 grabKeyboard;
  // pointer
  struct anonymous_30 pointer;
  // motionEvents
  struct anonymous_32 motionEvents;
  // coords
  struct anonymous_33 coords;
  // inputFocus
  struct anonymous_35 inputFocus;
  // textExtents
  struct anonymous_36 textExtents;
  // fonts
  struct anonymous_37 fonts;
  // fontPath
  struct anonymous_38 fontPath;
  // image
  struct anonymous_132 image;
  // colormaps
  struct anonymous_39 colormaps;
  // allocColor
  struct anonymous_40 allocColor;
  // allocNamedColor
  struct anonymous_41 allocNamedColor;
  // colorCells
  struct anonymous_42 colorCells;
  // colorPlanes
  struct anonymous_43 colorPlanes;
  // colors
  struct anonymous_44 colors;
  // lookupColor
  struct anonymous_46 lookupColor;
  // bestSize
  struct anonymous_47 bestSize;
  // extension
  struct anonymous_48 extension;
  // extensions
  struct anonymous_49 extensions;
  // setModifierMapping
  struct anonymous_50 setModifierMapping;
  // getModifierMapping
  struct anonymous_51 getModifierMapping;
  // setPointerMapping
  struct anonymous_50 setPointerMapping;
  // getKeyboardMapping
  struct anonymous_52 getKeyboardMapping;
  // getPointerMapping
  struct anonymous_53 getPointerMapping;
  // pointerControl
  struct anonymous_54 pointerControl;
  // screenSaver
  struct anonymous_55 screenSaver;
  // hosts
  struct anonymous_56 hosts;
  // error
  struct anonymous_121 error;
  // event
  struct _xEvent event;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous_86
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct _BRWindow
{
  // rect
  struct anonymous_17 rect;
  // rrect
  struct anonymous_17 rrect;
  // nbytes
  signed int nbytes;
  // windowid
  unsigned long int windowid;
};

struct _CacheData
{
  // workdir
  char *workdir;
  // projname
  char *projname;
  // specsfile
  char *specsfile;
  // imgdata
  char *imgdata;
  // audiodata
  char *audiodata;
  // ifp
  struct gzFile_s **ifp;
  // uncifp
  struct _IO_FILE *uncifp;
  // afp
  struct _IO_FILE *afp;
};

struct _CachedFrame
{
  // header
  struct _FrameHeader *header;
  // YBlocks
  unsigned int *YBlocks;
  // UBlocks
  unsigned int *UBlocks;
  // VBlocks
  unsigned int *VBlocks;
  // YData
  unsigned char *YData;
  // UData
  unsigned char *UData;
  // VData
  unsigned char *VData;
};

struct _DisplaySpecs
{
  // screen
  signed int screen;
  // width
  unsigned int width;
  // height
  unsigned int height;
  // root
  unsigned long int root;
  // visual
  struct anonymous_21 *visual;
  // gc
  struct _XGC *gc;
  // depth
  signed int depth;
};

struct theora_comment
{
  // user_comments
  char **user_comments;
  // comment_lengths
  signed int *comment_lengths;
  // comments
  signed int comments;
  // vendor
  char *vendor;
};

struct vorbis_info
{
  // version
  signed int version;
  // channels
  signed int channels;
  // rate
  signed long int rate;
  // bitrate_upper
  signed long int bitrate_upper;
  // bitrate_nominal
  signed long int bitrate_nominal;
  // bitrate_lower
  signed long int bitrate_lower;
  // bitrate_window
  signed long int bitrate_window;
  // codec_setup
  void *codec_setup;
};

struct vorbis_comment
{
  // user_comments
  char **user_comments;
  // comment_lengths
  signed int *comment_lengths;
  // comments
  signed int comments;
  // vendor
  char *vendor;
};

struct vorbis_dsp_state
{
  // analysisp
  signed int analysisp;
  // vi
  struct vorbis_info *vi;
  // pcm
  float **pcm;
  // pcmret
  float **pcmret;
  // pcm_storage
  signed int pcm_storage;
  // pcm_current
  signed int pcm_current;
  // pcm_returned
  signed int pcm_returned;
  // preextrapolate
  signed int preextrapolate;
  // eofflag
  signed int eofflag;
  // lW
  signed long int lW;
  // W
  signed long int W;
  // nW
  signed long int nW;
  // centerW
  signed long int centerW;
  // granulepos
  signed long int granulepos;
  // sequence
  signed long int sequence;
  // glue_bits
  signed long int glue_bits;
  // time_bits
  signed long int time_bits;
  // floor_bits
  signed long int floor_bits;
  // res_bits
  signed long int res_bits;
  // backend_state
  void *backend_state;
};

struct vorbis_block
{
  // pcm
  float **pcm;
  // opb
  struct anonymous_145 opb;
  // lW
  signed long int lW;
  // W
  signed long int W;
  // nW
  signed long int nW;
  // pcmend
  signed int pcmend;
  // mode
  signed int mode;
  // eofflag
  signed int eofflag;
  // granulepos
  signed long int granulepos;
  // sequence
  signed long int sequence;
  // vd
  struct vorbis_dsp_state *vd;
  // localstore
  void *localstore;
  // localtop
  signed long int localtop;
  // localalloc
  signed long int localalloc;
  // totaluse
  signed long int totaluse;
  // reap
  struct alloc_chain *reap;
  // glue_bits
  signed long int glue_bits;
  // time_bits
  signed long int time_bits;
  // floor_bits
  signed long int floor_bits;
  // res_bits
  signed long int res_bits;
  // internal
  void *internal;
};

struct _EncData
{
  // m_ogg_ts
  struct anonymous_14 m_ogg_ts;
  // m_ogg_vs
  struct anonymous_14 m_ogg_vs;
  // m_ogg_pg
  struct anonymous_15 m_ogg_pg;
  // m_ogg_pckt1
  struct anonymous_126 m_ogg_pckt1;
  // m_ogg_pckt2
  struct anonymous_126 m_ogg_pckt2;
  // m_th_st
  struct anonymous_13 m_th_st;
  // m_th_inf
  struct anonymous_127 m_th_inf;
  // m_th_cmmnt
  struct theora_comment m_th_cmmnt;
  // yuv
  struct anonymous_45 yuv;
  // m_vo_inf
  struct vorbis_info m_vo_inf;
  // m_vo_cmmnt
  struct vorbis_comment m_vo_cmmnt;
  // m_vo_dsp
  struct vorbis_dsp_state m_vo_dsp;
  // m_vo_block
  struct vorbis_block m_vo_block;
  // x_offset
  signed int x_offset;
  // y_offset
  signed int y_offset;
  // fp
  struct _IO_FILE *fp;
};

struct _FrameHeader
{
  // frame_prefix
  char frame_prefix[4l];
  // frameno
  unsigned int frameno;
  // current_total
  unsigned int current_total;
  // Ynum
  unsigned int Ynum;
  // Unum
  unsigned int Unum;
  // Vnum
  unsigned int Vnum;
};

struct _HotKey
{
  // modnum
  signed int modnum;
  // mask
  unsigned int mask[4l];
  // key
  signed int key;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct _JackData
{
  // pdata
  struct _ProgData *pdata;
  // client
  struct _jack_client *client;
  // buffersize
  unsigned int buffersize;
  // frequency
  unsigned int frequency;
  // nports
  unsigned int nports;
  // ringbuffer_secs
  float ringbuffer_secs;
  // port_names
  char **port_names;
  // ports
  struct _jack_port **ports;
  // portbuf
  float **portbuf;
  // snd_buff_ready_mutex
  union anonymous_86 *snd_buff_ready_mutex;
  // sound_data_read
  union anonymous_83 *sound_data_read;
  // sound_buffer
  struct anonymous_85 *sound_buffer;
  // capture_started
  signed int capture_started;
};

struct _ProgArgs
{
  // delay
  signed int delay;
  // windowid
  unsigned long int windowid;
  // display
  char *display;
  // x
  signed int x;
  // y
  signed int y;
  // width
  signed int width;
  // height
  signed int height;
  // filename
  char *filename;
  // cursor_color
  signed int cursor_color;
  // have_dummy_cursor
  signed int have_dummy_cursor;
  // xfixes_cursor
  signed int xfixes_cursor;
  // fps
  float fps;
  // frequency
  unsigned int frequency;
  // channels
  unsigned int channels;
  // device
  char *device;
  // buffsize
  unsigned long int buffsize;
  // rescue_path
  const char *rescue_path;
  // nosound
  signed int nosound;
  // noshared
  signed int noshared;
  // nowmcheck
  signed int nowmcheck;
  // full_shots
  signed int full_shots;
  // follow_mouse
  signed int follow_mouse;
  // no_encode
  signed int no_encode;
  // no_quick_subsample
  signed int no_quick_subsample;
  // v_bitrate
  signed int v_bitrate;
  // v_quality
  signed int v_quality;
  // s_quality
  signed int s_quality;
  // encOnTheFly
  signed int encOnTheFly;
  // workdir
  char *workdir;
  // pause_shortcut
  char *pause_shortcut;
  // stop_shortcut
  char *stop_shortcut;
  // noframe
  signed int noframe;
  // zerocompression
  signed int zerocompression;
  // overwrite
  signed int overwrite;
  // use_jack
  signed int use_jack;
  // jack_nports
  unsigned int jack_nports;
  // jack_port_names
  char *jack_port_names[100l];
  // jack_ringbuffer_secs
  float jack_ringbuffer_secs;
};

struct _ProgData
{
  // args
  struct _ProgArgs args;
  // specs
  struct _DisplaySpecs specs;
  // brwin
  struct _BRWindow brwin;
  // rect_root
  struct _RectArea *rect_root;
  // sound_buffer
  struct _SndBuffer *sound_buffer;
  // enc_data
  struct _EncData *enc_data;
  // cache_data
  struct _CacheData *cache_data;
  // pause_key
  struct _HotKey pause_key;
  // stop_key
  struct _HotKey stop_key;
  // jdata
  struct _JackData *jdata;
  // dpy
  struct _XDisplay *dpy;
  // sound_buffer_mutex
  union anonymous_86 sound_buffer_mutex;
  // snd_buff_ready_mutex
  union anonymous_86 snd_buff_ready_mutex;
  // img_buff_ready_mutex
  union anonymous_86 img_buff_ready_mutex;
  // theora_lib_mutex
  union anonymous_86 theora_lib_mutex;
  // vorbis_lib_mutex
  union anonymous_86 vorbis_lib_mutex;
  // libogg_mutex
  union anonymous_86 libogg_mutex;
  // yuv_mutex
  union anonymous_86 yuv_mutex;
  // time_cond
  union anonymous_83 time_cond;
  // pause_cond
  union anonymous_83 pause_cond;
  // sound_data_read
  union anonymous_83 sound_data_read;
  // image_buffer_ready
  union anonymous_83 image_buffer_ready;
  // theora_lib_clean
  union anonymous_83 theora_lib_clean;
  // vorbis_lib_clean
  union anonymous_83 vorbis_lib_clean;
  // dummy_pointer
  unsigned char *dummy_pointer;
  // npxl
  unsigned char npxl;
  // periodtime
  unsigned int periodtime;
  // frametime
  unsigned int frametime;
  // shaped_w
  unsigned long int shaped_w;
  // damage_event
  signed int damage_event;
  // damage_error
  signed int damage_error;
  // shm_opcode
  signed int shm_opcode;
  // dummy_p_size
  signed int dummy_p_size;
  // th_encoding_clean
  signed int th_encoding_clean;
  // v_encoding_clean
  signed int v_encoding_clean;
  // v_enc_thread_waiting
  signed int v_enc_thread_waiting;
  // th_enc_thread_waiting
  signed int th_enc_thread_waiting;
  // timer_alive
  signed int timer_alive;
  // hard_pause
  signed int hard_pause;
  // avd
  signed int avd;
  // sound_framesize
  signed int sound_framesize;
  // running
  signed int running;
  // paused
  signed int paused;
  // aborted
  signed int aborted;
  // pause_state_changed
  signed int pause_state_changed;
  // frames_total
  unsigned int frames_total;
  // frames_lost
  unsigned int frames_lost;
  // capture_busy
  signed int capture_busy;
  // encoder_busy
  signed int encoder_busy;
  // pause_mutex
  union anonymous_86 pause_mutex;
  // time_mutex
  union anonymous_86 time_mutex;
  // sound_handle
  struct _snd_pcm *sound_handle;
  // periodsize
  unsigned long int periodsize;
};

struct _RectArea
{
  // rect
  struct anonymous_17 rect;
  // prev
  struct _RectArea *prev;
  // next
  struct _RectArea *next;
};

struct _ShmGetImage
{
  // reqType
  unsigned char reqType;
  // shmReqType
  unsigned char shmReqType;
  // length
  unsigned short int length;
  // drawable
  unsigned int drawable;
  // x
  signed short int x;
  // y
  signed short int y;
  // width
  unsigned short int width;
  // height
  unsigned short int height;
  // planeMask
  unsigned int planeMask;
  // format
  unsigned char format;
  // pad0
  unsigned char pad0;
  // pad1
  unsigned char pad1;
  // pad2
  unsigned char pad2;
  // shmseg
  unsigned int shmseg;
  // offset
  unsigned int offset;
};

struct _ShmGetImageReply
{
  // type
  unsigned char type;
  // depth
  unsigned char depth;
  // sequenceNumber
  unsigned short int sequenceNumber;
  // length
  unsigned int length;
  // visual
  unsigned int visual;
  // size
  unsigned int size;
  // pad0
  unsigned int pad0;
  // pad1
  unsigned int pad1;
  // pad2
  unsigned int pad2;
  // pad3
  unsigned int pad3;
};

struct _SndBuffer
{
  // data
  signed char *data;
  // next
  struct _SndBuffer *next;
};

struct _XConnWatchInfo
{
  // fn
  void (*fn)(struct _XDisplay *, char *, signed int, signed int, char **);
  // client_data
  char *client_data;
  // next
  struct _XConnWatchInfo *next;
};

struct _XConnectionInfo
{
  // fd
  signed int fd;
  // read_callback
  void (*read_callback)(struct _XDisplay *, signed int, char *);
  // call_data
  char *call_data;
  // watch_data
  char **watch_data;
  // next
  struct _XConnectionInfo *next;
};

struct _XDisplay
{
  // ext_data
  struct _XExtData *ext_data;
  // free_funcs
  struct _XFreeFuncs *free_funcs;
  // fd
  signed int fd;
  // conn_checker
  signed int conn_checker;
  // proto_major_version
  signed int proto_major_version;
  // proto_minor_version
  signed int proto_minor_version;
  // vendor
  char *vendor;
  // resource_base
  unsigned long int resource_base;
  // resource_mask
  unsigned long int resource_mask;
  // resource_id
  unsigned long int resource_id;
  // resource_shift
  signed int resource_shift;
  // resource_alloc
  unsigned long int (*resource_alloc)(struct _XDisplay *);
  // byte_order
  signed int byte_order;
  // bitmap_unit
  signed int bitmap_unit;
  // bitmap_pad
  signed int bitmap_pad;
  // bitmap_bit_order
  signed int bitmap_bit_order;
  // nformats
  signed int nformats;
  // pixmap_format
  struct anonymous_90 *pixmap_format;
  // vnumber
  signed int vnumber;
  // release
  signed int release;
  // head
  struct _XSQEvent *head;
  // tail
  struct _XSQEvent *tail;
  // qlen
  signed int qlen;
  // last_request_read
  unsigned long int last_request_read;
  // request
  unsigned long int request;
  // last_req
  char *last_req;
  // buffer
  char *buffer;
  // bufptr
  char *bufptr;
  // bufmax
  char *bufmax;
  // max_request_size
  unsigned int max_request_size;
  // db
  struct _XrmHashBucketRec *db;
  // synchandler
  signed int (*synchandler)(struct _XDisplay *);
  // display_name
  char *display_name;
  // default_screen
  signed int default_screen;
  // nscreens
  signed int nscreens;
  // screens
  struct anonymous_93 *screens;
  // motion_buffer
  unsigned long int motion_buffer;
  // flags
  volatile unsigned long int flags;
  // min_keycode
  signed int min_keycode;
  // max_keycode
  signed int max_keycode;
  // keysyms
  unsigned long int *keysyms;
  // modifiermap
  struct anonymous_95 *modifiermap;
  // keysyms_per_keycode
  signed int keysyms_per_keycode;
  // xdefaults
  char *xdefaults;
  // scratch_buffer
  char *scratch_buffer;
  // scratch_length
  unsigned long int scratch_length;
  // ext_number
  signed int ext_number;
  // ext_procs
  struct _XExten *ext_procs;
  // event_vec
  signed int (*event_vec[128l])(struct _XDisplay *, union _XEvent *, struct _xEvent *);
  // wire_vec
  signed int (*wire_vec[128l])(struct _XDisplay *, union _XEvent *, struct _xEvent *);
  // lock_meaning
  unsigned long int lock_meaning;
  // lock
  struct _XLockInfo *lock;
  // async_handlers
  struct _XInternalAsync *async_handlers;
  // bigreq_size
  unsigned long int bigreq_size;
  // lock_fns
  struct _XLockPtrs *lock_fns;
  // idlist_alloc
  void (*idlist_alloc)(struct _XDisplay *, unsigned long int *, signed int);
  // key_bindings
  struct _XKeytrans *key_bindings;
  // cursor_font
  unsigned long int cursor_font;
  // atoms
  struct _XDisplayAtoms *atoms;
  // mode_switch
  unsigned int mode_switch;
  // num_lock
  unsigned int num_lock;
  // context_db
  struct _XContextDB *context_db;
  // error_vec
  signed int (**error_vec)(struct _XDisplay *, struct anonymous_118 *, struct anonymous_121 *);
  // cms
  struct anonymous_122 cms;
  // im_filters
  struct _XIMFilter *im_filters;
  // qfree
  struct _XSQEvent *qfree;
  // next_event_serial_num
  unsigned long int next_event_serial_num;
  // flushes
  struct _XExten *flushes;
  // im_fd_info
  struct _XConnectionInfo *im_fd_info;
  // im_fd_length
  signed int im_fd_length;
  // conn_watchers
  struct _XConnWatchInfo *conn_watchers;
  // watcher_count
  signed int watcher_count;
  // filedes
  char *filedes;
  // savedsynchandler
  signed int (*savedsynchandler)(struct _XDisplay *);
  // resource_max
  unsigned long int resource_max;
  // xcmisc_opcode
  signed int xcmisc_opcode;
  // xkb_info
  struct _XkbInfoRec *xkb_info;
  // trans_conn
  struct _XtransConnInfo *trans_conn;
  // xcb
  struct _X11XCBPrivate *xcb;
  // next_cookie
  unsigned int next_cookie;
  // generic_event_vec
  signed int (*generic_event_vec[128l])(struct _XDisplay *, struct anonymous_125 *, struct _xEvent *);
  // generic_event_copy_vec
  signed int (*generic_event_copy_vec[128l])(struct _XDisplay *, struct anonymous_125 *, struct anonymous_125 *);
  // cookiejar
  void *cookiejar;
};

union _XEvent
{
  // type
  signed int type;
  // xany
  struct anonymous_94 xany;
  // xkey
  struct anonymous_0 xkey;
  // xbutton
  struct anonymous_87 xbutton;
  // xmotion
  struct anonymous_88 xmotion;
  // xcrossing
  struct anonymous_89 xcrossing;
  // xfocus
  struct anonymous_96 xfocus;
  // xexpose
  struct anonymous_97 xexpose;
  // xgraphicsexpose
  struct anonymous_98 xgraphicsexpose;
  // xnoexpose
  struct anonymous_99 xnoexpose;
  // xvisibility
  struct anonymous_100 xvisibility;
  // xcreatewindow
  struct anonymous_101 xcreatewindow;
  // xdestroywindow
  struct anonymous_102 xdestroywindow;
  // xunmap
  struct anonymous_103 xunmap;
  // xmap
  struct anonymous_104 xmap;
  // xmaprequest
  struct anonymous_105 xmaprequest;
  // xreparent
  struct anonymous_106 xreparent;
  // xconfigure
  struct anonymous_107 xconfigure;
  // xgravity
  struct anonymous_108 xgravity;
  // xresizerequest
  struct anonymous_109 xresizerequest;
  // xconfigurerequest
  struct anonymous_110 xconfigurerequest;
  // xcirculate
  struct anonymous_111 xcirculate;
  // xcirculaterequest
  struct anonymous_112 xcirculaterequest;
  // xproperty
  struct anonymous_113 xproperty;
  // xselectionclear
  struct anonymous_114 xselectionclear;
  // xselectionrequest
  struct anonymous_115 xselectionrequest;
  // xselection
  struct anonymous_116 xselection;
  // xcolormap
  struct anonymous_117 xcolormap;
  // xclient
  struct anonymous_119 xclient;
  // xmapping
  struct anonymous_120 xmapping;
  // xerror
  struct anonymous_118 xerror;
  // xkeymap
  struct anonymous_123 xkeymap;
  // xgeneric
  struct anonymous_124 xgeneric;
  // xcookie
  struct anonymous_125 xcookie;
  // pad
  signed long int pad[24l];
};

struct _XExtData
{
  // number
  signed int number;
  // next
  struct _XExtData *next;
  // free_private
  signed int (*free_private)(struct _XExtData *);
  // private_data
  char *private_data;
};

struct _XExten
{
  // next
  struct _XExten *next;
  // codes
  struct anonymous_91 codes;
  // create_GC
  signed int (*create_GC)(struct _XDisplay *, struct _XGC *, struct anonymous_91 *);
  // copy_GC
  signed int (*copy_GC)(struct _XDisplay *, struct _XGC *, struct anonymous_91 *);
  // flush_GC
  signed int (*flush_GC)(struct _XDisplay *, struct _XGC *, struct anonymous_91 *);
  // free_GC
  signed int (*free_GC)(struct _XDisplay *, struct _XGC *, struct anonymous_91 *);
  // create_Font
  signed int (*create_Font)(struct _XDisplay *, struct anonymous_92 *, struct anonymous_91 *);
  // free_Font
  signed int (*free_Font)(struct _XDisplay *, struct anonymous_92 *, struct anonymous_91 *);
  // close_display
  signed int (*close_display)(struct _XDisplay *, struct anonymous_91 *);
  // error
  signed int (*error)(struct _XDisplay *, struct anonymous_121 *, struct anonymous_91 *, signed int *);
  // error_string
  char * (*error_string)(struct _XDisplay *, signed int, struct anonymous_91 *, char *, signed int);
  // name
  char *name;
  // error_values
  void (*error_values)(struct _XDisplay *, struct anonymous_118 *, void *);
  // before_flush
  void (*before_flush)(struct _XDisplay *, struct anonymous_91 *, const char *, signed long int);
  // next_flush
  struct _XExten *next_flush;
};

struct _XFreeFuncs
{
  // atoms
  void (*atoms)(struct _XDisplay *);
  // modifiermap
  signed int (*modifiermap)(struct anonymous_95 *);
  // key_bindings
  void (*key_bindings)(struct _XDisplay *);
  // context_db
  void (*context_db)(struct _XDisplay *);
  // defaultCCCs
  void (*defaultCCCs)(struct _XDisplay *);
  // clientCmaps
  void (*clientCmaps)(struct _XDisplay *);
  // intensityMaps
  void (*intensityMaps)(struct _XDisplay *);
  // im_filters
  void (*im_filters)(struct _XDisplay *);
  // xkb
  void (*xkb)(struct _XDisplay *);
};

struct _XGC
{
  // ext_data
  struct _XExtData *ext_data;
  // gid
  unsigned long int gid;
  // rects
  signed int rects;
  // dashes
  signed int dashes;
  // dirty
  unsigned long int dirty;
  // values
  struct anonymous_16 values;
};

struct funcs
{
  // create_image
  struct _XImage * (*create_image)(struct _XDisplay *, struct anonymous_21 *, unsigned int, signed int, signed int, char *, unsigned int, unsigned int, signed int, signed int);
  // destroy_image
  signed int (*destroy_image)(struct _XImage *);
  // get_pixel
  unsigned long int (*get_pixel)(struct _XImage *, signed int, signed int);
  // put_pixel
  signed int (*put_pixel)(struct _XImage *, signed int, signed int, unsigned long int);
  // sub_image
  struct _XImage * (*sub_image)(struct _XImage *, signed int, signed int, unsigned int, unsigned int);
  // add_pixel
  signed int (*add_pixel)(struct _XImage *, signed long int);
};

struct _XImage
{
  // width
  signed int width;
  // height
  signed int height;
  // xoffset
  signed int xoffset;
  // format
  signed int format;
  // data
  char *data;
  // byte_order
  signed int byte_order;
  // bitmap_unit
  signed int bitmap_unit;
  // bitmap_bit_order
  signed int bitmap_bit_order;
  // bitmap_pad
  signed int bitmap_pad;
  // depth
  signed int depth;
  // bytes_per_line
  signed int bytes_per_line;
  // bits_per_pixel
  signed int bits_per_pixel;
  // red_mask
  unsigned long int red_mask;
  // green_mask
  unsigned long int green_mask;
  // blue_mask
  unsigned long int blue_mask;
  // obdata
  char *obdata;
  // f
  struct funcs f;
};

struct _XInternalAsync
{
  // next
  struct _XInternalAsync *next;
  // handler
  signed int (*handler)(struct _XDisplay *, union anonymous_134 *, char *, signed int, char *);
  // data
  char *data;
};

struct _XLockPtrs
{
  // lock_display
  void (*lock_display)(struct _XDisplay *);
  // unlock_display
  void (*unlock_display)(struct _XDisplay *);
};

struct _XSQEvent
{
  // next
  struct _XSQEvent *next;
  // event
  union _XEvent event;
  // qserial_num
  unsigned long int qserial_num;
};

struct alloc_chain
{
  // ptr
  void *ptr;
  // next
  struct alloc_chain *next;
};

struct gzFile_s
{
  // have
  unsigned int have;
  // next
  unsigned char *next;
  // pos
  signed long int pos;
};

struct ipc_perm
{
  // __key
  signed int __key;
  // uid
  unsigned int uid;
  // gid
  unsigned int gid;
  // cuid
  unsigned int cuid;
  // cgid
  unsigned int cgid;
  // mode
  unsigned short int mode;
  // __pad1
  unsigned short int __pad1;
  // __seq
  unsigned short int __seq;
  // __pad2
  unsigned short int __pad2;
  // __glibc_reserved1
  unsigned long int __glibc_reserved1;
  // __glibc_reserved2
  unsigned long int __glibc_reserved2;
};

struct poptOption
{
  // longName
  const char *longName;
  // shortName
  char shortName;
  // argInfo
  unsigned int argInfo;
  // arg
  void *arg;
  // val
  signed int val;
  // descrip
  const char *descrip;
  // argDescrip
  const char *argDescrip;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct shmid_ds
{
  // shm_perm
  struct ipc_perm shm_perm;
  // shm_segsz
  unsigned long int shm_segsz;
  // shm_atime
  signed long int shm_atime;
  // shm_dtime
  signed long int shm_dtime;
  // shm_ctime
  signed long int shm_ctime;
  // shm_cpid
  signed int shm_cpid;
  // shm_lpid
  signed int shm_lpid;
  // shm_nattch
  unsigned long int shm_nattch;
  // __glibc_reserved4
  unsigned long int __glibc_reserved4;
  // __glibc_reserved5
  unsigned long int __glibc_reserved5;
};

struct sigaction
{
  // __sigaction_handler
  union anonymous_12 __sigaction_handler;
  // sa_mask
  struct anonymous_2 sa_mask;
  // sa_flags
  signed int sa_flags;
  // sa_restorer
  void (*sa_restorer)(void);
};

struct timespec
{
  // tv_sec
  signed long int tv_sec;
  // tv_nsec
  signed long int tv_nsec;
};

struct stat
{
  // st_dev
  unsigned long int st_dev;
  // st_ino
  unsigned long int st_ino;
  // st_nlink
  unsigned long int st_nlink;
  // st_mode
  unsigned int st_mode;
  // st_uid
  unsigned int st_uid;
  // st_gid
  unsigned int st_gid;
  // __pad0
  signed int __pad0;
  // st_rdev
  unsigned long int st_rdev;
  // st_size
  signed long int st_size;
  // st_blksize
  signed long int st_blksize;
  // st_blocks
  signed long int st_blocks;
  // st_atim
  struct timespec st_atim;
  // st_mtim
  struct timespec st_mtim;
  // st_ctim
  struct timespec st_ctim;
  // __glibc_reserved
  signed long int __glibc_reserved[3l];
};


// UbVr
// file rmd_yuv_utils.c line 35
unsigned char UbVr[256l];
// Ug
// file rmd_yuv_utils.c line 35
unsigned char Ug[256l];
// Ur
// file rmd_yuv_utils.c line 35
unsigned char Ur[256l];
// Vb
// file rmd_yuv_utils.c line 36
unsigned char Vb[256l];
// Vg
// file rmd_yuv_utils.c line 36
unsigned char Vg[256l];
// Yb
// file rmd_yuv_utils.c line 34
unsigned char Yb[256l];
// Yg
// file rmd_yuv_utils.c line 34
unsigned char Yg[256l];
// Yr
// file rmd_yuv_utils.c line 34
unsigned char Yr[256l];
// pdata_aborted
// file rmd_register_callbacks.c line 39
static signed int *pdata_aborted = (signed int *)(void *)0;
// pdata_pause_state_changed
// file rmd_register_callbacks.c line 40
static signed int *pdata_pause_state_changed = (signed int *)(void *)0;
// pdata_paused
// file rmd_register_callbacks.c line 38
static signed int *pdata_paused = (signed int *)(void *)0;
// pdata_running
// file rmd_register_callbacks.c line 37
static signed int *pdata_running = (signed int *)(void *)0;
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// stdout
// file /usr/include/stdio.h line 169
extern struct _IO_FILE *stdout;
// ublocks
// file rmd_yuv_utils.c line 42
unsigned int *ublocks;
// vblocks
// file rmd_yuv_utils.c line 43
unsigned int *vblocks;
// yblocks
// file rmd_yuv_utils.c line 41
unsigned int *yblocks;

// _le_16
// file skeleton.c line 29
static unsigned short int _le_16(unsigned short int s)
{
  unsigned short int ret = s;
  return ret;
}

// _le_32
// file skeleton.c line 40
static unsigned int _le_32(unsigned int i)
{
  unsigned int ret = i;
  return ret;
}

// _le_64
// file skeleton.c line 53
static signed long int _le_64(signed long int l)
{
  signed long int ret = l;
  unsigned char *ucptr = (unsigned char *)&ret;
  return *((signed long int *)ucptr);
}

// add_eos_packet_to_stream
// file skeleton.h line 65
extern signed int add_eos_packet_to_stream(struct anonymous_14 *os)
{
  struct anonymous_126 op;
  memset((void *)&op, 0, sizeof(struct anonymous_126) /*48ul*/ );
  op.e_o_s = (signed long int)1;
  ogg_stream_packetin(os, &op);
  return 0;
}

// add_fisbone_to_stream
// file skeleton.h line 64
extern signed int add_fisbone_to_stream(struct anonymous_14 *os, struct anonymous_139 *fp)
{
  struct anonymous_126 op;
  signed int ret;
  ret=ogg_from_fisbone(fp, &op);
  if(!(ret >= 0))
    return ret;

  else
  {
    ogg_stream_packetin(os, &op);
    free((void *)op.packet);
    return 0;
  }
}

// add_fishead_to_stream
// file skeleton.h line 63
extern signed int add_fishead_to_stream(struct anonymous_14 *os, struct anonymous_140 *fp)
{
  struct anonymous_126 op;
  signed int ret;
  ret=ogg_from_fishead(fp, &op);
  if(!(ret >= 0))
    return ret;

  else
  {
    ogg_stream_packetin(os, &op);
    free((void *)op.packet);
    return 0;
  }
}

// add_message_header_field
// file skeleton.h line 54
extern signed int add_message_header_field(struct anonymous_139 *fp, char *header_key, char *header_value)
{
  signed int this_message_size;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(header_key);
  unsigned long int return_value_strlen_2;
  return_value_strlen_2=strlen(header_value);
  this_message_size = (signed int)(return_value_strlen_1 + return_value_strlen_2 + (unsigned long int)4);
  if(fp->message_header_fields == ((char *)NULL))
  {
    void *return_value_calloc_3;
    return_value_calloc_3=calloc((unsigned long int)(this_message_size + 1), sizeof(char) /*1ul*/ );
    fp->message_header_fields = (char *)return_value_calloc_3;
  }

  else
  {
    signed int new_size = (signed int)((unsigned long int)(fp->current_header_size + (unsigned int)this_message_size + (unsigned int)1) * sizeof(char) /*1ul*/ );
    void *return_value_realloc_4;
    return_value_realloc_4=realloc((void *)fp->message_header_fields, (unsigned long int)new_size);
    fp->message_header_fields = (char *)return_value_realloc_4;
  }
  snprintf(fp->message_header_fields + (signed long int)fp->current_header_size, (unsigned long int)(this_message_size + 1), "%s: %s\r\n", header_key, header_value);
  fp->current_header_size = fp->current_header_size + (unsigned int)this_message_size;
  return 0;
}

// fisbone_clear
// file skeleton.c line 238
extern signed int fisbone_clear(struct anonymous_139 *fp)
{
  if(fp == ((struct anonymous_139 *)NULL))
    return -1;

  else
  {
    free((void *)fp->message_header_fields);
    return 0;
  }
}

// fisbone_from_data
// file skeleton.c line 206
static signed int fisbone_from_data(const unsigned char *data, signed int len, struct anonymous_139 *fp)
{
  if(fp == ((struct anonymous_139 *)NULL))
    return -1;

  else
  {
    signed int return_value_memcmp_1;
    return_value_memcmp_1=memcmp((const void *)data, (const void *)"fisbone\0", (unsigned long int)8);
    if(!(return_value_memcmp_1 == 0))
      return -1;

    else
    {
      fp->serial_no=_le_32(*((unsigned int *)(data + (signed long int)12)));
      fp->nr_header_packet=_le_32(*((unsigned int *)(data + (signed long int)16)));
      fp->granule_rate_n=_le_64(*((signed long int *)(data + (signed long int)20)));
      fp->granule_rate_d=_le_64(*((signed long int *)(data + (signed long int)28)));
      fp->start_granule=_le_64(*((signed long int *)(data + (signed long int)36)));
      fp->preroll=_le_32(*((unsigned int *)(data + (signed long int)44)));
      fp->granule_shift = data[(signed long int)48];
      fp->current_header_size = (unsigned int)(len - 52);
      void *return_value_calloc_2;
      return_value_calloc_2=calloc((unsigned long int)(fp->current_header_size + (unsigned int)1), sizeof(char) /*1ul*/ );
      fp->message_header_fields = (char *)return_value_calloc_2;
      if(fp->message_header_fields == ((char *)NULL))
        return -1;

      else
      {
        memcpy((void *)fp->message_header_fields, (const void *)(data + (signed long int)52), (unsigned long int)fp->current_header_size);
        return 0;
      }
    }
  }
}

// fisbone_from_ogg
// file skeleton.c line 229
extern signed int fisbone_from_ogg(struct anonymous_126 *op, struct anonymous_139 *fp)
{
  signed int return_value_fisbone_from_data_1;
  return_value_fisbone_from_data_1=fisbone_from_data(op->packet, (signed int)op->bytes, fp);
  return return_value_fisbone_from_data_1;
}

// fisbone_from_ogg_page
// file skeleton.c line 234
extern signed int fisbone_from_ogg_page(const struct anonymous_15 *og, struct anonymous_139 *fp)
{
  signed int return_value_fisbone_from_data_1;
  return_value_fisbone_from_data_1=fisbone_from_data(og->body, (signed int)og->body_len, fp);
  return return_value_fisbone_from_data_1;
}

// fishead_from_data
// file skeleton.c line 178
static signed int fishead_from_data(const unsigned char *data, signed int len, struct anonymous_140 *fp)
{
  if(data == ((const unsigned char *)NULL))
    return -1;

  else
  {
    signed int return_value_memcmp_1;
    return_value_memcmp_1=memcmp((const void *)data, (const void *)"fishead\0", (unsigned long int)8);
    if(!(return_value_memcmp_1 == 0))
      return -1;

    else
    {
      fp->version_major=_le_16(*((unsigned short int *)(data + (signed long int)8)));
      fp->version_minor=_le_16(*((unsigned short int *)(data + (signed long int)10)));
      fp->ptime_n=_le_64(*((signed long int *)(data + (signed long int)12)));
      fp->ptime_d=_le_64(*((signed long int *)(data + (signed long int)20)));
      fp->btime_n=_le_64(*((signed long int *)(data + (signed long int)28)));
      fp->btime_d=_le_64(*((signed long int *)(data + (signed long int)36)));
      memcpy((void *)fp->UTC, (const void *)(data + (signed long int)44), (unsigned long int)20);
      return 0;
    }
  }
}

// fishead_from_ogg
// file skeleton.c line 196
extern signed int fishead_from_ogg(struct anonymous_126 *op, struct anonymous_140 *fp)
{
  signed int return_value_fishead_from_data_1;
  return_value_fishead_from_data_1=fishead_from_data(op->packet, (signed int)op->bytes, fp);
  return return_value_fishead_from_data_1;
}

// fishead_from_ogg_page
// file skeleton.c line 201
extern signed int fishead_from_ogg_page(const struct anonymous_15 *og, struct anonymous_140 *fp)
{
  signed int return_value_fishead_from_data_1;
  return_value_fishead_from_data_1=fishead_from_data(og->body, (signed int)og->body_len, fp);
  return return_value_fishead_from_data_1;
}

// flush_ogg_stream_to_file
// file skeleton.c line 282
extern signed int flush_ogg_stream_to_file(struct anonymous_14 *os, struct _IO_FILE *out)
{
  struct anonymous_15 og;
  signed int result;
  do
  {
    result=ogg_stream_flush(os, &og);
    if(result == 0)
      break;

    if(result == 0)
      break;

    result=write_ogg_page_to_file(&og, out);
    if(!((signed long int)result == og.body_len + og.header_len))
      return 1;

  }
  while((_Bool)1);
  return 0;
}

// m_add_fishead_packet
// file rmd_init_encoder.c line 43
static void m_add_fishead_packet(struct anonymous_14 *m_ogg_state)
{
  struct anonymous_140 skel_fp;
  skel_fp.btime_n = (signed long int)0;
  skel_fp.ptime_n = skel_fp.btime_n;
  skel_fp.btime_d = (signed long int)1000;
  skel_fp.ptime_d = skel_fp.btime_d;
  add_fishead_to_stream(m_ogg_state, &skel_fp);
}

// main
// file rmd.c line 49
signed int main(signed int argc, char **argv)
{
  struct _ProgData pdata;
  signed int exit_status = 0;
  rmdSetupDefaultArgs(&pdata.args);
  signed int return_value_rmdParseArgs_1;
  return_value_rmdParseArgs_1=rmdParseArgs(argc, argv, &pdata.args);
  if(return_value_rmdParseArgs_1 == 0)
    exit(1);

  if(!(pdata.args.rescue_path == ((const char *)NULL)))
  {
    signed int return_value_rmdRescue_2;
    return_value_rmdRescue_2=rmdRescue(pdata.args.rescue_path);
    exit(return_value_rmdRescue_2);
  }

  signed int return_value_XInitThreads_3;
  return_value_XInitThreads_3=XInitThreads();
  if(return_value_XInitThreads_3 == 0)
  {
    fprintf(stderr, "Couldn't initialize thread support!\n");
    exit(7);
  }

  if(!(pdata.args.display == ((char *)NULL)))
  {
    pdata.dpy=XOpenDisplay(pdata.args.display);
    XSetErrorHandler(rmdErrorHandler);
  }

  else
  {
    fprintf(stderr, "No display specified for connection!\n");
    exit(8);
  }
  signed int return_value_rmdWMIsCompositing_5;
  _Bool tmp_if_expr_8;
  signed int return_value_rmdRegisterShortcut_7;
  _Bool tmp_if_expr_10;
  signed int return_value_rmdRegisterShortcut_9;
  if(pdata.dpy == ((struct _XDisplay *)NULL))
  {
    fprintf(stderr, "Cannot connect to X server %s\n", pdata.args.display);
    exit(9);
  }

  else
  {
    struct _EncData enc_data;
    struct _CacheData cache_data;
    struct _JackData jdata;
    jdata.pdata = &pdata;
    pdata.jdata = &jdata;
    pdata.specs.screen = ((struct anonymous_146 *)pdata.dpy)->default_screen;
    pdata.specs.width = (unsigned int)(&((struct anonymous_146 *)pdata.dpy)->screens[(signed long int)pdata.specs.screen])->width;
    pdata.specs.height = (unsigned int)(&((struct anonymous_146 *)pdata.dpy)->screens[(signed long int)pdata.specs.screen])->height;
    pdata.specs.root = (&((struct anonymous_146 *)pdata.dpy)->screens[(signed long int)pdata.specs.screen])->root;
    pdata.specs.visual = (&((struct anonymous_146 *)pdata.dpy)->screens[(signed long int)pdata.specs.screen])->root_visual;
    pdata.specs.gc = (&((struct anonymous_146 *)pdata.dpy)->screens[(signed long int)pdata.specs.screen])->default_gc;
    pdata.specs.depth = (&((struct anonymous_146 *)pdata.dpy)->screens[(signed long int)pdata.specs.screen])->root_depth;
    if(!(pdata.specs.depth == 16) && !(pdata.specs.depth == 24) && !(pdata.specs.depth == 32))
    {
      fprintf(stderr, "Only 32bpp,24bpp and 16bpp color depth modes are currently supported.\n");
      exit(10);
    }

    signed int return_value_rmdSetBRWindow_4;
    return_value_rmdSetBRWindow_4=rmdSetBRWindow(pdata.dpy, &pdata.brwin, &pdata.specs, &pdata.args);
    if(return_value_rmdSetBRWindow_4 == 0)
      exit(11);

    if(pdata.args.nowmcheck == 0)
    {
      return_value_rmdWMIsCompositing_5=rmdWMIsCompositing(pdata.dpy, pdata.specs.screen);
      if(!(return_value_rmdWMIsCompositing_5 == 0))
      {
        fprintf(stderr, "\nDetected compositing window manager.\nReverting to full screen capture at every frame.\nTo disable this check run with --no-wm-check\n(though that is not advised, since it will probably produce faulty results).\n\n");
        pdata.args.full_shots = 1;
        pdata.args.noshared = 0;
      }

    }

    rmdQueryExtensions(pdata.dpy, &pdata.args, &pdata.damage_event, &pdata.damage_error, &pdata.shm_opcode);
    exit_status=rmdInitializeData(&pdata, &enc_data, &cache_data);
    if(exit_status == 0)
    {
      signed int return_value_strcmp_6;
      return_value_strcmp_6=strcmp(pdata.args.pause_shortcut, pdata.args.stop_shortcut);
      if(return_value_strcmp_6 == 0)
        tmp_if_expr_8 = (_Bool)1;

      else
      {
        return_value_rmdRegisterShortcut_7=rmdRegisterShortcut(pdata.dpy, pdata.specs.root, pdata.args.pause_shortcut, &pdata.pause_key);
        tmp_if_expr_8 = return_value_rmdRegisterShortcut_7 != 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_8)
        tmp_if_expr_10 = (_Bool)1;

      else
      {
        return_value_rmdRegisterShortcut_9=rmdRegisterShortcut(pdata.dpy, pdata.specs.root, pdata.args.stop_shortcut, &pdata.stop_key);
        tmp_if_expr_10 = return_value_rmdRegisterShortcut_9 != 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_10)
      {
        fprintf(stderr, "Invalid shortcut, or shortcuts are the same!\n\nUsing defaults.\n");
        rmdRegisterShortcut(pdata.dpy, pdata.specs.root, "Control+Mod1+p", &pdata.pause_key);
        rmdRegisterShortcut(pdata.dpy, pdata.specs.root, "Control+Mod1+s", &pdata.stop_key);
      }

      rmdThreads(&pdata);
      XCloseDisplay(pdata.dpy);
      fprintf(stderr, ".\n");
      if(pdata.args.encOnTheFly == 0 && pdata.args.no_encode == 0)
      {
        if(pdata.aborted == 0)
          rmdEncodeCache(&pdata);

        fprintf(stderr, "Cleanning up cache...\n");
        signed int return_value_rmdPurgeCache_11;
        return_value_rmdPurgeCache_11=rmdPurgeCache(pdata.cache_data, (signed int)!(pdata.args.nosound != 0));
        if(!(return_value_rmdPurgeCache_11 == 0))
          fprintf(stderr, "Some error occured while cleaning up cache!\n");

        fprintf(stderr, "Done!!!\n");
      }

      if(!(pdata.args.encOnTheFly == 0) && !(pdata.aborted == 0))
      {
        signed int return_value_remove_12;
        return_value_remove_12=remove(pdata.args.filename);
        if(!(return_value_remove_12 == 0))
        {
          perror("Error while removing file:\n");
          return 1;
        }

        else
        {
          fprintf(stderr, "SIGABRT received,file %s removed\n", pdata.args.filename);
          return 0;
        }
      }

      else
        fprintf(stderr, "Goodbye!\n");
      rmdCleanUp();
    }

  }
  return exit_status;
}

// ogg_from_fisbone
// file skeleton.c line 144
extern signed int ogg_from_fisbone(struct anonymous_139 *fp, struct anonymous_126 *op)
{
  signed int packet_size;
  if(op == ((struct anonymous_126 *)NULL) || fp == ((struct anonymous_139 *)NULL))
    return -1;

  else
  {
    packet_size = (signed int)((unsigned int)52 + fp->current_header_size);
    memset((void *)op, 0, sizeof(struct anonymous_126) /*48ul*/ );
    void *return_value_calloc_1;
    return_value_calloc_1=calloc((unsigned long int)packet_size, sizeof(unsigned char) /*1ul*/ );
    op->packet = (unsigned char *)return_value_calloc_1;
    if(op->packet == ((unsigned char *)NULL))
      return -1;

    else
    {
      memset((void *)op->packet, 0, (unsigned long int)packet_size);
      memcpy((void *)op->packet, (const void *)"fisbone\0", (unsigned long int)8);
      *((unsigned int *)(op->packet + (signed long int)8))=_le_32((unsigned int)44);
      *((unsigned int *)(op->packet + (signed long int)12))=_le_32(fp->serial_no);
      *((unsigned int *)(op->packet + (signed long int)16))=_le_32(fp->nr_header_packet);
      *((signed long int *)(op->packet + (signed long int)20))=_le_64(fp->granule_rate_n);
      *((signed long int *)(op->packet + (signed long int)28))=_le_64(fp->granule_rate_d);
      *((signed long int *)(op->packet + (signed long int)36))=_le_64(fp->start_granule);
      *((unsigned int *)(op->packet + (signed long int)44))=_le_32(fp->preroll);
      op->packet[(signed long int)48] = fp->granule_shift;
      if(!(fp->message_header_fields == ((char *)NULL)))
        memcpy((void *)(op->packet + (signed long int)52), (const void *)fp->message_header_fields, (unsigned long int)fp->current_header_size);

      op->b_o_s = (signed long int)0;
      op->e_o_s = (signed long int)0;
      op->bytes = (signed long int)packet_size;
      return 0;
    }
  }
}

// ogg_from_fishead
// file skeleton.c line 114
extern signed int ogg_from_fishead(struct anonymous_140 *fp, struct anonymous_126 *op)
{
  if(op == ((struct anonymous_126 *)NULL) || fp == ((struct anonymous_140 *)NULL))
    return -1;

  else
  {
    memset((void *)op, 0, sizeof(struct anonymous_126) /*48ul*/ );
    void *return_value_calloc_1;
    return_value_calloc_1=calloc((unsigned long int)64, sizeof(unsigned char) /*1ul*/ );
    op->packet = (unsigned char *)return_value_calloc_1;
    if(op->packet == ((unsigned char *)NULL))
      return -1;

    else
    {
      memset((void *)op->packet, 0, (unsigned long int)64);
      memcpy((void *)op->packet, (const void *)"fishead\0", (unsigned long int)8);
      *((unsigned short int *)(op->packet + (signed long int)8))=_le_16((unsigned short int)3);
      *((unsigned short int *)(op->packet + (signed long int)10))=_le_16((unsigned short int)0);
      *((signed long int *)(op->packet + (signed long int)12))=_le_64(fp->ptime_n);
      *((signed long int *)(op->packet + (signed long int)20))=_le_64(fp->ptime_d);
      *((signed long int *)(op->packet + (signed long int)28))=_le_64(fp->btime_n);
      *((signed long int *)(op->packet + (signed long int)36))=_le_64(fp->btime_d);
      op->b_o_s = (signed long int)1;
      op->e_o_s = (signed long int)0;
      op->bytes = (signed long int)64;
      return 0;
    }
  }
}

// ogg_page_cp
// file rmd_flush_to_ogg.c line 47
static void ogg_page_cp(struct anonymous_15 *new, struct anonymous_15 *old)
{
  signed int i = 0;
  unsigned char *newp;
  unsigned char *oldp;
  new->header_len = old->header_len;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc((unsigned long int)new->header_len);
  new->header = (unsigned char *)return_value_malloc_1;
  new->body_len = old->body_len;
  void *return_value_malloc_2;
  return_value_malloc_2=malloc((unsigned long int)new->body_len);
  new->body = (unsigned char *)return_value_malloc_2;
  newp = new->header;
  oldp = old->header;
  i = 0;
  unsigned char *tmp_post_3;
  unsigned char *tmp_post_4;
  for( ; !((signed long int)i >= new->header_len); i = i + 1)
  {
    tmp_post_3 = newp;
    newp = newp + 1l;
    tmp_post_4 = oldp;
    oldp = oldp + 1l;
    *tmp_post_3 = *tmp_post_4;
  }
  newp = new->body;
  oldp = old->body;
  i = 0;
  unsigned char *tmp_post_5;
  unsigned char *tmp_post_6;
  for( ; !((signed long int)i >= new->body_len); i = i + 1)
  {
    tmp_post_5 = newp;
    newp = newp + 1l;
    tmp_post_6 = oldp;
    oldp = oldp + 1l;
    *tmp_post_5 = *tmp_post_6;
  }
}

// ogg_page_cp_free
// file rmd_flush_to_ogg.c line 67
static void ogg_page_cp_free(struct anonymous_15 *pg)
{
  pg->body_len = (signed long int)0;
  pg->header_len = pg->body_len;
  free((void *)pg->header);
  free((void *)pg->body);
}

// rmdBRWinCpy
// file rmd_get_frame.c line 269
static void rmdBRWinCpy(struct _BRWindow *target, struct _BRWindow *source)
{
  target->rect.x = source->rect.x;
  target->rect.y = source->rect.y;
  target->rect.width = source->rect.width;
  target->rect.height = source->rect.height;
  target->rrect.x = source->rrect.x;
  target->rrect.y = source->rrect.y;
  target->rrect.width = source->rrect.width;
  target->rrect.height = source->rrect.height;
  target->nbytes = source->nbytes;
  target->windowid = source->windowid;
}

// rmdBlocksFromList
// file rmd_get_frame.c line 316
static void rmdBlocksFromList(struct _RectArea **root, unsigned int x_offset, unsigned int y_offset, unsigned int blocknum_x, unsigned int blocknum_y)
{
  struct _RectArea *temp;
  signed int i;
  signed int j;
  signed int blockno;
  signed int row_start;
  signed int row_end;
  signed int column_start;
  signed int column_end;
  temp = *root;
  i = 0;
  for( ; !((unsigned int)i >= blocknum_x * blocknum_y); i = i + 1)
  {
    vblocks[(signed long int)i] = (unsigned int)0;
    ublocks[(signed long int)i] = vblocks[(signed long int)i];
    yblocks[(signed long int)i] = ublocks[(signed long int)i];
  }
  for( ; !(temp == ((struct _RectArea *)NULL)); temp = temp->next)
  {
    column_start = (signed int)((unsigned int)temp->rect.x - x_offset) / 0x0010;
    column_end = (signed int)((unsigned int)((signed int)temp->rect.x + ((signed int)temp->rect.width - 1)) - x_offset) / 0x0010;
    row_start = (signed int)((unsigned int)temp->rect.y - y_offset) / 0x0010;
    row_end = (signed int)((unsigned int)((signed int)temp->rect.y + ((signed int)temp->rect.height - 1)) - y_offset) / 0x0010;
    i = row_start;
    for( ; !(i >= 1 + row_end); i = i + 1)
    {
      j = column_start;
      for( ; !(j >= 1 + column_end); j = j + 1)
      {
        blockno = (signed int)((unsigned int)i * blocknum_x + (unsigned int)j);
        yblocks[(signed long int)blockno] = (unsigned int)1;
        ublocks[(signed long int)blockno] = (unsigned int)1;
        vblocks[(signed long int)blockno] = (unsigned int)1;
      }
    }
  }
}

// rmdCacheFileN
// file rmd_cache.c line 51
static void rmdCacheFileN(char *name, char **newname, signed int n)
{
  char numbuf[8l];
  strcpy(*newname, name);
  strcat(*newname, ".");
  snprintf(numbuf, (unsigned long int)8, "%d", n);
  strcat(*newname, numbuf);
}

// rmdCacheImageBuffer
// file rmd_cache_frame.c line 87
void * rmdCacheImageBuffer(struct _ProgData *pdata)
{
  struct gzFile_s **fp = (struct gzFile_s **)(void *)0;
  struct _IO_FILE *ucfp = (struct _IO_FILE *)(void *)0;
  signed int index_entry_size = (signed int)sizeof(unsigned int) /*4ul*/ ;
  signed int blocknum_x = pdata->enc_data->yuv.y_width / 0x0010;
  signed int blocknum_y = pdata->enc_data->yuv.y_height / 0x0010;
  signed int firstrun = 1;
  signed int frameno = 0;
  signed int nbytes = 0;
  signed int nth_cache = 1;
  const signed long int vnum_array_size0 = (signed long int)(blocknum_x * blocknum_y);
  const signed long int y_short_blocks_array_size0 = (signed long int)(blocknum_x * blocknum_y);
  const signed long int u_short_blocks_array_size0 = (signed long int)(blocknum_x * blocknum_y);
  unsigned int ynum;
  unsigned int unum;
  unsigned int vnum;
  unsigned int y_short_blocks[vnum_array_size0];
  unsigned int u_short_blocks[y_short_blocks_array_size0];
  unsigned int v_short_blocks[u_short_blocks_array_size0];
  unsigned long long int total_bytes = (unsigned long long int)0;
  unsigned long long int total_received_bytes = (unsigned long long int)0;
  if(pdata->args.zerocompression == 0)
  {
    fp = pdata->cache_data->ifp;
    if(fp == ((struct gzFile_s **)NULL))
      exit(13);

  }

  else
  {
    ucfp = pdata->cache_data->uncifp;
    if(ucfp == ((struct _IO_FILE *)NULL))
      exit(13);

  }
  signed int return_value_gzwrite_2;
  signed int return_value_gzwrite_3;
  signed int return_value_gzwrite_4;
  unsigned long int return_value_fwrite_6;
  unsigned long int return_value_fwrite_7;
  unsigned long int return_value_fwrite_8;
  signed int return_value_rmdFlushBlock_9;
  signed int return_value_rmdFlushBlock_10;
  signed int return_value_rmdFlushBlock_11;
  while(!(pdata->running == 0))
  {
    signed int j;
    struct _FrameHeader fheader;
    vnum = (unsigned int)0;
    unum = vnum;
    ynum = unum;
    pdata->th_enc_thread_waiting = 1;
    pthread_mutex_lock(&pdata->img_buff_ready_mutex);
    pthread_cond_wait(&pdata->image_buffer_ready, &pdata->img_buff_ready_mutex);
    pthread_mutex_unlock(&pdata->img_buff_ready_mutex);
    pdata->th_enc_thread_waiting = 0;
    if(!(pdata->paused == 0))
    {
      pthread_mutex_lock(&pdata->pause_mutex);
      pthread_cond_wait(&pdata->pause_cond, &pdata->pause_mutex);
      pthread_mutex_unlock(&pdata->pause_mutex);
    }

    pthread_mutex_lock(&pdata->yuv_mutex);
    if(!(firstrun == 0))
    {
      firstrun = 0;
      j = 0;
      for( ; !(j >= blocknum_x * blocknum_y); j = j + 1)
      {
        ynum = ynum + 1u;
        yblocks[(signed long int)(ynum - (unsigned int)1)] = (unsigned int)1;
        y_short_blocks[(signed long int)(ynum - (unsigned int)1)] = (unsigned int)j;
        unum = unum + 1u;
        ublocks[(signed long int)(unum - (unsigned int)1)] = (unsigned int)1;
        u_short_blocks[(signed long int)(ynum - (unsigned int)1)] = (unsigned int)j;
        vnum = vnum + 1u;
        vblocks[(signed long int)(vnum - (unsigned int)1)] = (unsigned int)1;
        v_short_blocks[(signed long int)(ynum - (unsigned int)1)] = (unsigned int)j;
      }
    }

    else
    {
      j = 0;
      for( ; !(j >= blocknum_x * blocknum_y); j = j + 1)
      {
        if(!(yblocks[(signed long int)j] == 0u))
        {
          ynum = ynum + 1u;
          y_short_blocks[(signed long int)(ynum - (unsigned int)1)] = (unsigned int)j;
        }

        if(!(ublocks[(signed long int)j] == 0u))
        {
          unum = unum + 1u;
          u_short_blocks[(signed long int)(unum - (unsigned int)1)] = (unsigned int)j;
        }

        if(!(vblocks[(signed long int)j] == 0u))
        {
          vnum = vnum + 1u;
          v_short_blocks[(signed long int)(vnum - (unsigned int)1)] = (unsigned int)j;
        }

      }
    }
    if(pdata->args.zerocompression == 0)
    {
      if(!((unsigned int)((6 * blocknum_x * blocknum_y) / 10) >= 4u * ynum + unum + vnum))
        gzsetparams((struct gzFile_s *)fp, 1, 1);

      else
        gzsetparams((struct gzFile_s *)fp, 0, 1);
    }

    strncpy(fheader.frame_prefix, "FRAM", (unsigned long int)4);
    frameno = frameno + 1;
    fheader.frameno = (unsigned int)frameno;
    fheader.current_total = pdata->frames_total;
    fheader.Ynum = ynum;
    fheader.Unum = unum;
    fheader.Vnum = vnum;
    if(pdata->args.zerocompression == 0)
    {
      signed int return_value_gzwrite_1;
      return_value_gzwrite_1=gzwrite((struct gzFile_s *)fp, (void *)&fheader, (unsigned int)sizeof(struct _FrameHeader) /*24ul*/ );
      nbytes = nbytes + return_value_gzwrite_1;
      if(!(ynum == 0u))
      {
        return_value_gzwrite_2=gzwrite((struct gzFile_s *)fp, (void *)y_short_blocks, ynum * (unsigned int)index_entry_size);
        nbytes = nbytes + return_value_gzwrite_2;
      }

      if(!(unum == 0u))
      {
        return_value_gzwrite_3=gzwrite((struct gzFile_s *)fp, (void *)u_short_blocks, unum * (unsigned int)index_entry_size);
        nbytes = nbytes + return_value_gzwrite_3;
      }

      if(!(vnum == 0u))
      {
        return_value_gzwrite_4=gzwrite((struct gzFile_s *)fp, (void *)v_short_blocks, vnum * (unsigned int)index_entry_size);
        nbytes = nbytes + return_value_gzwrite_4;
      }

    }

    else
    {
      unsigned long int return_value_fwrite_5;
      return_value_fwrite_5=fwrite((void *)&fheader, sizeof(struct _FrameHeader) /*24ul*/ , (unsigned long int)1, ucfp);
      nbytes = nbytes + (signed int)(sizeof(struct _FrameHeader) /*24ul*/  * return_value_fwrite_5);
      if(!(ynum == 0u))
      {
        return_value_fwrite_6=fwrite((const void *)y_short_blocks, (unsigned long int)index_entry_size, (unsigned long int)ynum, ucfp);
        nbytes = nbytes + (signed int)((unsigned long int)index_entry_size * return_value_fwrite_6);
      }

      if(!(unum == 0u))
      {
        return_value_fwrite_7=fwrite((const void *)u_short_blocks, (unsigned long int)index_entry_size, (unsigned long int)unum, ucfp);
        nbytes = nbytes + (signed int)((unsigned long int)index_entry_size * return_value_fwrite_7);
      }

      if(!(vnum == 0u))
      {
        return_value_fwrite_8=fwrite((const void *)v_short_blocks, (unsigned long int)index_entry_size, (unsigned long int)vnum, ucfp);
        nbytes = nbytes + (signed int)((unsigned long int)index_entry_size * return_value_fwrite_8);
      }

    }
    if(!(ynum == 0u))
    {
      j = 0;
      for( ; !((unsigned int)j >= ynum); j = j + 1)
      {
        return_value_rmdFlushBlock_9=rmdFlushBlock(pdata->enc_data->yuv.y, (signed int)y_short_blocks[(signed long int)j], pdata->enc_data->yuv.y_width, pdata->enc_data->yuv.y_height, 0x0010, fp, ucfp, 0);
        nbytes = nbytes + return_value_rmdFlushBlock_9;
      }
    }

    if(!(unum == 0u))
    {
      j = 0;
      for( ; !((unsigned int)j >= unum); j = j + 1)
      {
        return_value_rmdFlushBlock_10=rmdFlushBlock(pdata->enc_data->yuv.u, (signed int)u_short_blocks[(signed long int)j], pdata->enc_data->yuv.uv_width, pdata->enc_data->yuv.uv_height, 0x0008, fp, ucfp, 0);
        nbytes = nbytes + return_value_rmdFlushBlock_10;
      }
    }

    if(!(vnum == 0u))
    {
      j = 0;
      for( ; !((unsigned int)j >= vnum); j = j + 1)
      {
        return_value_rmdFlushBlock_11=rmdFlushBlock(pdata->enc_data->yuv.v, (signed int)v_short_blocks[(signed long int)j], pdata->enc_data->yuv.uv_width, pdata->enc_data->yuv.uv_height, 0x0008, fp, ucfp, 0);
        nbytes = nbytes + return_value_rmdFlushBlock_11;
      }
    }

    pthread_mutex_unlock(&pdata->yuv_mutex);
    signed int return_value_rmdFlushBlock_12;
    return_value_rmdFlushBlock_12=rmdFlushBlock((unsigned char *)(void *)0, 0, 0, 0, 0, fp, ucfp, 1);
    nbytes = nbytes + return_value_rmdFlushBlock_12;
    pdata->avd = pdata->avd + (signed int)pdata->frametime;
    if(nbytes >= 524288001)
    {
      signed int return_value_rmdSwapCacheFilesWrite_13;
      return_value_rmdSwapCacheFilesWrite_13=rmdSwapCacheFilesWrite(pdata->cache_data->imgdata, nth_cache, &fp, &ucfp);
      if(!(return_value_rmdSwapCacheFilesWrite_13 == 0))
      {
        fprintf(stderr, "New cache file could not be created.\nEnding recording...\n");
        fflush(stderr);
        raise(2);
      }

      total_bytes = total_bytes + (unsigned long long int)nbytes;
      nth_cache = nth_cache + 1;
      nbytes = 0;
    }

  }
  total_bytes = total_bytes + (unsigned long long int)nbytes;
  unsigned int bytes_per_pixel = (unsigned int)(pdata->specs.depth >= 24 ? 4 : 2);
  unsigned int pixels_per_frame = (unsigned int)((signed int)pdata->brwin.rrect.width * (signed int)pdata->brwin.rrect.height);
  total_received_bytes = (unsigned long long int)frameno * (unsigned long int)bytes_per_pixel * (unsigned long int)pixels_per_frame;
  if(!(total_received_bytes == 0ull))
  {
    double percent_of_data_left = ((double)total_bytes / (double)total_received_bytes) * (double)100;
    fprintf(stderr, "\n*********************************************\n\nCached %llu MB, from %llu MB that were received.\nAverage cache compression ratio: %.1f %%\n\n*********************************************\n", total_bytes / (unsigned long int)(1024 * 1024), total_received_bytes / (unsigned long int)(1024 * 1024), (double)100 - percent_of_data_left);
  }

  fprintf(stderr, "Saved %d frames in a total of %d requests\n", frameno, pdata->frames_total);
  fflush(stderr);
  if(pdata->args.zerocompression == 0)
  {
    gzflush((struct gzFile_s *)fp, 4);
    gzclose((struct gzFile_s *)fp);
  }

  else
  {
    fflush(ucfp);
    fclose(ucfp);
  }
  signed int *return_value___errno_location_14;
  return_value___errno_location_14=__errno_location();
  pthread_exit((void *)&(*return_value___errno_location_14));
}

// rmdCacheSoundBuffer
// file rmd_cache_audio.c line 41
void * rmdCacheSoundBuffer(struct _ProgData *pdata)
{
  void *jackbuf = (void *)0;
  if(!(pdata->args.use_jack == 0))
    jackbuf=malloc((unsigned long int)((unsigned int)pdata->sound_framesize * pdata->jdata->buffersize));

  _Bool tmp_if_expr_1;
  while(!(pdata->running == 0))
  {
    struct _SndBuffer *buff = (struct _SndBuffer *)(void *)0;
    if(!(pdata->paused == 0))
    {
      pthread_mutex_lock(&pdata->pause_mutex);
      pthread_cond_wait(&pdata->pause_cond, &pdata->pause_mutex);
      pthread_mutex_unlock(&pdata->pause_mutex);
    }

    if(pdata->args.use_jack == 0)
    {
      if(pdata->sound_buffer == ((struct _SndBuffer *)NULL))
      {
        pdata->v_enc_thread_waiting = 1;
        pthread_mutex_lock(&pdata->snd_buff_ready_mutex);
        pthread_cond_wait(&pdata->sound_data_read, &pdata->snd_buff_ready_mutex);
        pthread_mutex_unlock(&pdata->snd_buff_ready_mutex);
        pdata->v_enc_thread_waiting = 0;
      }

      if(pdata->sound_buffer == ((struct _SndBuffer *)NULL))
        tmp_if_expr_1 = (_Bool)1;

      else
        tmp_if_expr_1 = !(pdata->running != 0) ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_1)
        break;

      pthread_mutex_lock(&pdata->sound_buffer_mutex);
      buff = pdata->sound_buffer;
      pdata->sound_buffer = pdata->sound_buffer->next;
      pthread_mutex_unlock(&pdata->sound_buffer_mutex);
      fwrite((const void *)buff->data, (unsigned long int)1, pdata->periodsize * (unsigned long int)pdata->sound_framesize, pdata->cache_data->afp);
      free((void *)buff->data);
      free((void *)buff);
    }

    else
    {
      unsigned long int return_value;
      return_value=(jack_ringbuffer_read_space)(pdata->jdata->sound_buffer);
      if(return_value >= (unsigned long int)(pdata->jdata->buffersize * (unsigned int)pdata->sound_framesize))
      {
        (jack_ringbuffer_read)(pdata->jdata->sound_buffer, (char *)jackbuf, (unsigned long int)((unsigned int)pdata->sound_framesize * pdata->jdata->buffersize));
        fwrite(jackbuf, (unsigned long int)1, (unsigned long int)((unsigned int)pdata->sound_framesize * pdata->jdata->buffersize), pdata->cache_data->afp);
      }

      else
      {
        pdata->v_enc_thread_waiting = 1;
        pthread_mutex_lock(&pdata->snd_buff_ready_mutex);
        pthread_cond_wait(&pdata->sound_data_read, &pdata->snd_buff_ready_mutex);
        pthread_mutex_unlock(&pdata->snd_buff_ready_mutex);
        pdata->v_enc_thread_waiting = 0;
        continue;
      }
    }
    pdata->avd = pdata->avd - (signed int)pdata->periodtime;
  }
  fclose(pdata->cache_data->afp);
  signed int *return_value___errno_location_2;
  return_value___errno_location_2=__errno_location();
  pthread_exit((void *)&(*return_value___errno_location_2));
}

// rmdCaptureSound
// file rmd_capture_sound.c line 43
void * rmdCaptureSound(struct _ProgData *pdata)
{
  signed int frames = (signed int)pdata->periodsize;
  usleep(pdata->frametime);
  while(!(pdata->running == 0))
  {
    signed int sret = 0;
    struct _SndBuffer *newbuf;
    struct _SndBuffer *tmp;
    if(!(pdata->paused == 0))
    {
      if(pdata->hard_pause == 0)
      {
        snd_pcm_pause(pdata->sound_handle, 1);
        pthread_mutex_lock(&pdata->pause_mutex);
        pthread_cond_wait(&pdata->pause_cond, &pdata->pause_mutex);
        pthread_mutex_unlock(&pdata->pause_mutex);
        snd_pcm_pause(pdata->sound_handle, 0);
      }

      else
      {
        snd_pcm_close(pdata->sound_handle);
        pthread_mutex_lock(&pdata->pause_mutex);
        pthread_cond_wait(&pdata->pause_cond, &pdata->pause_mutex);
        pthread_mutex_unlock(&pdata->pause_mutex);
        pdata->sound_handle=rmdOpenDev(pdata->args.device, &pdata->args.channels, &pdata->args.frequency, &pdata->args.buffsize, (unsigned long int *)(void *)0, (unsigned int *)(void *)0, (signed int *)(void *)0);
        if(pdata->sound_handle == ((struct _snd_pcm *)NULL))
        {
          fprintf(stderr, "Couldn't reopen sound device.Exiting\n");
          pdata->running = 0;
          signed int *return_value___errno_location_1;
          return_value___errno_location_1=__errno_location();
          *return_value___errno_location_1 = 3;
          signed int *return_value___errno_location_2;
          return_value___errno_location_2=__errno_location();
          pthread_exit((void *)&(*return_value___errno_location_2));
        }

      }
    }

    void *return_value_malloc_3;
    return_value_malloc_3=malloc(sizeof(struct _SndBuffer) /*16ul*/ );
    newbuf = (struct _SndBuffer *)return_value_malloc_3;
    void *return_value_malloc_4;
    return_value_malloc_4=malloc((unsigned long int)(frames * pdata->sound_framesize));
    newbuf->data = (signed char *)return_value_malloc_4;
    newbuf->next = (struct _SndBuffer *)(void *)0;
    while(!(sret >= frames))
    {
      signed int temp_sret;
      signed long int return_value_snd_pcm_readi_5;
      return_value_snd_pcm_readi_5=snd_pcm_readi(pdata->sound_handle, (void *)(newbuf->data + (signed long int)(pdata->sound_framesize * sret)), (unsigned long int)(frames - sret));
      temp_sret = (signed int)return_value_snd_pcm_readi_5;
      if(temp_sret == -32)
      {
        const char *return_value_snd_strerror_6;
        return_value_snd_strerror_6=snd_strerror(temp_sret);
        fprintf(stderr, "%s: Overrun occurred.\n", return_value_snd_strerror_6);
        snd_pcm_prepare(pdata->sound_handle);
      }

      else
        if(!(temp_sret >= 0))
        {
          const char *return_value_snd_strerror_7;
          return_value_snd_strerror_7=snd_strerror(temp_sret);
          fprintf(stderr, "An error occured while reading sound data:\n %s\n", return_value_snd_strerror_7);
          snd_pcm_prepare(pdata->sound_handle);
        }

        else
          sret = sret + temp_sret;
    }
    pthread_mutex_lock(&pdata->sound_buffer_mutex);
    tmp = pdata->sound_buffer;
    if(pdata->sound_buffer == ((struct _SndBuffer *)NULL))
      pdata->sound_buffer = newbuf;

    else
    {
      for( ; !(tmp->next == ((struct _SndBuffer *)NULL)); tmp = tmp->next)
        ;
      tmp->next = newbuf;
    }
    pthread_mutex_unlock(&pdata->sound_buffer_mutex);
    pthread_mutex_lock(&pdata->snd_buff_ready_mutex);
    pthread_cond_signal(&pdata->sound_data_read);
    pthread_mutex_unlock(&pdata->snd_buff_ready_mutex);
  }
  snd_pcm_close(pdata->sound_handle);
  signed int *return_value___errno_location_8;
  return_value___errno_location_8=__errno_location();
  pthread_exit((void *)&(*return_value___errno_location_8));
}

// rmdCleanUp
// file rmd_initialize_data.h line 59
void rmdCleanUp(void)
{
  free((void *)yblocks);
  free((void *)ublocks);
  free((void *)vblocks);
}

// rmdClearList
// file rmd_rectinsert.h line 52
void rmdClearList(struct _RectArea **root)
{
  struct _RectArea *temp = *root;
  if(!(temp == ((struct _RectArea *)NULL)))
  {
    while(!(temp->next == ((struct _RectArea *)NULL)))
    {
      temp = temp->next;
      free((void *)temp->prev);
    }
    free((void *)temp);
    *root = (struct _RectArea *)(void *)0;
  }

}

// rmdCollideRects
// file rmd_rectinsert.c line 59
static signed int rmdCollideRects(struct anonymous_17 *xrect1, struct anonymous_17 *xrect2, struct anonymous_17 *xrect_return, signed int *nrects)
{
  _Bool tmp_if_expr_43;
  if((signed int)xrect1->x >= (signed int)xrect2->x)
    tmp_if_expr_43 = (signed int)xrect1->x + (signed int)xrect1->width <= (signed int)xrect2->x + (signed int)xrect2->width ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_43 = (_Bool)0;
  _Bool tmp_if_expr_44;
  if(tmp_if_expr_43)
    tmp_if_expr_44 = (signed int)xrect1->y >= (signed int)xrect2->y ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_44 = (_Bool)0;
  _Bool tmp_if_expr_45;
  if(tmp_if_expr_44)
    tmp_if_expr_45 = (signed int)xrect1->y + (signed int)xrect1->height <= (signed int)xrect2->y + (signed int)xrect2->height ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_45 = (_Bool)0;
  _Bool tmp_if_expr_40;
  _Bool tmp_if_expr_41;
  _Bool tmp_if_expr_42;
  _Bool tmp_if_expr_37;
  _Bool tmp_if_expr_38;
  _Bool tmp_if_expr_39;
  _Bool tmp_if_expr_1;
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_5;
  _Bool tmp_if_expr_6;
  _Bool tmp_if_expr_7;
  _Bool tmp_if_expr_8;
  _Bool tmp_if_expr_9;
  _Bool tmp_if_expr_10;
  _Bool tmp_if_expr_11;
  _Bool tmp_if_expr_12;
  _Bool tmp_if_expr_13;
  _Bool tmp_if_expr_14;
  _Bool tmp_if_expr_15;
  _Bool tmp_if_expr_16;
  _Bool tmp_if_expr_17;
  _Bool tmp_if_expr_18;
  _Bool tmp_if_expr_19;
  _Bool tmp_if_expr_20;
  _Bool tmp_if_expr_21;
  _Bool tmp_if_expr_22;
  _Bool tmp_if_expr_23;
  _Bool tmp_if_expr_24;
  _Bool tmp_if_expr_29;
  _Bool tmp_if_expr_30;
  _Bool tmp_if_expr_27;
  _Bool tmp_if_expr_28;
  _Bool tmp_if_expr_25;
  _Bool tmp_if_expr_26;
  _Bool tmp_if_expr_33;
  _Bool tmp_if_expr_32;
  _Bool tmp_if_expr_31;
  _Bool tmp_if_expr_36;
  _Bool tmp_if_expr_35;
  _Bool tmp_if_expr_34;
  if(tmp_if_expr_45)
  {
    *nrects = 0;
    return 1;
  }

  else
  {
    if((signed int)xrect2->x >= (signed int)xrect1->x)
      tmp_if_expr_40 = (signed int)xrect2->x + (signed int)xrect2->width <= (signed int)xrect1->x + (signed int)xrect1->width ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_40 = (_Bool)0;
    if(tmp_if_expr_40)
      tmp_if_expr_41 = (signed int)xrect2->y >= (signed int)xrect1->y ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_41 = (_Bool)0;
    if(tmp_if_expr_41)
      tmp_if_expr_42 = (signed int)xrect2->y + (signed int)xrect2->height <= (signed int)xrect1->y + (signed int)xrect1->height ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_42 = (_Bool)0;
    if(tmp_if_expr_42)
    {
      *nrects = 0;
      return 2;
    }

    else
    {
      if(!((signed int)xrect1->x + (signed int)xrect1->width >= (signed int)xrect2->x))
        tmp_if_expr_37 = (_Bool)1;

      else
        tmp_if_expr_37 = (signed int)xrect2->x + (signed int)xrect2->width < (signed int)xrect1->x ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_37)
        tmp_if_expr_38 = (_Bool)1;

      else
        tmp_if_expr_38 = (signed int)xrect1->y + (signed int)xrect1->height < (signed int)xrect2->y ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_38)
        tmp_if_expr_39 = (_Bool)1;

      else
        tmp_if_expr_39 = (signed int)xrect2->y + (signed int)xrect2->height < (signed int)xrect1->y ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_39)
      {
        *nrects = 0;
        return 0;
      }

      else
      {
        signed int x1[2l] = { (signed int)xrect1->x, (signed int)xrect1->x + (signed int)xrect1->width };
        signed int y1[2l] = { (signed int)xrect1->y, (signed int)xrect1->y + (signed int)xrect1->height };
        signed int x2[2l] = { (signed int)xrect2->x, (signed int)xrect2->x + (signed int)xrect2->width };
        signed int y2[2l] = { (signed int)xrect2->y, (signed int)xrect2->y + (signed int)xrect2->height };
        signed int enclosed[2l][4l];
        signed int tot1;
        signed int tot2;
        if(x1[0l] >= x2[0l])
          tmp_if_expr_1 = x1[(signed long int)0] <= x2[(signed long int)1] ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_1 = (_Bool)0;
        if(tmp_if_expr_1)
          tmp_if_expr_2 = y1[(signed long int)0] >= y2[(signed long int)0] ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_2 = (_Bool)0;
        if(tmp_if_expr_2)
          tmp_if_expr_3 = y1[(signed long int)0] <= y2[(signed long int)1] ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_3 = (_Bool)0;
        enclosed[(signed long int)0][(signed long int)0] = tmp_if_expr_3 ? 1 : 0;
        if(x1[1l] >= x2[0l])
          tmp_if_expr_4 = x1[(signed long int)1] <= x2[(signed long int)1] ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_4 = (_Bool)0;
        if(tmp_if_expr_4)
          tmp_if_expr_5 = y1[(signed long int)0] >= y2[(signed long int)0] ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_5 = (_Bool)0;
        if(tmp_if_expr_5)
          tmp_if_expr_6 = y1[(signed long int)0] <= y2[(signed long int)1] ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_6 = (_Bool)0;
        enclosed[(signed long int)0][(signed long int)1] = tmp_if_expr_6 ? 1 : 0;
        if(x1[0l] >= x2[0l])
          tmp_if_expr_7 = x1[(signed long int)0] <= x2[(signed long int)1] ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_7 = (_Bool)0;
        if(tmp_if_expr_7)
          tmp_if_expr_8 = y1[(signed long int)1] >= y2[(signed long int)0] ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_8 = (_Bool)0;
        if(tmp_if_expr_8)
          tmp_if_expr_9 = y1[(signed long int)1] <= y2[(signed long int)1] ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_9 = (_Bool)0;
        enclosed[(signed long int)0][(signed long int)2] = tmp_if_expr_9 ? 1 : 0;
        if(x1[1l] >= x2[0l])
          tmp_if_expr_10 = x1[(signed long int)1] <= x2[(signed long int)1] ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_10 = (_Bool)0;
        if(tmp_if_expr_10)
          tmp_if_expr_11 = y1[(signed long int)1] >= y2[(signed long int)0] ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_11 = (_Bool)0;
        if(tmp_if_expr_11)
          tmp_if_expr_12 = y1[(signed long int)1] <= y2[(signed long int)1] ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_12 = (_Bool)0;
        enclosed[(signed long int)0][(signed long int)3] = tmp_if_expr_12 ? 1 : 0;
        if(x2[0l] >= x1[0l])
          tmp_if_expr_13 = x2[(signed long int)0] <= x1[(signed long int)1] ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_13 = (_Bool)0;
        if(tmp_if_expr_13)
          tmp_if_expr_14 = y2[(signed long int)0] >= y1[(signed long int)0] ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_14 = (_Bool)0;
        if(tmp_if_expr_14)
          tmp_if_expr_15 = y2[(signed long int)0] <= y1[(signed long int)1] ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_15 = (_Bool)0;
        enclosed[(signed long int)1][(signed long int)0] = tmp_if_expr_15 ? 1 : 0;
        if(x2[1l] >= x1[0l])
          tmp_if_expr_16 = x2[(signed long int)1] <= x1[(signed long int)1] ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_16 = (_Bool)0;
        if(tmp_if_expr_16)
          tmp_if_expr_17 = y2[(signed long int)0] >= y1[(signed long int)0] ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_17 = (_Bool)0;
        if(tmp_if_expr_17)
          tmp_if_expr_18 = y2[(signed long int)0] <= y1[(signed long int)1] ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_18 = (_Bool)0;
        enclosed[(signed long int)1][(signed long int)1] = tmp_if_expr_18 ? 1 : 0;
        if(x2[0l] >= x1[0l])
          tmp_if_expr_19 = x2[(signed long int)0] <= x1[(signed long int)1] ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_19 = (_Bool)0;
        if(tmp_if_expr_19)
          tmp_if_expr_20 = y2[(signed long int)1] >= y1[(signed long int)0] ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_20 = (_Bool)0;
        if(tmp_if_expr_20)
          tmp_if_expr_21 = y2[(signed long int)1] <= y1[(signed long int)1] ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_21 = (_Bool)0;
        enclosed[(signed long int)1][(signed long int)2] = tmp_if_expr_21 ? 1 : 0;
        if(x2[1l] >= x1[0l])
          tmp_if_expr_22 = x2[(signed long int)1] <= x1[(signed long int)1] ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_22 = (_Bool)0;
        if(tmp_if_expr_22)
          tmp_if_expr_23 = y2[(signed long int)1] >= y1[(signed long int)0] ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_23 = (_Bool)0;
        if(tmp_if_expr_23)
          tmp_if_expr_24 = y2[(signed long int)1] <= y1[(signed long int)1] ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_24 = (_Bool)0;
        enclosed[(signed long int)1][(signed long int)3] = tmp_if_expr_24 ? 1 : 0;
        tot1 = enclosed[(signed long int)0][(signed long int)0] + enclosed[(signed long int)0][(signed long int)1] + enclosed[(signed long int)0][(signed long int)2] + enclosed[(signed long int)0][(signed long int)3];
        tot2 = enclosed[(signed long int)1][(signed long int)0] + enclosed[(signed long int)1][(signed long int)1] + enclosed[(signed long int)1][(signed long int)2] + enclosed[(signed long int)1][(signed long int)3];
        if(tot1 == 2 && tot2 == 2)
        {
          if(!(enclosed[1l][0l] == 0))
            tmp_if_expr_29 = enclosed[(signed long int)1][(signed long int)1] != 0 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_29 = (_Bool)0;
          if(tmp_if_expr_29)
            tmp_if_expr_30 = xrect1->width == xrect2->width ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_30 = (_Bool)0;
          if(tmp_if_expr_30)
          {
            *nrects = 1;
            (xrect_return + (signed long int)0)->x = xrect1->x;
            (xrect_return + (signed long int)0)->y = xrect1->y;
            (xrect_return + (signed long int)0)->width = xrect1->width;
            (xrect_return + (signed long int)0)->height = (unsigned short int)(((signed int)xrect2->height + (signed int)xrect2->y) - (signed int)xrect1->y);
            return -10;
          }

          else
          {
            if(!(enclosed[1l][0l] == 0))
              tmp_if_expr_27 = enclosed[(signed long int)1][(signed long int)2] != 0 ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr_27 = (_Bool)0;
            if(tmp_if_expr_27)
              tmp_if_expr_28 = xrect1->height == xrect2->height ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr_28 = (_Bool)0;
            if(tmp_if_expr_28)
            {
              *nrects = 1;
              (xrect_return + (signed long int)0)->x = xrect1->x;
              (xrect_return + (signed long int)0)->y = xrect1->y;
              (xrect_return + (signed long int)0)->width = (unsigned short int)(((signed int)xrect2->width + (signed int)xrect2->x) - (signed int)xrect1->x);
              (xrect_return + (signed long int)0)->height = xrect1->height;
              return -10;
            }

            else
            {
              if(!(enclosed[1l][3l] == 0))
                tmp_if_expr_25 = enclosed[(signed long int)1][(signed long int)1] != 0 ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr_25 = (_Bool)0;
              if(tmp_if_expr_25)
                tmp_if_expr_26 = xrect1->height == xrect2->height ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr_26 = (_Bool)0;
              if(tmp_if_expr_26)
              {
                *nrects = 1;
                (xrect_return + (signed long int)0)->x = xrect2->x;
                (xrect_return + (signed long int)0)->y = xrect2->y;
                (xrect_return + (signed long int)0)->width = (unsigned short int)(((signed int)xrect1->width + (signed int)xrect1->x) - (signed int)xrect2->x);
                (xrect_return + (signed long int)0)->height = xrect2->height;
                return -10;
              }

              else
                if(!(enclosed[1l][3l] == 0))
                {
                  if(!(enclosed[1l][2l] == 0))
                  {
                    if(xrect1->width == xrect2->width)
                    {
                      *nrects = 1;
                      (xrect_return + (signed long int)0)->x = xrect2->x;
                      (xrect_return + (signed long int)0)->y = xrect2->y;
                      (xrect_return + (signed long int)0)->width = xrect2->width;
                      (xrect_return + (signed long int)0)->height = (unsigned short int)(((signed int)xrect1->height + (signed int)xrect1->y) - (signed int)xrect2->y);
                      return -10;
                    }

                  }

                }

            }
          }
        }

        if(tot2 == 2)
        {
          (xrect_return + (signed long int)0)->x = xrect2->x;
          (xrect_return + (signed long int)0)->y = xrect2->y;
          (xrect_return + (signed long int)0)->width = xrect2->width;
          (xrect_return + (signed long int)0)->height = xrect2->height;
          *nrects = 1;
          if(!(enclosed[1l][0l] == 0))
            tmp_if_expr_33 = enclosed[(signed long int)1][(signed long int)1] != 0 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_33 = (_Bool)0;
          if(tmp_if_expr_33)
          {
            (xrect_return + (signed long int)0)->y = (signed short int)y1[(signed long int)1];
            (xrect_return + (signed long int)0)->height = (xrect_return + (signed long int)0)->height - (unsigned short int)(y1[(signed long int)1] - y2[(signed long int)0]);
          }

          else
          {
            if(!(enclosed[1l][0l] == 0))
              tmp_if_expr_32 = enclosed[(signed long int)1][(signed long int)2] != 0 ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr_32 = (_Bool)0;
            if(tmp_if_expr_32)
            {
              (xrect_return + (signed long int)0)->x = (signed short int)x1[(signed long int)1];
              (xrect_return + (signed long int)0)->width = (xrect_return + (signed long int)0)->width - (unsigned short int)(x1[(signed long int)1] - x2[(signed long int)0]);
            }

            else
            {
              if(!(enclosed[1l][3l] == 0))
                tmp_if_expr_31 = enclosed[(signed long int)1][(signed long int)1] != 0 ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr_31 = (_Bool)0;
              if(tmp_if_expr_31)
                (xrect_return + (signed long int)0)->width = (xrect_return + (signed long int)0)->width - (unsigned short int)(x2[(signed long int)1] - x1[(signed long int)0]);

              else
                if(!(enclosed[1l][3l] == 0))
                {
                  if(!(enclosed[1l][2l] == 0))
                    (xrect_return + (signed long int)0)->height = (xrect_return + (signed long int)0)->height - (unsigned short int)(y2[(signed long int)1] - y1[(signed long int)0]);

                }

            }
          }
          return -2;
        }

        else
          if(tot1 == 2)
          {
            (xrect_return + (signed long int)1)->x = xrect2->x;
            (xrect_return + (signed long int)1)->y = xrect2->y;
            (xrect_return + (signed long int)1)->width = xrect2->width;
            (xrect_return + (signed long int)1)->height = xrect2->height;
            (xrect_return + (signed long int)0)->x = xrect1->x;
            (xrect_return + (signed long int)0)->y = xrect1->y;
            (xrect_return + (signed long int)0)->width = xrect1->width;
            (xrect_return + (signed long int)0)->height = xrect1->height;
            *nrects = 1;
            if(!(enclosed[0l][0l] == 0))
              tmp_if_expr_36 = enclosed[(signed long int)0][(signed long int)1] != 0 ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr_36 = (_Bool)0;
            if(tmp_if_expr_36)
            {
              (xrect_return + (signed long int)0)->y = (signed short int)y2[(signed long int)1];
              (xrect_return + (signed long int)0)->height = (xrect_return + (signed long int)0)->height - (unsigned short int)(y2[(signed long int)1] - y1[(signed long int)0]);
            }

            else
            {
              if(!(enclosed[0l][0l] == 0))
                tmp_if_expr_35 = enclosed[(signed long int)0][(signed long int)2] != 0 ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr_35 = (_Bool)0;
              if(tmp_if_expr_35)
              {
                (xrect_return + (signed long int)0)->x = (signed short int)x2[(signed long int)1];
                (xrect_return + (signed long int)0)->width = (xrect_return + (signed long int)0)->width - (unsigned short int)(x2[(signed long int)1] - x1[(signed long int)0]);
              }

              else
              {
                if(!(enclosed[0l][3l] == 0))
                  tmp_if_expr_34 = enclosed[(signed long int)0][(signed long int)1] != 0 ? (_Bool)1 : (_Bool)0;

                else
                  tmp_if_expr_34 = (_Bool)0;
                if(tmp_if_expr_34)
                  (xrect_return + (signed long int)0)->width = (xrect_return + (signed long int)0)->width - (unsigned short int)(x1[(signed long int)1] - x2[(signed long int)0]);

                else
                  if(!(enclosed[0l][3l] == 0))
                  {
                    if(!(enclosed[0l][2l] == 0))
                      (xrect_return + (signed long int)0)->height = (xrect_return + (signed long int)0)->height - (unsigned short int)(y1[(signed long int)1] - y2[(signed long int)0]);

                  }

              }
            }
            return -1;
          }

          else
            if(tot2 == 1)
            {
              *nrects = 2;
              if(!(enclosed[1l][0l] == 0))
              {
                (xrect_return + (signed long int)0)->x = (signed short int)x1[(signed long int)1];
                (xrect_return + (signed long int)0)->y = (signed short int)y2[(signed long int)0];
                (xrect_return + (signed long int)0)->width = (unsigned short int)(((signed int)xrect2->width - x1[(signed long int)1]) + x2[(signed long int)0]);
                (xrect_return + (signed long int)0)->height = xrect2->height;
                (xrect_return + (signed long int)1)->x = (signed short int)x2[(signed long int)0];
                (xrect_return + (signed long int)1)->y = (signed short int)y1[(signed long int)1];
                (xrect_return + (signed long int)1)->width = (unsigned short int)(x1[(signed long int)1] - x2[(signed long int)0]);
                (xrect_return + (signed long int)1)->height = (unsigned short int)(((signed int)xrect2->height - y1[(signed long int)1]) + y2[(signed long int)0]);
              }

              else
                if(!(enclosed[1l][1l] == 0))
                {
                  (xrect_return + (signed long int)0)->x = (signed short int)x2[(signed long int)0];
                  (xrect_return + (signed long int)0)->y = (signed short int)y2[(signed long int)0];
                  (xrect_return + (signed long int)0)->width = (unsigned short int)(((signed int)xrect2->width - x2[(signed long int)1]) + x1[(signed long int)0]);
                  (xrect_return + (signed long int)0)->height = xrect2->height;
                  (xrect_return + (signed long int)1)->x = (signed short int)x1[(signed long int)0];
                  (xrect_return + (signed long int)1)->y = (signed short int)y1[(signed long int)1];
                  (xrect_return + (signed long int)1)->width = (unsigned short int)(x2[(signed long int)1] - x1[(signed long int)0]);
                  (xrect_return + (signed long int)1)->height = (unsigned short int)(((signed int)xrect2->height - y1[(signed long int)1]) + y2[(signed long int)0]);
                }

                else
                  if(!(enclosed[1l][2l] == 0))
                  {
                    (xrect_return + (signed long int)0)->x = (signed short int)x1[(signed long int)1];
                    (xrect_return + (signed long int)0)->y = (signed short int)y2[(signed long int)0];
                    (xrect_return + (signed long int)0)->width = (unsigned short int)(((signed int)xrect2->width - x1[(signed long int)1]) + x2[(signed long int)0]);
                    (xrect_return + (signed long int)0)->height = xrect2->height;
                    (xrect_return + (signed long int)1)->x = (signed short int)x2[(signed long int)0];
                    (xrect_return + (signed long int)1)->y = (signed short int)y2[(signed long int)0];
                    (xrect_return + (signed long int)1)->width = (unsigned short int)(x1[(signed long int)1] - x2[(signed long int)0]);
                    (xrect_return + (signed long int)1)->height = (unsigned short int)(((signed int)xrect2->height - y2[(signed long int)1]) + y1[(signed long int)0]);
                  }

                  else
                    if(!(enclosed[1l][3l] == 0))
                    {
                      (xrect_return + (signed long int)0)->x = (signed short int)x2[(signed long int)0];
                      (xrect_return + (signed long int)0)->y = (signed short int)y2[(signed long int)0];
                      (xrect_return + (signed long int)0)->width = (unsigned short int)(((signed int)xrect2->width - x2[(signed long int)1]) + x1[(signed long int)0]);
                      (xrect_return + (signed long int)0)->height = xrect2->height;
                      (xrect_return + (signed long int)1)->x = (signed short int)x1[(signed long int)0];
                      (xrect_return + (signed long int)1)->y = (signed short int)y2[(signed long int)0];
                      (xrect_return + (signed long int)1)->width = (unsigned short int)(x2[(signed long int)1] - x1[(signed long int)0]);
                      (xrect_return + (signed long int)1)->height = (unsigned short int)(((signed int)xrect2->height - y2[(signed long int)1]) + y1[(signed long int)0]);
                    }

              return -2;
            }

            else
            {
              *nrects = 2;
              if(!((signed int)xrect2->y >= (signed int)xrect1->y))
              {
                (xrect_return + (signed long int)1)->x = (signed short int)x2[(signed long int)0];
                (xrect_return + (signed long int)0)->x = (xrect_return + (signed long int)1)->x;
                (xrect_return + (signed long int)1)->width = xrect2->width;
                (xrect_return + (signed long int)0)->width = (xrect_return + (signed long int)1)->width;
                (xrect_return + (signed long int)0)->y = (signed short int)y2[(signed long int)0];
                (xrect_return + (signed long int)0)->height = (unsigned short int)(((signed int)xrect2->height - y2[(signed long int)1]) + y1[(signed long int)0]);
                (xrect_return + (signed long int)1)->y = (signed short int)y1[(signed long int)1];
                (xrect_return + (signed long int)1)->height = (unsigned short int)(y2[(signed long int)1] - y1[(signed long int)1]);
              }

              else
              {
                (xrect_return + (signed long int)1)->y = (signed short int)y2[(signed long int)0];
                (xrect_return + (signed long int)0)->y = (xrect_return + (signed long int)1)->y;
                (xrect_return + (signed long int)1)->height = xrect2->height;
                (xrect_return + (signed long int)0)->height = (xrect_return + (signed long int)1)->height;
                (xrect_return + (signed long int)0)->x = (signed short int)x2[(signed long int)0];
                (xrect_return + (signed long int)0)->width = (unsigned short int)(((signed int)xrect2->width - x2[(signed long int)1]) + x1[(signed long int)0]);
                (xrect_return + (signed long int)1)->x = (signed short int)x1[(signed long int)1];
                (xrect_return + (signed long int)1)->width = (unsigned short int)(x2[(signed long int)1] - x1[(signed long int)1]);
              }
              return -2;
            }
      }
    }
  }
}

// rmdDrawFrame
// file rmd_frame.c line 41
void rmdDrawFrame(struct _XDisplay *dpy, signed int screen, unsigned long int win, signed int width, signed int height)
{
  struct _XGC *gc;
  struct anonymous_16 gcv;
  struct anonymous_18 white;
  struct anonymous_18 white_e;
  struct anonymous_18 black;
  struct anonymous_18 black_e;
  unsigned long int gcmask = (unsigned long int)(1L << 2);
  XAllocNamedColor(dpy, (&((struct anonymous_146 *)dpy)->screens[(signed long int)screen])->cmap, "white", &white, &white_e);
  XAllocNamedColor(dpy, (&((struct anonymous_146 *)dpy)->screens[(signed long int)screen])->cmap, "black", &black, &black_e);
  gcv.foreground = black.pixel;
  gc=XCreateGC(dpy, win, gcmask, &gcv);
  XFillRectangle(dpy, win, gc, 1, 1, (unsigned int)(width + (6 - 1) * 2), (unsigned int)(height + (6 - 1) * 2));
  gcv.foreground = white.pixel;
  XChangeGC(dpy, gc, gcmask, &gcv);
  XFillRectangle(dpy, win, gc, 6 - 1, 6 - 1, (unsigned int)(width + 1 * 2), (unsigned int)(height + 1 * 2));
  XFreeGC(dpy, gc);
}

// rmdEncodeCache
// file rmd_encode_cache.h line 38
void rmdEncodeCache(struct _ProgData *pdata)
{
  unsigned long int flush_to_ogg_t;
  unsigned long int load_cache_t;
  fprintf(stderr, "STATE:ENCODING\n");
  fflush(stderr);
  fprintf(stderr, "Encoding started!\nThis may take several minutes.\nPressing Ctrl-C will cancel the procedure (resuming will not be possible, but\nany portion of the video, which is already encoded won't be deleted).\nPlease wait...\n");
  pdata->running = (signed int)!(0 != 0);
  rmdInitEncoder(pdata, pdata->enc_data, 1);
  if(pdata->args.nosound == 0)
    for( ; !(pdata->sound_buffer == ((struct _SndBuffer *)NULL)); pdata->sound_buffer = pdata->sound_buffer->next)
      free((void *)pdata->sound_buffer->data);

  pthread_create(&flush_to_ogg_t, (const union pthread_attr_t *)(void *)0, (void * (*)(void *))(void *)rmdFlushToOgg, (void *)pdata);
  pthread_create(&load_cache_t, (const union pthread_attr_t *)(void *)0, (void * (*)(void *))(void *)rmdLoadCache, (void *)pdata);
  pthread_join(load_cache_t, (void **)(void *)0);
  fprintf(stderr, "Encoding finished!\nWait a moment please...\n");
  pthread_join(flush_to_ogg_t, (void **)(void *)0);
}

// rmdEncodeImageBuffer
// file rmd_encode_image_buffer.c line 35
void * rmdEncodeImageBuffer(struct _ProgData *pdata)
{
  pdata->th_encoding_clean = 0;
  while(!(pdata->running == 0))
  {
    pdata->th_enc_thread_waiting = 1;
    pthread_mutex_lock(&pdata->img_buff_ready_mutex);
    pthread_cond_wait(&pdata->image_buffer_ready, &pdata->img_buff_ready_mutex);
    pthread_mutex_unlock(&pdata->img_buff_ready_mutex);
    pdata->th_enc_thread_waiting = 0;
    pdata->encoder_busy = (signed int)!(0 != 0);
    if(!(pdata->paused == 0))
    {
      pthread_mutex_lock(&pdata->pause_mutex);
      pthread_cond_wait(&pdata->pause_cond, &pdata->pause_mutex);
      pthread_mutex_unlock(&pdata->pause_mutex);
    }

    pthread_mutex_lock(&pdata->yuv_mutex);
    signed int return_value_theora_encode_YUVin_2;
    return_value_theora_encode_YUVin_2=theora_encode_YUVin(&pdata->enc_data->m_th_st, &pdata->enc_data->yuv);
    if(!(return_value_theora_encode_YUVin_2 == 0))
    {
      fprintf(stderr, "Encoder not ready!\n");
      pthread_mutex_unlock(&pdata->yuv_mutex);
    }

    else
    {
      pthread_mutex_unlock(&pdata->yuv_mutex);
      signed int return_value_theora_encode_packetout_1;
      return_value_theora_encode_packetout_1=theora_encode_packetout(&pdata->enc_data->m_th_st, 0, &pdata->enc_data->m_ogg_pckt1);
      if(return_value_theora_encode_packetout_1 == 1)
      {
        pthread_mutex_lock(&pdata->libogg_mutex);
        ogg_stream_packetin(&pdata->enc_data->m_ogg_ts, &pdata->enc_data->m_ogg_pckt1);
        pthread_mutex_unlock(&pdata->libogg_mutex);
        pdata->avd = pdata->avd + (signed int)pdata->frametime;
      }

    }
    pdata->encoder_busy = 0;
  }
  pdata->th_encoding_clean = 1;
  pthread_mutex_lock(&pdata->theora_lib_mutex);
  pthread_cond_signal(&pdata->theora_lib_clean);
  pthread_mutex_unlock(&pdata->theora_lib_mutex);
  signed int *return_value___errno_location_3;
  return_value___errno_location_3=__errno_location();
  pthread_exit((void *)&(*return_value___errno_location_3));
}

// rmdEncodeSoundBuffer
// file rmd_encode_sound_buffer.c line 39
void * rmdEncodeSoundBuffer(struct _ProgData *pdata)
{
  signed int sampread = (signed int)pdata->periodsize;
  void *jackbuf = (void *)0;
  if(!(pdata->args.use_jack == 0))
    jackbuf=malloc((unsigned long int)((unsigned int)pdata->sound_framesize * pdata->jdata->buffersize));

  pdata->v_encoding_clean = 0;
  _Bool tmp_if_expr_1;
  signed int return_value_vorbis_analysis_blockout_2;
  signed int return_value_vorbis_bitrate_flushpacket_3;
  while(!(pdata->running == 0))
  {
    float **vorbis_buffer;
    signed int count = 0;
    signed int i;
    signed int j;
    struct _SndBuffer *buff = (struct _SndBuffer *)(void *)0;
    if(!(pdata->paused == 0))
    {
      pthread_mutex_lock(&pdata->pause_mutex);
      pthread_cond_wait(&pdata->pause_cond, &pdata->pause_mutex);
      pthread_mutex_unlock(&pdata->pause_mutex);
    }

    if(pdata->args.use_jack == 0)
    {
      if(pdata->sound_buffer == ((struct _SndBuffer *)NULL))
      {
        pdata->v_enc_thread_waiting = 1;
        pthread_mutex_lock(&pdata->snd_buff_ready_mutex);
        pthread_cond_wait(&pdata->sound_data_read, &pdata->snd_buff_ready_mutex);
        pthread_mutex_unlock(&pdata->snd_buff_ready_mutex);
        pdata->v_enc_thread_waiting = 0;
      }

      if(pdata->sound_buffer == ((struct _SndBuffer *)NULL))
        tmp_if_expr_1 = (_Bool)1;

      else
        tmp_if_expr_1 = !(pdata->running != 0) ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_1)
        break;

      pthread_mutex_lock(&pdata->sound_buffer_mutex);
      buff = pdata->sound_buffer;
      pdata->sound_buffer = pdata->sound_buffer->next;
      pthread_mutex_unlock(&pdata->sound_buffer_mutex);
      vorbis_buffer=vorbis_analysis_buffer(&pdata->enc_data->m_vo_dsp, sampread);
      i = 0;
      for( ; !(i >= sampread); i = i + 1)
      {
        j = 0;
        for( ; !((unsigned int)j >= pdata->args.channels); j = j + 1)
        {
          vorbis_buffer[(signed long int)j][(signed long int)i] = (float)((signed int)buff->data[(signed long int)(count + 1)] << 8 | 0x00ff & (signed int)buff->data[(signed long int)count]) / 32768.f;
          count = count + 2;
        }
      }
      free((void *)buff->data);
      free((void *)buff);
    }

    else
    {
      unsigned long int return_value;
      return_value=(jack_ringbuffer_read_space)(pdata->jdata->sound_buffer);
      if(return_value >= (unsigned long int)(pdata->jdata->buffersize * (unsigned int)pdata->sound_framesize))
      {
        (jack_ringbuffer_read)(pdata->jdata->sound_buffer, (char *)jackbuf, (unsigned long int)((unsigned int)pdata->sound_framesize * pdata->jdata->buffersize));
        vorbis_buffer=vorbis_analysis_buffer(&pdata->enc_data->m_vo_dsp, sampread);
        j = 0;
        if(!((unsigned int)j >= pdata->args.channels))
        {
          i = 0;
          if(!(i >= sampread))
          {
            vorbis_buffer[(signed long int)j][(signed long int)i] = ((float *)jackbuf)[(signed long int)count];
            count = count + 1;
            i = i + 1;
          }

          j = j + 1;
        }

      }

      else
      {
        pdata->v_enc_thread_waiting = 1;
        pthread_mutex_lock(&pdata->snd_buff_ready_mutex);
        pthread_cond_wait(&pdata->sound_data_read, &pdata->snd_buff_ready_mutex);
        pthread_mutex_unlock(&pdata->snd_buff_ready_mutex);
        pdata->v_enc_thread_waiting = 0;
        continue;
      }
    }
    vorbis_analysis_wrote(&pdata->enc_data->m_vo_dsp, sampread);
    pthread_mutex_lock(&pdata->libogg_mutex);
    do
    {
      return_value_vorbis_analysis_blockout_2=vorbis_analysis_blockout(&pdata->enc_data->m_vo_dsp, &pdata->enc_data->m_vo_block);
      if(!(return_value_vorbis_analysis_blockout_2 == 1))
        break;

      vorbis_analysis(&pdata->enc_data->m_vo_block, (struct anonymous_126 *)(void *)0);
      vorbis_bitrate_addblock(&pdata->enc_data->m_vo_block);
      do
      {
        return_value_vorbis_bitrate_flushpacket_3=vorbis_bitrate_flushpacket(&pdata->enc_data->m_vo_dsp, &pdata->enc_data->m_ogg_pckt2);
        if(return_value_vorbis_bitrate_flushpacket_3 == 0)
          break;

        ogg_stream_packetin(&pdata->enc_data->m_ogg_vs, &pdata->enc_data->m_ogg_pckt2);
      }
      while((_Bool)1);
    }
    while((_Bool)1);
    pthread_mutex_unlock(&pdata->libogg_mutex);
    pdata->avd = pdata->avd - (signed int)pdata->periodtime;
  }
  pdata->v_encoding_clean = 1;
  pthread_mutex_lock(&pdata->vorbis_lib_mutex);
  pthread_cond_signal(&pdata->vorbis_lib_clean);
  pthread_mutex_unlock(&pdata->vorbis_lib_mutex);
  signed int *return_value___errno_location_4;
  return_value___errno_location_4=__errno_location();
  pthread_exit((void *)&(*return_value___errno_location_4));
}

// rmdErrorHandler
// file rmd_error.h line 46
signed int rmdErrorHandler(struct _XDisplay *dpy, struct anonymous_118 *e)
{
  char error_desc[1024l];
  XGetErrorText(dpy, (signed int)e->error_code, error_desc, (signed int)sizeof(char [1024l]) /*1024ul*/ );
  fprintf(stderr, "X Error: %s\n", (const void *)error_desc);
  fflush(stderr);
  _Bool tmp_if_expr_2;
  if((signed int)e->error_code == 3)
    tmp_if_expr_2 = (signed int)e->request_code == 3 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_2 = (_Bool)0;
  _Bool tmp_if_expr_1;
  if(tmp_if_expr_2)
  {
    fprintf(stderr, "BadWindow on XGetWindowAttributes.\nIgnoring...\n");
    fflush(stderr);
    return 0;
  }

  else
  {
    if((signed int)e->error_code == 10)
      tmp_if_expr_1 = (signed int)e->request_code == 33 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_1 = (_Bool)0;
    if(tmp_if_expr_1)
    {
      fprintf(stderr, "Bad Access on XGrabKey.\nShortcut already assigned.\n");
      fflush(stderr);
      return 0;
    }

    else
      exit(1);
  }
}

// rmdEventLoop
// file rmd_poll_events.h line 46
void rmdEventLoop(struct _ProgData *pdata)
{
  signed int inserts = 0;
  union _XEvent event;
  signed int return_value_XPending_1;
  signed int return_value_XGetWindowAttributes_2;
  _Bool tmp_if_expr_15;
  _Bool tmp_if_expr_16;
  _Bool tmp_if_expr_17;
  _Bool tmp_if_expr_3;
  signed int tmp_if_expr_5;
  signed int tmp_if_expr_4;
  _Bool tmp_if_expr_6;
  signed int tmp_if_expr_8;
  signed int tmp_if_expr_7;
  signed int tmp_if_expr_11;
  signed int tmp_if_expr_10;
  signed int tmp_if_expr_9;
  signed int tmp_if_expr_14;
  signed int tmp_if_expr_13;
  signed int tmp_if_expr_12;
  do
  {
    return_value_XPending_1=XPending(pdata->dpy);
    if(return_value_XPending_1 == 0)
      break;

    XNextEvent(pdata->dpy, &event);
    if(event.type == 2)
    {
      struct anonymous_0 *rmdEventLoop__1__1__1__e = (struct anonymous_0 *)&event;
      if(rmdEventLoop__1__1__1__e->keycode == (unsigned int)pdata->pause_key.key)
      {
        signed int i = 0;
        signed int found = 0;
        i = 0;
        for( ; !(i >= pdata->pause_key.modnum); i = i + 1)
          if(pdata->pause_key.mask[(signed long int)i] == rmdEventLoop__1__1__1__e->state)
          {
            found = 1;
            break;
          }

        if(!(found == 0))
        {
          raise(10);
          continue;
        }

      }

      if(rmdEventLoop__1__1__1__e->keycode == (unsigned int)pdata->stop_key.key)
      {
        signed int rmdEventLoop__1__1__1__2__i = 0;
        signed int rmdEventLoop__1__1__1__2__found = 0;
        rmdEventLoop__1__1__1__2__i = 0;
        for( ; !(rmdEventLoop__1__1__1__2__i >= pdata->stop_key.modnum); rmdEventLoop__1__1__1__2__i = rmdEventLoop__1__1__1__2__i + 1)
          if(pdata->stop_key.mask[(signed long int)rmdEventLoop__1__1__1__2__i] == rmdEventLoop__1__1__1__e->state)
          {
            rmdEventLoop__1__1__1__2__found = 1;
            break;
          }

        if(!(rmdEventLoop__1__1__1__2__found == 0))
        {
          raise(2);
          continue;
        }

      }

    }

    else
      if(event.type == 12)
      {
        if(!(event.xexpose.count == 0))
          continue;

        else
          if(pdata->args.noframe == 0)
            rmdDrawFrame(pdata->dpy, pdata->specs.screen, pdata->shaped_w, (signed int)pdata->brwin.rrect.width, (signed int)pdata->brwin.rrect.height);

      }

      else
        if(pdata->args.full_shots == 0)
        {
          if(event.type == 19)
          {
            struct anonymous attribs;
            if(((struct anonymous_104 *)&event)->override_redirect == 0)
            {
              return_value_XGetWindowAttributes_2=XGetWindowAttributes(pdata->dpy, event.xcreatewindow.window, &attribs);
              if(!(return_value_XGetWindowAttributes_2 == 0))
              {
                if(attribs.override_redirect == 0)
                {
                  if(attribs.depth == pdata->specs.depth)
                    XDamageCreate(pdata->dpy, event.xcreatewindow.window, 0);

                }

              }

            }

          }

          else
            if(event.type == pdata->damage_event)
            {
              struct anonymous_1 *e = (struct anonymous_1 *)&event;
              struct anonymous_17 xrect;
              if((signed int)pdata->brwin.rrect.x >= (signed int)e->area.x)
                tmp_if_expr_15 = (signed int)e->area.y <= (signed int)(&pdata->brwin)->rrect.y ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr_15 = (_Bool)0;
              if(tmp_if_expr_15)
                tmp_if_expr_16 = (signed int)e->area.width >= (signed int)(&pdata->brwin)->rrect.width ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr_16 = (_Bool)0;
              if(tmp_if_expr_16)
                tmp_if_expr_17 = (signed int)e->area.height < (signed int)(&pdata->brwin)->rrect.height ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr_17 = (_Bool)0;
              if(tmp_if_expr_17)
              {
                (&xrect)->x = (&pdata->brwin)->rrect.x;
                (&xrect)->y = (&pdata->brwin)->rrect.y;
                (&xrect)->width = (&pdata->brwin)->rrect.width;
                (&xrect)->height = (&pdata->brwin)->rrect.height;
              }

              else
              {
                if((signed int)e->area.x + (signed int)e->area.width >= (signed int)pdata->brwin.rrect.x)
                  tmp_if_expr_3 = (signed int)e->area.x <= (signed int)(&pdata->brwin)->rrect.x + (signed int)(&pdata->brwin)->rrect.width ? (_Bool)1 : (_Bool)0;

                else
                  tmp_if_expr_3 = (_Bool)0;
                if(tmp_if_expr_3)
                {
                  if((signed int)pdata->brwin.rrect.x >= (signed int)e->area.x)
                    tmp_if_expr_4 = (signed int)(&pdata->brwin)->rrect.x;

                  else
                    tmp_if_expr_4 = (signed int)e->area.x;
                  tmp_if_expr_5 = tmp_if_expr_4;
                }

                else
                  tmp_if_expr_5 = -1;
                (&xrect)->x = (signed short int)tmp_if_expr_5;
                if((signed int)e->area.y + (signed int)e->area.height >= (signed int)pdata->brwin.rrect.y)
                  tmp_if_expr_6 = (signed int)e->area.y <= (signed int)(&pdata->brwin)->rrect.y + (signed int)(&pdata->brwin)->rrect.height ? (_Bool)1 : (_Bool)0;

                else
                  tmp_if_expr_6 = (_Bool)0;
                if(tmp_if_expr_6)
                {
                  if((signed int)pdata->brwin.rrect.y >= (signed int)e->area.y)
                    tmp_if_expr_7 = (signed int)(&pdata->brwin)->rrect.y;

                  else
                    tmp_if_expr_7 = (signed int)e->area.y;
                  tmp_if_expr_8 = tmp_if_expr_7;
                }

                else
                  tmp_if_expr_8 = -1;
                (&xrect)->y = (signed short int)tmp_if_expr_8;
                if((signed int)pdata->brwin.rrect.x >= (signed int)e->area.x)
                  tmp_if_expr_11 = (signed int)e->area.width - ((signed int)(&pdata->brwin)->rrect.x - (signed int)e->area.x);

                else
                {
                  if((signed int)pdata->brwin.rrect.x + (signed int)pdata->brwin.rrect.width >= (signed int)e->area.x)
                  {
                    if(!((signed int)pdata->brwin.rrect.x + (signed int)pdata->brwin.rrect.width + -((signed int)e->area.x) >= (signed int)e->area.width))
                      tmp_if_expr_9 = ((signed int)(&pdata->brwin)->rrect.width - (signed int)e->area.x) + (signed int)(&pdata->brwin)->rrect.x;

                    else
                      tmp_if_expr_9 = (signed int)e->area.width;
                    tmp_if_expr_10 = tmp_if_expr_9;
                  }

                  else
                    tmp_if_expr_10 = 0;
                  tmp_if_expr_11 = tmp_if_expr_10;
                }
                (&xrect)->width = (unsigned short int)tmp_if_expr_11;
                if((signed int)pdata->brwin.rrect.y >= (signed int)e->area.y)
                  tmp_if_expr_14 = (signed int)e->area.height - ((signed int)(&pdata->brwin)->rrect.y - (signed int)e->area.y);

                else
                {
                  if((signed int)pdata->brwin.rrect.y + (signed int)pdata->brwin.rrect.height >= (signed int)e->area.y)
                  {
                    if(!((signed int)pdata->brwin.rrect.y + (signed int)pdata->brwin.rrect.height + -((signed int)e->area.y) >= (signed int)e->area.height))
                      tmp_if_expr_12 = ((signed int)(&pdata->brwin)->rrect.height - (signed int)e->area.y) + (signed int)(&pdata->brwin)->rrect.y;

                    else
                      tmp_if_expr_12 = (signed int)e->area.height;
                    tmp_if_expr_13 = tmp_if_expr_12;
                  }

                  else
                    tmp_if_expr_13 = 0;
                  tmp_if_expr_14 = tmp_if_expr_13;
                }
                (&xrect)->height = (unsigned short int)tmp_if_expr_14;
                if(!((signed int)pdata->brwin.rrect.width >= (signed int)xrect.width))
                  (&xrect)->width = (&pdata->brwin)->rrect.width;

                if(!((signed int)pdata->brwin.rrect.height >= (signed int)xrect.height))
                  (&xrect)->height = (&pdata->brwin)->rrect.height;

              }
              if((signed int)xrect.x >= 0 && (signed int)xrect.y >= 0 && (signed int)xrect.height >= 1 && (signed int)xrect.width >= 1)
              {
                signed int return_value_rmdRectInsert_18;
                return_value_rmdRectInsert_18=rmdRectInsert(&pdata->rect_root, &xrect);
                inserts = inserts + return_value_rmdRectInsert_18;
              }

            }

        }

  }
  while((_Bool)1);
}

// rmdFirstFrame
// file rmd_get_frame.c line 199
static signed int rmdFirstFrame(struct _ProgData *pdata, struct _XImage **image, struct anonymous_34 *shminfo, char **pxl_data)
{
  if(!(pdata->args.noshared == 0))
  {
    void *return_value_malloc_1;
    return_value_malloc_1=malloc((unsigned long int)pdata->brwin.nbytes);
    *pxl_data = (char *)return_value_malloc_1;
    *image=XCreateImage(pdata->dpy, pdata->specs.visual, (unsigned int)pdata->specs.depth, 2, 0, *pxl_data, (unsigned int)pdata->brwin.rrect.width, (unsigned int)pdata->brwin.rrect.height, 8, 0);
    XInitImage(*image);
    rmdGetZPixmap(pdata->dpy, pdata->specs.root, (*image)->data, (signed int)pdata->brwin.rrect.x, (signed int)pdata->brwin.rrect.y, (signed int)pdata->brwin.rrect.width, (signed int)pdata->brwin.rrect.height);
  }

  else
  {
    *image=XShmCreateImage(pdata->dpy, pdata->specs.visual, (unsigned int)pdata->specs.depth, 2, *pxl_data, shminfo, (unsigned int)pdata->brwin.rrect.width, (unsigned int)pdata->brwin.rrect.height);
    shminfo->shmid=shmget((signed int)0, (unsigned long int)((*image)->bytes_per_line * (*image)->height), 01000 | 0777);
    if(shminfo->shmid == -1)
    {
      fprintf(stderr, "Failed to obtain Shared Memory segment!\n");
      return 12;
    }

    void *return_value_shmat_2;
    return_value_shmat_2=shmat(shminfo->shmid, (void *)0, 0);
    (*image)->data = (char *)return_value_shmat_2;
    shminfo->shmaddr = (*image)->data;
    shminfo->readOnly = 0;
    signed int return_value_XShmAttach_3;
    return_value_XShmAttach_3=XShmAttach(pdata->dpy, shminfo);
    if(return_value_XShmAttach_3 == 0)
    {
      fprintf(stderr, "Failed to attach shared memory to proccess.\n");
      return 12;
    }

    XShmGetImage(pdata->dpy, pdata->specs.root, *image, (signed int)pdata->brwin.rrect.x, (signed int)pdata->brwin.rrect.y, (unsigned long int)~0L);
  }
  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_11;
  _Bool tmp_if_expr_5;
  _Bool tmp_if_expr_6;
  _Bool tmp_if_expr_7;
  _Bool tmp_if_expr_8;
  _Bool tmp_if_expr_9;
  _Bool tmp_if_expr_10;
  if(pdata->specs.depth == 24)
    tmp_if_expr_4 = (_Bool)1;

  else
    tmp_if_expr_4 = pdata->specs.depth == 32 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_4)
  {
    signed int rmdFirstFrame__1__3__1__1__1__k;
    signed int rmdFirstFrame__1__3__1__1__1__i;
    unsigned int rmdFirstFrame__1__3__1__1__1__t_val;
    unsigned char *rmdFirstFrame__1__3__1__1__1__yuv_y = (&pdata->enc_data->yuv)->y + (signed long int)pdata->enc_data->x_offset + (signed long int)(pdata->enc_data->y_offset * (&pdata->enc_data->yuv)->y_width);
    unsigned char *rmdFirstFrame__1__3__1__1__1___yr = Yr;
    unsigned char *rmdFirstFrame__1__3__1__1__1___yg = Yg;
    unsigned char *rmdFirstFrame__1__3__1__1__1___yb = Yb;
    unsigned int *rmdFirstFrame__1__3__1__1__1__datapi = (unsigned int *)(unsigned char *)(*image)->data;
    rmdFirstFrame__1__3__1__1__1__k = 0;
    for( ; !(rmdFirstFrame__1__3__1__1__1__k >= (signed int)pdata->brwin.rrect.height); rmdFirstFrame__1__3__1__1__1__k = rmdFirstFrame__1__3__1__1__1__k + 1)
    {
      rmdFirstFrame__1__3__1__1__1__i = 0;
      for( ; !(rmdFirstFrame__1__3__1__1__1__i >= (signed int)pdata->brwin.rrect.width); rmdFirstFrame__1__3__1__1__1__i = rmdFirstFrame__1__3__1__1__1__i + 1)
      {
        rmdFirstFrame__1__3__1__1__1__t_val = *rmdFirstFrame__1__3__1__1__1__datapi;
        *rmdFirstFrame__1__3__1__1__1__yuv_y = (unsigned char)((signed int)rmdFirstFrame__1__3__1__1__1___yr[(signed long int)((rmdFirstFrame__1__3__1__1__1__t_val & (unsigned int)0x00ff0000) >> 16)] + (signed int)rmdFirstFrame__1__3__1__1__1___yg[(signed long int)((rmdFirstFrame__1__3__1__1__1__t_val & (unsigned int)0x0000ff00) >> 8)] + (signed int)rmdFirstFrame__1__3__1__1__1___yb[(signed long int)(rmdFirstFrame__1__3__1__1__1__t_val & (unsigned int)0x000000ff)]);
        rmdFirstFrame__1__3__1__1__1__datapi = rmdFirstFrame__1__3__1__1__1__datapi + 1l;
        rmdFirstFrame__1__3__1__1__1__yuv_y = rmdFirstFrame__1__3__1__1__1__yuv_y + 1l;
      }
      rmdFirstFrame__1__3__1__1__1__yuv_y = rmdFirstFrame__1__3__1__1__1__yuv_y + (signed long int)((&pdata->enc_data->yuv)->y_width - (signed int)pdata->brwin.rrect.width);
    }
    signed int k;
    signed int i;
    unsigned int t_val;
    unsigned char *yuv_u = (&pdata->enc_data->yuv)->u + (signed long int)(pdata->enc_data->x_offset / 2) + (signed long int)((pdata->enc_data->y_offset * (&pdata->enc_data->yuv)->uv_width) / 2);
    unsigned char *yuv_v = (&pdata->enc_data->yuv)->v + (signed long int)(pdata->enc_data->x_offset / 2) + (signed long int)((pdata->enc_data->y_offset * (&pdata->enc_data->yuv)->uv_width) / 2);
    unsigned char *_ur = Ur;
    unsigned char *_ug = Ug;
    unsigned char *_ubvr = UbVr;
    unsigned char *_vg = Vg;
    unsigned char *_vb = Vb;
    unsigned int *datapi = (unsigned int *)(unsigned char *)(*image)->data;
    unsigned int *datapi_next = (unsigned int *)(void *)0;
    if(pdata->args.no_quick_subsample == 1)
      datapi_next = datapi + (signed long int)pdata->brwin.rrect.width;

    k = 0;
    for( ; !(k >= (signed int)pdata->brwin.rrect.height); k = k + 2)
    {
      i = 0;
      for( ; !(i >= (signed int)pdata->brwin.rrect.width); i = i + 2)
      {
        if(pdata->args.no_quick_subsample == 1)
        {
          unsigned int t1;
          unsigned int t2;
          unsigned int t3;
          unsigned int t4;
          t1 = *datapi;
          t2 = datapi[(signed long int)1];
          t3 = *datapi_next;
          t4 = datapi_next[(signed long int)1];
          t_val = (((t1 & (unsigned int)0x00ff0000) + (t2 & (unsigned int)0x00ff0000) + (t3 & (unsigned int)0x00ff0000) + (t4 & (unsigned int)0x00ff0000)) / (unsigned int)4 & (unsigned int)0x00ff0000) + (((t1 & (unsigned int)0x0000ff00) + (t2 & (unsigned int)0x0000ff00) + (t3 & (unsigned int)0x0000ff00) + (t4 & (unsigned int)0x0000ff00)) / (unsigned int)4 & (unsigned int)0x0000ff00) + (((t1 & (unsigned int)0x000000ff) + (t2 & (unsigned int)0x000000ff) + (t3 & (unsigned int)0x000000ff) + (t4 & (unsigned int)0x000000ff)) / (unsigned int)4 & (unsigned int)0x000000ff);
        }

        else
          t_val = *datapi;
        *yuv_u = (unsigned char)((signed int)_ur[(signed long int)((t_val & (unsigned int)0x00ff0000) >> 16)] + (signed int)_ug[(signed long int)((t_val & (unsigned int)0x0000ff00) >> 8)] + (signed int)_ubvr[(signed long int)(t_val & (unsigned int)0x000000ff)]);
        *yuv_v = (unsigned char)((signed int)_ubvr[(signed long int)((t_val & (unsigned int)0x00ff0000) >> 16)] + (signed int)_vg[(signed long int)((t_val & (unsigned int)0x0000ff00) >> 8)] + (signed int)_vb[(signed long int)(t_val & (unsigned int)0x000000ff)]);
        datapi = datapi + (signed long int)2;
        if(pdata->args.no_quick_subsample == 1)
          datapi_next = datapi_next + (signed long int)2;

        yuv_u = yuv_u + 1l;
        yuv_v = yuv_v + 1l;
      }
      yuv_u = yuv_u + (signed long int)(((&pdata->enc_data->yuv)->y_width - (signed int)pdata->brwin.rrect.width) / 2);
      yuv_v = yuv_v + (signed long int)(((&pdata->enc_data->yuv)->y_width - (signed int)pdata->brwin.rrect.width) / 2);
      datapi = datapi + (signed long int)pdata->brwin.rrect.width;
      if(pdata->args.no_quick_subsample == 1)
        datapi_next = datapi_next + (signed long int)pdata->brwin.rrect.width;

    }
  }

  else
    if(pdata->specs.depth == 16)
    {
      signed int rmdFirstFrame__1__3__1__2__1__k;
      signed int rmdFirstFrame__1__3__1__2__1__i;
      unsigned short int rmdFirstFrame__1__3__1__2__1__t_val;
      unsigned char *yuv_y = (&pdata->enc_data->yuv)->y + (signed long int)pdata->enc_data->x_offset + (signed long int)(pdata->enc_data->y_offset * (&pdata->enc_data->yuv)->y_width);
      unsigned char *_yr = Yr;
      unsigned char *_yg = Yg;
      unsigned char *_yb = Yb;
      unsigned short int *rmdFirstFrame__1__3__1__2__1__datapi = (unsigned short int *)(unsigned char *)(*image)->data;
      rmdFirstFrame__1__3__1__2__1__k = 0;
      for( ; !(rmdFirstFrame__1__3__1__2__1__k >= (signed int)pdata->brwin.rrect.height); rmdFirstFrame__1__3__1__2__1__k = rmdFirstFrame__1__3__1__2__1__k + 1)
      {
        rmdFirstFrame__1__3__1__2__1__i = 0;
        for( ; !(rmdFirstFrame__1__3__1__2__1__i >= (signed int)pdata->brwin.rrect.width); rmdFirstFrame__1__3__1__2__1__i = rmdFirstFrame__1__3__1__2__1__i + 1)
        {
          rmdFirstFrame__1__3__1__2__1__t_val = *rmdFirstFrame__1__3__1__2__1__datapi;
          *yuv_y = (unsigned char)((signed int)_yr[(signed long int)((((signed int)rmdFirstFrame__1__3__1__2__1__t_val & 0xf800) >> 11) * 8)] + (signed int)_yg[(signed long int)((((signed int)rmdFirstFrame__1__3__1__2__1__t_val & 0x7e0) >> 5) * 4)] + (signed int)_yb[(signed long int)(((signed int)rmdFirstFrame__1__3__1__2__1__t_val & 0x1f) * 8)]);
          rmdFirstFrame__1__3__1__2__1__datapi = rmdFirstFrame__1__3__1__2__1__datapi + 1l;
          yuv_y = yuv_y + 1l;
        }
        yuv_y = yuv_y + (signed long int)((&pdata->enc_data->yuv)->y_width - (signed int)pdata->brwin.rrect.width);
      }
      signed int rmdFirstFrame__1__3__1__2__2__k;
      signed int rmdFirstFrame__1__3__1__2__2__i;
      unsigned short int rmdFirstFrame__1__3__1__2__2__t_val;
      unsigned char *rmdFirstFrame__1__3__1__2__2__yuv_u = (&pdata->enc_data->yuv)->u + (signed long int)(pdata->enc_data->x_offset / 2) + (signed long int)((pdata->enc_data->y_offset * (&pdata->enc_data->yuv)->uv_width) / 2);
      unsigned char *rmdFirstFrame__1__3__1__2__2__yuv_v = (&pdata->enc_data->yuv)->v + (signed long int)(pdata->enc_data->x_offset / 2) + (signed long int)((pdata->enc_data->y_offset * (&pdata->enc_data->yuv)->uv_width) / 2);
      unsigned char *rmdFirstFrame__1__3__1__2__2___ur = Ur;
      unsigned char *rmdFirstFrame__1__3__1__2__2___ug = Ug;
      unsigned char *rmdFirstFrame__1__3__1__2__2___ubvr = UbVr;
      unsigned char *rmdFirstFrame__1__3__1__2__2___vg = Vg;
      unsigned char *rmdFirstFrame__1__3__1__2__2___vb = Vb;
      unsigned short int *rmdFirstFrame__1__3__1__2__2__datapi = (unsigned short int *)(unsigned char *)(*image)->data;
      unsigned short int *rmdFirstFrame__1__3__1__2__2__datapi_next = (unsigned short int *)(void *)0;
      if(pdata->args.no_quick_subsample == 1)
        rmdFirstFrame__1__3__1__2__2__datapi_next = rmdFirstFrame__1__3__1__2__2__datapi + (signed long int)pdata->brwin.rrect.width;

      rmdFirstFrame__1__3__1__2__2__k = 0;
      for( ; !(rmdFirstFrame__1__3__1__2__2__k >= (signed int)pdata->brwin.rrect.height); rmdFirstFrame__1__3__1__2__2__k = rmdFirstFrame__1__3__1__2__2__k + 2)
      {
        rmdFirstFrame__1__3__1__2__2__i = 0;
        for( ; !(rmdFirstFrame__1__3__1__2__2__i >= (signed int)pdata->brwin.rrect.width); rmdFirstFrame__1__3__1__2__2__i = rmdFirstFrame__1__3__1__2__2__i + 2)
        {
          if(pdata->args.no_quick_subsample == 1)
          {
            unsigned short int rmdFirstFrame__1__3__1__2__2__2__1__1__1__1__1__t1;
            unsigned short int rmdFirstFrame__1__3__1__2__2__2__1__1__1__1__1__t2;
            unsigned short int rmdFirstFrame__1__3__1__2__2__2__1__1__1__1__1__t3;
            unsigned short int rmdFirstFrame__1__3__1__2__2__2__1__1__1__1__1__t4;
            rmdFirstFrame__1__3__1__2__2__2__1__1__1__1__1__t1 = *rmdFirstFrame__1__3__1__2__2__datapi;
            rmdFirstFrame__1__3__1__2__2__2__1__1__1__1__1__t2 = rmdFirstFrame__1__3__1__2__2__datapi[(signed long int)1];
            rmdFirstFrame__1__3__1__2__2__2__1__1__1__1__1__t3 = *rmdFirstFrame__1__3__1__2__2__datapi_next;
            rmdFirstFrame__1__3__1__2__2__2__1__1__1__1__1__t4 = rmdFirstFrame__1__3__1__2__2__datapi_next[(signed long int)1];
            rmdFirstFrame__1__3__1__2__2__t_val = (unsigned short int)(((((signed int)rmdFirstFrame__1__3__1__2__2__2__1__1__1__1__1__t1 & 0xf800) + ((signed int)rmdFirstFrame__1__3__1__2__2__2__1__1__1__1__1__t2 & 0xf800) + ((signed int)rmdFirstFrame__1__3__1__2__2__2__1__1__1__1__1__t3 & 0xf800) + ((signed int)rmdFirstFrame__1__3__1__2__2__2__1__1__1__1__1__t4 & 0xf800)) / 4 & 0xf800) + ((((signed int)rmdFirstFrame__1__3__1__2__2__2__1__1__1__1__1__t1 & 0x7e0) + ((signed int)rmdFirstFrame__1__3__1__2__2__2__1__1__1__1__1__t2 & 0x7e0) + ((signed int)rmdFirstFrame__1__3__1__2__2__2__1__1__1__1__1__t3 & 0x7e0) + ((signed int)rmdFirstFrame__1__3__1__2__2__2__1__1__1__1__1__t4 & 0x7e0)) / 4 & 0x7e0) + ((((signed int)rmdFirstFrame__1__3__1__2__2__2__1__1__1__1__1__t1 & 0x1f) + ((signed int)rmdFirstFrame__1__3__1__2__2__2__1__1__1__1__1__t2 & 0x1f) + ((signed int)rmdFirstFrame__1__3__1__2__2__2__1__1__1__1__1__t3 & 0x1f) + ((signed int)rmdFirstFrame__1__3__1__2__2__2__1__1__1__1__1__t4 & 0x1f)) / 4 & 0x1f));
          }

          else
            rmdFirstFrame__1__3__1__2__2__t_val = *rmdFirstFrame__1__3__1__2__2__datapi;
          *rmdFirstFrame__1__3__1__2__2__yuv_u = (unsigned char)((signed int)rmdFirstFrame__1__3__1__2__2___ur[(signed long int)((((signed int)rmdFirstFrame__1__3__1__2__2__t_val & 0xf800) >> 11) * 8)] + (signed int)rmdFirstFrame__1__3__1__2__2___ug[(signed long int)((((signed int)rmdFirstFrame__1__3__1__2__2__t_val & 0x7e0) >> 5) * 4)] + (signed int)rmdFirstFrame__1__3__1__2__2___ubvr[(signed long int)(((signed int)rmdFirstFrame__1__3__1__2__2__t_val & 0x1f) * 8)]);
          *rmdFirstFrame__1__3__1__2__2__yuv_v = (unsigned char)((signed int)rmdFirstFrame__1__3__1__2__2___ubvr[(signed long int)((((signed int)rmdFirstFrame__1__3__1__2__2__t_val & 0xf800) >> 11) * 8)] + (signed int)rmdFirstFrame__1__3__1__2__2___vg[(signed long int)((((signed int)rmdFirstFrame__1__3__1__2__2__t_val & 0x7e0) >> 5) * 4)] + (signed int)rmdFirstFrame__1__3__1__2__2___vb[(signed long int)(((signed int)rmdFirstFrame__1__3__1__2__2__t_val & 0x1f) * 8)]);
          rmdFirstFrame__1__3__1__2__2__datapi = rmdFirstFrame__1__3__1__2__2__datapi + (signed long int)2;
          if(pdata->args.no_quick_subsample == 1)
            rmdFirstFrame__1__3__1__2__2__datapi_next = rmdFirstFrame__1__3__1__2__2__datapi_next + (signed long int)2;

          rmdFirstFrame__1__3__1__2__2__yuv_u = rmdFirstFrame__1__3__1__2__2__yuv_u + 1l;
          rmdFirstFrame__1__3__1__2__2__yuv_v = rmdFirstFrame__1__3__1__2__2__yuv_v + 1l;
        }
        rmdFirstFrame__1__3__1__2__2__yuv_u = rmdFirstFrame__1__3__1__2__2__yuv_u + (signed long int)(((&pdata->enc_data->yuv)->y_width - (signed int)pdata->brwin.rrect.width) / 2);
        rmdFirstFrame__1__3__1__2__2__yuv_v = rmdFirstFrame__1__3__1__2__2__yuv_v + (signed long int)(((&pdata->enc_data->yuv)->y_width - (signed int)pdata->brwin.rrect.width) / 2);
        rmdFirstFrame__1__3__1__2__2__datapi = rmdFirstFrame__1__3__1__2__2__datapi + (signed long int)pdata->brwin.rrect.width;
        if(pdata->args.no_quick_subsample == 1)
          rmdFirstFrame__1__3__1__2__2__datapi_next = rmdFirstFrame__1__3__1__2__2__datapi_next + (signed long int)pdata->brwin.rrect.width;

      }
    }

  return 0;
}

// rmdFixBufferSize
// file rmd_initialize_data.c line 45
static void rmdFixBufferSize(unsigned long int *buffsize)
{
  unsigned long int buffsize_t = *buffsize;
  unsigned long int buffsize_ret = (unsigned long int)1;
  for( ; buffsize_t >= 2ul; buffsize_ret = buffsize_ret << 1)
    buffsize_t = buffsize_t >> 1;
  fprintf(stderr, "Buffer size adjusted to %d from %d frames.\n", (signed int)buffsize_ret, (signed int)*buffsize);
}

// rmdFlushBlock
// file rmd_cache_frame.c line 47
static signed int rmdFlushBlock(unsigned char *buf, signed int blockno, signed int width, signed int height, signed int blockwidth, struct gzFile_s **fp, struct _IO_FILE *ucfp, signed int flush)
{
  signed int j;
  signed int i;
  signed int bytes_written = 0;
  signed int block_i = !(blockwidth != 0) ? 0 : blockno / (width / blockwidth);
  signed int block_k = !(blockwidth != 0) ? 0 : blockno % (width / blockwidth);
  unsigned char *buf_reg = &buf[(signed long int)((block_i * width + block_k) * blockwidth)];
  double return_value_pow_1;
  return_value_pow_1=pow((double)blockwidth, (double)2);
  static unsigned char out_buffer[4096l];
  static unsigned int out_buffer_bytes = (unsigned int)0;
  if((double)out_buffer_bytes + return_value_pow_1 >= 4096.000000 || !(flush == 0) && !(out_buffer_bytes == 0u))
  {
    if(ucfp == ((struct _IO_FILE *)NULL))
      gzwrite((struct gzFile_s *)fp, (void *)out_buffer, out_buffer_bytes);

    else
      fwrite((void *)out_buffer, (unsigned long int)1, (unsigned long int)out_buffer_bytes, ucfp);
    bytes_written = (signed int)out_buffer_bytes;
    out_buffer_bytes = (unsigned int)0;
  }

  unsigned char *tmp_post_2;
  unsigned char *tmp_post_3;
  if(flush == 0)
  {
    unsigned char *out_buf_reg = &out_buffer[(signed long int)out_buffer_bytes];
    j = 0;
    for( ; !(j >= blockwidth); j = j + 1)
    {
      i = 0;
      for( ; !(i >= blockwidth); i = i + 1)
      {
        tmp_post_2 = out_buf_reg;
        out_buf_reg = out_buf_reg + 1l;
        tmp_post_3 = buf_reg;
        buf_reg = buf_reg + 1l;
        *tmp_post_2 = *tmp_post_3;
      }
      out_buffer_bytes = out_buffer_bytes + (unsigned int)blockwidth;
      buf_reg = buf_reg + (signed long int)(width - blockwidth);
    }
  }

  return bytes_written;
}

// rmdFlushToOgg
// file rmd_flush_to_ogg.h line 38
void * rmdFlushToOgg(struct _ProgData *pdata)
{
  signed int videoflag = 0;
  signed int audioflag = 0;
  double video_bytesout = (double)0;
  double audio_bytesout = (double)0;
  struct anonymous_15 videopage;
  struct anonymous_15 videopage_copy;
  struct anonymous_15 audiopage;
  struct anonymous_15 audiopage_copy;
  double audiotime = (double)0;
  double videotime = (double)0;
  signed int working = 1;
  signed int th_st_fin = 0;
  signed int v_st_fin = pdata->args.nosound;
  double tmp_if_expr_3;
  signed long int return_value_ogg_page_granulepos_1;
  double return_value_theora_granule_time_2;
  double tmp_if_expr_6;
  signed long int return_value_ogg_page_granulepos_4;
  double return_value_vorbis_granule_time_5;
  double tmp_if_expr_9;
  signed long int return_value_ogg_page_granulepos_7;
  double return_value_theora_granule_time_8;
  double tmp_if_expr_12;
  signed long int return_value_ogg_page_granulepos_10;
  double return_value_vorbis_granule_time_11;
  _Bool tmp_if_expr_13;
  while(!(working == 0))
  {
    signed int audio_or_video = 0;
    if(!(pdata->running == 0))
    {
      pthread_mutex_lock(&pdata->libogg_mutex);
      if(videoflag == 0)
      {
        videoflag=ogg_stream_pageout(&pdata->enc_data->m_ogg_ts, &videopage);
        if(!(videoflag == 0))
        {
          return_value_ogg_page_granulepos_1=ogg_page_granulepos(&videopage);
          return_value_theora_granule_time_2=theora_granule_time(&pdata->enc_data->m_th_st, return_value_ogg_page_granulepos_1);
          tmp_if_expr_3 = return_value_theora_granule_time_2;
        }

        else
          tmp_if_expr_3 = (double)-1;
        videotime = tmp_if_expr_3;
        if(!(videoflag == 0))
          ogg_page_cp(&videopage_copy, &videopage);

      }

      if(pdata->args.nosound == 0)
      {
        if(audioflag == 0)
        {
          audioflag=ogg_stream_pageout(&pdata->enc_data->m_ogg_vs, &audiopage);
          if(!(audioflag == 0))
          {
            return_value_ogg_page_granulepos_4=ogg_page_granulepos(&audiopage);
            return_value_vorbis_granule_time_5=vorbis_granule_time(&pdata->enc_data->m_vo_dsp, return_value_ogg_page_granulepos_4);
            tmp_if_expr_6 = return_value_vorbis_granule_time_5;
          }

          else
            tmp_if_expr_6 = (double)-1;
          audiotime = tmp_if_expr_6;
          if(!(audioflag == 0))
            ogg_page_cp(&audiopage_copy, &audiopage);

        }

      }

      pthread_mutex_unlock(&pdata->libogg_mutex);
    }

    else
    {
      if(th_st_fin == 0 && videoflag == 0)
      {
        pthread_mutex_lock(&pdata->libogg_mutex);
        videoflag=ogg_stream_flush(&pdata->enc_data->m_ogg_ts, &videopage);
        if(!(videoflag == 0))
        {
          return_value_ogg_page_granulepos_7=ogg_page_granulepos(&videopage);
          return_value_theora_granule_time_8=theora_granule_time(&pdata->enc_data->m_th_st, return_value_ogg_page_granulepos_7);
          tmp_if_expr_9 = return_value_theora_granule_time_8;
        }

        else
          tmp_if_expr_9 = (double)-1;
        videotime = tmp_if_expr_9;
        if(!(videoflag == 0))
          ogg_page_cp(&videopage_copy, &videopage);

        pthread_mutex_unlock(&pdata->libogg_mutex);
        if(videoflag == 0)
        {
          if(pdata->th_encoding_clean == 0)
          {
            pthread_mutex_lock(&pdata->theora_lib_mutex);
            pthread_cond_wait(&pdata->theora_lib_clean, &pdata->theora_lib_mutex);
            pthread_mutex_unlock(&pdata->theora_lib_mutex);
          }

          rmdSyncEncodeImageBuffer(pdata);
        }

      }

      if(pdata->args.nosound == 0)
      {
        if(v_st_fin == 0)
        {
          if(audioflag == 0)
          {
            pthread_mutex_lock(&pdata->libogg_mutex);
            audioflag=ogg_stream_flush(&pdata->enc_data->m_ogg_vs, &audiopage);
            if(!(audioflag == 0))
            {
              return_value_ogg_page_granulepos_10=ogg_page_granulepos(&audiopage);
              return_value_vorbis_granule_time_11=vorbis_granule_time(&pdata->enc_data->m_vo_dsp, return_value_ogg_page_granulepos_10);
              tmp_if_expr_12 = return_value_vorbis_granule_time_11;
            }

            else
              tmp_if_expr_12 = (double)-1;
            audiotime = tmp_if_expr_12;
            if(!(audioflag == 0))
              ogg_page_cp(&audiopage_copy, &audiopage);

            pthread_mutex_unlock(&pdata->libogg_mutex);
            if(audioflag == 0)
            {
              if(pdata->v_encoding_clean == 0)
              {
                pthread_mutex_lock(&pdata->vorbis_lib_mutex);
                pthread_cond_wait(&pdata->vorbis_lib_clean, &pdata->vorbis_lib_mutex);
                pthread_mutex_unlock(&pdata->vorbis_lib_mutex);
              }

              rmdSyncEncodeSoundBuffer(pdata, (signed char *)(void *)0);
            }

          }

        }

      }

    }
    if(!(th_st_fin == 0))
      videoflag = 0;

    if(!(v_st_fin == 0))
      audioflag = 0;

    if(audioflag == 0 && v_st_fin == 0)
      tmp_if_expr_13 = !(pdata->args.nosound != 0) ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_13 = (_Bool)0;
    if(th_st_fin == 0 && videoflag == 0 || tmp_if_expr_13)
      usleep((unsigned int)10000);

    else
    {
      if(audioflag == 0)
        audio_or_video = 1;

      else
        if(videoflag == 0)
          audio_or_video = 0;

        else
          if(audiotime < videotime)
            audio_or_video = 0;

          else
            audio_or_video = 1;
      if(audio_or_video == 1)
      {
        unsigned long int return_value_fwrite_14;
        return_value_fwrite_14=fwrite((const void *)videopage_copy.header, (unsigned long int)1, (unsigned long int)videopage_copy.header_len, pdata->enc_data->fp);
        video_bytesout = video_bytesout + (double)return_value_fwrite_14;
        unsigned long int return_value_fwrite_15;
        return_value_fwrite_15=fwrite((const void *)videopage_copy.body, (unsigned long int)1, (unsigned long int)videopage_copy.body_len, pdata->enc_data->fp);
        video_bytesout = video_bytesout + (double)return_value_fwrite_15;
        videoflag = 0;
        if(pdata->running == 0)
        {
          pthread_mutex_lock(&pdata->libogg_mutex);
          signed int return_value_ogg_page_eos_16;
          return_value_ogg_page_eos_16=ogg_page_eos(&videopage_copy);
          if(!(return_value_ogg_page_eos_16 == 0))
            th_st_fin = 1;

          pthread_mutex_unlock(&pdata->libogg_mutex);
        }

        ogg_page_cp_free(&videopage_copy);
      }

      else
      {
        unsigned long int return_value_fwrite_17;
        return_value_fwrite_17=fwrite((const void *)audiopage_copy.header, (unsigned long int)1, (unsigned long int)audiopage_copy.header_len, pdata->enc_data->fp);
        audio_bytesout = audio_bytesout + (double)return_value_fwrite_17;
        unsigned long int return_value_fwrite_18;
        return_value_fwrite_18=fwrite((const void *)audiopage_copy.body, (unsigned long int)1, (unsigned long int)audiopage_copy.body_len, pdata->enc_data->fp);
        audio_bytesout = audio_bytesout + (double)return_value_fwrite_18;
        audioflag = 0;
        if(pdata->running == 0)
        {
          pthread_mutex_lock(&pdata->libogg_mutex);
          signed int return_value_ogg_page_eos_19;
          return_value_ogg_page_eos_19=ogg_page_eos(&audiopage_copy);
          if(!(return_value_ogg_page_eos_19 == 0))
            v_st_fin = 1;

          pthread_mutex_unlock(&pdata->libogg_mutex);
        }

        ogg_page_cp_free(&audiopage_copy);
      }
      working = (signed int)(!(th_st_fin != 0) || !(v_st_fin != 0));
    }
  }
  pthread_mutex_lock(&pdata->libogg_mutex);
  ogg_stream_clear(&pdata->enc_data->m_ogg_ts);
  if(pdata->args.nosound == 0)
    ogg_stream_clear(&pdata->enc_data->m_ogg_vs);

  pthread_mutex_unlock(&pdata->libogg_mutex);
  if(!(pdata->enc_data->fp == ((struct _IO_FILE *)NULL)))
    fclose(pdata->enc_data->fp);

  fprintf(stderr, "\r   \nDone.\nWritten %.0f bytes\n(%.0f of which were video data and %.0f audio data)\n\n", video_bytesout + audio_bytesout, video_bytesout, audio_bytesout);
  signed int *return_value___errno_location_20;
  return_value___errno_location_20=__errno_location();
  pthread_exit((void *)&(*return_value___errno_location_20));
}

// rmdFrameInit
// file rmd_frame.c line 94
unsigned long int rmdFrameInit(struct _XDisplay *dpy, signed int screen, unsigned long int root, signed int x, signed int y, signed int width, signed int height)
{
  struct anonymous_19 attribs;
  struct anonymous_18 white;
  struct anonymous_18 white_e;
  unsigned long int win;
  unsigned long int valuemask = (unsigned long int)(1L << 0 | 1L << 1 | 1L << 10 | 1L << 9 | 1L << 13);
  XAllocNamedColor(dpy, (&((struct anonymous_146 *)dpy)->screens[(signed long int)screen])->cmap, "white", &white, &white_e);
  attribs.background_pixmap = (unsigned long int)0L;
  attribs.background_pixel = white.pixel;
  attribs.save_under = 1;
  attribs.override_redirect = 1;
  attribs.colormap = (&((struct anonymous_146 *)dpy)->screens[(signed long int)screen])->cmap;
  win=XCreateWindow(dpy, root, x - 6, y - 6, (unsigned int)(width + 6 * 2), (unsigned int)(height + 6 * 2), (unsigned int)0, (signed int)0L, (unsigned int)1, ((struct anonymous_21 *)NULL), valuemask, &attribs);
  struct anonymous_17 rect;
  rect.y = (signed short int)6;
  rect.x = rect.y;
  rect.width = (unsigned short int)width;
  rect.height = (unsigned short int)height;
  XShapeCombineRectangles(dpy, win, 0, 0, 0, &rect, 1, 3, 0);
  XMapWindow(dpy, win);
  rmdDrawFrame(dpy, screen, win, width, height);
  return win;
}

// rmdGetFrame
// file rmd_get_frame.c line 357
void * rmdGetFrame(struct _ProgData *pdata)
{
  signed int rmdGetFrame__1__i = 0;
  signed int blocknum_x = pdata->enc_data->yuv.y_width / 0x0010;
  signed int blocknum_y = pdata->enc_data->yuv.y_height / 0x0010;
  unsigned int msk_ret;
  struct anonymous_17 mouse_pos_abs;
  struct anonymous_17 mouse_pos_rel;
  struct anonymous_17 mouse_pos_temp;
  struct _BRWindow temp_brwin;
  unsigned long int root_ret;
  unsigned long int child_ret;
  struct anonymous_31 *xcim = (struct anonymous_31 *)(void *)0;
  struct _XImage *image = (struct _XImage *)(void *)0;
  struct _XImage *image_back = (struct _XImage *)(void *)0;
  struct anonymous_34 shminfo;
  struct anonymous_34 shminfo_back;
  signed int init_img1 = 0;
  signed int init_img2 = 0;
  signed int img_sel;
  signed int d_buff;
  char *pxl_data = (char *)(void *)0;
  char *pxl_data_back = (char *)(void *)0;
  d_buff = pdata->args.full_shots;
  img_sel = d_buff;
  signed int return_value_rmdFirstFrame_2;
  return_value_rmdFirstFrame_2=rmdFirstFrame(pdata, &image, &shminfo, &pxl_data);
  init_img1 = (signed int)(return_value_rmdFirstFrame_2 != 0);
  if(!(init_img1 == 0))
  {
    if(!(pdata->args.encOnTheFly == 0))
    {
      signed int return_value_remove_1;
      return_value_remove_1=remove(pdata->args.filename);
      if(!(return_value_remove_1 == 0))
        perror("Error while removing file:\n");

      else
        fprintf(stderr, "SIGABRT received,file %s removed\n", pdata->args.filename);
    }

    else
      rmdPurgeCache(pdata->cache_data, (signed int)!(pdata->args.nosound != 0));
    exit(init_img1);
  }

  if(!(d_buff == 0))
  {
    signed int return_value_rmdFirstFrame_4;
    return_value_rmdFirstFrame_4=rmdFirstFrame(pdata, &image_back, &shminfo_back, &pxl_data_back);
    init_img2 = (signed int)(return_value_rmdFirstFrame_4 != 0);
    if(!(init_img2 == 0))
    {
      if(!(pdata->args.encOnTheFly == 0))
      {
        signed int return_value_remove_3;
        return_value_remove_3=remove(pdata->args.filename);
        if(!(return_value_remove_3 == 0))
          perror("Error while removing file:\n");

        else
          fprintf(stderr, "SIGABRT received,file %s removed\n", pdata->args.filename);
      }

      else
        rmdPurgeCache(pdata->cache_data, (signed int)!(pdata->args.nosound != 0));
      exit(init_img2);
    }

  }

  if(pdata->args.noframe == 0)
  {
    pdata->shaped_w=rmdFrameInit(pdata->dpy, pdata->specs.screen, pdata->specs.root, (signed int)pdata->brwin.rrect.x, (signed int)pdata->brwin.rrect.y, (signed int)pdata->brwin.rrect.width, (signed int)pdata->brwin.rrect.height);
    XSelectInput(pdata->dpy, pdata->shaped_w, 1L << 15);
  }

  mouse_pos_temp.x = (signed short int)0;
  mouse_pos_abs.x = mouse_pos_temp.x;
  mouse_pos_temp.y = (signed short int)0;
  mouse_pos_abs.y = mouse_pos_temp.y;
  mouse_pos_temp.width = (unsigned short int)pdata->dummy_p_size;
  mouse_pos_abs.width = mouse_pos_temp.width;
  mouse_pos_temp.height = (unsigned short int)pdata->dummy_p_size;
  mouse_pos_abs.height = mouse_pos_temp.height;
  rmdInitEventsPolling(pdata);
  _Bool tmp_if_expr_5;
  _Bool tmp_if_expr_20;
  _Bool tmp_if_expr_21;
  _Bool tmp_if_expr_6;
  signed int tmp_if_expr_8;
  signed int tmp_if_expr_7;
  _Bool tmp_if_expr_9;
  signed int tmp_if_expr_11;
  signed int tmp_if_expr_10;
  signed int tmp_if_expr_14;
  signed int tmp_if_expr_13;
  signed int tmp_if_expr_12;
  signed int tmp_if_expr_17;
  signed int tmp_if_expr_16;
  signed int tmp_if_expr_15;
  unsigned char *tmp_if_expr_18;
  _Bool tmp_if_expr_19;
  signed int tmp_if_expr_22;
  signed int tmp_if_expr_23;
  unsigned char *tmp_if_expr_24;
  unsigned char *tmp_if_expr_26;
  unsigned char *tmp_if_expr_25;
  _Bool tmp_if_expr_27;
  _Bool tmp_if_expr_34;
  _Bool tmp_if_expr_28;
  _Bool tmp_if_expr_29;
  _Bool tmp_if_expr_30;
  _Bool tmp_if_expr_31;
  _Bool tmp_if_expr_32;
  _Bool tmp_if_expr_33;
  _Bool tmp_if_expr_49;
  _Bool tmp_if_expr_35;
  signed int tmp_if_expr_37;
  signed int tmp_if_expr_36;
  _Bool tmp_if_expr_38;
  signed int tmp_if_expr_40;
  signed int tmp_if_expr_39;
  signed int tmp_if_expr_43;
  signed int tmp_if_expr_42;
  signed int tmp_if_expr_41;
  signed int tmp_if_expr_46;
  signed int tmp_if_expr_45;
  signed int tmp_if_expr_44;
  unsigned char *tmp_if_expr_47;
  _Bool tmp_if_expr_48;
  while(!(pdata->running == 0))
  {
    if(pdata->avd >= 1)
      tmp_if_expr_5 = (_Bool)1;

    else
      tmp_if_expr_5 = pdata->args.nosound != 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_5)
    {
      pthread_mutex_lock(&pdata->time_mutex);
      pthread_cond_wait(&pdata->time_cond, &pdata->time_mutex);
      pthread_mutex_unlock(&pdata->time_mutex);
      if(pdata->paused == 0)
        goto __CPROVER_DUMP_L16;

      rmdEventLoop(pdata);
    }

    else
    {

    __CPROVER_DUMP_L16:
      ;
      rmdEventLoop(pdata);
      if(!(d_buff == 0))
        img_sel = img_sel != 0 ? 0 : 1;

      pdata->capture_busy = (signed int)!(0 != 0);
      rmdBRWinCpy(&temp_brwin, &pdata->brwin);
      if(!(pdata->args.xfixes_cursor == 0))
        tmp_if_expr_20 = (_Bool)1;

      else
        tmp_if_expr_20 = pdata->args.have_dummy_cursor != 0 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_20)
        tmp_if_expr_21 = (_Bool)1;

      else
        tmp_if_expr_21 = pdata->args.follow_mouse != 0 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_21)
      {
        if(pdata->args.full_shots == 0)
        {
          if((signed int)mouse_pos_temp.x >= 0)
          {
            if((signed int)mouse_pos_temp.y >= 0)
            {
              if((signed int)mouse_pos_temp.width >= 1)
              {
                if((signed int)mouse_pos_temp.height >= 1)
                  rmdRectInsert(&pdata->rect_root, &mouse_pos_temp);

              }

            }

          }

        }

        if(!(pdata->args.xfixes_cursor == 0))
        {
          xcim=XFixesGetCursorImage(pdata->dpy);
          mouse_pos_abs.x = (signed short int)((signed int)xcim->x - (signed int)xcim->xhot);
          mouse_pos_abs.y = (signed short int)((signed int)xcim->y - (signed int)xcim->yhot);
          mouse_pos_abs.width = xcim->width;
          mouse_pos_abs.height = xcim->height;
        }

        else
          XQueryPointer(pdata->dpy, pdata->specs.root, &root_ret, &child_ret, (signed int *)&mouse_pos_abs.x, (signed int *)&mouse_pos_abs.y, (signed int *)&mouse_pos_rel.x, (signed int *)&mouse_pos_rel.y, &msk_ret);
        if((signed int)mouse_pos_abs.x + (signed int)mouse_pos_abs.width >= (signed int)temp_brwin.rrect.x)
          tmp_if_expr_6 = (signed int)mouse_pos_abs.x <= (signed int)(&temp_brwin)->rrect.x + (signed int)(&temp_brwin)->rrect.width ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_6 = (_Bool)0;
        if(tmp_if_expr_6)
        {
          if((signed int)temp_brwin.rrect.x >= (signed int)mouse_pos_abs.x)
            tmp_if_expr_7 = (signed int)(&temp_brwin)->rrect.x;

          else
            tmp_if_expr_7 = (signed int)mouse_pos_abs.x;
          tmp_if_expr_8 = tmp_if_expr_7;
        }

        else
          tmp_if_expr_8 = -1;
        (&mouse_pos_temp)->x = (signed short int)tmp_if_expr_8;
        if((signed int)mouse_pos_abs.y + (signed int)mouse_pos_abs.height >= (signed int)temp_brwin.rrect.y)
          tmp_if_expr_9 = (signed int)mouse_pos_abs.y <= (signed int)(&temp_brwin)->rrect.y + (signed int)(&temp_brwin)->rrect.height ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_9 = (_Bool)0;
        if(tmp_if_expr_9)
        {
          if((signed int)temp_brwin.rrect.y >= (signed int)mouse_pos_abs.y)
            tmp_if_expr_10 = (signed int)(&temp_brwin)->rrect.y;

          else
            tmp_if_expr_10 = (signed int)mouse_pos_abs.y;
          tmp_if_expr_11 = tmp_if_expr_10;
        }

        else
          tmp_if_expr_11 = -1;
        (&mouse_pos_temp)->y = (signed short int)tmp_if_expr_11;
        if((signed int)temp_brwin.rrect.x >= (signed int)mouse_pos_abs.x)
          tmp_if_expr_14 = (signed int)mouse_pos_abs.width - ((signed int)(&temp_brwin)->rrect.x - (signed int)mouse_pos_abs.x);

        else
        {
          if((signed int)temp_brwin.rrect.x + (signed int)temp_brwin.rrect.width >= (signed int)mouse_pos_abs.x)
          {
            if(!((signed int)temp_brwin.rrect.x + (signed int)temp_brwin.rrect.width + -((signed int)mouse_pos_abs.x) >= (signed int)mouse_pos_abs.width))
              tmp_if_expr_12 = ((signed int)(&temp_brwin)->rrect.width - (signed int)mouse_pos_abs.x) + (signed int)(&temp_brwin)->rrect.x;

            else
              tmp_if_expr_12 = (signed int)mouse_pos_abs.width;
            tmp_if_expr_13 = tmp_if_expr_12;
          }

          else
            tmp_if_expr_13 = 0;
          tmp_if_expr_14 = tmp_if_expr_13;
        }
        (&mouse_pos_temp)->width = (unsigned short int)tmp_if_expr_14;
        if((signed int)temp_brwin.rrect.y >= (signed int)mouse_pos_abs.y)
          tmp_if_expr_17 = (signed int)mouse_pos_abs.height - ((signed int)(&temp_brwin)->rrect.y - (signed int)mouse_pos_abs.y);

        else
        {
          if((signed int)temp_brwin.rrect.y + (signed int)temp_brwin.rrect.height >= (signed int)mouse_pos_abs.y)
          {
            if(!((signed int)temp_brwin.rrect.y + (signed int)temp_brwin.rrect.height + -((signed int)mouse_pos_abs.y) >= (signed int)mouse_pos_abs.height))
              tmp_if_expr_15 = ((signed int)(&temp_brwin)->rrect.height - (signed int)mouse_pos_abs.y) + (signed int)(&temp_brwin)->rrect.y;

            else
              tmp_if_expr_15 = (signed int)mouse_pos_abs.height;
            tmp_if_expr_16 = tmp_if_expr_15;
          }

          else
            tmp_if_expr_16 = 0;
          tmp_if_expr_17 = tmp_if_expr_16;
        }
        (&mouse_pos_temp)->height = (unsigned short int)tmp_if_expr_17;
        if(!((signed int)temp_brwin.rrect.width >= (signed int)mouse_pos_temp.width))
          (&mouse_pos_temp)->width = (&temp_brwin)->rrect.width;

        if(!((signed int)temp_brwin.rrect.height >= (signed int)mouse_pos_temp.height))
          (&mouse_pos_temp)->height = (&temp_brwin)->rrect.height;

        if((signed int)mouse_pos_temp.x >= 0 && (signed int)mouse_pos_temp.y >= 0 && (signed int)mouse_pos_temp.height >= 1 && (signed int)mouse_pos_temp.width >= 1)
        {
          if(pdata->args.full_shots == 0)
            rmdRectInsert(&pdata->rect_root, &mouse_pos_temp);

          else
            if(!(d_buff == 0))
            {
              unsigned char *back_buff;
              if(!(img_sel == 0))
                tmp_if_expr_18 = (unsigned char *)image->data;

              else
                tmp_if_expr_18 = (unsigned char *)image_back->data;
              back_buff = tmp_if_expr_18;
              if(pdata->specs.depth == 24)
                tmp_if_expr_19 = (_Bool)1;

              else
                tmp_if_expr_19 = pdata->specs.depth == 32 ? (_Bool)1 : (_Bool)0;
              if(tmp_if_expr_19)
              {
                signed int rmdGetFrame__1__4__2__5__2__1__1__1__k;
                signed int rmdGetFrame__1__4__2__5__2__1__1__1__i;
                unsigned int *rmdGetFrame__1__4__2__5__2__1__1__1__datapi = (unsigned int *)back_buff + (signed long int)((((signed int)mouse_pos_temp.y - (signed int)temp_brwin.rrect.y) + pdata->enc_data->y_offset) * (signed int)temp_brwin.rrect.width) + (signed long int)(((signed int)mouse_pos_temp.x - (signed int)temp_brwin.rrect.x) + pdata->enc_data->x_offset);
                rmdGetFrame__1__4__2__5__2__1__1__1__k = 0;
                for( ; !(rmdGetFrame__1__4__2__5__2__1__1__1__k >= (signed int)mouse_pos_temp.height); rmdGetFrame__1__4__2__5__2__1__1__1__k = rmdGetFrame__1__4__2__5__2__1__1__1__k + 1)
                {
                  rmdGetFrame__1__4__2__5__2__1__1__1__i = 0;
                  for( ; !(rmdGetFrame__1__4__2__5__2__1__1__1__i >= (signed int)mouse_pos_temp.width); rmdGetFrame__1__4__2__5__2__1__1__1__i = rmdGetFrame__1__4__2__5__2__1__1__1__i + 1)
                  {
                    *rmdGetFrame__1__4__2__5__2__1__1__1__datapi = *rmdGetFrame__1__4__2__5__2__1__1__1__datapi + (unsigned int)1;
                    rmdGetFrame__1__4__2__5__2__1__1__1__datapi = rmdGetFrame__1__4__2__5__2__1__1__1__datapi + 1l;
                  }
                  rmdGetFrame__1__4__2__5__2__1__1__1__datapi = rmdGetFrame__1__4__2__5__2__1__1__1__datapi + (signed long int)((signed int)temp_brwin.rrect.width - (signed int)mouse_pos_temp.width);
                }
              }

              else
              {
                signed int rmdGetFrame__1__4__2__5__2__1__2__1__k;
                signed int rmdGetFrame__1__4__2__5__2__1__2__1__i;
                unsigned short int *rmdGetFrame__1__4__2__5__2__1__2__1__datapi = (unsigned short int *)back_buff + (signed long int)((((signed int)mouse_pos_temp.y - (signed int)temp_brwin.rrect.y) + pdata->enc_data->y_offset) * (signed int)temp_brwin.rrect.width) + (signed long int)(((signed int)mouse_pos_temp.x - (signed int)temp_brwin.rrect.x) + pdata->enc_data->x_offset);
                rmdGetFrame__1__4__2__5__2__1__2__1__k = 0;
                for( ; !(rmdGetFrame__1__4__2__5__2__1__2__1__k >= (signed int)mouse_pos_temp.height); rmdGetFrame__1__4__2__5__2__1__2__1__k = rmdGetFrame__1__4__2__5__2__1__2__1__k + 1)
                {
                  rmdGetFrame__1__4__2__5__2__1__2__1__i = 0;
                  for( ; !(rmdGetFrame__1__4__2__5__2__1__2__1__i >= (signed int)mouse_pos_temp.width); rmdGetFrame__1__4__2__5__2__1__2__1__i = rmdGetFrame__1__4__2__5__2__1__2__1__i + 1)
                  {
                    *rmdGetFrame__1__4__2__5__2__1__2__1__datapi = *rmdGetFrame__1__4__2__5__2__1__2__1__datapi + (unsigned short int)1;
                    rmdGetFrame__1__4__2__5__2__1__2__1__datapi = rmdGetFrame__1__4__2__5__2__1__2__1__datapi + 1l;
                  }
                  rmdGetFrame__1__4__2__5__2__1__2__1__datapi = rmdGetFrame__1__4__2__5__2__1__2__1__datapi + (signed long int)((signed int)temp_brwin.rrect.width - (signed int)mouse_pos_temp.width);
                }
              }
            }

        }

      }

      if(!(pdata->args.follow_mouse == 0))
      {
        if(!(pdata->args.xfixes_cursor == 0))
          tmp_if_expr_22 = (signed int)xcim->xhot;

        else
          tmp_if_expr_22 = 0;
        if(!(pdata->args.xfixes_cursor == 0))
          tmp_if_expr_23 = (signed int)xcim->yhot;

        else
          tmp_if_expr_23 = 0;
        rmdMoveCaptureArea(&pdata->brwin, (signed int)mouse_pos_abs.x + tmp_if_expr_22, (signed int)mouse_pos_abs.y + tmp_if_expr_23, (signed int)pdata->specs.width, (signed int)pdata->specs.height);
        if(pdata->args.noframe == 0)
          rmdMoveFrame(pdata->dpy, pdata->shaped_w, (signed int)temp_brwin.rrect.x, (signed int)temp_brwin.rrect.y);

      }

      if(pdata->args.full_shots == 0)
      {
        pthread_mutex_lock(&pdata->yuv_mutex);
        rmdUpdateImage(pdata->dpy, &pdata->enc_data->yuv, &pdata->specs, &pdata->rect_root, &temp_brwin, pdata->enc_data, image->data, pdata->args.noshared, &shminfo, pdata->shm_opcode, pdata->args.no_quick_subsample);
        rmdBlocksFromList(&pdata->rect_root, (unsigned int)temp_brwin.rrect.x, (unsigned int)temp_brwin.rrect.y, (unsigned int)(pdata->enc_data->yuv.y_width / 0x0010), (unsigned int)(pdata->enc_data->yuv.y_height / 0x0010));
        pthread_mutex_unlock(&pdata->yuv_mutex);
      }

      else
      {
        unsigned char *rmdGetFrame__1__4__5__front_buff;
        if(img_sel == 0)
          tmp_if_expr_24 = (unsigned char *)image->data;

        else
          tmp_if_expr_24 = (unsigned char *)image_back->data;
        rmdGetFrame__1__4__5__front_buff = tmp_if_expr_24;
        unsigned char *rmdGetFrame__1__4__5__back_buff;
        if(d_buff == 0)
          tmp_if_expr_26 = (unsigned char *)(void *)0;

        else
        {
          if(!(img_sel == 0))
            tmp_if_expr_25 = (unsigned char *)image->data;

          else
            tmp_if_expr_25 = (unsigned char *)image_back->data;
          tmp_if_expr_26 = tmp_if_expr_25;
        }
        rmdGetFrame__1__4__5__back_buff = tmp_if_expr_26;
        if(pdata->args.noshared == 0)
          XShmGetImage(pdata->dpy, pdata->specs.root, !(img_sel != 0) ? image : image_back, (signed int)temp_brwin.rrect.x, (signed int)temp_brwin.rrect.y, (unsigned long int)~0L);

        if(!(pdata->args.noshared == 0))
          rmdGetZPixmap(pdata->dpy, pdata->specs.root, image->data, (signed int)temp_brwin.rrect.x, (signed int)temp_brwin.rrect.y, (signed int)temp_brwin.rrect.width, (signed int)temp_brwin.rrect.height);

        pthread_mutex_lock(&pdata->yuv_mutex);
        rmdGetFrame__1__i = 0;
        for( ; !(rmdGetFrame__1__i >= blocknum_x * blocknum_y); rmdGetFrame__1__i = rmdGetFrame__1__i + 1)
        {
          vblocks[(signed long int)rmdGetFrame__1__i] = (unsigned int)0;
          ublocks[(signed long int)rmdGetFrame__1__i] = vblocks[(signed long int)rmdGetFrame__1__i];
          yblocks[(signed long int)rmdGetFrame__1__i] = ublocks[(signed long int)rmdGetFrame__1__i];
        }
        if(rmdGetFrame__1__4__5__back_buff == ((unsigned char *)NULL))
        {
          if(pdata->specs.depth == 24)
            tmp_if_expr_27 = (_Bool)1;

          else
            tmp_if_expr_27 = pdata->specs.depth == 32 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr_27)
          {
            signed int rmdGetFrame__1__4__5__4__1__1__1__k;
            signed int rmdGetFrame__1__4__5__4__1__1__1__i;
            unsigned int t_val;
            unsigned char *yuv_y = (&pdata->enc_data->yuv)->y + (signed long int)pdata->enc_data->x_offset + (signed long int)(pdata->enc_data->y_offset * (&pdata->enc_data->yuv)->y_width);
            unsigned char *_yr = Yr;
            unsigned char *_yg = Yg;
            unsigned char *_yb = Yb;
            unsigned int *rmdGetFrame__1__4__5__4__1__1__1__datapi = (unsigned int *)rmdGetFrame__1__4__5__front_buff;
            rmdGetFrame__1__4__5__4__1__1__1__k = 0;
            for( ; !(rmdGetFrame__1__4__5__4__1__1__1__k >= (signed int)temp_brwin.rrect.height); rmdGetFrame__1__4__5__4__1__1__1__k = rmdGetFrame__1__4__5__4__1__1__1__k + 1)
            {
              rmdGetFrame__1__4__5__4__1__1__1__i = 0;
              for( ; !(rmdGetFrame__1__4__5__4__1__1__1__i >= (signed int)temp_brwin.rrect.width); rmdGetFrame__1__4__5__4__1__1__1__i = rmdGetFrame__1__4__5__4__1__1__1__i + 1)
              {
                t_val = *rmdGetFrame__1__4__5__4__1__1__1__datapi;
                *yuv_y = (unsigned char)((signed int)_yr[(signed long int)((t_val & (unsigned int)0x00ff0000) >> 16)] + (signed int)_yg[(signed long int)((t_val & (unsigned int)0x0000ff00) >> 8)] + (signed int)_yb[(signed long int)(t_val & (unsigned int)0x000000ff)]);
                rmdGetFrame__1__4__5__4__1__1__1__datapi = rmdGetFrame__1__4__5__4__1__1__1__datapi + 1l;
                yuv_y = yuv_y + 1l;
              }
              yuv_y = yuv_y + (signed long int)((&pdata->enc_data->yuv)->y_width - (signed int)temp_brwin.rrect.width);
            }
            signed int rmdGetFrame__1__4__5__4__1__1__2__k;
            signed int rmdGetFrame__1__4__5__4__1__1__2__i;
            unsigned int rmdGetFrame__1__4__5__4__1__1__2__t_val;
            unsigned char *yuv_u = (&pdata->enc_data->yuv)->u + (signed long int)(pdata->enc_data->x_offset / 2) + (signed long int)((pdata->enc_data->y_offset * (&pdata->enc_data->yuv)->uv_width) / 2);
            unsigned char *yuv_v = (&pdata->enc_data->yuv)->v + (signed long int)(pdata->enc_data->x_offset / 2) + (signed long int)((pdata->enc_data->y_offset * (&pdata->enc_data->yuv)->uv_width) / 2);
            unsigned char *rmdGetFrame__1__4__5__4__1__1__2___ur = Ur;
            unsigned char *rmdGetFrame__1__4__5__4__1__1__2___ug = Ug;
            unsigned char *rmdGetFrame__1__4__5__4__1__1__2___ubvr = UbVr;
            unsigned char *rmdGetFrame__1__4__5__4__1__1__2___vg = Vg;
            unsigned char *rmdGetFrame__1__4__5__4__1__1__2___vb = Vb;
            unsigned int *rmdGetFrame__1__4__5__4__1__1__2__datapi = (unsigned int *)rmdGetFrame__1__4__5__front_buff;
            unsigned int *rmdGetFrame__1__4__5__4__1__1__2__datapi_next = (unsigned int *)(void *)0;
            if(pdata->args.no_quick_subsample == 1)
              rmdGetFrame__1__4__5__4__1__1__2__datapi_next = rmdGetFrame__1__4__5__4__1__1__2__datapi + (signed long int)temp_brwin.rrect.width;

            rmdGetFrame__1__4__5__4__1__1__2__k = 0;
            for( ; !(rmdGetFrame__1__4__5__4__1__1__2__k >= (signed int)temp_brwin.rrect.height); rmdGetFrame__1__4__5__4__1__1__2__k = rmdGetFrame__1__4__5__4__1__1__2__k + 2)
            {
              rmdGetFrame__1__4__5__4__1__1__2__i = 0;
              for( ; !(rmdGetFrame__1__4__5__4__1__1__2__i >= (signed int)temp_brwin.rrect.width); rmdGetFrame__1__4__5__4__1__1__2__i = rmdGetFrame__1__4__5__4__1__1__2__i + 2)
              {
                if(pdata->args.no_quick_subsample == 1)
                {
                  unsigned int rmdGetFrame__1__4__5__4__1__1__2__2__1__1__1__1__1__t1;
                  unsigned int rmdGetFrame__1__4__5__4__1__1__2__2__1__1__1__1__1__t2;
                  unsigned int rmdGetFrame__1__4__5__4__1__1__2__2__1__1__1__1__1__t3;
                  unsigned int rmdGetFrame__1__4__5__4__1__1__2__2__1__1__1__1__1__t4;
                  rmdGetFrame__1__4__5__4__1__1__2__2__1__1__1__1__1__t1 = *rmdGetFrame__1__4__5__4__1__1__2__datapi;
                  rmdGetFrame__1__4__5__4__1__1__2__2__1__1__1__1__1__t2 = rmdGetFrame__1__4__5__4__1__1__2__datapi[(signed long int)1];
                  rmdGetFrame__1__4__5__4__1__1__2__2__1__1__1__1__1__t3 = *rmdGetFrame__1__4__5__4__1__1__2__datapi_next;
                  rmdGetFrame__1__4__5__4__1__1__2__2__1__1__1__1__1__t4 = rmdGetFrame__1__4__5__4__1__1__2__datapi_next[(signed long int)1];
                  rmdGetFrame__1__4__5__4__1__1__2__t_val = (((rmdGetFrame__1__4__5__4__1__1__2__2__1__1__1__1__1__t1 & (unsigned int)0x00ff0000) + (rmdGetFrame__1__4__5__4__1__1__2__2__1__1__1__1__1__t2 & (unsigned int)0x00ff0000) + (rmdGetFrame__1__4__5__4__1__1__2__2__1__1__1__1__1__t3 & (unsigned int)0x00ff0000) + (rmdGetFrame__1__4__5__4__1__1__2__2__1__1__1__1__1__t4 & (unsigned int)0x00ff0000)) / (unsigned int)4 & (unsigned int)0x00ff0000) + (((rmdGetFrame__1__4__5__4__1__1__2__2__1__1__1__1__1__t1 & (unsigned int)0x0000ff00) + (rmdGetFrame__1__4__5__4__1__1__2__2__1__1__1__1__1__t2 & (unsigned int)0x0000ff00) + (rmdGetFrame__1__4__5__4__1__1__2__2__1__1__1__1__1__t3 & (unsigned int)0x0000ff00) + (rmdGetFrame__1__4__5__4__1__1__2__2__1__1__1__1__1__t4 & (unsigned int)0x0000ff00)) / (unsigned int)4 & (unsigned int)0x0000ff00) + (((rmdGetFrame__1__4__5__4__1__1__2__2__1__1__1__1__1__t1 & (unsigned int)0x000000ff) + (rmdGetFrame__1__4__5__4__1__1__2__2__1__1__1__1__1__t2 & (unsigned int)0x000000ff) + (rmdGetFrame__1__4__5__4__1__1__2__2__1__1__1__1__1__t3 & (unsigned int)0x000000ff) + (rmdGetFrame__1__4__5__4__1__1__2__2__1__1__1__1__1__t4 & (unsigned int)0x000000ff)) / (unsigned int)4 & (unsigned int)0x000000ff);
                }

                else
                  rmdGetFrame__1__4__5__4__1__1__2__t_val = *rmdGetFrame__1__4__5__4__1__1__2__datapi;
                *yuv_u = (unsigned char)((signed int)rmdGetFrame__1__4__5__4__1__1__2___ur[(signed long int)((rmdGetFrame__1__4__5__4__1__1__2__t_val & (unsigned int)0x00ff0000) >> 16)] + (signed int)rmdGetFrame__1__4__5__4__1__1__2___ug[(signed long int)((rmdGetFrame__1__4__5__4__1__1__2__t_val & (unsigned int)0x0000ff00) >> 8)] + (signed int)rmdGetFrame__1__4__5__4__1__1__2___ubvr[(signed long int)(rmdGetFrame__1__4__5__4__1__1__2__t_val & (unsigned int)0x000000ff)]);
                *yuv_v = (unsigned char)((signed int)rmdGetFrame__1__4__5__4__1__1__2___ubvr[(signed long int)((rmdGetFrame__1__4__5__4__1__1__2__t_val & (unsigned int)0x00ff0000) >> 16)] + (signed int)rmdGetFrame__1__4__5__4__1__1__2___vg[(signed long int)((rmdGetFrame__1__4__5__4__1__1__2__t_val & (unsigned int)0x0000ff00) >> 8)] + (signed int)rmdGetFrame__1__4__5__4__1__1__2___vb[(signed long int)(rmdGetFrame__1__4__5__4__1__1__2__t_val & (unsigned int)0x000000ff)]);
                rmdGetFrame__1__4__5__4__1__1__2__datapi = rmdGetFrame__1__4__5__4__1__1__2__datapi + (signed long int)2;
                if(pdata->args.no_quick_subsample == 1)
                  rmdGetFrame__1__4__5__4__1__1__2__datapi_next = rmdGetFrame__1__4__5__4__1__1__2__datapi_next + (signed long int)2;

                yuv_u = yuv_u + 1l;
                yuv_v = yuv_v + 1l;
              }
              yuv_u = yuv_u + (signed long int)(((&pdata->enc_data->yuv)->y_width - (signed int)temp_brwin.rrect.width) / 2);
              yuv_v = yuv_v + (signed long int)(((&pdata->enc_data->yuv)->y_width - (signed int)temp_brwin.rrect.width) / 2);
              rmdGetFrame__1__4__5__4__1__1__2__datapi = rmdGetFrame__1__4__5__4__1__1__2__datapi + (signed long int)temp_brwin.rrect.width;
              if(pdata->args.no_quick_subsample == 1)
                rmdGetFrame__1__4__5__4__1__1__2__datapi_next = rmdGetFrame__1__4__5__4__1__1__2__datapi_next + (signed long int)temp_brwin.rrect.width;

            }
          }

          else
            if(pdata->specs.depth == 16)
            {
              signed int rmdGetFrame__1__4__5__4__1__2__1__k;
              signed int rmdGetFrame__1__4__5__4__1__2__1__i;
              unsigned short int rmdGetFrame__1__4__5__4__1__2__1__t_val;
              unsigned char *rmdGetFrame__1__4__5__4__1__2__1__yuv_y = (&pdata->enc_data->yuv)->y + (signed long int)pdata->enc_data->x_offset + (signed long int)(pdata->enc_data->y_offset * (&pdata->enc_data->yuv)->y_width);
              unsigned char *rmdGetFrame__1__4__5__4__1__2__1___yr = Yr;
              unsigned char *rmdGetFrame__1__4__5__4__1__2__1___yg = Yg;
              unsigned char *rmdGetFrame__1__4__5__4__1__2__1___yb = Yb;
              unsigned short int *rmdGetFrame__1__4__5__4__1__2__1__datapi = (unsigned short int *)rmdGetFrame__1__4__5__front_buff;
              rmdGetFrame__1__4__5__4__1__2__1__k = 0;
              for( ; !(rmdGetFrame__1__4__5__4__1__2__1__k >= (signed int)temp_brwin.rrect.height); rmdGetFrame__1__4__5__4__1__2__1__k = rmdGetFrame__1__4__5__4__1__2__1__k + 1)
              {
                rmdGetFrame__1__4__5__4__1__2__1__i = 0;
                for( ; !(rmdGetFrame__1__4__5__4__1__2__1__i >= (signed int)temp_brwin.rrect.width); rmdGetFrame__1__4__5__4__1__2__1__i = rmdGetFrame__1__4__5__4__1__2__1__i + 1)
                {
                  rmdGetFrame__1__4__5__4__1__2__1__t_val = *rmdGetFrame__1__4__5__4__1__2__1__datapi;
                  *rmdGetFrame__1__4__5__4__1__2__1__yuv_y = (unsigned char)((signed int)rmdGetFrame__1__4__5__4__1__2__1___yr[(signed long int)((((signed int)rmdGetFrame__1__4__5__4__1__2__1__t_val & 0xf800) >> 11) * 8)] + (signed int)rmdGetFrame__1__4__5__4__1__2__1___yg[(signed long int)((((signed int)rmdGetFrame__1__4__5__4__1__2__1__t_val & 0x7e0) >> 5) * 4)] + (signed int)rmdGetFrame__1__4__5__4__1__2__1___yb[(signed long int)(((signed int)rmdGetFrame__1__4__5__4__1__2__1__t_val & 0x1f) * 8)]);
                  rmdGetFrame__1__4__5__4__1__2__1__datapi = rmdGetFrame__1__4__5__4__1__2__1__datapi + 1l;
                  rmdGetFrame__1__4__5__4__1__2__1__yuv_y = rmdGetFrame__1__4__5__4__1__2__1__yuv_y + 1l;
                }
                rmdGetFrame__1__4__5__4__1__2__1__yuv_y = rmdGetFrame__1__4__5__4__1__2__1__yuv_y + (signed long int)((&pdata->enc_data->yuv)->y_width - (signed int)temp_brwin.rrect.width);
              }
              signed int rmdGetFrame__1__4__5__4__1__2__2__k;
              signed int rmdGetFrame__1__4__5__4__1__2__2__i;
              unsigned short int rmdGetFrame__1__4__5__4__1__2__2__t_val;
              unsigned char *rmdGetFrame__1__4__5__4__1__2__2__yuv_u = (&pdata->enc_data->yuv)->u + (signed long int)(pdata->enc_data->x_offset / 2) + (signed long int)((pdata->enc_data->y_offset * (&pdata->enc_data->yuv)->uv_width) / 2);
              unsigned char *rmdGetFrame__1__4__5__4__1__2__2__yuv_v = (&pdata->enc_data->yuv)->v + (signed long int)(pdata->enc_data->x_offset / 2) + (signed long int)((pdata->enc_data->y_offset * (&pdata->enc_data->yuv)->uv_width) / 2);
              unsigned char *rmdGetFrame__1__4__5__4__1__2__2___ur = Ur;
              unsigned char *rmdGetFrame__1__4__5__4__1__2__2___ug = Ug;
              unsigned char *rmdGetFrame__1__4__5__4__1__2__2___ubvr = UbVr;
              unsigned char *rmdGetFrame__1__4__5__4__1__2__2___vg = Vg;
              unsigned char *rmdGetFrame__1__4__5__4__1__2__2___vb = Vb;
              unsigned short int *rmdGetFrame__1__4__5__4__1__2__2__datapi = (unsigned short int *)rmdGetFrame__1__4__5__front_buff;
              unsigned short int *rmdGetFrame__1__4__5__4__1__2__2__datapi_next = (unsigned short int *)(void *)0;
              if(pdata->args.no_quick_subsample == 1)
                rmdGetFrame__1__4__5__4__1__2__2__datapi_next = rmdGetFrame__1__4__5__4__1__2__2__datapi + (signed long int)temp_brwin.rrect.width;

              rmdGetFrame__1__4__5__4__1__2__2__k = 0;
              for( ; !(rmdGetFrame__1__4__5__4__1__2__2__k >= (signed int)temp_brwin.rrect.height); rmdGetFrame__1__4__5__4__1__2__2__k = rmdGetFrame__1__4__5__4__1__2__2__k + 2)
              {
                rmdGetFrame__1__4__5__4__1__2__2__i = 0;
                for( ; !(rmdGetFrame__1__4__5__4__1__2__2__i >= (signed int)temp_brwin.rrect.width); rmdGetFrame__1__4__5__4__1__2__2__i = rmdGetFrame__1__4__5__4__1__2__2__i + 2)
                {
                  if(pdata->args.no_quick_subsample == 1)
                  {
                    unsigned short int rmdGetFrame__1__4__5__4__1__2__2__2__1__1__1__1__1__t1;
                    unsigned short int rmdGetFrame__1__4__5__4__1__2__2__2__1__1__1__1__1__t2;
                    unsigned short int rmdGetFrame__1__4__5__4__1__2__2__2__1__1__1__1__1__t3;
                    unsigned short int rmdGetFrame__1__4__5__4__1__2__2__2__1__1__1__1__1__t4;
                    rmdGetFrame__1__4__5__4__1__2__2__2__1__1__1__1__1__t1 = *rmdGetFrame__1__4__5__4__1__2__2__datapi;
                    rmdGetFrame__1__4__5__4__1__2__2__2__1__1__1__1__1__t2 = rmdGetFrame__1__4__5__4__1__2__2__datapi[(signed long int)1];
                    rmdGetFrame__1__4__5__4__1__2__2__2__1__1__1__1__1__t3 = *rmdGetFrame__1__4__5__4__1__2__2__datapi_next;
                    rmdGetFrame__1__4__5__4__1__2__2__2__1__1__1__1__1__t4 = rmdGetFrame__1__4__5__4__1__2__2__datapi_next[(signed long int)1];
                    rmdGetFrame__1__4__5__4__1__2__2__t_val = (unsigned short int)(((((signed int)rmdGetFrame__1__4__5__4__1__2__2__2__1__1__1__1__1__t1 & 0xf800) + ((signed int)rmdGetFrame__1__4__5__4__1__2__2__2__1__1__1__1__1__t2 & 0xf800) + ((signed int)rmdGetFrame__1__4__5__4__1__2__2__2__1__1__1__1__1__t3 & 0xf800) + ((signed int)rmdGetFrame__1__4__5__4__1__2__2__2__1__1__1__1__1__t4 & 0xf800)) / 4 & 0xf800) + ((((signed int)rmdGetFrame__1__4__5__4__1__2__2__2__1__1__1__1__1__t1 & 0x7e0) + ((signed int)rmdGetFrame__1__4__5__4__1__2__2__2__1__1__1__1__1__t2 & 0x7e0) + ((signed int)rmdGetFrame__1__4__5__4__1__2__2__2__1__1__1__1__1__t3 & 0x7e0) + ((signed int)rmdGetFrame__1__4__5__4__1__2__2__2__1__1__1__1__1__t4 & 0x7e0)) / 4 & 0x7e0) + ((((signed int)rmdGetFrame__1__4__5__4__1__2__2__2__1__1__1__1__1__t1 & 0x1f) + ((signed int)rmdGetFrame__1__4__5__4__1__2__2__2__1__1__1__1__1__t2 & 0x1f) + ((signed int)rmdGetFrame__1__4__5__4__1__2__2__2__1__1__1__1__1__t3 & 0x1f) + ((signed int)rmdGetFrame__1__4__5__4__1__2__2__2__1__1__1__1__1__t4 & 0x1f)) / 4 & 0x1f));
                  }

                  else
                    rmdGetFrame__1__4__5__4__1__2__2__t_val = *rmdGetFrame__1__4__5__4__1__2__2__datapi;
                  *rmdGetFrame__1__4__5__4__1__2__2__yuv_u = (unsigned char)((signed int)rmdGetFrame__1__4__5__4__1__2__2___ur[(signed long int)((((signed int)rmdGetFrame__1__4__5__4__1__2__2__t_val & 0xf800) >> 11) * 8)] + (signed int)rmdGetFrame__1__4__5__4__1__2__2___ug[(signed long int)((((signed int)rmdGetFrame__1__4__5__4__1__2__2__t_val & 0x7e0) >> 5) * 4)] + (signed int)rmdGetFrame__1__4__5__4__1__2__2___ubvr[(signed long int)(((signed int)rmdGetFrame__1__4__5__4__1__2__2__t_val & 0x1f) * 8)]);
                  *rmdGetFrame__1__4__5__4__1__2__2__yuv_v = (unsigned char)((signed int)rmdGetFrame__1__4__5__4__1__2__2___ubvr[(signed long int)((((signed int)rmdGetFrame__1__4__5__4__1__2__2__t_val & 0xf800) >> 11) * 8)] + (signed int)rmdGetFrame__1__4__5__4__1__2__2___vg[(signed long int)((((signed int)rmdGetFrame__1__4__5__4__1__2__2__t_val & 0x7e0) >> 5) * 4)] + (signed int)rmdGetFrame__1__4__5__4__1__2__2___vb[(signed long int)(((signed int)rmdGetFrame__1__4__5__4__1__2__2__t_val & 0x1f) * 8)]);
                  rmdGetFrame__1__4__5__4__1__2__2__datapi = rmdGetFrame__1__4__5__4__1__2__2__datapi + (signed long int)2;
                  if(pdata->args.no_quick_subsample == 1)
                    rmdGetFrame__1__4__5__4__1__2__2__datapi_next = rmdGetFrame__1__4__5__4__1__2__2__datapi_next + (signed long int)2;

                  rmdGetFrame__1__4__5__4__1__2__2__yuv_u = rmdGetFrame__1__4__5__4__1__2__2__yuv_u + 1l;
                  rmdGetFrame__1__4__5__4__1__2__2__yuv_v = rmdGetFrame__1__4__5__4__1__2__2__yuv_v + 1l;
                }
                rmdGetFrame__1__4__5__4__1__2__2__yuv_u = rmdGetFrame__1__4__5__4__1__2__2__yuv_u + (signed long int)(((&pdata->enc_data->yuv)->y_width - (signed int)temp_brwin.rrect.width) / 2);
                rmdGetFrame__1__4__5__4__1__2__2__yuv_v = rmdGetFrame__1__4__5__4__1__2__2__yuv_v + (signed long int)(((&pdata->enc_data->yuv)->y_width - (signed int)temp_brwin.rrect.width) / 2);
                rmdGetFrame__1__4__5__4__1__2__2__datapi = rmdGetFrame__1__4__5__4__1__2__2__datapi + (signed long int)temp_brwin.rrect.width;
                if(pdata->args.no_quick_subsample == 1)
                  rmdGetFrame__1__4__5__4__1__2__2__datapi_next = rmdGetFrame__1__4__5__4__1__2__2__datapi_next + (signed long int)temp_brwin.rrect.width;

              }
            }

        }

        else
        {
          if(pdata->specs.depth == 24)
            tmp_if_expr_34 = (_Bool)1;

          else
            tmp_if_expr_34 = pdata->specs.depth == 32 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr_34)
          {
            signed int rmdGetFrame__1__4__5__4__2__1__1__k;
            signed int rmdGetFrame__1__4__5__4__2__1__1__i;
            unsigned int rmdGetFrame__1__4__5__4__2__1__1__t_val;
            unsigned char *rmdGetFrame__1__4__5__4__2__1__1__yuv_y = (&pdata->enc_data->yuv)->y + (signed long int)pdata->enc_data->x_offset + (signed long int)(pdata->enc_data->y_offset * (&pdata->enc_data->yuv)->y_width);
            unsigned char *rmdGetFrame__1__4__5__4__2__1__1___yr = Yr;
            unsigned char *rmdGetFrame__1__4__5__4__2__1__1___yg = Yg;
            unsigned char *rmdGetFrame__1__4__5__4__2__1__1___yb = Yb;
            unsigned int *rmdGetFrame__1__4__5__4__2__1__1__datapi = (unsigned int *)rmdGetFrame__1__4__5__front_buff;
            unsigned int *rmdGetFrame__1__4__5__4__2__1__1__datapi_back = (unsigned int *)rmdGetFrame__1__4__5__back_buff;
            rmdGetFrame__1__4__5__4__2__1__1__k = 0;
            for( ; !(rmdGetFrame__1__4__5__4__2__1__1__k >= (signed int)temp_brwin.rrect.height); rmdGetFrame__1__4__5__4__2__1__1__k = rmdGetFrame__1__4__5__4__2__1__1__k + 1)
            {
              rmdGetFrame__1__4__5__4__2__1__1__i = 0;
              for( ; !(rmdGetFrame__1__4__5__4__2__1__1__i >= (signed int)temp_brwin.rrect.width); rmdGetFrame__1__4__5__4__2__1__1__i = rmdGetFrame__1__4__5__4__2__1__1__i + 1)
              {
                if(!(*rmdGetFrame__1__4__5__4__2__1__1__datapi == *rmdGetFrame__1__4__5__4__2__1__1__datapi_back))
                {
                  rmdGetFrame__1__4__5__4__2__1__1__t_val = *rmdGetFrame__1__4__5__4__2__1__1__datapi;
                  *rmdGetFrame__1__4__5__4__2__1__1__yuv_y = (unsigned char)((signed int)rmdGetFrame__1__4__5__4__2__1__1___yr[(signed long int)((rmdGetFrame__1__4__5__4__2__1__1__t_val & (unsigned int)0x00ff0000) >> 16)] + (signed int)rmdGetFrame__1__4__5__4__2__1__1___yg[(signed long int)((rmdGetFrame__1__4__5__4__2__1__1__t_val & (unsigned int)0x0000ff00) >> 8)] + (signed int)rmdGetFrame__1__4__5__4__2__1__1___yb[(signed long int)(rmdGetFrame__1__4__5__4__2__1__1__t_val & (unsigned int)0x000000ff)]);
                  yblocks[(signed long int)((rmdGetFrame__1__4__5__4__2__1__1__k / 0x0010) * ((signed int)temp_brwin.rrect.width / 0x0010) + rmdGetFrame__1__4__5__4__2__1__1__i / 0x0010)] = (unsigned int)1;
                }

                rmdGetFrame__1__4__5__4__2__1__1__datapi = rmdGetFrame__1__4__5__4__2__1__1__datapi + 1l;
                rmdGetFrame__1__4__5__4__2__1__1__datapi_back = rmdGetFrame__1__4__5__4__2__1__1__datapi_back + 1l;
                rmdGetFrame__1__4__5__4__2__1__1__yuv_y = rmdGetFrame__1__4__5__4__2__1__1__yuv_y + 1l;
              }
              rmdGetFrame__1__4__5__4__2__1__1__yuv_y = rmdGetFrame__1__4__5__4__2__1__1__yuv_y + (signed long int)((&pdata->enc_data->yuv)->y_width - (signed int)temp_brwin.rrect.width);
            }
            signed int rmdGetFrame__1__4__5__4__2__1__2__k;
            signed int rmdGetFrame__1__4__5__4__2__1__2__i;
            unsigned int rmdGetFrame__1__4__5__4__2__1__2__t_val;
            unsigned char *rmdGetFrame__1__4__5__4__2__1__2__yuv_u = (&pdata->enc_data->yuv)->u + (signed long int)(pdata->enc_data->x_offset / 2) + (signed long int)((pdata->enc_data->y_offset * (&pdata->enc_data->yuv)->uv_width) / 2);
            unsigned char *rmdGetFrame__1__4__5__4__2__1__2__yuv_v = (&pdata->enc_data->yuv)->v + (signed long int)(pdata->enc_data->x_offset / 2) + (signed long int)((pdata->enc_data->y_offset * (&pdata->enc_data->yuv)->uv_width) / 2);
            unsigned char *rmdGetFrame__1__4__5__4__2__1__2___ur = Ur;
            unsigned char *rmdGetFrame__1__4__5__4__2__1__2___ug = Ug;
            unsigned char *rmdGetFrame__1__4__5__4__2__1__2___ubvr = UbVr;
            unsigned char *rmdGetFrame__1__4__5__4__2__1__2___vg = Vg;
            unsigned char *rmdGetFrame__1__4__5__4__2__1__2___vb = Vb;
            unsigned int *rmdGetFrame__1__4__5__4__2__1__2__datapi = (unsigned int *)rmdGetFrame__1__4__5__front_buff;
            unsigned int *rmdGetFrame__1__4__5__4__2__1__2__datapi_next = (unsigned int *)(void *)0;
            unsigned int *rmdGetFrame__1__4__5__4__2__1__2__datapi_back = (unsigned int *)rmdGetFrame__1__4__5__back_buff;
            unsigned int *rmdGetFrame__1__4__5__4__2__1__2__datapi_back_next = (unsigned int *)(void *)0;
            if(pdata->args.no_quick_subsample == 1)
            {
              rmdGetFrame__1__4__5__4__2__1__2__datapi_next = rmdGetFrame__1__4__5__4__2__1__2__datapi + (signed long int)temp_brwin.rrect.width;
              rmdGetFrame__1__4__5__4__2__1__2__datapi_back_next = rmdGetFrame__1__4__5__4__2__1__2__datapi_back + (signed long int)temp_brwin.rrect.width;
              rmdGetFrame__1__4__5__4__2__1__2__k = 0;
              for( ; !(rmdGetFrame__1__4__5__4__2__1__2__k >= (signed int)temp_brwin.rrect.height); rmdGetFrame__1__4__5__4__2__1__2__k = rmdGetFrame__1__4__5__4__2__1__2__k + 2)
              {
                rmdGetFrame__1__4__5__4__2__1__2__i = 0;
                for( ; !(rmdGetFrame__1__4__5__4__2__1__2__i >= (signed int)temp_brwin.rrect.width); rmdGetFrame__1__4__5__4__2__1__2__i = rmdGetFrame__1__4__5__4__2__1__2__i + 2)
                {
                  if(!(*rmdGetFrame__1__4__5__4__2__1__2__datapi == *rmdGetFrame__1__4__5__4__2__1__2__datapi_back))
                    tmp_if_expr_28 = (_Bool)1;

                  else
                    tmp_if_expr_28 = rmdGetFrame__1__4__5__4__2__1__2__datapi[(signed long int)1] != rmdGetFrame__1__4__5__4__2__1__2__datapi_back[(signed long int)1] ? (_Bool)1 : (_Bool)0;
                  if(tmp_if_expr_28)
                    tmp_if_expr_29 = (_Bool)1;

                  else
                    tmp_if_expr_29 = *rmdGetFrame__1__4__5__4__2__1__2__datapi_next != *rmdGetFrame__1__4__5__4__2__1__2__datapi_back_next ? (_Bool)1 : (_Bool)0;
                  if(tmp_if_expr_29)
                    tmp_if_expr_30 = (_Bool)1;

                  else
                    tmp_if_expr_30 = rmdGetFrame__1__4__5__4__2__1__2__datapi_next[(signed long int)1] != rmdGetFrame__1__4__5__4__2__1__2__datapi_back_next[(signed long int)1] ? (_Bool)1 : (_Bool)0;
                  if(tmp_if_expr_30)
                  {
                    if(pdata->args.no_quick_subsample == 1)
                    {
                      unsigned int rmdGetFrame__1__4__5__4__2__1__2__1__1__1__1__1__1__1__1__t1;
                      unsigned int rmdGetFrame__1__4__5__4__2__1__2__1__1__1__1__1__1__1__1__t2;
                      unsigned int rmdGetFrame__1__4__5__4__2__1__2__1__1__1__1__1__1__1__1__t3;
                      unsigned int rmdGetFrame__1__4__5__4__2__1__2__1__1__1__1__1__1__1__1__t4;
                      rmdGetFrame__1__4__5__4__2__1__2__1__1__1__1__1__1__1__1__t1 = *rmdGetFrame__1__4__5__4__2__1__2__datapi;
                      rmdGetFrame__1__4__5__4__2__1__2__1__1__1__1__1__1__1__1__t2 = rmdGetFrame__1__4__5__4__2__1__2__datapi[(signed long int)1];
                      rmdGetFrame__1__4__5__4__2__1__2__1__1__1__1__1__1__1__1__t3 = *rmdGetFrame__1__4__5__4__2__1__2__datapi_next;
                      rmdGetFrame__1__4__5__4__2__1__2__1__1__1__1__1__1__1__1__t4 = rmdGetFrame__1__4__5__4__2__1__2__datapi_next[(signed long int)1];
                      rmdGetFrame__1__4__5__4__2__1__2__t_val = (((rmdGetFrame__1__4__5__4__2__1__2__1__1__1__1__1__1__1__1__t1 & (unsigned int)0x00ff0000) + (rmdGetFrame__1__4__5__4__2__1__2__1__1__1__1__1__1__1__1__t2 & (unsigned int)0x00ff0000) + (rmdGetFrame__1__4__5__4__2__1__2__1__1__1__1__1__1__1__1__t3 & (unsigned int)0x00ff0000) + (rmdGetFrame__1__4__5__4__2__1__2__1__1__1__1__1__1__1__1__t4 & (unsigned int)0x00ff0000)) / (unsigned int)4 & (unsigned int)0x00ff0000) + (((rmdGetFrame__1__4__5__4__2__1__2__1__1__1__1__1__1__1__1__t1 & (unsigned int)0x0000ff00) + (rmdGetFrame__1__4__5__4__2__1__2__1__1__1__1__1__1__1__1__t2 & (unsigned int)0x0000ff00) + (rmdGetFrame__1__4__5__4__2__1__2__1__1__1__1__1__1__1__1__t3 & (unsigned int)0x0000ff00) + (rmdGetFrame__1__4__5__4__2__1__2__1__1__1__1__1__1__1__1__t4 & (unsigned int)0x0000ff00)) / (unsigned int)4 & (unsigned int)0x0000ff00) + (((rmdGetFrame__1__4__5__4__2__1__2__1__1__1__1__1__1__1__1__t1 & (unsigned int)0x000000ff) + (rmdGetFrame__1__4__5__4__2__1__2__1__1__1__1__1__1__1__1__t2 & (unsigned int)0x000000ff) + (rmdGetFrame__1__4__5__4__2__1__2__1__1__1__1__1__1__1__1__t3 & (unsigned int)0x000000ff) + (rmdGetFrame__1__4__5__4__2__1__2__1__1__1__1__1__1__1__1__t4 & (unsigned int)0x000000ff)) / (unsigned int)4 & (unsigned int)0x000000ff);
                    }

                    else
                      rmdGetFrame__1__4__5__4__2__1__2__t_val = *rmdGetFrame__1__4__5__4__2__1__2__datapi;
                    *rmdGetFrame__1__4__5__4__2__1__2__yuv_u = (unsigned char)((signed int)rmdGetFrame__1__4__5__4__2__1__2___ur[(signed long int)((rmdGetFrame__1__4__5__4__2__1__2__t_val & (unsigned int)0x00ff0000) >> 16)] + (signed int)rmdGetFrame__1__4__5__4__2__1__2___ug[(signed long int)((rmdGetFrame__1__4__5__4__2__1__2__t_val & (unsigned int)0x0000ff00) >> 8)] + (signed int)rmdGetFrame__1__4__5__4__2__1__2___ubvr[(signed long int)(rmdGetFrame__1__4__5__4__2__1__2__t_val & (unsigned int)0x000000ff)]);
                    *rmdGetFrame__1__4__5__4__2__1__2__yuv_v = (unsigned char)((signed int)rmdGetFrame__1__4__5__4__2__1__2___ubvr[(signed long int)((rmdGetFrame__1__4__5__4__2__1__2__t_val & (unsigned int)0x00ff0000) >> 16)] + (signed int)rmdGetFrame__1__4__5__4__2__1__2___vg[(signed long int)((rmdGetFrame__1__4__5__4__2__1__2__t_val & (unsigned int)0x0000ff00) >> 8)] + (signed int)rmdGetFrame__1__4__5__4__2__1__2___vb[(signed long int)(rmdGetFrame__1__4__5__4__2__1__2__t_val & (unsigned int)0x000000ff)]);
                    ublocks[(signed long int)((rmdGetFrame__1__4__5__4__2__1__2__k / 0x0010) * ((signed int)temp_brwin.rrect.width / 0x0010) + rmdGetFrame__1__4__5__4__2__1__2__i / 0x0010)] = (unsigned int)1;
                    vblocks[(signed long int)((rmdGetFrame__1__4__5__4__2__1__2__k / 0x0010) * ((signed int)temp_brwin.rrect.width / 0x0010) + rmdGetFrame__1__4__5__4__2__1__2__i / 0x0010)] = (unsigned int)1;
                  }

                  rmdGetFrame__1__4__5__4__2__1__2__datapi = rmdGetFrame__1__4__5__4__2__1__2__datapi + (signed long int)2;
                  rmdGetFrame__1__4__5__4__2__1__2__datapi_back = rmdGetFrame__1__4__5__4__2__1__2__datapi_back + (signed long int)2;
                  if(pdata->args.no_quick_subsample == 1)
                  {
                    rmdGetFrame__1__4__5__4__2__1__2__datapi_next = rmdGetFrame__1__4__5__4__2__1__2__datapi_next + (signed long int)2;
                    rmdGetFrame__1__4__5__4__2__1__2__datapi_back_next = rmdGetFrame__1__4__5__4__2__1__2__datapi_back_next + (signed long int)2;
                  }

                  rmdGetFrame__1__4__5__4__2__1__2__yuv_u = rmdGetFrame__1__4__5__4__2__1__2__yuv_u + 1l;
                  rmdGetFrame__1__4__5__4__2__1__2__yuv_v = rmdGetFrame__1__4__5__4__2__1__2__yuv_v + 1l;
                }
                rmdGetFrame__1__4__5__4__2__1__2__yuv_u = rmdGetFrame__1__4__5__4__2__1__2__yuv_u + (signed long int)(((&pdata->enc_data->yuv)->y_width - (signed int)temp_brwin.rrect.width) / 2);
                rmdGetFrame__1__4__5__4__2__1__2__yuv_v = rmdGetFrame__1__4__5__4__2__1__2__yuv_v + (signed long int)(((&pdata->enc_data->yuv)->y_width - (signed int)temp_brwin.rrect.width) / 2);
                rmdGetFrame__1__4__5__4__2__1__2__datapi = rmdGetFrame__1__4__5__4__2__1__2__datapi + (signed long int)temp_brwin.rrect.width;
                rmdGetFrame__1__4__5__4__2__1__2__datapi_back = rmdGetFrame__1__4__5__4__2__1__2__datapi_back + (signed long int)temp_brwin.rrect.width;
                if(pdata->args.no_quick_subsample == 1)
                {
                  rmdGetFrame__1__4__5__4__2__1__2__datapi_next = rmdGetFrame__1__4__5__4__2__1__2__datapi_next + (signed long int)temp_brwin.rrect.width;
                  rmdGetFrame__1__4__5__4__2__1__2__datapi_back_next = rmdGetFrame__1__4__5__4__2__1__2__datapi_back_next + (signed long int)temp_brwin.rrect.width;
                }

              }
            }

            else
            {
              rmdGetFrame__1__4__5__4__2__1__2__k = 0;
              for( ; !(rmdGetFrame__1__4__5__4__2__1__2__k >= (signed int)temp_brwin.rrect.height); rmdGetFrame__1__4__5__4__2__1__2__k = rmdGetFrame__1__4__5__4__2__1__2__k + 2)
              {
                rmdGetFrame__1__4__5__4__2__1__2__i = 0;
                for( ; !(rmdGetFrame__1__4__5__4__2__1__2__i >= (signed int)temp_brwin.rrect.width); rmdGetFrame__1__4__5__4__2__1__2__i = rmdGetFrame__1__4__5__4__2__1__2__i + 2)
                {
                  if(!(*rmdGetFrame__1__4__5__4__2__1__2__datapi == *rmdGetFrame__1__4__5__4__2__1__2__datapi_back))
                  {
                    if(pdata->args.no_quick_subsample == 1)
                    {
                      unsigned int rmdGetFrame__1__4__5__4__2__1__2__2__1__1__1__1__1__1__1__t1;
                      unsigned int rmdGetFrame__1__4__5__4__2__1__2__2__1__1__1__1__1__1__1__t2;
                      unsigned int rmdGetFrame__1__4__5__4__2__1__2__2__1__1__1__1__1__1__1__t3;
                      unsigned int rmdGetFrame__1__4__5__4__2__1__2__2__1__1__1__1__1__1__1__t4;
                      rmdGetFrame__1__4__5__4__2__1__2__2__1__1__1__1__1__1__1__t1 = *rmdGetFrame__1__4__5__4__2__1__2__datapi;
                      rmdGetFrame__1__4__5__4__2__1__2__2__1__1__1__1__1__1__1__t2 = rmdGetFrame__1__4__5__4__2__1__2__datapi[(signed long int)1];
                      rmdGetFrame__1__4__5__4__2__1__2__2__1__1__1__1__1__1__1__t3 = *rmdGetFrame__1__4__5__4__2__1__2__datapi_next;
                      rmdGetFrame__1__4__5__4__2__1__2__2__1__1__1__1__1__1__1__t4 = rmdGetFrame__1__4__5__4__2__1__2__datapi_next[(signed long int)1];
                      rmdGetFrame__1__4__5__4__2__1__2__t_val = (((rmdGetFrame__1__4__5__4__2__1__2__2__1__1__1__1__1__1__1__t1 & (unsigned int)0x00ff0000) + (rmdGetFrame__1__4__5__4__2__1__2__2__1__1__1__1__1__1__1__t2 & (unsigned int)0x00ff0000) + (rmdGetFrame__1__4__5__4__2__1__2__2__1__1__1__1__1__1__1__t3 & (unsigned int)0x00ff0000) + (rmdGetFrame__1__4__5__4__2__1__2__2__1__1__1__1__1__1__1__t4 & (unsigned int)0x00ff0000)) / (unsigned int)4 & (unsigned int)0x00ff0000) + (((rmdGetFrame__1__4__5__4__2__1__2__2__1__1__1__1__1__1__1__t1 & (unsigned int)0x0000ff00) + (rmdGetFrame__1__4__5__4__2__1__2__2__1__1__1__1__1__1__1__t2 & (unsigned int)0x0000ff00) + (rmdGetFrame__1__4__5__4__2__1__2__2__1__1__1__1__1__1__1__t3 & (unsigned int)0x0000ff00) + (rmdGetFrame__1__4__5__4__2__1__2__2__1__1__1__1__1__1__1__t4 & (unsigned int)0x0000ff00)) / (unsigned int)4 & (unsigned int)0x0000ff00) + (((rmdGetFrame__1__4__5__4__2__1__2__2__1__1__1__1__1__1__1__t1 & (unsigned int)0x000000ff) + (rmdGetFrame__1__4__5__4__2__1__2__2__1__1__1__1__1__1__1__t2 & (unsigned int)0x000000ff) + (rmdGetFrame__1__4__5__4__2__1__2__2__1__1__1__1__1__1__1__t3 & (unsigned int)0x000000ff) + (rmdGetFrame__1__4__5__4__2__1__2__2__1__1__1__1__1__1__1__t4 & (unsigned int)0x000000ff)) / (unsigned int)4 & (unsigned int)0x000000ff);
                    }

                    else
                      rmdGetFrame__1__4__5__4__2__1__2__t_val = *rmdGetFrame__1__4__5__4__2__1__2__datapi;
                    *rmdGetFrame__1__4__5__4__2__1__2__yuv_u = (unsigned char)((signed int)rmdGetFrame__1__4__5__4__2__1__2___ur[(signed long int)((rmdGetFrame__1__4__5__4__2__1__2__t_val & (unsigned int)0x00ff0000) >> 16)] + (signed int)rmdGetFrame__1__4__5__4__2__1__2___ug[(signed long int)((rmdGetFrame__1__4__5__4__2__1__2__t_val & (unsigned int)0x0000ff00) >> 8)] + (signed int)rmdGetFrame__1__4__5__4__2__1__2___ubvr[(signed long int)(rmdGetFrame__1__4__5__4__2__1__2__t_val & (unsigned int)0x000000ff)]);
                    *rmdGetFrame__1__4__5__4__2__1__2__yuv_v = (unsigned char)((signed int)rmdGetFrame__1__4__5__4__2__1__2___ubvr[(signed long int)((rmdGetFrame__1__4__5__4__2__1__2__t_val & (unsigned int)0x00ff0000) >> 16)] + (signed int)rmdGetFrame__1__4__5__4__2__1__2___vg[(signed long int)((rmdGetFrame__1__4__5__4__2__1__2__t_val & (unsigned int)0x0000ff00) >> 8)] + (signed int)rmdGetFrame__1__4__5__4__2__1__2___vb[(signed long int)(rmdGetFrame__1__4__5__4__2__1__2__t_val & (unsigned int)0x000000ff)]);
                    ublocks[(signed long int)((rmdGetFrame__1__4__5__4__2__1__2__k / 0x0010) * ((signed int)temp_brwin.rrect.width / 0x0010) + rmdGetFrame__1__4__5__4__2__1__2__i / 0x0010)] = (unsigned int)1;
                    vblocks[(signed long int)((rmdGetFrame__1__4__5__4__2__1__2__k / 0x0010) * ((signed int)temp_brwin.rrect.width / 0x0010) + rmdGetFrame__1__4__5__4__2__1__2__i / 0x0010)] = (unsigned int)1;
                  }

                  rmdGetFrame__1__4__5__4__2__1__2__datapi = rmdGetFrame__1__4__5__4__2__1__2__datapi + (signed long int)2;
                  rmdGetFrame__1__4__5__4__2__1__2__datapi_back = rmdGetFrame__1__4__5__4__2__1__2__datapi_back + (signed long int)2;
                  if(pdata->args.no_quick_subsample == 1)
                  {
                    rmdGetFrame__1__4__5__4__2__1__2__datapi_next = rmdGetFrame__1__4__5__4__2__1__2__datapi_next + (signed long int)2;
                    rmdGetFrame__1__4__5__4__2__1__2__datapi_back_next = rmdGetFrame__1__4__5__4__2__1__2__datapi_back_next + (signed long int)2;
                  }

                  rmdGetFrame__1__4__5__4__2__1__2__yuv_u = rmdGetFrame__1__4__5__4__2__1__2__yuv_u + 1l;
                  rmdGetFrame__1__4__5__4__2__1__2__yuv_v = rmdGetFrame__1__4__5__4__2__1__2__yuv_v + 1l;
                }
                rmdGetFrame__1__4__5__4__2__1__2__yuv_u = rmdGetFrame__1__4__5__4__2__1__2__yuv_u + (signed long int)(((&pdata->enc_data->yuv)->y_width - (signed int)temp_brwin.rrect.width) / 2);
                rmdGetFrame__1__4__5__4__2__1__2__yuv_v = rmdGetFrame__1__4__5__4__2__1__2__yuv_v + (signed long int)(((&pdata->enc_data->yuv)->y_width - (signed int)temp_brwin.rrect.width) / 2);
                rmdGetFrame__1__4__5__4__2__1__2__datapi = rmdGetFrame__1__4__5__4__2__1__2__datapi + (signed long int)temp_brwin.rrect.width;
                rmdGetFrame__1__4__5__4__2__1__2__datapi_back = rmdGetFrame__1__4__5__4__2__1__2__datapi_back + (signed long int)temp_brwin.rrect.width;
                if(pdata->args.no_quick_subsample == 1)
                {
                  rmdGetFrame__1__4__5__4__2__1__2__datapi_next = rmdGetFrame__1__4__5__4__2__1__2__datapi_next + (signed long int)temp_brwin.rrect.width;
                  rmdGetFrame__1__4__5__4__2__1__2__datapi_back_next = rmdGetFrame__1__4__5__4__2__1__2__datapi_back_next + (signed long int)temp_brwin.rrect.width;
                }

              }
            }
          }

          else
            if(pdata->specs.depth == 16)
            {
              signed int rmdGetFrame__1__4__5__4__2__2__1__k;
              signed int rmdGetFrame__1__4__5__4__2__2__1__i;
              unsigned short int rmdGetFrame__1__4__5__4__2__2__1__t_val;
              unsigned char *rmdGetFrame__1__4__5__4__2__2__1__yuv_y = (&pdata->enc_data->yuv)->y + (signed long int)pdata->enc_data->x_offset + (signed long int)(pdata->enc_data->y_offset * (&pdata->enc_data->yuv)->y_width);
              unsigned char *rmdGetFrame__1__4__5__4__2__2__1___yr = Yr;
              unsigned char *rmdGetFrame__1__4__5__4__2__2__1___yg = Yg;
              unsigned char *rmdGetFrame__1__4__5__4__2__2__1___yb = Yb;
              unsigned short int *rmdGetFrame__1__4__5__4__2__2__1__datapi = (unsigned short int *)rmdGetFrame__1__4__5__front_buff;
              unsigned short int *rmdGetFrame__1__4__5__4__2__2__1__datapi_back = (unsigned short int *)rmdGetFrame__1__4__5__back_buff;
              rmdGetFrame__1__4__5__4__2__2__1__k = 0;
              for( ; !(rmdGetFrame__1__4__5__4__2__2__1__k >= (signed int)temp_brwin.rrect.height); rmdGetFrame__1__4__5__4__2__2__1__k = rmdGetFrame__1__4__5__4__2__2__1__k + 1)
              {
                rmdGetFrame__1__4__5__4__2__2__1__i = 0;
                for( ; !(rmdGetFrame__1__4__5__4__2__2__1__i >= (signed int)temp_brwin.rrect.width); rmdGetFrame__1__4__5__4__2__2__1__i = rmdGetFrame__1__4__5__4__2__2__1__i + 1)
                {
                  if(!(*rmdGetFrame__1__4__5__4__2__2__1__datapi == *rmdGetFrame__1__4__5__4__2__2__1__datapi_back))
                  {
                    rmdGetFrame__1__4__5__4__2__2__1__t_val = *rmdGetFrame__1__4__5__4__2__2__1__datapi;
                    *rmdGetFrame__1__4__5__4__2__2__1__yuv_y = (unsigned char)((signed int)rmdGetFrame__1__4__5__4__2__2__1___yr[(signed long int)((((signed int)rmdGetFrame__1__4__5__4__2__2__1__t_val & 0xf800) >> 11) * 8)] + (signed int)rmdGetFrame__1__4__5__4__2__2__1___yg[(signed long int)((((signed int)rmdGetFrame__1__4__5__4__2__2__1__t_val & 0x7e0) >> 5) * 4)] + (signed int)rmdGetFrame__1__4__5__4__2__2__1___yb[(signed long int)(((signed int)rmdGetFrame__1__4__5__4__2__2__1__t_val & 0x1f) * 8)]);
                    yblocks[(signed long int)((rmdGetFrame__1__4__5__4__2__2__1__k / 0x0010) * ((signed int)temp_brwin.rrect.width / 0x0010) + rmdGetFrame__1__4__5__4__2__2__1__i / 0x0010)] = (unsigned int)1;
                  }

                  rmdGetFrame__1__4__5__4__2__2__1__datapi = rmdGetFrame__1__4__5__4__2__2__1__datapi + 1l;
                  rmdGetFrame__1__4__5__4__2__2__1__datapi_back = rmdGetFrame__1__4__5__4__2__2__1__datapi_back + 1l;
                  rmdGetFrame__1__4__5__4__2__2__1__yuv_y = rmdGetFrame__1__4__5__4__2__2__1__yuv_y + 1l;
                }
                rmdGetFrame__1__4__5__4__2__2__1__yuv_y = rmdGetFrame__1__4__5__4__2__2__1__yuv_y + (signed long int)((&pdata->enc_data->yuv)->y_width - (signed int)temp_brwin.rrect.width);
              }
              signed int rmdGetFrame__1__4__5__4__2__2__2__k;
              signed int rmdGetFrame__1__4__5__4__2__2__2__i;
              unsigned short int rmdGetFrame__1__4__5__4__2__2__2__t_val;
              unsigned char *rmdGetFrame__1__4__5__4__2__2__2__yuv_u = (&pdata->enc_data->yuv)->u + (signed long int)(pdata->enc_data->x_offset / 2) + (signed long int)((pdata->enc_data->y_offset * (&pdata->enc_data->yuv)->uv_width) / 2);
              unsigned char *rmdGetFrame__1__4__5__4__2__2__2__yuv_v = (&pdata->enc_data->yuv)->v + (signed long int)(pdata->enc_data->x_offset / 2) + (signed long int)((pdata->enc_data->y_offset * (&pdata->enc_data->yuv)->uv_width) / 2);
              unsigned char *_ur = Ur;
              unsigned char *_ug = Ug;
              unsigned char *_ubvr = UbVr;
              unsigned char *_vg = Vg;
              unsigned char *_vb = Vb;
              unsigned short int *datapi = (unsigned short int *)rmdGetFrame__1__4__5__front_buff;
              unsigned short int *datapi_next = (unsigned short int *)(void *)0;
              unsigned short int *datapi_back = (unsigned short int *)rmdGetFrame__1__4__5__back_buff;
              unsigned short int *datapi_back_next = (unsigned short int *)(void *)0;
              if(pdata->args.no_quick_subsample == 1)
              {
                datapi_next = datapi + (signed long int)temp_brwin.rrect.width;
                datapi_back_next = datapi_back + (signed long int)temp_brwin.rrect.width;
                rmdGetFrame__1__4__5__4__2__2__2__k = 0;
                for( ; !(rmdGetFrame__1__4__5__4__2__2__2__k >= (signed int)temp_brwin.rrect.height); rmdGetFrame__1__4__5__4__2__2__2__k = rmdGetFrame__1__4__5__4__2__2__2__k + 2)
                {
                  rmdGetFrame__1__4__5__4__2__2__2__i = 0;
                  for( ; !(rmdGetFrame__1__4__5__4__2__2__2__i >= (signed int)temp_brwin.rrect.width); rmdGetFrame__1__4__5__4__2__2__2__i = rmdGetFrame__1__4__5__4__2__2__2__i + 2)
                  {
                    if(!(*datapi == *datapi_back))
                      tmp_if_expr_31 = (_Bool)1;

                    else
                      tmp_if_expr_31 = datapi[(signed long int)1] != datapi_back[(signed long int)1] ? (_Bool)1 : (_Bool)0;
                    if(tmp_if_expr_31)
                      tmp_if_expr_32 = (_Bool)1;

                    else
                      tmp_if_expr_32 = *datapi_next != *datapi_back_next ? (_Bool)1 : (_Bool)0;
                    if(tmp_if_expr_32)
                      tmp_if_expr_33 = (_Bool)1;

                    else
                      tmp_if_expr_33 = datapi_next[(signed long int)1] != datapi_back_next[(signed long int)1] ? (_Bool)1 : (_Bool)0;
                    if(tmp_if_expr_33)
                    {
                      if(pdata->args.no_quick_subsample == 1)
                      {
                        unsigned short int t1;
                        unsigned short int t2;
                        unsigned short int t3;
                        unsigned short int t4;
                        t1 = *datapi;
                        t2 = datapi[(signed long int)1];
                        t3 = *datapi_next;
                        t4 = datapi_next[(signed long int)1];
                        rmdGetFrame__1__4__5__4__2__2__2__t_val = (unsigned short int)(((((signed int)t1 & 0xf800) + ((signed int)t2 & 0xf800) + ((signed int)t3 & 0xf800) + ((signed int)t4 & 0xf800)) / 4 & 0xf800) + ((((signed int)t1 & 0x7e0) + ((signed int)t2 & 0x7e0) + ((signed int)t3 & 0x7e0) + ((signed int)t4 & 0x7e0)) / 4 & 0x7e0) + ((((signed int)t1 & 0x1f) + ((signed int)t2 & 0x1f) + ((signed int)t3 & 0x1f) + ((signed int)t4 & 0x1f)) / 4 & 0x1f));
                      }

                      else
                        rmdGetFrame__1__4__5__4__2__2__2__t_val = *datapi;
                      *rmdGetFrame__1__4__5__4__2__2__2__yuv_u = (unsigned char)((signed int)_ur[(signed long int)((((signed int)rmdGetFrame__1__4__5__4__2__2__2__t_val & 0xf800) >> 11) * 8)] + (signed int)_ug[(signed long int)((((signed int)rmdGetFrame__1__4__5__4__2__2__2__t_val & 0x7e0) >> 5) * 4)] + (signed int)_ubvr[(signed long int)(((signed int)rmdGetFrame__1__4__5__4__2__2__2__t_val & 0x1f) * 8)]);
                      *rmdGetFrame__1__4__5__4__2__2__2__yuv_v = (unsigned char)((signed int)_ubvr[(signed long int)((((signed int)rmdGetFrame__1__4__5__4__2__2__2__t_val & 0xf800) >> 11) * 8)] + (signed int)_vg[(signed long int)((((signed int)rmdGetFrame__1__4__5__4__2__2__2__t_val & 0x7e0) >> 5) * 4)] + (signed int)_vb[(signed long int)(((signed int)rmdGetFrame__1__4__5__4__2__2__2__t_val & 0x1f) * 8)]);
                      ublocks[(signed long int)((rmdGetFrame__1__4__5__4__2__2__2__k / 0x0010) * ((signed int)temp_brwin.rrect.width / 0x0010) + rmdGetFrame__1__4__5__4__2__2__2__i / 0x0010)] = (unsigned int)1;
                      vblocks[(signed long int)((rmdGetFrame__1__4__5__4__2__2__2__k / 0x0010) * ((signed int)temp_brwin.rrect.width / 0x0010) + rmdGetFrame__1__4__5__4__2__2__2__i / 0x0010)] = (unsigned int)1;
                    }

                    datapi = datapi + (signed long int)2;
                    datapi_back = datapi_back + (signed long int)2;
                    if(pdata->args.no_quick_subsample == 1)
                    {
                      datapi_next = datapi_next + (signed long int)2;
                      datapi_back_next = datapi_back_next + (signed long int)2;
                    }

                    rmdGetFrame__1__4__5__4__2__2__2__yuv_u = rmdGetFrame__1__4__5__4__2__2__2__yuv_u + 1l;
                    rmdGetFrame__1__4__5__4__2__2__2__yuv_v = rmdGetFrame__1__4__5__4__2__2__2__yuv_v + 1l;
                  }
                  rmdGetFrame__1__4__5__4__2__2__2__yuv_u = rmdGetFrame__1__4__5__4__2__2__2__yuv_u + (signed long int)(((&pdata->enc_data->yuv)->y_width - (signed int)temp_brwin.rrect.width) / 2);
                  rmdGetFrame__1__4__5__4__2__2__2__yuv_v = rmdGetFrame__1__4__5__4__2__2__2__yuv_v + (signed long int)(((&pdata->enc_data->yuv)->y_width - (signed int)temp_brwin.rrect.width) / 2);
                  datapi = datapi + (signed long int)temp_brwin.rrect.width;
                  datapi_back = datapi_back + (signed long int)temp_brwin.rrect.width;
                  if(pdata->args.no_quick_subsample == 1)
                  {
                    datapi_next = datapi_next + (signed long int)temp_brwin.rrect.width;
                    datapi_back_next = datapi_back_next + (signed long int)temp_brwin.rrect.width;
                  }

                }
              }

              else
              {
                rmdGetFrame__1__4__5__4__2__2__2__k = 0;
                for( ; !(rmdGetFrame__1__4__5__4__2__2__2__k >= (signed int)temp_brwin.rrect.height); rmdGetFrame__1__4__5__4__2__2__2__k = rmdGetFrame__1__4__5__4__2__2__2__k + 2)
                {
                  rmdGetFrame__1__4__5__4__2__2__2__i = 0;
                  for( ; !(rmdGetFrame__1__4__5__4__2__2__2__i >= (signed int)temp_brwin.rrect.width); rmdGetFrame__1__4__5__4__2__2__2__i = rmdGetFrame__1__4__5__4__2__2__2__i + 2)
                  {
                    if(!(*datapi == *datapi_back))
                    {
                      if(pdata->args.no_quick_subsample == 1)
                      {
                        unsigned short int rmdGetFrame__1__4__5__4__2__2__2__2__1__1__1__1__1__1__1__t1;
                        unsigned short int rmdGetFrame__1__4__5__4__2__2__2__2__1__1__1__1__1__1__1__t2;
                        unsigned short int rmdGetFrame__1__4__5__4__2__2__2__2__1__1__1__1__1__1__1__t3;
                        unsigned short int rmdGetFrame__1__4__5__4__2__2__2__2__1__1__1__1__1__1__1__t4;
                        rmdGetFrame__1__4__5__4__2__2__2__2__1__1__1__1__1__1__1__t1 = *datapi;
                        rmdGetFrame__1__4__5__4__2__2__2__2__1__1__1__1__1__1__1__t2 = datapi[(signed long int)1];
                        rmdGetFrame__1__4__5__4__2__2__2__2__1__1__1__1__1__1__1__t3 = *datapi_next;
                        rmdGetFrame__1__4__5__4__2__2__2__2__1__1__1__1__1__1__1__t4 = datapi_next[(signed long int)1];
                        rmdGetFrame__1__4__5__4__2__2__2__t_val = (unsigned short int)(((((signed int)rmdGetFrame__1__4__5__4__2__2__2__2__1__1__1__1__1__1__1__t1 & 0xf800) + ((signed int)rmdGetFrame__1__4__5__4__2__2__2__2__1__1__1__1__1__1__1__t2 & 0xf800) + ((signed int)rmdGetFrame__1__4__5__4__2__2__2__2__1__1__1__1__1__1__1__t3 & 0xf800) + ((signed int)rmdGetFrame__1__4__5__4__2__2__2__2__1__1__1__1__1__1__1__t4 & 0xf800)) / 4 & 0xf800) + ((((signed int)rmdGetFrame__1__4__5__4__2__2__2__2__1__1__1__1__1__1__1__t1 & 0x7e0) + ((signed int)rmdGetFrame__1__4__5__4__2__2__2__2__1__1__1__1__1__1__1__t2 & 0x7e0) + ((signed int)rmdGetFrame__1__4__5__4__2__2__2__2__1__1__1__1__1__1__1__t3 & 0x7e0) + ((signed int)rmdGetFrame__1__4__5__4__2__2__2__2__1__1__1__1__1__1__1__t4 & 0x7e0)) / 4 & 0x7e0) + ((((signed int)rmdGetFrame__1__4__5__4__2__2__2__2__1__1__1__1__1__1__1__t1 & 0x1f) + ((signed int)rmdGetFrame__1__4__5__4__2__2__2__2__1__1__1__1__1__1__1__t2 & 0x1f) + ((signed int)rmdGetFrame__1__4__5__4__2__2__2__2__1__1__1__1__1__1__1__t3 & 0x1f) + ((signed int)rmdGetFrame__1__4__5__4__2__2__2__2__1__1__1__1__1__1__1__t4 & 0x1f)) / 4 & 0x1f));
                      }

                      else
                        rmdGetFrame__1__4__5__4__2__2__2__t_val = *datapi;
                      *rmdGetFrame__1__4__5__4__2__2__2__yuv_u = (unsigned char)((signed int)_ur[(signed long int)((((signed int)rmdGetFrame__1__4__5__4__2__2__2__t_val & 0xf800) >> 11) * 8)] + (signed int)_ug[(signed long int)((((signed int)rmdGetFrame__1__4__5__4__2__2__2__t_val & 0x7e0) >> 5) * 4)] + (signed int)_ubvr[(signed long int)(((signed int)rmdGetFrame__1__4__5__4__2__2__2__t_val & 0x1f) * 8)]);
                      *rmdGetFrame__1__4__5__4__2__2__2__yuv_v = (unsigned char)((signed int)_ubvr[(signed long int)((((signed int)rmdGetFrame__1__4__5__4__2__2__2__t_val & 0xf800) >> 11) * 8)] + (signed int)_vg[(signed long int)((((signed int)rmdGetFrame__1__4__5__4__2__2__2__t_val & 0x7e0) >> 5) * 4)] + (signed int)_vb[(signed long int)(((signed int)rmdGetFrame__1__4__5__4__2__2__2__t_val & 0x1f) * 8)]);
                      ublocks[(signed long int)((rmdGetFrame__1__4__5__4__2__2__2__k / 0x0010) * ((signed int)temp_brwin.rrect.width / 0x0010) + rmdGetFrame__1__4__5__4__2__2__2__i / 0x0010)] = (unsigned int)1;
                      vblocks[(signed long int)((rmdGetFrame__1__4__5__4__2__2__2__k / 0x0010) * ((signed int)temp_brwin.rrect.width / 0x0010) + rmdGetFrame__1__4__5__4__2__2__2__i / 0x0010)] = (unsigned int)1;
                    }

                    datapi = datapi + (signed long int)2;
                    datapi_back = datapi_back + (signed long int)2;
                    if(pdata->args.no_quick_subsample == 1)
                    {
                      datapi_next = datapi_next + (signed long int)2;
                      datapi_back_next = datapi_back_next + (signed long int)2;
                    }

                    rmdGetFrame__1__4__5__4__2__2__2__yuv_u = rmdGetFrame__1__4__5__4__2__2__2__yuv_u + 1l;
                    rmdGetFrame__1__4__5__4__2__2__2__yuv_v = rmdGetFrame__1__4__5__4__2__2__2__yuv_v + 1l;
                  }
                  rmdGetFrame__1__4__5__4__2__2__2__yuv_u = rmdGetFrame__1__4__5__4__2__2__2__yuv_u + (signed long int)(((&pdata->enc_data->yuv)->y_width - (signed int)temp_brwin.rrect.width) / 2);
                  rmdGetFrame__1__4__5__4__2__2__2__yuv_v = rmdGetFrame__1__4__5__4__2__2__2__yuv_v + (signed long int)(((&pdata->enc_data->yuv)->y_width - (signed int)temp_brwin.rrect.width) / 2);
                  datapi = datapi + (signed long int)temp_brwin.rrect.width;
                  datapi_back = datapi_back + (signed long int)temp_brwin.rrect.width;
                  if(pdata->args.no_quick_subsample == 1)
                  {
                    datapi_next = datapi_next + (signed long int)temp_brwin.rrect.width;
                    datapi_back_next = datapi_back_next + (signed long int)temp_brwin.rrect.width;
                  }

                }
              }
            }

        }
        pthread_mutex_unlock(&pdata->yuv_mutex);
      }
      if(!(pdata->args.xfixes_cursor == 0))
        tmp_if_expr_49 = (_Bool)1;

      else
        tmp_if_expr_49 = pdata->args.have_dummy_cursor != 0 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_49)
      {
        signed int mouse_xoffset;
        signed int mouse_yoffset;
        if((signed int)mouse_pos_abs.x + (signed int)mouse_pos_abs.width >= (signed int)temp_brwin.rrect.x)
          tmp_if_expr_35 = (signed int)mouse_pos_abs.x <= (signed int)(&temp_brwin)->rrect.x + (signed int)(&temp_brwin)->rrect.width ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_35 = (_Bool)0;
        if(tmp_if_expr_35)
        {
          if((signed int)temp_brwin.rrect.x >= (signed int)mouse_pos_abs.x)
            tmp_if_expr_36 = (signed int)(&temp_brwin)->rrect.x;

          else
            tmp_if_expr_36 = (signed int)mouse_pos_abs.x;
          tmp_if_expr_37 = tmp_if_expr_36;
        }

        else
          tmp_if_expr_37 = -1;
        (&mouse_pos_temp)->x = (signed short int)tmp_if_expr_37;
        if((signed int)mouse_pos_abs.y + (signed int)mouse_pos_abs.height >= (signed int)temp_brwin.rrect.y)
          tmp_if_expr_38 = (signed int)mouse_pos_abs.y <= (signed int)(&temp_brwin)->rrect.y + (signed int)(&temp_brwin)->rrect.height ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_38 = (_Bool)0;
        if(tmp_if_expr_38)
        {
          if((signed int)temp_brwin.rrect.y >= (signed int)mouse_pos_abs.y)
            tmp_if_expr_39 = (signed int)(&temp_brwin)->rrect.y;

          else
            tmp_if_expr_39 = (signed int)mouse_pos_abs.y;
          tmp_if_expr_40 = tmp_if_expr_39;
        }

        else
          tmp_if_expr_40 = -1;
        (&mouse_pos_temp)->y = (signed short int)tmp_if_expr_40;
        if((signed int)temp_brwin.rrect.x >= (signed int)mouse_pos_abs.x)
          tmp_if_expr_43 = (signed int)mouse_pos_abs.width - ((signed int)(&temp_brwin)->rrect.x - (signed int)mouse_pos_abs.x);

        else
        {
          if((signed int)temp_brwin.rrect.x + (signed int)temp_brwin.rrect.width >= (signed int)mouse_pos_abs.x)
          {
            if(!((signed int)temp_brwin.rrect.x + (signed int)temp_brwin.rrect.width + -((signed int)mouse_pos_abs.x) >= (signed int)mouse_pos_abs.width))
              tmp_if_expr_41 = ((signed int)(&temp_brwin)->rrect.width - (signed int)mouse_pos_abs.x) + (signed int)(&temp_brwin)->rrect.x;

            else
              tmp_if_expr_41 = (signed int)mouse_pos_abs.width;
            tmp_if_expr_42 = tmp_if_expr_41;
          }

          else
            tmp_if_expr_42 = 0;
          tmp_if_expr_43 = tmp_if_expr_42;
        }
        (&mouse_pos_temp)->width = (unsigned short int)tmp_if_expr_43;
        if((signed int)temp_brwin.rrect.y >= (signed int)mouse_pos_abs.y)
          tmp_if_expr_46 = (signed int)mouse_pos_abs.height - ((signed int)(&temp_brwin)->rrect.y - (signed int)mouse_pos_abs.y);

        else
        {
          if((signed int)temp_brwin.rrect.y + (signed int)temp_brwin.rrect.height >= (signed int)mouse_pos_abs.y)
          {
            if(!((signed int)temp_brwin.rrect.y + (signed int)temp_brwin.rrect.height + -((signed int)mouse_pos_abs.y) >= (signed int)mouse_pos_abs.height))
              tmp_if_expr_44 = ((signed int)(&temp_brwin)->rrect.height - (signed int)mouse_pos_abs.y) + (signed int)(&temp_brwin)->rrect.y;

            else
              tmp_if_expr_44 = (signed int)mouse_pos_abs.height;
            tmp_if_expr_45 = tmp_if_expr_44;
          }

          else
            tmp_if_expr_45 = 0;
          tmp_if_expr_46 = tmp_if_expr_45;
        }
        (&mouse_pos_temp)->height = (unsigned short int)tmp_if_expr_46;
        if(!((signed int)temp_brwin.rrect.width >= (signed int)mouse_pos_temp.width))
          (&mouse_pos_temp)->width = (&temp_brwin)->rrect.width;

        if(!((signed int)temp_brwin.rrect.height >= (signed int)mouse_pos_temp.height))
          (&mouse_pos_temp)->height = (&temp_brwin)->rrect.height;

        mouse_xoffset = (signed int)mouse_pos_temp.x - (signed int)mouse_pos_abs.x;
        mouse_yoffset = (signed int)mouse_pos_temp.y - (signed int)mouse_pos_abs.y;
        if(!(mouse_xoffset >= 0) || !((signed int)mouse_pos_abs.width >= mouse_xoffset))
          mouse_xoffset = 0;

        if(!(mouse_yoffset >= 0) || !((signed int)mouse_pos_abs.height >= mouse_yoffset))
          mouse_yoffset = 0;

        if((signed int)mouse_pos_temp.x >= 0 && (signed int)mouse_pos_temp.y >= 0 && (signed int)mouse_pos_temp.height >= 1 && (signed int)mouse_pos_temp.width >= 1)
        {
          if(!(pdata->args.xfixes_cursor == 0))
          {
            signed int i;
            signed int k;
            signed int j = 0;
            unsigned char avg0;
            unsigned char avg1;
            unsigned char avg2;
            unsigned char avg3;
            signed int x_2 = (((signed int)mouse_pos_temp.x - (signed int)temp_brwin.rrect.x) + pdata->enc_data->x_offset) / 2;
            signed int y_2 = (((signed int)mouse_pos_temp.y - (signed int)temp_brwin.rrect.y) + pdata->enc_data->y_offset) / 2;
            k = mouse_yoffset;
            for( ; !(k >= mouse_yoffset + (signed int)mouse_pos_temp.height); k = k + 1)
            {
              i = mouse_xoffset;
              for( ; !(i >= mouse_xoffset + (signed int)mouse_pos_temp.width); i = i + 1)
              {
                j = k * ((signed int)mouse_pos_temp.width + ((signed int)xcim->width - (signed int)mouse_pos_temp.width)) + i;
                (&pdata->enc_data->yuv)->y[(signed long int)(((signed int)mouse_pos_temp.x - (signed int)temp_brwin.rrect.x) + pdata->enc_data->x_offset + (i - mouse_xoffset) + ((k + ((signed int)mouse_pos_temp.y - (signed int)temp_brwin.rrect.y) + pdata->enc_data->y_offset) - mouse_yoffset) * (&pdata->enc_data->yuv)->y_width)] = (unsigned char)(((signed int)(&pdata->enc_data->yuv)->y[(signed long int)(((signed int)mouse_pos_temp.x - (signed int)temp_brwin.rrect.x) + pdata->enc_data->x_offset + (i - mouse_xoffset) + ((k - mouse_yoffset) + ((signed int)mouse_pos_temp.y - (signed int)temp_brwin.rrect.y) + pdata->enc_data->y_offset) * (&pdata->enc_data->yuv)->y_width)] * ((0x7f * 2 + 1) - (signed int)((unsigned char *)xcim->pixels)[(signed long int)((unsigned long int)j * sizeof(unsigned long int) /*8ul*/  + (unsigned long int)3)]) + (((signed int)Yr[(signed long int)((unsigned char *)xcim->pixels)[(signed long int)((unsigned long int)j * sizeof(unsigned long int) /*8ul*/  + (unsigned long int)2)]] + (signed int)Yg[(signed long int)((unsigned char *)xcim->pixels)[(signed long int)((unsigned long int)j * sizeof(unsigned long int) /*8ul*/  + (unsigned long int)1)]] + (signed int)Yb[(signed long int)((unsigned char *)xcim->pixels)[(signed long int)((unsigned long int)j * sizeof(unsigned long int) /*8ul*/  + (unsigned long int)0)]]) % (0x7f * 2 + 1 + 1)) * (signed int)((unsigned char *)xcim->pixels)[(signed long int)((unsigned long int)j * sizeof(unsigned long int) /*8ul*/  + (unsigned long int)3)]) / (0x7f * 2 + 1));
                if(!(i % 2 == 0) && !(k % 2 == 0))
                {
                  avg3 = (unsigned char)(((signed int)((unsigned char *)xcim->pixels)[(signed long int)((unsigned long int)(k * ((signed int)mouse_pos_temp.width + ((signed int)xcim->width - (signed int)mouse_pos_temp.width)) + i) * sizeof(unsigned long int) /*8ul*/  + (unsigned long int)3)] + (signed int)((unsigned char *)xcim->pixels)[(signed long int)((unsigned long int)((k - 1) * ((signed int)mouse_pos_temp.width + ((signed int)xcim->width - (signed int)mouse_pos_temp.width)) + i) * sizeof(unsigned long int) /*8ul*/  + (unsigned long int)3)] + (signed int)((unsigned char *)xcim->pixels)[(signed long int)((unsigned long int)((k * ((signed int)mouse_pos_temp.width + ((signed int)xcim->width - (signed int)mouse_pos_temp.width)) + i) - 1) * sizeof(unsigned long int) /*8ul*/  + (unsigned long int)3)] + (signed int)((unsigned char *)xcim->pixels)[(signed long int)((unsigned long int)(((k - 1) * ((signed int)mouse_pos_temp.width + ((signed int)xcim->width - (signed int)mouse_pos_temp.width)) + i) - 1) * sizeof(unsigned long int) /*8ul*/  + (unsigned long int)3)]) / 4);
                  avg2 = (unsigned char)(((signed int)((unsigned char *)xcim->pixels)[(signed long int)((unsigned long int)(k * ((signed int)mouse_pos_temp.width + ((signed int)xcim->width - (signed int)mouse_pos_temp.width)) + i) * sizeof(unsigned long int) /*8ul*/  + (unsigned long int)2)] + (signed int)((unsigned char *)xcim->pixels)[(signed long int)((unsigned long int)((k - 1) * ((signed int)mouse_pos_temp.width + ((signed int)xcim->width - (signed int)mouse_pos_temp.width)) + i) * sizeof(unsigned long int) /*8ul*/  + (unsigned long int)2)] + (signed int)((unsigned char *)xcim->pixels)[(signed long int)((unsigned long int)((k * ((signed int)mouse_pos_temp.width + ((signed int)xcim->width - (signed int)mouse_pos_temp.width)) + i) - 1) * sizeof(unsigned long int) /*8ul*/  + (unsigned long int)2)] + (signed int)((unsigned char *)xcim->pixels)[(signed long int)((unsigned long int)(((k - 1) * ((signed int)mouse_pos_temp.width + ((signed int)xcim->width - (signed int)mouse_pos_temp.width)) + i) - 1) * sizeof(unsigned long int) /*8ul*/  + (unsigned long int)2)]) / 4);
                  avg1 = (unsigned char)(((signed int)((unsigned char *)xcim->pixels)[(signed long int)((unsigned long int)(k * ((signed int)mouse_pos_temp.width + ((signed int)xcim->width - (signed int)mouse_pos_temp.width)) + i) * sizeof(unsigned long int) /*8ul*/  + (unsigned long int)1)] + (signed int)((unsigned char *)xcim->pixels)[(signed long int)((unsigned long int)((k - 1) * ((signed int)mouse_pos_temp.width + ((signed int)xcim->width - (signed int)mouse_pos_temp.width)) + i) * sizeof(unsigned long int) /*8ul*/  + (unsigned long int)1)] + (signed int)((unsigned char *)xcim->pixels)[(signed long int)((unsigned long int)((k * ((signed int)mouse_pos_temp.width + ((signed int)xcim->width - (signed int)mouse_pos_temp.width)) + i) - 1) * sizeof(unsigned long int) /*8ul*/  + (unsigned long int)1)] + (signed int)((unsigned char *)xcim->pixels)[(signed long int)((unsigned long int)(((k - 1) * ((signed int)mouse_pos_temp.width + ((signed int)xcim->width - (signed int)mouse_pos_temp.width)) + i) - 1) * sizeof(unsigned long int) /*8ul*/  + (unsigned long int)1)]) / 4);
                  avg0 = (unsigned char)(((signed int)((unsigned char *)xcim->pixels)[(signed long int)((unsigned long int)(k * ((signed int)mouse_pos_temp.width + ((signed int)xcim->width - (signed int)mouse_pos_temp.width)) + i) * sizeof(unsigned long int) /*8ul*/  + (unsigned long int)0)] + (signed int)((unsigned char *)xcim->pixels)[(signed long int)((unsigned long int)((k - 1) * ((signed int)mouse_pos_temp.width + ((signed int)xcim->width - (signed int)mouse_pos_temp.width)) + i) * sizeof(unsigned long int) /*8ul*/  + (unsigned long int)0)] + (signed int)((unsigned char *)xcim->pixels)[(signed long int)((unsigned long int)((k * ((signed int)mouse_pos_temp.width + ((signed int)xcim->width - (signed int)mouse_pos_temp.width)) + i) - 1) * sizeof(unsigned long int) /*8ul*/  + (unsigned long int)0)] + (signed int)((unsigned char *)xcim->pixels)[(signed long int)((unsigned long int)(((k - 1) * ((signed int)mouse_pos_temp.width + ((signed int)xcim->width - (signed int)mouse_pos_temp.width)) + i) - 1) * sizeof(unsigned long int) /*8ul*/  + (unsigned long int)0)]) / 4);
                  (&pdata->enc_data->yuv)->u[(signed long int)(x_2 + (i - mouse_xoffset) / 2 + ((k - mouse_yoffset) / 2 + y_2) * (&pdata->enc_data->yuv)->uv_width)] = (unsigned char)(((signed int)(&pdata->enc_data->yuv)->u[(signed long int)(x_2 + (i - mouse_xoffset) / 2 + ((k - mouse_yoffset) / 2 + y_2) * (&pdata->enc_data->yuv)->uv_width)] * ((0x7f * 2 + 1) - (signed int)avg3) + (((signed int)Ur[(signed long int)avg2] + (signed int)Ug[(signed long int)avg1] + (signed int)UbVr[(signed long int)avg0]) % (0x7f * 2 + 1 + 1)) * (signed int)avg3) / (0x7f * 2 + 1));
                  (&pdata->enc_data->yuv)->v[(signed long int)(x_2 + (i - mouse_xoffset) / 2 + ((k - mouse_yoffset) / 2 + y_2) * (&pdata->enc_data->yuv)->uv_width)] = (unsigned char)(((signed int)(&pdata->enc_data->yuv)->v[(signed long int)(x_2 + (i - mouse_xoffset) / 2 + ((k - mouse_yoffset) / 2 + y_2) * (&pdata->enc_data->yuv)->uv_width)] * ((0x7f * 2 + 1) - (signed int)avg3) + (((signed int)UbVr[(signed long int)avg2] + (signed int)Vg[(signed long int)avg1] + (signed int)Vb[(signed long int)avg0]) % (0x7f * 2 + 1 + 1)) * (signed int)avg3) / (0x7f * 2 + 1));
                }

              }
            }
          }

          else
          {
            signed int rmdGetFrame__1__4__6__2__2__1__i;
            signed int rmdGetFrame__1__4__6__2__2__1__k;
            signed int rmdGetFrame__1__4__6__2__2__1__j = 0;
            signed int rmdGetFrame__1__4__6__2__2__1__x_2 = (((signed int)mouse_pos_temp.x - (signed int)temp_brwin.rrect.x) + pdata->enc_data->x_offset) / 2;
            signed int rmdGetFrame__1__4__6__2__2__1__y_2 = (((signed int)mouse_pos_temp.y - (signed int)temp_brwin.rrect.y) + pdata->enc_data->y_offset) / 2;
            signed int y_width_2 = (&pdata->enc_data->yuv)->y_width / 2;
            rmdGetFrame__1__4__6__2__2__1__k = mouse_yoffset;
            for( ; !(rmdGetFrame__1__4__6__2__2__1__k >= mouse_yoffset + (signed int)mouse_pos_temp.height); rmdGetFrame__1__4__6__2__2__1__k = rmdGetFrame__1__4__6__2__2__1__k + 1)
            {
              rmdGetFrame__1__4__6__2__2__1__i = mouse_xoffset;
              for( ; !(rmdGetFrame__1__4__6__2__2__1__i >= mouse_xoffset + (signed int)mouse_pos_temp.width); rmdGetFrame__1__4__6__2__2__1__i = rmdGetFrame__1__4__6__2__2__1__i + 1)
              {
                rmdGetFrame__1__4__6__2__2__1__j = rmdGetFrame__1__4__6__2__2__1__k * 16 + rmdGetFrame__1__4__6__2__2__1__i;
                if(!(pdata->dummy_pointer[(signed long int)(4 * rmdGetFrame__1__4__6__2__2__1__j)] == pdata->npxl))
                {
                  (&pdata->enc_data->yuv)->y[(signed long int)(((signed int)mouse_pos_temp.x - (signed int)temp_brwin.rrect.x) + pdata->enc_data->x_offset + (rmdGetFrame__1__4__6__2__2__1__i - mouse_xoffset) + ((rmdGetFrame__1__4__6__2__2__1__k - mouse_yoffset) + ((signed int)mouse_pos_temp.y - (signed int)temp_brwin.rrect.y) + pdata->enc_data->y_offset) * (&pdata->enc_data->yuv)->y_width)] = (unsigned char)((signed int)Yr[(signed long int)pdata->dummy_pointer[(signed long int)(rmdGetFrame__1__4__6__2__2__1__j * 4 + 2)]] + (signed int)Yg[(signed long int)pdata->dummy_pointer[(signed long int)(rmdGetFrame__1__4__6__2__2__1__j * 4 + 1)]] + (signed int)Yb[(signed long int)pdata->dummy_pointer[(signed long int)(rmdGetFrame__1__4__6__2__2__1__j * 4 + 0)]]);
                  if(!(rmdGetFrame__1__4__6__2__2__1__i % 2 == 0) && !(rmdGetFrame__1__4__6__2__2__1__k % 2 == 0))
                  {
                    (&pdata->enc_data->yuv)->u[(signed long int)(rmdGetFrame__1__4__6__2__2__1__x_2 + (rmdGetFrame__1__4__6__2__2__1__i - mouse_xoffset) / 2 + ((rmdGetFrame__1__4__6__2__2__1__k - mouse_yoffset) / 2 + rmdGetFrame__1__4__6__2__2__1__y_2) * y_width_2)] = (unsigned char)((signed int)Ur[(signed long int)pdata->dummy_pointer[(signed long int)((rmdGetFrame__1__4__6__2__2__1__k * (signed int)mouse_pos_temp.width + rmdGetFrame__1__4__6__2__2__1__i) * 4 + 2)]] + (signed int)Ug[(signed long int)pdata->dummy_pointer[(signed long int)((rmdGetFrame__1__4__6__2__2__1__k * (signed int)mouse_pos_temp.width + rmdGetFrame__1__4__6__2__2__1__i) * 4 + 1)]] + (signed int)UbVr[(signed long int)pdata->dummy_pointer[(signed long int)((rmdGetFrame__1__4__6__2__2__1__k * (signed int)mouse_pos_temp.width + rmdGetFrame__1__4__6__2__2__1__i) * 4 + 0)]]);
                    (&pdata->enc_data->yuv)->v[(signed long int)(rmdGetFrame__1__4__6__2__2__1__x_2 + (rmdGetFrame__1__4__6__2__2__1__i - mouse_xoffset) / 2 + ((rmdGetFrame__1__4__6__2__2__1__k - mouse_yoffset) / 2 + rmdGetFrame__1__4__6__2__2__1__y_2) * y_width_2)] = (unsigned char)((signed int)UbVr[(signed long int)pdata->dummy_pointer[(signed long int)((rmdGetFrame__1__4__6__2__2__1__k * (signed int)mouse_pos_temp.width + rmdGetFrame__1__4__6__2__2__1__i) * 4 + 2)]] + (signed int)Vg[(signed long int)pdata->dummy_pointer[(signed long int)((rmdGetFrame__1__4__6__2__2__1__k * (signed int)mouse_pos_temp.width + rmdGetFrame__1__4__6__2__2__1__i) * 4 + 1)]] + (signed int)Vb[(signed long int)pdata->dummy_pointer[(signed long int)((rmdGetFrame__1__4__6__2__2__1__k * (signed int)mouse_pos_temp.width + rmdGetFrame__1__4__6__2__2__1__i) * 4 + 0)]]);
                  }

                }

              }
            }
          }
          if(!(d_buff == 0))
          {
            unsigned char *front_buff;
            if(img_sel == 0)
              tmp_if_expr_47 = (unsigned char *)image->data;

            else
              tmp_if_expr_47 = (unsigned char *)image_back->data;
            front_buff = tmp_if_expr_47;
            if(pdata->specs.depth == 24)
              tmp_if_expr_48 = (_Bool)1;

            else
              tmp_if_expr_48 = pdata->specs.depth == 32 ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr_48)
            {
              signed int rmdGetFrame__1__4__6__2__3__1__1__1__k;
              signed int rmdGetFrame__1__4__6__2__3__1__1__1__i;
              unsigned int *rmdGetFrame__1__4__6__2__3__1__1__1__datapi = (unsigned int *)front_buff + (signed long int)((((signed int)mouse_pos_temp.y - (signed int)temp_brwin.rrect.y) + pdata->enc_data->y_offset) * (signed int)temp_brwin.rrect.width) + (signed long int)(((signed int)mouse_pos_temp.x - (signed int)temp_brwin.rrect.x) + pdata->enc_data->x_offset);
              rmdGetFrame__1__4__6__2__3__1__1__1__k = 0;
              for( ; !(rmdGetFrame__1__4__6__2__3__1__1__1__k >= (signed int)mouse_pos_temp.height); rmdGetFrame__1__4__6__2__3__1__1__1__k = rmdGetFrame__1__4__6__2__3__1__1__1__k + 1)
              {
                rmdGetFrame__1__4__6__2__3__1__1__1__i = 0;
                for( ; !(rmdGetFrame__1__4__6__2__3__1__1__1__i >= (signed int)mouse_pos_temp.width); rmdGetFrame__1__4__6__2__3__1__1__1__i = rmdGetFrame__1__4__6__2__3__1__1__1__i + 1)
                {
                  *rmdGetFrame__1__4__6__2__3__1__1__1__datapi = *rmdGetFrame__1__4__6__2__3__1__1__1__datapi + (unsigned int)1;
                  rmdGetFrame__1__4__6__2__3__1__1__1__datapi = rmdGetFrame__1__4__6__2__3__1__1__1__datapi + 1l;
                }
                rmdGetFrame__1__4__6__2__3__1__1__1__datapi = rmdGetFrame__1__4__6__2__3__1__1__1__datapi + (signed long int)((signed int)temp_brwin.rrect.width - (signed int)mouse_pos_temp.width);
              }
            }

            else
            {
              signed int rmdGetFrame__1__4__6__2__3__1__2__1__k;
              signed int rmdGetFrame__1__4__6__2__3__1__2__1__i;
              unsigned short int *rmdGetFrame__1__4__6__2__3__1__2__1__datapi = (unsigned short int *)front_buff + (signed long int)((((signed int)mouse_pos_temp.y - (signed int)temp_brwin.rrect.y) + pdata->enc_data->y_offset) * (signed int)temp_brwin.rrect.width) + (signed long int)(((signed int)mouse_pos_temp.x - (signed int)temp_brwin.rrect.x) + pdata->enc_data->x_offset);
              rmdGetFrame__1__4__6__2__3__1__2__1__k = 0;
              for( ; !(rmdGetFrame__1__4__6__2__3__1__2__1__k >= (signed int)mouse_pos_temp.height); rmdGetFrame__1__4__6__2__3__1__2__1__k = rmdGetFrame__1__4__6__2__3__1__2__1__k + 1)
              {
                rmdGetFrame__1__4__6__2__3__1__2__1__i = 0;
                for( ; !(rmdGetFrame__1__4__6__2__3__1__2__1__i >= (signed int)mouse_pos_temp.width); rmdGetFrame__1__4__6__2__3__1__2__1__i = rmdGetFrame__1__4__6__2__3__1__2__1__i + 1)
                {
                  *rmdGetFrame__1__4__6__2__3__1__2__1__datapi = *rmdGetFrame__1__4__6__2__3__1__2__1__datapi + (unsigned short int)1;
                  rmdGetFrame__1__4__6__2__3__1__2__1__datapi = rmdGetFrame__1__4__6__2__3__1__2__1__datapi + 1l;
                }
                rmdGetFrame__1__4__6__2__3__1__2__1__datapi = rmdGetFrame__1__4__6__2__3__1__2__1__datapi + (signed long int)((signed int)temp_brwin.rrect.width - (signed int)mouse_pos_temp.width);
              }
            }
          }

        }

        if(!(pdata->args.xfixes_cursor == 0))
        {
          XFree((void *)xcim);
          xcim = (struct anonymous_31 *)(void *)0;
        }

      }

      if(pdata->args.full_shots == 0)
        rmdClearList(&pdata->rect_root);

      if(!(pdata->encoder_busy == 0))
        pdata->frames_lost = pdata->frames_lost + 1u;

      pthread_mutex_lock(&pdata->img_buff_ready_mutex);
      pthread_cond_broadcast(&pdata->image_buffer_ready);
      pthread_mutex_unlock(&pdata->img_buff_ready_mutex);
      pdata->capture_busy = 0;
    }
  }
  if(pdata->args.noframe == 0)
    XDestroyWindow(pdata->dpy, pdata->shaped_w);

  pthread_mutex_lock(&pdata->img_buff_ready_mutex);
  pthread_cond_broadcast(&pdata->image_buffer_ready);
  pthread_mutex_unlock(&pdata->img_buff_ready_mutex);
  if(pdata->args.noshared == 0)
  {
    XShmDetach(pdata->dpy, &shminfo);
    shmdt((const void *)shminfo.shmaddr);
    shmctl(shminfo.shmid, 0, ((struct shmid_ds *)NULL));
    if(!(d_buff == 0))
    {
      XShmDetach(pdata->dpy, &shminfo_back);
      shmdt((const void *)shminfo_back.shmaddr);
      shmctl(shminfo_back.shmid, 0, ((struct shmid_ds *)NULL));
    }

  }

  signed int *return_value___errno_location_50;
  return_value___errno_location_50=__errno_location();
  pthread_exit((void *)&(*return_value___errno_location_50));
}

// rmdGetZPixmap
// file rmd_getzpixmap.h line 55
signed int rmdGetZPixmap(struct _XDisplay *dpy, unsigned long int root, char *data, signed int x, signed int y, signed int width, signed int height)
{
  struct anonymous_132 reply;
  struct anonymous_133 *request;
  signed long int nbytes;
  if(!(dpy->lock_fns == ((struct _XLockPtrs *)NULL)))
    dpy->lock_fns->lock_display(dpy);

  void *return_value__XGetRequest_1;
  return_value__XGetRequest_1=_XGetRequest(dpy, (unsigned char)73, (unsigned long int)20);
  request = (struct anonymous_133 *)return_value__XGetRequest_1;
  request->drawable = (unsigned int)root;
  request->x = (signed short int)x;
  request->y = (signed short int)y;
  request->width = (unsigned short int)width;
  request->height = (unsigned short int)height;
  request->planeMask = (unsigned int)(unsigned long int)~0L;
  request->format = (unsigned char)2;
  signed int return_value__XReply_2;
  return_value__XReply_2=_XReply(dpy, (union anonymous_134 *)&reply, 0, 0);
  if(reply.length == 0u || return_value__XReply_2 == 0)
  {
    if(!(dpy->lock_fns == ((struct _XLockPtrs *)NULL)))
      dpy->lock_fns->unlock_display(dpy);

    if(!(dpy->synchandler == ((signed int (*)(struct _XDisplay *))NULL)))
      dpy->synchandler(dpy);

    return 1;
  }

  else
  {
    nbytes = (signed long int)reply.length << 2;
    _XReadPad(dpy, data, nbytes);
    if(!(dpy->lock_fns == ((struct _XLockPtrs *)NULL)))
      dpy->lock_fns->unlock_display(dpy);

    if(!(dpy->synchandler == ((signed int (*)(struct _XDisplay *))NULL)))
      dpy->synchandler(dpy);

    return 0;
  }
}

// rmdGetZPixmapSHM
// file rmd_getzpixmap.c line 72
signed int rmdGetZPixmapSHM(struct _XDisplay *dpy, unsigned long int root, struct anonymous_34 *shminfo, signed int shm_opcode, char *data, signed int x, signed int y, signed int width, signed int height)
{
  struct _ShmGetImageReply reply;
  struct _ShmGetImage *request = (struct _ShmGetImage *)(void *)0;
  signed long int nbytes;
  if(!(dpy->lock_fns == ((struct _XLockPtrs *)NULL)))
    dpy->lock_fns->lock_display(dpy);

  void *return_value__XGetRequest_1;
  return_value__XGetRequest_1=_XGetRequest(dpy, (unsigned char)4, (unsigned long int)32);
  request = (struct _ShmGetImage *)return_value__XGetRequest_1;
  request->reqType = (unsigned char)shm_opcode;
  request->shmReqType = (unsigned char)4;
  request->shmseg = (unsigned int)shminfo->shmseg;
  request->drawable = (unsigned int)root;
  request->x = (signed short int)x;
  request->y = (signed short int)y;
  request->width = (unsigned short int)width;
  request->height = (unsigned short int)height;
  request->planeMask = (unsigned int)(unsigned long int)~0L;
  request->format = (unsigned char)2;
  request->offset = (unsigned int)(data - shminfo->shmaddr);
  signed int return_value__XReply_2;
  return_value__XReply_2=_XReply(dpy, (union anonymous_134 *)&reply, 0, 0);
  if(reply.length == 0u || return_value__XReply_2 == 0)
  {
    if(!(dpy->lock_fns == ((struct _XLockPtrs *)NULL)))
      dpy->lock_fns->unlock_display(dpy);

    if(!(dpy->synchandler == ((signed int (*)(struct _XDisplay *))NULL)))
      dpy->synchandler(dpy);

    return 1;
  }

  else
  {
    nbytes = (signed long int)reply.length << 2;
    _XReadPad(dpy, data, nbytes);
    if(!(dpy->lock_fns == ((struct _XLockPtrs *)NULL)))
      dpy->lock_fns->unlock_display(dpy);

    if(!(dpy->synchandler == ((signed int (*)(struct _XDisplay *))NULL)))
      dpy->synchandler(dpy);

    return 0;
  }
}

// rmdIncrementalNaming
// file rmd_init_encoder.c line 56
static signed int rmdIncrementalNaming(char **name)
{
  struct stat buff;
  char *base_name__;
  signed int i = 0;
  signed int fname_length;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(*name);
  fname_length = (signed int)(return_value_strlen_1 - (unsigned long int)4);
  void *return_value_malloc_2;
  return_value_malloc_2=malloc((unsigned long int)(fname_length + 1));
  base_name__ = (char *)return_value_malloc_2;
  strncpy(base_name__, *name, (unsigned long int)fname_length);
  base_name__[(signed long int)fname_length] = (char)0;
  signed int return_value_stat_3;
  do
  {
    return_value_stat_3=stat(*name, &buff);
    if(!(return_value_stat_3 == 0))
      break;

    char *tname;
    unsigned long int return_value_strlen_4;
    return_value_strlen_4=strlen(*name);
    void *return_value_malloc_5;
    return_value_malloc_5=malloc(return_value_strlen_4 + (unsigned long int)10);
    tname = (char *)return_value_malloc_5;
    char numbuf[8l];
    strcpy(tname, base_name__);
    strcat(tname, "-");
    i = i + 1;
    snprintf(numbuf, (unsigned long int)8, "%d", i);
    strcat(tname, numbuf);
    strcat(tname, ".ogv");
    free((void *)*name);
    unsigned long int return_value_strlen_6;
    return_value_strlen_6=strlen(tname);
    void *return_value_malloc_7;
    return_value_malloc_7=malloc(return_value_strlen_6 + (unsigned long int)1);
    *name = (char *)return_value_malloc_7;
    strcpy(*name, tname);
    free((void *)tname);
  }
  while((_Bool)1);
  free((void *)base_name__);
  return 0;
}

// rmdInitCacheData
// file rmd_cache.c line 130
void rmdInitCacheData(struct _ProgData *pdata, struct _EncData *enc_data_t, struct _CacheData *cache_data_t)
{
  signed int width;
  signed int height;
  signed int offset_x;
  signed int offset_y;
  signed int pid;
  char pidbuf[8l];
  width = ((signed int)pdata->brwin.rrect.width + 15 >> 4) << 4;
  height = ((signed int)pdata->brwin.rrect.height + 15 >> 4) << 4;
  offset_x = (width - (signed int)pdata->brwin.rrect.width) / 2 & ~1;
  offset_y = (height - (signed int)pdata->brwin.rrect.height) / 2 & ~1;
  pdata->enc_data = enc_data_t;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc((unsigned long int)(height * width));
  enc_data_t->yuv.y = (unsigned char *)return_value_malloc_1;
  void *return_value_malloc_2;
  return_value_malloc_2=malloc((unsigned long int)((height * width) / 4));
  enc_data_t->yuv.u = (unsigned char *)return_value_malloc_2;
  void *return_value_malloc_3;
  return_value_malloc_3=malloc((unsigned long int)((height * width) / 4));
  enc_data_t->yuv.v = (unsigned char *)return_value_malloc_3;
  enc_data_t->yuv.y_width = width;
  enc_data_t->yuv.y_height = height;
  enc_data_t->yuv.y_stride = width;
  enc_data_t->yuv.uv_width = width / 2;
  enc_data_t->yuv.uv_height = height / 2;
  enc_data_t->yuv.uv_stride = width / 2;
  enc_data_t->x_offset = offset_x;
  enc_data_t->y_offset = offset_y;
  pdata->cache_data = cache_data_t;
  cache_data_t->workdir = pdata->args.workdir;
  pid=getpid();
  snprintf(pidbuf, (unsigned long int)8, "%d", pid);
  unsigned long int return_value_strlen_4;
  return_value_strlen_4=strlen(cache_data_t->workdir);
  unsigned long int return_value_strlen_5;
  return_value_strlen_5=strlen(pidbuf);
  void *return_value_malloc_6;
  return_value_malloc_6=malloc(return_value_strlen_4 + (unsigned long int)12 + return_value_strlen_5 + (unsigned long int)3);
  cache_data_t->projname = (char *)return_value_malloc_6;
  strcpy(cache_data_t->projname, cache_data_t->workdir);
  strcat(cache_data_t->projname, "/");
  strcat(cache_data_t->projname, "rMD-session-");
  strcat(cache_data_t->projname, pidbuf);
  strcat(cache_data_t->projname, "/");
  unsigned long int return_value_strlen_7;
  return_value_strlen_7=strlen(cache_data_t->projname);
  void *return_value_malloc_8;
  return_value_malloc_8=malloc(return_value_strlen_7 + (unsigned long int)11);
  cache_data_t->imgdata = (char *)return_value_malloc_8;
  strcpy(cache_data_t->imgdata, cache_data_t->projname);
  strcat(cache_data_t->imgdata, "img.out");
  unsigned long int return_value_strlen_9;
  return_value_strlen_9=strlen(cache_data_t->projname);
  void *return_value_malloc_10;
  return_value_malloc_10=malloc(return_value_strlen_9 + (unsigned long int)10);
  cache_data_t->audiodata = (char *)return_value_malloc_10;
  strcpy(cache_data_t->audiodata, cache_data_t->projname);
  strcat(cache_data_t->audiodata, "audio.pcm");
  unsigned long int return_value_strlen_11;
  return_value_strlen_11=strlen(cache_data_t->projname);
  void *return_value_malloc_12;
  return_value_malloc_12=malloc(return_value_strlen_11 + (unsigned long int)10);
  cache_data_t->specsfile = (char *)return_value_malloc_12;
  strcpy(cache_data_t->specsfile, cache_data_t->projname);
  strcat(cache_data_t->specsfile, "specs.txt");
  signed int return_value_mkdir_13;
  return_value_mkdir_13=mkdir(cache_data_t->projname, (unsigned int)0777);
  if(!(return_value_mkdir_13 == 0))
  {
    fprintf(stderr, "Could not create temporary directory %s !!!\n", cache_data_t->projname);
    exit(13);
  }

  if(pdata->args.zerocompression == 0)
  {
    struct gzFile_s *return_value_gzopen_14;
    return_value_gzopen_14=gzopen(cache_data_t->imgdata, "wb0f");
    cache_data_t->ifp = (struct gzFile_s **)return_value_gzopen_14;
    if(cache_data_t->ifp == ((struct gzFile_s **)NULL))
    {
      fprintf(stderr, "Could not create temporary file %s !!!\n", cache_data_t->imgdata);
      exit(13);
    }

  }

  else
  {
    cache_data_t->uncifp=fopen(cache_data_t->imgdata, "wb0f");
    if(cache_data_t->uncifp == ((struct _IO_FILE *)NULL))
    {
      fprintf(stderr, "Could not create temporary file %s !!!\n", cache_data_t->imgdata);
      exit(13);
    }

  }
  if(pdata->args.nosound == 0)
  {
    cache_data_t->afp=fopen(cache_data_t->audiodata, "wb");
    if(cache_data_t->afp == ((struct _IO_FILE *)NULL))
    {
      fprintf(stderr, "Could not create temporary file %s !!!\n", cache_data_t->audiodata);
      exit(13);
    }

  }

  signed int return_value_rmdWriteSpecsFile_15;
  return_value_rmdWriteSpecsFile_15=rmdWriteSpecsFile(pdata);
  if(!(return_value_rmdWriteSpecsFile_15 == 0))
  {
    fprintf(stderr, "Could not write specsfile %s !!!\n", cache_data_t->specsfile);
    exit(13);
  }

}

// rmdInitEncoder
// file rmd_init_encoder.h line 44
void rmdInitEncoder(struct _ProgData *pdata, struct _EncData *enc_data_t, signed int buffer_ready)
{
  signed int y0;
  signed int y1;
  signed int y2;
  signed int fname_length;
  struct anonymous_14 m_ogg_skel;
  struct anonymous_15 skel_og_pg;
  struct anonymous_139 skel_fbv;
  struct anonymous_139 skel_fba;
  pdata->enc_data = enc_data_t;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(pdata->args.filename);
  fname_length = (signed int)return_value_strlen_1;
  _Bool tmp_if_expr_3;
  if(fname_length >= 5)
    tmp_if_expr_3 = (signed int)pdata->args.filename[(signed long int)(fname_length - 4)] == 46 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_3 = (_Bool)0;
  _Bool tmp_if_expr_5;
  _Bool tmp_if_expr_4;
  if(tmp_if_expr_3)
  {
    if((signed int)pdata->args.filename[(signed long int)(fname_length + -3)] == 111)
      tmp_if_expr_4 = (_Bool)1;

    else
      tmp_if_expr_4 = (signed int)pdata->args.filename[(signed long int)(fname_length - 3)] == 79 ? (_Bool)1 : (_Bool)0;
    tmp_if_expr_5 = tmp_if_expr_4 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_5 = (_Bool)0;
  _Bool tmp_if_expr_7;
  _Bool tmp_if_expr_6;
  if(tmp_if_expr_5)
  {
    if((signed int)pdata->args.filename[(signed long int)(fname_length + -2)] == 103)
      tmp_if_expr_6 = (_Bool)1;

    else
      tmp_if_expr_6 = (signed int)pdata->args.filename[(signed long int)(fname_length - 2)] == 71 ? (_Bool)1 : (_Bool)0;
    tmp_if_expr_7 = tmp_if_expr_6 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_7 = (_Bool)0;
  _Bool tmp_if_expr_9;
  _Bool tmp_if_expr_8;
  if(tmp_if_expr_7)
  {
    if((signed int)pdata->args.filename[(signed long int)(fname_length + -1)] == 118)
      tmp_if_expr_8 = (_Bool)1;

    else
      tmp_if_expr_8 = (signed int)pdata->args.filename[(signed long int)(fname_length - 1)] == 86 ? (_Bool)1 : (_Bool)0;
    tmp_if_expr_9 = tmp_if_expr_8 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_9 = (_Bool)0;
  if(!tmp_if_expr_9)
  {
    char *new_name;
    void *return_value_malloc_2;
    return_value_malloc_2=malloc((unsigned long int)(fname_length + 5));
    new_name = (char *)return_value_malloc_2;
    strcpy(new_name, pdata->args.filename);
    strcat(new_name, ".ogv");
    free((void *)pdata->args.filename);
    pdata->args.filename = new_name;
  }

  if(pdata->args.overwrite == 0)
  {
    rmdIncrementalNaming(&pdata->args.filename);
    fprintf(stderr, "Output file: %s\n", pdata->args.filename);
  }

  enc_data_t->fp=fopen(pdata->args.filename, "w");
  if(enc_data_t->fp == ((struct _IO_FILE *)NULL))
  {
    fprintf(stderr, "Cannot open file %s for writting!\n", pdata->args.filename);
    exit(13);
  }

  signed long int return_value_time_10;
  return_value_time_10=time((signed long int *)(void *)0);
  srand((unsigned int)return_value_time_10);
  signed int return_value_rand_11;
  return_value_rand_11=rand();
  y0 = return_value_rand_11 + 1;
  signed int return_value_rand_12;
  return_value_rand_12=rand();
  y1 = return_value_rand_12 + 1;
  signed int return_value_rand_13;
  return_value_rand_13=rand();
  y2 = return_value_rand_13 + 1;
  y2 = y2 + (signed int)(y1 == y2);
  y0 = y0 == y1 || y0 == y2 ? y1 + y2 : y0;
  ogg_stream_init(&m_ogg_skel, y0);
  m_add_fishead_packet(&m_ogg_skel);
  signed int return_value_ogg_stream_pageout_14;
  return_value_ogg_stream_pageout_14=ogg_stream_pageout(&m_ogg_skel, &skel_og_pg);
  if(!(return_value_ogg_stream_pageout_14 == 1))
  {
    fprintf(stderr, "Internal Ogg library error.\n");
    exit(2);
  }

  fwrite((const void *)skel_og_pg.header, (unsigned long int)1, (unsigned long int)skel_og_pg.header_len, enc_data_t->fp);
  fwrite((const void *)skel_og_pg.body, (unsigned long int)1, (unsigned long int)skel_og_pg.body_len, enc_data_t->fp);
  ogg_stream_init(&enc_data_t->m_ogg_ts, y1);
  if(pdata->args.nosound == 0)
    ogg_stream_init(&enc_data_t->m_ogg_vs, y2);

  theora_info_init(&enc_data_t->m_th_inf);
  enc_data_t->m_th_inf.frame_width = (unsigned int)pdata->brwin.rrect.width;
  enc_data_t->m_th_inf.frame_height = (unsigned int)pdata->brwin.rrect.height;
  enc_data_t->m_th_inf.width = (enc_data_t->m_th_inf.frame_width + (unsigned int)15 >> 4) << 4;
  enc_data_t->m_th_inf.height = (enc_data_t->m_th_inf.frame_height + (unsigned int)15 >> 4) << 4;
  enc_data_t->m_th_inf.offset_x = (unsigned int)0;
  enc_data_t->m_th_inf.offset_y = (unsigned int)0;
  enc_data_t->m_th_inf.fps_numerator = (unsigned int)((double)pdata->args.fps * 100.0);
  enc_data_t->m_th_inf.fps_denominator = (unsigned int)100;
  enc_data_t->m_th_inf.aspect_numerator = (unsigned int)1;
  enc_data_t->m_th_inf.aspect_denominator = (unsigned int)1;
  enc_data_t->m_th_inf.colorspace = (enum anonymous_143)OC_CS_UNSPECIFIED;
  enc_data_t->m_th_inf.pixelformat = (enum anonymous_144)OC_PF_420;
  enc_data_t->m_th_inf.target_bitrate = pdata->args.v_bitrate;
  enc_data_t->m_th_inf.quality = pdata->args.v_quality;
  enc_data_t->m_th_inf.dropframes_p = 0;
  enc_data_t->m_th_inf.quick_p = 1;
  enc_data_t->m_th_inf.keyframe_auto_p = 1;
  enc_data_t->m_th_inf.keyframe_frequency = (unsigned int)64;
  enc_data_t->m_th_inf.keyframe_frequency_force = (unsigned int)64;
  enc_data_t->m_th_inf.keyframe_data_target_bitrate = (unsigned int)((double)enc_data_t->m_th_inf.quality * 1.5);
  enc_data_t->m_th_inf.keyframe_auto_threshold = 80;
  enc_data_t->m_th_inf.keyframe_mindistance = (unsigned int)8;
  enc_data_t->m_th_inf.noise_sensitivity = 1;
  enc_data_t->m_th_inf.sharpness = 2;
  theora_encode_init(&enc_data_t->m_th_st, &enc_data_t->m_th_inf);
  if(pdata->args.nosound == 0)
  {
    signed int ret;
    vorbis_info_init(&enc_data_t->m_vo_inf);
    ret=vorbis_encode_init_vbr(&enc_data_t->m_vo_inf, (signed long int)pdata->args.channels, (signed long int)pdata->args.frequency, (float)((double)(float)pdata->args.s_quality * 0.1));
    if(!(ret == 0))
    {
      fprintf(stderr, "Error while setting up vorbis stream quality!\n");
      exit(2);
    }

    vorbis_comment_init(&enc_data_t->m_vo_cmmnt);
    vorbis_analysis_init(&enc_data_t->m_vo_dsp, &enc_data_t->m_vo_inf);
    vorbis_block_init(&enc_data_t->m_vo_dsp, &enc_data_t->m_vo_block);
  }

  theora_encode_header(&enc_data_t->m_th_st, &enc_data_t->m_ogg_pckt1);
  ogg_stream_packetin(&enc_data_t->m_ogg_ts, &enc_data_t->m_ogg_pckt1);
  signed int return_value_ogg_stream_pageout_15;
  return_value_ogg_stream_pageout_15=ogg_stream_pageout(&enc_data_t->m_ogg_ts, &enc_data_t->m_ogg_pg);
  if(!(return_value_ogg_stream_pageout_15 == 1))
  {
    fprintf(stderr, "Internal Ogg library error.\n");
    exit(2);
  }

  fwrite((const void *)enc_data_t->m_ogg_pg.header, (unsigned long int)1, (unsigned long int)enc_data_t->m_ogg_pg.header_len, enc_data_t->fp);
  fwrite((const void *)enc_data_t->m_ogg_pg.body, (unsigned long int)1, (unsigned long int)enc_data_t->m_ogg_pg.body_len, enc_data_t->fp);
  theora_comment_init(&enc_data_t->m_th_cmmnt);
  theora_comment_add_tag(&enc_data_t->m_th_cmmnt, "recordMyDesktop", "0.3.8.1");
  theora_encode_comment(&enc_data_t->m_th_cmmnt, &enc_data_t->m_ogg_pckt1);
  ogg_stream_packetin(&enc_data_t->m_ogg_ts, &enc_data_t->m_ogg_pckt1);
  theora_encode_tables(&enc_data_t->m_th_st, &enc_data_t->m_ogg_pckt1);
  ogg_stream_packetin(&enc_data_t->m_ogg_ts, &enc_data_t->m_ogg_pckt1);
  if(pdata->args.nosound == 0)
  {
    struct anonymous_126 header;
    struct anonymous_126 header_comm;
    struct anonymous_126 header_code;
    vorbis_analysis_headerout(&enc_data_t->m_vo_dsp, &enc_data_t->m_vo_cmmnt, &header, &header_comm, &header_code);
    ogg_stream_packetin(&enc_data_t->m_ogg_vs, &header);
    signed int return_value_ogg_stream_pageout_16;
    return_value_ogg_stream_pageout_16=ogg_stream_pageout(&enc_data_t->m_ogg_vs, &enc_data_t->m_ogg_pg);
    if(!(return_value_ogg_stream_pageout_16 == 1))
    {
      fprintf(stderr, "Internal Ogg library error.\n");
      exit(2);
    }

    fwrite((const void *)enc_data_t->m_ogg_pg.header, (unsigned long int)1, (unsigned long int)enc_data_t->m_ogg_pg.header_len, enc_data_t->fp);
    fwrite((const void *)enc_data_t->m_ogg_pg.body, (unsigned long int)1, (unsigned long int)enc_data_t->m_ogg_pg.body_len, enc_data_t->fp);
    ogg_stream_packetin(&enc_data_t->m_ogg_vs, &header_comm);
    ogg_stream_packetin(&enc_data_t->m_ogg_vs, &header_code);
  }

  memset((void *)&skel_fbv, 0, sizeof(struct anonymous_139) /*56ul*/ );
  skel_fbv.serial_no = (unsigned int)enc_data_t->m_ogg_ts.serialno;
  skel_fbv.nr_header_packet = (unsigned int)3;
  skel_fbv.granule_rate_n = (signed long int)enc_data_t->m_th_inf.fps_numerator;
  skel_fbv.granule_rate_d = (signed long int)enc_data_t->m_th_inf.fps_denominator;
  skel_fbv.start_granule = (signed long int)0;
  skel_fbv.preroll = (unsigned int)0;
  signed int return_value_theora_granule_shift_17;
  return_value_theora_granule_shift_17=theora_granule_shift(&enc_data_t->m_th_inf);
  skel_fbv.granule_shift = (unsigned char)return_value_theora_granule_shift_17;
  add_message_header_field(&skel_fbv, "Content-Type", "video/theora");
  add_fisbone_to_stream(&m_ogg_skel, &skel_fbv);
  if(pdata->args.nosound == 0)
  {
    memset((void *)&skel_fba, 0, sizeof(struct anonymous_139) /*56ul*/ );
    skel_fba.serial_no = (unsigned int)enc_data_t->m_ogg_vs.serialno;
    skel_fba.nr_header_packet = (unsigned int)3;
    skel_fba.granule_rate_n = (signed long int)pdata->args.frequency;
    skel_fba.granule_rate_d = (signed long int)1;
    skel_fba.start_granule = (signed long int)0;
    skel_fba.preroll = (unsigned int)2;
    skel_fba.granule_shift = (unsigned char)0;
    add_message_header_field(&skel_fba, "Content-Type", "audio/vorbis");
    add_fisbone_to_stream(&m_ogg_skel, &skel_fba);
  }

  while((_Bool)1)
  {
    signed int rmdInitEncoder__1__9__result;
    rmdInitEncoder__1__9__result=ogg_stream_flush(&m_ogg_skel, &skel_og_pg);
    if(!(rmdInitEncoder__1__9__result >= 0))
    {
      fprintf(stderr, "Internal Ogg library error.\n");
      exit(2);
    }

    if(rmdInitEncoder__1__9__result == 0)
      break;

    fwrite((const void *)skel_og_pg.header, (unsigned long int)1, (unsigned long int)skel_og_pg.header_len, enc_data_t->fp);
    fwrite((const void *)skel_og_pg.body, (unsigned long int)1, (unsigned long int)skel_og_pg.body_len, enc_data_t->fp);
  }
  while((_Bool)1)
  {
    signed int result;
    result=ogg_stream_flush(&enc_data_t->m_ogg_ts, &enc_data_t->m_ogg_pg);
    if(!(result >= 0))
    {
      fprintf(stderr, "Internal Ogg library error.\n");
      exit(2);
    }

    if(result == 0)
      break;

    fwrite((const void *)enc_data_t->m_ogg_pg.header, (unsigned long int)1, (unsigned long int)enc_data_t->m_ogg_pg.header_len, enc_data_t->fp);
    fwrite((const void *)enc_data_t->m_ogg_pg.body, (unsigned long int)1, (unsigned long int)enc_data_t->m_ogg_pg.body_len, enc_data_t->fp);
  }
  if(pdata->args.nosound == 0)
    while((_Bool)1)
    {
      signed int rmdInitEncoder__1__11__1__result;
      rmdInitEncoder__1__11__1__result=ogg_stream_flush(&enc_data_t->m_ogg_vs, &enc_data_t->m_ogg_pg);
      if(!(rmdInitEncoder__1__11__1__result >= 0))
      {
        fprintf(stderr, "Internal Ogg library error.\n");
        exit(2);
      }

      if(rmdInitEncoder__1__11__1__result == 0)
        break;

      fwrite((const void *)enc_data_t->m_ogg_pg.header, (unsigned long int)1, (unsigned long int)enc_data_t->m_ogg_pg.header_len, enc_data_t->fp);
      fwrite((const void *)enc_data_t->m_ogg_pg.body, (unsigned long int)1, (unsigned long int)enc_data_t->m_ogg_pg.body_len, enc_data_t->fp);
    }

  add_eos_packet_to_stream(&m_ogg_skel);
  signed int return_value_ogg_stream_flush_18;
  return_value_ogg_stream_flush_18=ogg_stream_flush(&m_ogg_skel, &skel_og_pg);
  if(!(return_value_ogg_stream_flush_18 >= 0))
  {
    fprintf(stderr, "Internal Ogg library error.\n");
    exit(2);
  }

  fwrite((const void *)skel_og_pg.header, (unsigned long int)1, (unsigned long int)skel_og_pg.header_len, enc_data_t->fp);
  fwrite((const void *)skel_og_pg.body, (unsigned long int)1, (unsigned long int)skel_og_pg.body_len, enc_data_t->fp);
  if(buffer_ready == 0)
  {
    void *return_value_malloc_19;
    return_value_malloc_19=malloc((unsigned long int)(enc_data_t->m_th_inf.height * enc_data_t->m_th_inf.width));
    enc_data_t->yuv.y = (unsigned char *)return_value_malloc_19;
    void *return_value_malloc_20;
    return_value_malloc_20=malloc((unsigned long int)((enc_data_t->m_th_inf.height * enc_data_t->m_th_inf.width) / (unsigned int)4));
    enc_data_t->yuv.u = (unsigned char *)return_value_malloc_20;
    void *return_value_malloc_21;
    return_value_malloc_21=malloc((unsigned long int)((enc_data_t->m_th_inf.height * enc_data_t->m_th_inf.width) / (unsigned int)4));
    enc_data_t->yuv.v = (unsigned char *)return_value_malloc_21;
    enc_data_t->yuv.y_width = (signed int)enc_data_t->m_th_inf.width;
    enc_data_t->yuv.y_height = (signed int)enc_data_t->m_th_inf.height;
    enc_data_t->yuv.y_stride = (signed int)enc_data_t->m_th_inf.width;
    enc_data_t->yuv.uv_width = (signed int)(enc_data_t->m_th_inf.width / (unsigned int)2);
    enc_data_t->yuv.uv_height = (signed int)(enc_data_t->m_th_inf.height / (unsigned int)2);
    enc_data_t->yuv.uv_stride = (signed int)(enc_data_t->m_th_inf.width / (unsigned int)2);
    enc_data_t->x_offset = (signed int)enc_data_t->m_th_inf.offset_x;
    enc_data_t->y_offset = (signed int)enc_data_t->m_th_inf.offset_y;
  }

  theora_info_clear(&enc_data_t->m_th_inf);
}

// rmdInitEventsPolling
// file rmd_poll_events.h line 38
void rmdInitEventsPolling(struct _ProgData *pdata)
{
  unsigned long int root_return;
  unsigned long int parent_return;
  unsigned long int *children;
  unsigned int i;
  unsigned int nchildren;
  XSelectInput(pdata->dpy, pdata->specs.root, 1L << 19);
  if(pdata->args.full_shots == 0)
  {
    XQueryTree(pdata->dpy, pdata->specs.root, &root_return, &parent_return, &children, &nchildren);
    i = (unsigned int)0;
    for( ; !(i >= nchildren); i = i + 1u)
    {
      struct anonymous attribs;
      signed int return_value_XGetWindowAttributes_1;
      return_value_XGetWindowAttributes_1=XGetWindowAttributes(pdata->dpy, children[(signed long int)i], &attribs);
      if(!(return_value_XGetWindowAttributes_1 == 0))
      {
        if(attribs.override_redirect == 0)
        {
          if(attribs.depth == pdata->specs.depth)
            XDamageCreate(pdata->dpy, children[(signed long int)i], 0);

        }

      }

    }
    XFree((void *)children);
    XDamageCreate(pdata->dpy, pdata->specs.root, 0);
  }

}

// rmdInitializeData
// file rmd_initialize_data.h line 45
signed int rmdInitializeData(struct _ProgData *pdata, struct _EncData *enc_data, struct _CacheData *cache_data)
{
  signed int i;
  fprintf(stderr, "Initializing...\n");
  rmdMakeMatrices();
  if(!(pdata->args.have_dummy_cursor == 0))
  {
    pdata->dummy_pointer=rmdMakeDummyPointer(pdata->dpy, &pdata->specs, 16, pdata->args.cursor_color, 0, &pdata->npxl);
    pdata->dummy_p_size = 16;
  }

  else
    pdata->dummy_p_size = 0;
  pdata->rect_root = (struct _RectArea *)(void *)0;
  pthread_mutex_init(&pdata->sound_buffer_mutex, (const union anonymous_141 *)(void *)0);
  pthread_mutex_init(&pdata->snd_buff_ready_mutex, (const union anonymous_141 *)(void *)0);
  pthread_mutex_init(&pdata->img_buff_ready_mutex, (const union anonymous_141 *)(void *)0);
  pthread_mutex_init(&pdata->theora_lib_mutex, (const union anonymous_141 *)(void *)0);
  pthread_mutex_init(&pdata->vorbis_lib_mutex, (const union anonymous_141 *)(void *)0);
  pthread_mutex_init(&pdata->libogg_mutex, (const union anonymous_141 *)(void *)0);
  pthread_mutex_init(&pdata->yuv_mutex, (const union anonymous_141 *)(void *)0);
  pthread_mutex_init(&pdata->pause_mutex, (const union anonymous_141 *)(void *)0);
  pthread_mutex_init(&pdata->time_mutex, (const union anonymous_141 *)(void *)0);
  pthread_cond_init(&pdata->time_cond, (const union anonymous_141 *)(void *)0);
  pthread_cond_init(&pdata->pause_cond, (const union anonymous_141 *)(void *)0);
  pthread_cond_init(&pdata->image_buffer_ready, (const union anonymous_141 *)(void *)0);
  pthread_cond_init(&pdata->sound_data_read, (const union anonymous_141 *)(void *)0);
  pthread_cond_init(&pdata->theora_lib_clean, (const union anonymous_141 *)(void *)0);
  pthread_cond_init(&pdata->vorbis_lib_clean, (const union anonymous_141 *)(void *)0);
  pdata->v_encoding_clean = 1;
  pdata->th_encoding_clean = pdata->v_encoding_clean;
  pdata->avd = 0;
  pdata->sound_buffer = (struct _SndBuffer *)(void *)0;
  pdata->running = (signed int)!(0 != 0);
  pdata->paused = 0;
  pdata->aborted = 0;
  pdata->pause_state_changed = 0;
  pdata->frames_total = (unsigned int)0;
  pdata->frames_lost = (unsigned int)0;
  pdata->encoder_busy = 0;
  pdata->capture_busy = 0;
  if(pdata->args.nosound == 0)
  {
    if(pdata->args.use_jack == 0)
    {
      rmdFixBufferSize(&pdata->args.buffsize);
      pdata->sound_handle=rmdOpenDev(pdata->args.device, &pdata->args.channels, &pdata->args.frequency, &pdata->args.buffsize, &pdata->periodsize, &pdata->periodtime, &pdata->hard_pause);
      signed int return_value_snd_pcm_format_width_1;
      return_value_snd_pcm_format_width_1=snd_pcm_format_width((enum _snd_pcm_format)SND_PCM_FORMAT_S16_LE);
      pdata->sound_framesize = (signed int)((unsigned int)(return_value_snd_pcm_format_width_1 / 8) * pdata->args.channels);
      if(pdata->sound_handle == ((struct _snd_pcm *)NULL))
      {
        fprintf(stderr, "Error while opening/configuring soundcard %s\nTry running with the --no-sound or specify a correct device.\n", pdata->args.device);
        return 3;
      }

    }

    else
    {
      signed int jack_error = 0;
      pdata->jdata->port_names = pdata->args.jack_port_names;
      pdata->jdata->nports = pdata->args.jack_nports;
      pdata->jdata->ringbuffer_secs = pdata->args.jack_ringbuffer_secs;
      pdata->jdata->snd_buff_ready_mutex = &pdata->snd_buff_ready_mutex;
      pdata->jdata->sound_data_read = &pdata->sound_data_read;
      pdata->jdata->capture_started = 0;
      jack_error=rmdStartJackClient(pdata->jdata);
      if(!(jack_error == 0))
        return jack_error;

      pdata->args.buffsize = (unsigned long int)pdata->jdata->buffersize;
      pdata->periodsize = pdata->args.buffsize;
      pdata->args.frequency = pdata->jdata->frequency;
      pdata->args.channels = pdata->jdata->nports;
      pdata->periodtime = (unsigned int)(((unsigned long int)1000000 * pdata->args.buffsize) / (unsigned long int)pdata->args.frequency);
      pdata->sound_framesize = (signed int)(sizeof(float) /*4ul*/  * (unsigned long int)pdata->jdata->nports);
    }
  }

  if(!(pdata->args.encOnTheFly == 0))
    rmdInitEncoder(pdata, enc_data, 0);

  else
    rmdInitCacheData(pdata, enc_data, cache_data);
  i = 0;
  for( ; !(i >= pdata->enc_data->yuv.y_height * pdata->enc_data->yuv.y_width); i = i + 1)
    pdata->enc_data->yuv.y[(signed long int)i] = (unsigned char)0;
  i = 0;
  for( ; !(i >= pdata->enc_data->yuv.uv_height * pdata->enc_data->yuv.uv_width); i = i + 1)
  {
    pdata->enc_data->yuv.u[(signed long int)i] = (unsigned char)127;
    pdata->enc_data->yuv.v[(signed long int)i] = pdata->enc_data->yuv.u[(signed long int)i];
  }
  void *return_value_malloc_2;
  return_value_malloc_2=malloc(sizeof(unsigned int) /*4ul*/  * (unsigned long int)(pdata->enc_data->yuv.y_width / 0x0010) * (unsigned long int)(pdata->enc_data->yuv.y_height / 0x0010));
  yblocks = (unsigned int *)return_value_malloc_2;
  void *return_value_malloc_3;
  return_value_malloc_3=malloc(sizeof(unsigned int) /*4ul*/  * (unsigned long int)(pdata->enc_data->yuv.y_width / 0x0010) * (unsigned long int)(pdata->enc_data->yuv.y_height / 0x0010));
  ublocks = (unsigned int *)return_value_malloc_3;
  void *return_value_malloc_4;
  return_value_malloc_4=malloc(sizeof(unsigned int) /*4ul*/  * (unsigned long int)(pdata->enc_data->yuv.y_width / 0x0010) * (unsigned long int)(pdata->enc_data->yuv.y_height / 0x0010));
  vblocks = (unsigned int *)return_value_malloc_4;
  pdata->frametime = (unsigned int)((float)1000000 / pdata->args.fps);
  return 0;
}

// rmdJackCapture
// file rmd_jack.c line 49
static signed int rmdJackCapture(unsigned int nframes, void *jdata_t)
{
  signed int i = 0;
  struct _JackData *jdata = (struct _JackData *)jdata_t;
  _Bool tmp_if_expr_1;
  if(jdata->pdata->running == 0)
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = jdata->pdata->paused != 0 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_2;
  if(tmp_if_expr_1)
    tmp_if_expr_2 = (_Bool)1;

  else
    tmp_if_expr_2 = !(jdata->capture_started != 0) ? (_Bool)1 : (_Bool)0;
  void *return_value_jack_port_get_buffer_3;
  if(tmp_if_expr_2)
    return 0;

  else
  {
    i = 0;
    for( ; !((unsigned int)i >= jdata->nports); i = i + 1)
    {
      return_value_jack_port_get_buffer_3=jack_port_get_buffer(jdata->ports[(signed long int)i], nframes);
      jdata->portbuf[(signed long int)i] = (float *)return_value_jack_port_get_buffer_3;
    }
    i = 0;
    if(!((unsigned int)i >= jdata->nports))
    {
      (jack_ringbuffer_write)(jdata->sound_buffer, (const char *)(void *)jdata->portbuf[(signed long int)i], (unsigned long int)nframes * sizeof(float) /*4ul*/ );
      i = i + 1;
    }

    pthread_mutex_lock(jdata->snd_buff_ready_mutex);
    pthread_cond_signal(jdata->sound_data_read);
    pthread_mutex_unlock(jdata->snd_buff_ready_mutex);
    return 0;
  }
}

// rmdJackShutdown
// file rmd_jack.c line 129
static void rmdJackShutdown(void *jdata_t)
{
  struct _JackData *jdata = (struct _JackData *)jdata_t;
  jdata->pdata->running = 0;
  fprintf(stderr, "JACK shutdown\n");
}

// rmdLoadBlock
// file rmd_load_cache.c line 69
static void rmdLoadBlock(unsigned char *dest, unsigned char *source, signed int blockno, signed int width, signed int height, signed int blockwidth)
{
  signed int j;
  signed int block_i = blockno / (width / blockwidth);
  signed int block_k = blockno % (width / blockwidth);
  j = 0;
  for( ; !(j >= blockwidth); j = j + 1)
    memcpy((void *)&dest[(signed long int)((block_i * width + block_k) * blockwidth + j * width)], (const void *)&source[(signed long int)(j * blockwidth)], (unsigned long int)blockwidth);
}

// rmdLoadCache
// file rmd_load_cache.h line 39
void * rmdLoadCache(struct _ProgData *pdata)
{
  struct anonymous_45 *yuv = &pdata->enc_data->yuv;
  struct gzFile_s **ifp = (struct gzFile_s **)(void *)0;
  struct _IO_FILE *ucfp = (struct _IO_FILE *)(void *)0;
  struct _IO_FILE *afp = pdata->cache_data->afp;
  struct _FrameHeader fheader;
  struct _CachedFrame frame;
  signed int j = 0;
  signed int nth_cache = 1;
  signed int audio_end = 0;
  signed int extra_frames = 0;
  signed int missing_frames = 0;
  signed int thread_exit = 0;
  signed int blocknum_x = pdata->enc_data->yuv.y_width / 0x0010;
  signed int blocknum_y = pdata->enc_data->yuv.y_height / 0x0010;
  signed int blockszy = 0x0100;
  signed int blockszuv = 0x0040;
  signed char *sound_data;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(pdata->periodsize * (unsigned long int)pdata->sound_framesize);
  sound_data = (signed char *)return_value_malloc_1;
  const signed long int sound_data_array_size0 = (signed long int)((yuv->y_width * yuv->y_height) / 0x0100);
  const signed long int YBlocks_array_size0 = (signed long int)((yuv->uv_width * yuv->uv_height) / 0x0040);
  const signed long int UBlocks_array_size0 = (signed long int)((yuv->uv_width * yuv->uv_height) / 0x0040);
  unsigned int YBlocks[sound_data_array_size0];
  unsigned int UBlocks[YBlocks_array_size0];
  unsigned int VBlocks[UBlocks_array_size0];
  frame.header = &fheader;
  frame.YBlocks = YBlocks;
  frame.UBlocks = UBlocks;
  frame.VBlocks = VBlocks;
  void *return_value_malloc_2;
  return_value_malloc_2=malloc((unsigned long int)(yuv->y_width * yuv->y_height));
  frame.YData = (unsigned char *)return_value_malloc_2;
  void *return_value_malloc_3;
  return_value_malloc_3=malloc((unsigned long int)(yuv->uv_width * yuv->uv_height));
  frame.UData = (unsigned char *)return_value_malloc_3;
  void *return_value_malloc_4;
  return_value_malloc_4=malloc((unsigned long int)(yuv->uv_width * yuv->uv_height));
  frame.VData = (unsigned char *)return_value_malloc_4;
  if(pdata->args.zerocompression == 0)
  {
    struct gzFile_s *return_value_gzopen_5;
    return_value_gzopen_5=gzopen(pdata->cache_data->imgdata, "rb");
    ifp = (struct gzFile_s **)return_value_gzopen_5;
    if(ifp == ((struct gzFile_s **)NULL))
    {
      thread_exit = -1;
      pthread_exit((void *)&thread_exit);
    }

  }

  else
  {
    ucfp=fopen(pdata->cache_data->imgdata, "rb");
    if(ucfp == ((struct _IO_FILE *)NULL))
    {
      thread_exit = -1;
      pthread_exit((void *)&thread_exit);
    }

  }
  if(pdata->args.nosound == 0)
  {
    afp=fopen(pdata->cache_data->audiodata, "rb");
    if(afp == ((struct _IO_FILE *)NULL))
    {
      thread_exit = -1;
      pthread_exit((void *)&thread_exit);
    }

  }

  pdata->avd = 0;
  _Bool tmp_if_expr_17;
  _Bool tmp_if_expr_12;
  signed int return_value_gzread_11;
  _Bool tmp_if_expr_15;
  _Bool tmp_if_expr_14;
  unsigned long int return_value_fread_13;
  _Bool tmp_if_expr_6;
  _Bool tmp_if_expr_7;
  _Bool tmp_if_expr_9;
  signed int return_value_rmdReadFrame_8;
  while(!(pdata->running == 0))
  {
    if(!(pdata->avd >= 1))
      tmp_if_expr_17 = (_Bool)1;

    else
      tmp_if_expr_17 = pdata->args.nosound != 0 ? (_Bool)1 : (_Bool)0;
    if(!(audio_end == 0) || tmp_if_expr_17)
    {
      if(missing_frames >= 1)
      {
        extra_frames = extra_frames + 1;
        missing_frames = missing_frames - 1;
        rmdSyncEncodeImageBuffer(pdata);
      }

      else
      {
        if(pdata->args.zerocompression == 0)
        {
          return_value_gzread_11=gzread((struct gzFile_s *)ifp, (void *)frame.header, (unsigned int)sizeof(struct _FrameHeader) /*24ul*/ );
          tmp_if_expr_12 = (unsigned long int)return_value_gzread_11 == sizeof(struct _FrameHeader) /*24ul*/  ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_12 = (_Bool)0;
        if(tmp_if_expr_12)
          tmp_if_expr_15 = (_Bool)1;

        else
        {
          if(!(pdata->args.zerocompression == 0))
          {
            return_value_fread_13=fread((void *)frame.header, sizeof(struct _FrameHeader) /*24ul*/ , (unsigned long int)1, ucfp);
            tmp_if_expr_14 = return_value_fread_13 == (unsigned long int)1 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_14 = (_Bool)0;
          tmp_if_expr_15 = tmp_if_expr_14 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_15)
        {
          missing_frames = missing_frames + (signed int)(frame.header->current_total - ((unsigned int)extra_frames + frame.header->frameno));
          if(!(pdata->frames_total == 0u))
            fprintf(stdout, "\r[%d%%] ", ((frame.header->frameno + (unsigned int)extra_frames) * (unsigned int)100) / pdata->frames_total);

          else
            fprintf(stdout, "\r[%d frames rendered] ", frame.header->frameno + (unsigned int)extra_frames);
          fflush(stdout);
          if((unsigned int)blocknum_x * (unsigned int)blocknum_y >= frame.header->Ynum)
            tmp_if_expr_6 = frame.header->Unum <= (unsigned int)(blocknum_x * blocknum_y) ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_6 = (_Bool)0;
          if(tmp_if_expr_6)
            tmp_if_expr_7 = frame.header->Vnum <= (unsigned int)(blocknum_x * blocknum_y) ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_7 = (_Bool)0;
          if(tmp_if_expr_7)
          {
            return_value_rmdReadFrame_8=rmdReadFrame(&frame, pdata->args.zerocompression != 0 ? ucfp : (struct _IO_FILE *)(void *)0, pdata->args.zerocompression != 0 ? (struct gzFile_s **)(void *)0 : ifp);
            tmp_if_expr_9 = !(return_value_rmdReadFrame_8 != 0) ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_9 = (_Bool)0;
          if(tmp_if_expr_9)
          {
            if(!(frame.header->Ynum == 0u))
            {
              j = 0;
              for( ; !((unsigned int)j >= frame.header->Ynum); j = j + 1)
                rmdLoadBlock(yuv->y, &frame.YData[(signed long int)(j * blockszy)], (signed int)frame.YBlocks[(signed long int)j], yuv->y_width, yuv->y_height, 0x0010);
            }

            if(!(frame.header->Unum == 0u))
            {
              j = 0;
              for( ; !((unsigned int)j >= frame.header->Unum); j = j + 1)
                rmdLoadBlock(yuv->u, &frame.UData[(signed long int)(j * blockszuv)], (signed int)frame.UBlocks[(signed long int)j], yuv->uv_width, yuv->uv_height, 0x0008);
            }

            if(!(frame.header->Vnum == 0u))
            {
              j = 0;
              for( ; !((unsigned int)j >= frame.header->Vnum); j = j + 1)
                rmdLoadBlock(yuv->v, &frame.VData[(signed long int)(j * blockszuv)], (signed int)frame.VBlocks[(signed long int)j], yuv->uv_width, yuv->uv_height, 0x0008);
            }

            rmdSyncEncodeImageBuffer(pdata);
          }

          else
          {
            raise(2);
            continue;
          }
        }

        else
        {
          signed int return_value_rmdSwapCacheFilesRead_10;
          return_value_rmdSwapCacheFilesRead_10=rmdSwapCacheFilesRead(pdata->cache_data->imgdata, nth_cache, &ifp, &ucfp);
          if(!(return_value_rmdSwapCacheFilesRead_10 == 0))
            raise(2);

          else
          {
            fprintf(stderr, "\t[Cache File %d]", nth_cache);
            nth_cache = nth_cache + 1;
          }
          continue;
        }
      }
    }

    else
      if(audio_end == 0)
      {
        signed int nbytes;
        unsigned long int return_value_fread_16;
        return_value_fread_16=fread((void *)sound_data, (unsigned long int)1, pdata->periodsize * (unsigned long int)pdata->sound_framesize, afp);
        nbytes = (signed int)return_value_fread_16;
        if(!(nbytes >= 1))
          audio_end = 1;

        else
          rmdSyncEncodeSoundBuffer(pdata, sound_data);
      }

  }
  pdata->th_encoding_clean = 1;
  pdata->v_encoding_clean = pdata->th_encoding_clean;
  pthread_mutex_lock(&pdata->theora_lib_mutex);
  pthread_cond_signal(&pdata->theora_lib_clean);
  pthread_mutex_unlock(&pdata->theora_lib_mutex);
  pthread_mutex_lock(&pdata->vorbis_lib_mutex);
  pthread_cond_signal(&pdata->vorbis_lib_clean);
  pthread_mutex_unlock(&pdata->vorbis_lib_mutex);
  fprintf(stdout, "\n");
  free((void *)frame.YData);
  free((void *)frame.UData);
  free((void *)frame.VData);
  free((void *)sound_data);
  if(pdata->args.nosound == 0)
    fclose(afp);

  pthread_exit((void *)&thread_exit);
}

// rmdMakeDummyPointer
// file rmd_make_dummy_pointer.h line 51
unsigned char * rmdMakeDummyPointer(struct _XDisplay *display, struct _DisplaySpecs *specs, signed int size, signed int color, signed int type, unsigned char *npxl)
{
  unsigned long int bpixel;
  bpixel=XBlackPixel(display, specs->screen);
  unsigned long int wpixel;
  wpixel=XWhitePixel(display, specs->screen);
  signed int i;
  signed int k;
  signed int o = 46;
  unsigned long int b = (unsigned long int)(color != 0 ? 119 : 98);
  unsigned long int w = (unsigned long int)(color != 0 ? 98 : 119);
  char pmask[1l][16l][16l] = { { { (char)w, (char)w, (char)o, (char)o, (char)o, (char)o, (char)o, (char)o, (char)o, (char)o, (char)o, (char)o, (char)o, (char)o, (char)o, (char)o },
    { (char)w, (char)b, (char)w, (char)o, (char)o, (char)o, (char)o, (char)o, (char)o, (char)o, (char)o, (char)o, (char)o, (char)o, (char)o, (char)o },
    { (char)w, (char)b, (char)b, (char)w, (char)o, (char)o, (char)o, (char)o, (char)o, (char)o, (char)o, (char)o, (char)o, (char)o, (char)o, (char)o },
    { (char)w, (char)b, (char)b, (char)b, (char)w, (char)o, (char)o, (char)o, (char)o, (char)o, (char)o, (char)o, (char)o, (char)o, (char)o, (char)o },
    { (char)w, (char)b, (char)b, (char)b, (char)b, (char)w, (char)o, (char)o, (char)o, (char)o, (char)o, (char)o, (char)o, (char)o, (char)o, (char)o },
    { (char)w, (char)b, (char)b, (char)b, (char)b, (char)b, (char)w, (char)o, (char)o, (char)o, (char)o, (char)o, (char)o, (char)o, (char)o, (char)o },
    { (char)w, (char)b, (char)b, (char)b, (char)b, (char)b, (char)b, (char)w, (char)o, (char)o, (char)o, (char)o, (char)o, (char)o, (char)o, (char)o },
    { (char)w, (char)b, (char)b, (char)b, (char)b, (char)b, (char)b, (char)b, (char)w, (char)o, (char)o, (char)o, (char)o, (char)o, (char)o, (char)o },
    { (char)w, (char)b, (char)b, (char)b, (char)b, (char)b, (char)b, (char)b, (char)b, (char)w, (char)o, (char)o, (char)o, (char)o, (char)o, (char)o },
    { (char)w, (char)b, (char)b, (char)b, (char)b, (char)b, (char)w, (char)w, (char)w, (char)w, (char)o, (char)o, (char)o, (char)o, (char)o, (char)o },
    { (char)w, (char)b, (char)b, (char)b, (char)b, (char)b, (char)w, (char)o, (char)o, (char)o, (char)o, (char)o, (char)o, (char)o, (char)o, (char)o },
    { (char)w, (char)b, (char)b, (char)w, (char)w, (char)b, (char)b, (char)w, (char)o, (char)o, (char)o, (char)o, (char)o, (char)o, (char)o, (char)o },
    { (char)w, (char)b, (char)w, (char)o, (char)w, (char)b, (char)b, (char)w, (char)o, (char)o, (char)o, (char)o, (char)o, (char)o, (char)o, (char)o },
    { (char)w, (char)w, (char)o, (char)o, (char)o, (char)w, (char)b, (char)b, (char)w, (char)o, (char)o, (char)o, (char)o, (char)o, (char)o, (char)o },
    { (char)o, (char)o, (char)o, (char)o, (char)o, (char)w, (char)b, (char)b, (char)w, (char)o, (char)o, (char)o, (char)o, (char)o, (char)o, (char)o },
    { (char)o, (char)o, (char)o, (char)o, (char)o, (char)o, (char)w, (char)w, (char)o, (char)o, (char)o, (char)o, (char)o, (char)o, (char)o, (char)o } } };
  unsigned char *ret;
  const signed long int ret_array_size0 = (signed long int)(size * 4);
  void *return_value_malloc_1;
  return_value_malloc_1=malloc((unsigned long int)size * (unsigned long int)ret_array_size0);
  ret = (unsigned char *)return_value_malloc_1;
  unsigned char wp[4l] = { (unsigned char)((wpixel ^ (unsigned long int)0xff000000) >> 24),
    (unsigned char)((wpixel ^ (unsigned long int)0x00ff0000) >> 16),
    (unsigned char)((wpixel ^ (unsigned long int)0x0000ff00) >> 8),
    (unsigned char)(wpixel ^ (unsigned long int)0x000000ff) };
  unsigned char bp[4l] = { (unsigned char)((bpixel ^ (unsigned long int)0xff000000) >> 24),
    (unsigned char)((bpixel ^ (unsigned long int)0x00ff0000) >> 16),
    (unsigned char)((bpixel ^ (unsigned long int)0x0000ff00) >> 8),
    (unsigned char)(bpixel ^ (unsigned long int)0x000000ff) };
  signed int tmp_if_expr_2;
  if(!((signed int)wp[0l] + -1 == (signed int)bp[0l]))
    tmp_if_expr_2 = (signed int)wp[(signed long int)0] - 100;

  else
    tmp_if_expr_2 = (signed int)wp[(signed long int)0] - 102;
  *npxl = (unsigned char)tmp_if_expr_2;
  i = 0;
  signed int tmp_if_expr_4;
  signed int tmp_if_expr_3;
  signed int tmp_if_expr_6;
  signed int tmp_if_expr_5;
  signed int tmp_if_expr_8;
  signed int tmp_if_expr_7;
  signed int tmp_if_expr_10;
  signed int tmp_if_expr_9;
  for( ; !(i >= size); i = i + 1)
  {
    k = 0;
    for( ; !(k >= size); k = k + 1)
    {
      if((signed int)pmask[(signed long int)type][(signed long int)i][(signed long int)k] == 119)
        tmp_if_expr_4 = (signed int)wp[(signed long int)0];

      else
      {
        if((signed int)pmask[(signed long int)type][(signed long int)i][(signed long int)k] == 98)
          tmp_if_expr_3 = (signed int)bp[(signed long int)0];

        else
          tmp_if_expr_3 = (signed int)*npxl;
        tmp_if_expr_4 = tmp_if_expr_3;
      }
      ret[(signed long int)((i * size + k) * 4 + 3)] = (unsigned char)tmp_if_expr_4;
      if((signed int)pmask[(signed long int)type][(signed long int)i][(signed long int)k] == 119)
        tmp_if_expr_6 = (signed int)wp[(signed long int)1];

      else
      {
        if((signed int)pmask[(signed long int)type][(signed long int)i][(signed long int)k] == 98)
          tmp_if_expr_5 = (signed int)bp[(signed long int)1];

        else
          tmp_if_expr_5 = (signed int)*npxl;
        tmp_if_expr_6 = tmp_if_expr_5;
      }
      ret[(signed long int)((i * size + k) * 4 + 2)] = (unsigned char)tmp_if_expr_6;
      if((signed int)pmask[(signed long int)type][(signed long int)i][(signed long int)k] == 119)
        tmp_if_expr_8 = (signed int)wp[(signed long int)2];

      else
      {
        if((signed int)pmask[(signed long int)type][(signed long int)i][(signed long int)k] == 98)
          tmp_if_expr_7 = (signed int)bp[(signed long int)2];

        else
          tmp_if_expr_7 = (signed int)*npxl;
        tmp_if_expr_8 = tmp_if_expr_7;
      }
      ret[(signed long int)((i * size + k) * 4 + 1)] = (unsigned char)tmp_if_expr_8;
      if((signed int)pmask[(signed long int)type][(signed long int)i][(signed long int)k] == 119)
        tmp_if_expr_10 = (signed int)wp[(signed long int)3];

      else
      {
        if((signed int)pmask[(signed long int)type][(signed long int)i][(signed long int)k] == 98)
          tmp_if_expr_9 = (signed int)bp[(signed long int)3];

        else
          tmp_if_expr_9 = (signed int)*npxl;
        tmp_if_expr_10 = tmp_if_expr_9;
      }
      ret[(signed long int)((i * size + k) * 4 + 0)] = (unsigned char)tmp_if_expr_10;
    }
  }
  return ret;
}

// rmdMakeMatrices
// file rmd_yuv_utils.h line 377
void rmdMakeMatrices(void)
{
  signed int i;
  float Yscale = (float)219.0;
  float Yoffset = (float)16.0;
  float Cscale = (float)224.0;
  float Coffset = (float)128.0;
  float RGBscale = (float)255.0;
  float r;
  float g;
  float b;
  float yr;
  float yg;
  float yb;
  float ur;
  float ug;
  float ub;
  float vg;
  float vb;
  r = (float)0.299;
  b = (float)0.114;
  g = (float)((1.0 - (double)r) - (double)b);
  yr = (r * Yscale) / RGBscale;
  yg = (g * Yscale) / RGBscale;
  yb = (b * Yscale) / RGBscale;
  ur = (float)((((-0.5 * (double)r) / (double)((float)1 - b)) * (double)Cscale) / (double)RGBscale);
  ug = (float)((((-0.5 * (double)g) / (double)((float)1 - b)) * (double)Cscale) / (double)RGBscale);
  ub = (float)((0.5 * (double)Cscale) / (double)RGBscale);
  vg = (float)((((-0.5 * (double)g) / (double)((float)1 - r)) * (double)Cscale) / (double)RGBscale);
  vb = (float)((((-0.5 * (double)b) / (double)((float)1 - r)) * (double)Cscale) / (double)RGBscale);
  i = 0;
  for( ; !(i >= 256); i = i + 1)
  {
    double return_value_rmdRoundf_1;
    return_value_rmdRoundf_1=rmdRoundf((double)(Yoffset + yr * (float)i));
    Yr[(signed long int)i] = (unsigned char)return_value_rmdRoundf_1;
    double return_value_rmdRoundf_2;
    return_value_rmdRoundf_2=rmdRoundf((double)(yg * (float)i));
    Yg[(signed long int)i] = (unsigned char)return_value_rmdRoundf_2;
    double return_value_rmdRoundf_3;
    return_value_rmdRoundf_3=rmdRoundf((double)(yb * (float)i));
    Yb[(signed long int)i] = (unsigned char)return_value_rmdRoundf_3;
    double return_value_rmdRoundf_4;
    return_value_rmdRoundf_4=rmdRoundf((double)(Coffset + ur * (float)i));
    Ur[(signed long int)i] = (unsigned char)return_value_rmdRoundf_4;
    double return_value_rmdRoundf_5;
    return_value_rmdRoundf_5=rmdRoundf((double)(ug * (float)i));
    Ug[(signed long int)i] = (unsigned char)return_value_rmdRoundf_5;
    double return_value_rmdRoundf_6;
    return_value_rmdRoundf_6=rmdRoundf((double)(ub * (float)i));
    UbVr[(signed long int)i] = (unsigned char)return_value_rmdRoundf_6;
    double return_value_rmdRoundf_7;
    return_value_rmdRoundf_7=rmdRoundf((double)(vg * (float)i));
    Vg[(signed long int)i] = (unsigned char)return_value_rmdRoundf_7;
    double return_value_rmdRoundf_8;
    return_value_rmdRoundf_8=rmdRoundf((double)(Coffset + vb * (float)i));
    Vb[(signed long int)i] = (unsigned char)return_value_rmdRoundf_8;
  }
}

// rmdMoveCaptureArea
// file rmd_get_frame.c line 286
static void rmdMoveCaptureArea(struct _BRWindow *brwin, signed int cursor_x, signed int cursor_y, signed int width, signed int height)
{
  signed int t_x = 0;
  signed int t_y = 0;
  t_x = cursor_x - (signed int)brwin->rrect.width / 2;
  t_x = (t_x >> 1) << 1;
  signed int tmp_if_expr_2;
  signed int tmp_if_expr_1;
  if(!(t_x >= 0))
    tmp_if_expr_2 = 0;

  else
  {
    if(!(width >= t_x + (signed int)brwin->rrect.width))
      tmp_if_expr_1 = width - (signed int)brwin->rrect.width;

    else
      tmp_if_expr_1 = t_x;
    tmp_if_expr_2 = tmp_if_expr_1;
  }
  brwin->rrect.x = (signed short int)tmp_if_expr_2;
  t_y = cursor_y - (signed int)brwin->rrect.height / 2;
  t_y = (t_y >> 1) << 1;
  signed int tmp_if_expr_4;
  signed int tmp_if_expr_3;
  if(!(t_y >= 0))
    tmp_if_expr_4 = 0;

  else
  {
    if(!(height >= t_y + (signed int)brwin->rrect.height))
      tmp_if_expr_3 = height - (signed int)brwin->rrect.height;

    else
      tmp_if_expr_3 = t_y;
    tmp_if_expr_4 = tmp_if_expr_3;
  }
  brwin->rrect.y = (signed short int)tmp_if_expr_4;
}

// rmdMoveFrame
// file rmd_frame.c line 80
void rmdMoveFrame(struct _XDisplay *dpy, unsigned long int win, signed int x, signed int y)
{
  XMoveWindow(dpy, win, x - 6, y - 6);
}

// rmdOpenDev
// file rmd_opendev.h line 57
struct _snd_pcm * rmdOpenDev(const char *pcm_dev, unsigned int *channels, unsigned int *frequency, unsigned long int *buffsize, unsigned long int *periodsize, unsigned int *periodtime, signed int *hard_pause)
{
  struct _snd_pcm *mhandle;
  struct _snd_pcm_hw_params *hwparams;
  unsigned int periods = (unsigned int)2;
  unsigned int exactrate = *frequency;
  do
  {
    unsigned long int return_value_snd_pcm_hw_params_sizeof_1;
    return_value_snd_pcm_hw_params_sizeof_1=snd_pcm_hw_params_sizeof();
    void *return_value___builtin_alloca_2;
    return_value___builtin_alloca_2=__builtin_alloca(return_value_snd_pcm_hw_params_sizeof_1);
    *(&hwparams) = (struct _snd_pcm_hw_params *)return_value___builtin_alloca_2;
    unsigned long int return_value_snd_pcm_hw_params_sizeof_3;
    return_value_snd_pcm_hw_params_sizeof_3=snd_pcm_hw_params_sizeof();
    memset((void *)*(&hwparams), 0, return_value_snd_pcm_hw_params_sizeof_3);
  }
  while((_Bool)0);
  signed int return_value_snd_pcm_open_4;
  return_value_snd_pcm_open_4=snd_pcm_open(&mhandle, pcm_dev, (enum _snd_pcm_stream)SND_PCM_STREAM_CAPTURE, 0x00000002);
  if(!(return_value_snd_pcm_open_4 >= 0))
  {
    fprintf(stderr, "Couldn't open PCM device %s\n", pcm_dev);
    return (struct _snd_pcm *)(void *)0;
  }

  else
    fprintf(stderr, "Opened PCM device %s\n", pcm_dev);
  signed int return_value_snd_pcm_hw_params_any_5;
  return_value_snd_pcm_hw_params_any_5=snd_pcm_hw_params_any(mhandle, hwparams);
  signed int return_value_snd_pcm_hw_params_can_pause_13;
  if(!(return_value_snd_pcm_hw_params_any_5 >= 0))
  {
    fprintf(stderr, "Couldn't configure PCM device.\n");
    return (struct _snd_pcm *)(void *)0;
  }

  else
  {
    signed int return_value_snd_pcm_hw_params_set_access_6;
    return_value_snd_pcm_hw_params_set_access_6=snd_pcm_hw_params_set_access(mhandle, hwparams, (enum _snd_pcm_access)SND_PCM_ACCESS_RW_INTERLEAVED);
    if(!(return_value_snd_pcm_hw_params_set_access_6 >= 0))
    {
      fprintf(stderr, "Couldn't set access.\n");
      return (struct _snd_pcm *)(void *)0;
    }

    else
    {
      signed int return_value_snd_pcm_hw_params_set_format_7;
      return_value_snd_pcm_hw_params_set_format_7=snd_pcm_hw_params_set_format(mhandle, hwparams, (enum _snd_pcm_format)SND_PCM_FORMAT_S16_LE);
      if(!(return_value_snd_pcm_hw_params_set_format_7 >= 0))
      {
        fprintf(stderr, "Couldn't set format.\n");
        return (struct _snd_pcm *)(void *)0;
      }

      else
      {
        signed int return_value_snd_pcm_hw_params_set_rate_near_8;
        return_value_snd_pcm_hw_params_set_rate_near_8=snd_pcm_hw_params_set_rate_near(mhandle, hwparams, &exactrate, ((signed int *)NULL));
        if(!(return_value_snd_pcm_hw_params_set_rate_near_8 >= 0))
        {
          fprintf(stderr, "Couldn't set frequency.\n");
          return (struct _snd_pcm *)(void *)0;
        }

        else
        {
          if(!(*frequency == exactrate))
          {
            fprintf(stderr, "Playback frequency %dHz is not available...\nUsing %dHz instead.\n", *frequency, exactrate);
            *frequency = exactrate;
          }

          signed int return_value_snd_pcm_hw_params_set_channels_near_9;
          return_value_snd_pcm_hw_params_set_channels_near_9=snd_pcm_hw_params_set_channels_near(mhandle, hwparams, channels);
          if(!(return_value_snd_pcm_hw_params_set_channels_near_9 >= 0))
          {
            fprintf(stderr, "Couldn't set channels number.\n");
            return (struct _snd_pcm *)(void *)0;
          }

          else
            if(*channels >= 3u)
            {
              fprintf(stderr, "Channels number should be 1(mono) or 2(stereo).\n");
              return (struct _snd_pcm *)(void *)0;
            }

            else
            {
              signed int return_value_snd_pcm_hw_params_set_periods_near_10;
              return_value_snd_pcm_hw_params_set_periods_near_10=snd_pcm_hw_params_set_periods_near(mhandle, hwparams, &periods, ((signed int *)NULL));
              if(!(return_value_snd_pcm_hw_params_set_periods_near_10 >= 0))
              {
                fprintf(stderr, "Couldn't set periods.\n");
                return (struct _snd_pcm *)(void *)0;
              }

              else
              {
                signed int return_value_snd_pcm_hw_params_set_buffer_size_near_11;
                return_value_snd_pcm_hw_params_set_buffer_size_near_11=snd_pcm_hw_params_set_buffer_size_near(mhandle, hwparams, buffsize);
                if(!(return_value_snd_pcm_hw_params_set_buffer_size_near_11 >= 0))
                {
                  fprintf(stderr, "Couldn't set buffer size.\n");
                  return (struct _snd_pcm *)(void *)0;
                }

                else
                {
                  signed int return_value_snd_pcm_hw_params_12;
                  return_value_snd_pcm_hw_params_12=snd_pcm_hw_params(mhandle, hwparams);
                  if(!(return_value_snd_pcm_hw_params_12 >= 0))
                  {
                    fprintf(stderr, "Couldn't set hardware parameters.\n");
                    return (struct _snd_pcm *)(void *)0;
                  }

                  else
                  {
                    if(!(hard_pause == ((signed int *)NULL)))
                    {
                      return_value_snd_pcm_hw_params_can_pause_13=snd_pcm_hw_params_can_pause(hwparams);
                      if(return_value_snd_pcm_hw_params_can_pause_13 == 0)
                        *hard_pause = 1;

                    }

                    if(!(periodsize == ((unsigned long int *)NULL)))
                      snd_pcm_hw_params_get_period_size(hwparams, periodsize, ((signed int *)NULL));

                    if(!(periodtime == ((unsigned int *)NULL)))
                      snd_pcm_hw_params_get_period_time(hwparams, periodtime, ((signed int *)NULL));

                    fprintf(stderr, "Recording on device %s is set to:\n%d channels at %dHz\n", pcm_dev, *channels, *frequency);
                    snd_pcm_prepare(mhandle);
                    return mhandle;
                  }
                }
              }
            }
        }
      }
    }
  }
}

// rmdParseArgs
// file rmd_parseargs.h line 44
signed int rmdParseArgs(signed int argc, char **argv, struct _ProgArgs *arg_return)
{
  struct poptContext_s *popt_context = (struct poptContext_s *)(void *)0;
  signed int no_cursor = 0;
  signed int quick_subsampling = 0;
  signed int compress_cache = 0;
  signed int success = (signed int)!(0 != 0);
  signed int arg_id = 0;
  struct poptOption generic_options[5l] = { { .longName=(const char *)(void *)0, .shortName=(char)0, .argInfo=5U,
    .arg=(void *)rmdPrintAndExit, .val=0,
    .descrip=(const char *)(void *)0, .argDescrip=(const char *)(void *)0 },
    { .longName="help", .shortName=(char)104, .argInfo=0U,
    .arg=(void *)0, .val=0, .descrip="Print this help and exit.",
    .argDescrip=(const char *)(void *)0 },
    { .longName="version", .shortName=(char)0, .argInfo=0U,
    .arg=(void *)0, .val=0, .descrip="Print program version and exit.",
    .argDescrip=(const char *)(void *)0 },
    { .longName="print-config", .shortName=(char)0, .argInfo=0U,
    .arg=(void *)0, .val=0, .descrip="Print info about options selected during compilation and exit.",
    .argDescrip=(const char *)(void *)0 },
    { .longName=(const char *)(void *)0, .shortName=(char)0, .argInfo=(unsigned int)0,
    .arg=(void *)0, .val=0,
    .descrip=(const char *)(void *)0, .argDescrip=(const char *)(void *)0 } };
  struct poptOption image_options[14l] = { { .longName="windowid", .shortName=(char)0, .argInfo=2U,
    .arg=(void *)&arg_return->windowid, .val=0,
    .descrip="id of window to be recorded.", .argDescrip="id_of_window" },
    { .longName="display", .shortName=(char)0, .argInfo=1U,
    .arg=(void *)&arg_return->display, .val=0,
    .descrip="Display to connect to.", .argDescrip="DISPLAY" },
    { .longName="x", .shortName=(char)120, .argInfo=2U, .arg=(void *)&arg_return->x,
    .val=0, .descrip="Offset in x direction.",
    .argDescrip="N>=0" },
    { .longName="x", .shortName=(char)121, .argInfo=2U, .arg=(void *)&arg_return->y,
    .val=0, .descrip="Offset in y direction.",
    .argDescrip="N>=0" },
    { .longName="width", .shortName=(char)0, .argInfo=2U,
    .arg=(void *)&arg_return->width, .val=0,
    .descrip="Width of recorded window.", .argDescrip="N>0" },
    { .longName="height", .shortName=(char)0, .argInfo=2U,
    .arg=(void *)&arg_return->height, .val=0,
    .descrip="Height of recorded window.", .argDescrip="N>0" },
    { .longName="dummy-cursor", .shortName=(char)0, .argInfo=1U,
    .arg=(void *)0, .val=2, .descrip="Color of the dummy cursor [black|white]",
    .argDescrip="color" },
    { .longName="no-cursor", .shortName=(char)0, .argInfo=0U,
    .arg=(void *)&no_cursor, .val=0,
    .descrip="Disable drawing of the cursor.", .argDescrip=(const char *)(void *)0 },
    { .longName="no-shared", .shortName=(char)0, .argInfo=0U,
    .arg=(void *)&arg_return->noshared, .val=0,
    .descrip="Disable usage of MIT-shared memory extension(Not Recommended!).", .argDescrip=(const char *)(void *)0 },
    { .longName="full-shots", .shortName=(char)0, .argInfo=0U,
    .arg=(void *)&arg_return->full_shots, .val=0,
    .descrip="Take full screenshot at every frame(Not recomended!).", .argDescrip=(const char *)(void *)0 },
    { .longName="follow-mouse", .shortName=(char)0, .argInfo=0U,
    .arg=(void *)&arg_return->follow_mouse, .val=0,
    .descrip="Makes the capture area follow the mouse cursor. Autoenables --full-shots.", .argDescrip=(const char *)(void *)0 },
    { .longName="quick-subsampling", .shortName=(char)0, .argInfo=0U,
    .arg=(void *)&quick_subsampling, .val=0,
    .descrip="Do subsampling of the chroma planes by discarding, not averaging.", .argDescrip=(const char *)(void *)0 },
    { .longName="fps", .shortName=(char)0, .argInfo=8U, .arg=(void *)&arg_return->fps,
    .val=0, .descrip="A positive number denoting desired framerate.",
    .argDescrip="N(number>0.0)" },
    { .longName=(const char *)(void *)0, .shortName=(char)0, .argInfo=(unsigned int)0,
    .arg=(void *)0, .val=0,
    .descrip=(const char *)(void *)0, .argDescrip=(const char *)(void *)0 } };
  struct poptOption sound_options[8l] = { { .longName="channels", .shortName=(char)0, .argInfo=2U,
    .arg=(void *)&arg_return->channels, .val=0,
    .descrip="A positive number denoting desired sound channels in recording.", .argDescrip="N" },
    { .longName="freq", .shortName=(char)0, .argInfo=2U, .arg=(void *)&arg_return->frequency,
    .val=0,
    .descrip="A positive number denoting desired sound frequency.", .argDescrip="N" },
    { .longName="buffer-size", .shortName=(char)0, .argInfo=2U,
    .arg=(void *)&arg_return->buffsize, .val=0,
    .descrip="A positive number denoting the desired sound buffer size (in frames,when using ALSA or OSS)", .argDescrip="N" },
    { .longName="ring-buffer-size", .shortName=(char)0, .argInfo=8U,
    .arg=(void *)&arg_return->jack_ringbuffer_secs, .val=0,
    .descrip="A float number denoting the desired ring buffer size (in seconds,when using JACK only).", .argDescrip="N" },
    { .longName="device", .shortName=(char)0, .argInfo=1U,
    .arg=(void *)&arg_return->device, .val=0,
    .descrip="Sound device(default hw:0,0).", .argDescrip="SOUND_DEVICE" },
    { .longName="use-jack", .shortName=(char)0, .argInfo=1U | (unsigned int)0,
    .arg=(void *)&arg_return->x, .val=3,
    .descrip="Record audio from the specified list of space-separated jack ports.", .argDescrip="port1 port2... portn" },
    { .longName="no-sound", .shortName=(char)0, .argInfo=0U,
    .arg=(void *)&arg_return->nosound, .val=0,
    .descrip="Do not record sound.", .argDescrip=(const char *)(void *)0 },
    { .longName=(const char *)(void *)0, .shortName=(char)0, .argInfo=(unsigned int)0,
    .arg=(void *)0, .val=0,
    .descrip=(const char *)(void *)0, .argDescrip=(const char *)(void *)0 } };
  struct poptOption encoding_options[5l] = { { .longName="on-the-fly-encoding", .shortName=(char)0, .argInfo=0U,
    .arg=(void *)&arg_return->encOnTheFly, .val=0,
    .descrip="Encode the audio-video data, while recording.", .argDescrip=(const char *)(void *)0 },
    { .longName="v_quality", .shortName=(char)0, .argInfo=2U,
    .arg=(void *)&arg_return->v_quality, .val=0,
    .descrip="A number from 0 to 63 for desired encoded video quality(default 63).", .argDescrip="n" },
    { .longName="v_bitrate", .shortName=(char)0, .argInfo=2U,
    .arg=(void *)&arg_return->v_bitrate, .val=0,
    .descrip="A number from 0 to 2000000 for desired encoded video bitrate(default 0).", .argDescrip="n" },
    { .longName="s_quality", .shortName=(char)0, .argInfo=2U,
    .arg=(void *)&arg_return->s_quality, .val=0,
    .descrip="Desired audio quality(-1 to 10).", .argDescrip="n" },
    { .longName=(const char *)(void *)0, .shortName=(char)0, .argInfo=(unsigned int)0,
    .arg=(void *)0, .val=0,
    .descrip=(const char *)(void *)0, .argDescrip=(const char *)(void *)0 } };
  struct poptOption misc_options[12l] = { { .longName="rescue", .shortName=(char)0, .argInfo=1U,
    .arg=(void *)&arg_return->rescue_path, .val=0,
    .descrip="Encode data from a previous, crashed, session.", .argDescrip="path_to_data" },
    { .longName="no-encode", .shortName=(char)0, .argInfo=0U | 0x40000000U,
    .arg=(void *)&arg_return->no_encode, .val=0,
    .descrip="Do not encode any data after recording is complete. This is instead done manually afterwards with --rescue.", .argDescrip=(const char *)(void *)0 },
    { .longName="no-wm-check", .shortName=(char)0, .argInfo=0U,
    .arg=(void *)&arg_return->nowmcheck, .val=0,
    .descrip="Do not try to detect the window manager(and set options according to it)", .argDescrip=(const char *)(void *)0 },
    { .longName="no-frame", .shortName=(char)0, .argInfo=0U,
    .arg=(void *)&arg_return->noframe, .val=0,
    .descrip="Don not show the frame that visualizes the recorded area.", .argDescrip=(const char *)(void *)0 },
    { .longName="pause-shortcut", .shortName=(char)0, .argInfo=1U,
    .arg=(void *)&arg_return->pause_shortcut, .val=0,
    .descrip="Shortcut that will be used for (un)pausing (default Control+Mod1+p).", .argDescrip="MOD+KEY" },
    { .longName="stop-shortcut", .shortName=(char)0, .argInfo=1U,
    .arg=(void *)&arg_return->stop_shortcut, .val=0,
    .descrip="Shortcut that will be used to stop the recording (default Control+Mod1+s).", .argDescrip="MOD+KEY" },
    { .longName="compress-cache", .shortName=(char)0, .argInfo=0U,
    .arg=(void *)&compress_cache, .val=0,
    .descrip="Image data are cached with light compression.", .argDescrip=(const char *)(void *)0 },
    { .longName="workdir", .shortName=(char)0, .argInfo=1U,
    .arg=(void *)&arg_return->workdir, .val=0,
    .descrip="Location where a temporary directory will be created to hold project files(default _HOME).", .argDescrip="DIR" },
    { .longName="delay", .shortName=(char)0, .argInfo=1U,
    .arg=(void *)&arg_return->delay, .val=1,
    .descrip="Number of secs(default),minutes or hours before capture starts(number can be float)", .argDescrip="n[H|h|M|m]" },
    { .longName="overwrite", .shortName=(char)0, .argInfo=0U,
    .arg=(void *)&arg_return->overwrite, .val=0,
    .descrip="If there is already a file with the same name, delete it (default is to add a number postfix to the new one).", .argDescrip=(const char *)(void *)0 },
    { .longName="output", .shortName=(char)111, .argInfo=1U,
    .arg=(void *)&arg_return->filename, .val=0,
    .descrip="Name of recorded video(default out.ogv).", .argDescrip="filename" },
    { .longName=(const char *)(void *)0, .shortName=(char)0, .argInfo=(unsigned int)0,
    .arg=(void *)0, .val=0,
    .descrip=(const char *)(void *)0, .argDescrip=(const char *)(void *)0 } };
  struct poptOption rmd_args[6l] = { { .longName=(const char *)(void *)0, .shortName=(char)0, .argInfo=4U,
    .arg=(void *)generic_options, .val=0,
    .descrip="Generic Options", .argDescrip=(const char *)(void *)0 },
    { .longName=(const char *)(void *)0, .shortName=(char)0, .argInfo=4U,
    .arg=(void *)image_options, .val=0,
    .descrip="Image Options", .argDescrip=(const char *)(void *)0 },
    { .longName=(const char *)(void *)0, .shortName=(char)0, .argInfo=4U,
    .arg=(void *)sound_options, .val=0,
    .descrip="Sound Options", .argDescrip=(const char *)(void *)0 },
    { .longName=(const char *)(void *)0, .shortName=(char)0, .argInfo=4U,
    .arg=(void *)encoding_options, .val=0,
    .descrip="Encoding Options", .argDescrip=(const char *)(void *)0 },
    { .longName=(const char *)(void *)0, .shortName=(char)0, .argInfo=4U,
    .arg=(void *)misc_options, .val=0,
    .descrip="Misc Options", .argDescrip=(const char *)(void *)0 },
    { .longName=(const char *)(void *)0, .shortName=(char)0, .argInfo=(unsigned int)0,
    .arg=(void *)0, .val=0,
    .descrip=(const char *)(void *)0, .argDescrip=(const char *)(void *)0 } };
  popt_context=poptGetContext((const char *)(void *)0, argc, (const char **)argv, rmd_args, (unsigned int)0);
  poptSetOtherOptionHelp(popt_context, "[OPTIONS]^filename");
  unsigned long int return_value_strlen_2;
  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_3;
  signed int return_value_strcmp_5;
  do
  {
    arg_id=poptGetNextOpt(popt_context);
    if(!(arg_id >= 1))
      break;

    char *arg;
    arg=poptGetOptArg(popt_context);
    switch(arg_id)
    {
      case 1:
      {
        float num;
        double return_value_atof_1;
        return_value_atof_1=atof(arg);
        num = (float)return_value_atof_1;
        if(num > 0.000000f)
        {
          signed int k = 0;
          do
          {
            return_value_strlen_2=strlen(arg);
            if((unsigned long int)k >= return_value_strlen_2)
              break;

            if((signed int)arg[(signed long int)k] == 77)
              tmp_if_expr_4 = (_Bool)1;

            else
              tmp_if_expr_4 = (signed int)arg[(signed long int)k] == 109 ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr_4)
            {
              num = num * (float)60.0;
              break;
            }

            else
            {
              if((signed int)arg[(signed long int)k] == 72)
                tmp_if_expr_3 = (_Bool)1;

              else
                tmp_if_expr_3 = (signed int)arg[(signed long int)k] == 104 ? (_Bool)1 : (_Bool)0;
              if(tmp_if_expr_3)
              {
                num = num * (float)3600.0;
                break;
              }

            }
            k = k + 1;
          }
          while((_Bool)1);
          arg_return->delay = (signed int)num;
        }

        else
        {
          fprintf(stderr, "Argument Usage: --delay n[H|h|M|m]\nwhere n is a float number\n");
          success = 0;
        }
        break;
      }
      case 2:
      {
        signed int return_value_strcmp_6;
        return_value_strcmp_6=strcmp(arg, "white");
        if(return_value_strcmp_6 == 0)
          arg_return->cursor_color = 0;

        else
        {
          return_value_strcmp_5=strcmp(arg, "black");
          if(return_value_strcmp_5 == 0)
            arg_return->cursor_color = 1;

          else
          {
            fprintf(stderr, "Argument Usage:\n --dummy-cursor [black|white]\n");
            success = 0;
          }
        }
        arg_return->have_dummy_cursor = (signed int)!(0 != 0);
        arg_return->xfixes_cursor = 0;
        break;
      }
      case 3:
      {
        arg_return->jack_nports = (unsigned int)0;
        while(!(arg == ((char *)NULL)))
        {
          arg_return->jack_nports = arg_return->jack_nports + 1u;
          unsigned long int return_value_strlen_7;
          return_value_strlen_7=strlen(arg);
          void *return_value_malloc_8;
          return_value_malloc_8=malloc(return_value_strlen_7 + (unsigned long int)1);
          arg_return->jack_port_names[(signed long int)(arg_return->jack_nports - (unsigned int)1)] = (char *)return_value_malloc_8;
          strcpy(arg_return->jack_port_names[(signed long int)(arg_return->jack_nports - (unsigned int)1)], arg);
          arg=poptGetOptArg(popt_context);
        }
        if(arg_return->jack_nports >= 1u)
          arg_return->use_jack = 1;

        else
        {
          fprintf(stderr, "Argument Usage: --use-jack port1 port2... portn\n");
          success = 0;
        }
      }
    }
  }
  while((_Bool)1);
  const char *return_value_poptGetArg_9;
  if(arg_id == -1)
  {
    if(!(no_cursor == 0))
      arg_return->xfixes_cursor = 0;

    if(!(quick_subsampling == 0))
      arg_return->no_quick_subsample = 0;

    if(!(compress_cache == 0))
      arg_return->zerocompression = 0;

    if(!(arg_return->follow_mouse == 0))
      arg_return->full_shots = (signed int)!(0 != 0);

    if(arg_return->filename == ((char *)NULL))
    {
      return_value_poptGetArg_9=poptGetArg(popt_context);
      arg_return->filename=strdup(return_value_poptGetArg_9);
    }

  }

  else
  {
    const char *str;
    str=poptBadOption(popt_context, (unsigned int)0);
    success = 0;
    fprintf(stderr, "Error when parsing `%s': ", str);
    if(!(arg_id == -10))
    {
      if(arg_id == -17)
        goto __CPROVER_DUMP_L31;

    }

    else
    {
      fprintf(stderr, "Missing argument\n");
      goto __CPROVER_DUMP_L33;

    __CPROVER_DUMP_L31:
      ;
      fprintf(stderr, "Bad number\n");
      goto __CPROVER_DUMP_L33;
    }
    fprintf(stderr, "libpopt error: %d\n", arg_id);
  }

__CPROVER_DUMP_L33:
  ;
  _Bool tmp_if_expr_11;
  signed int return_value_rmdValidateArguments_10;
  if(!(success == 0))
  {
    return_value_rmdValidateArguments_10=rmdValidateArguments(arg_return);
    tmp_if_expr_11 = return_value_rmdValidateArguments_10 != 0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_11 = (_Bool)0;
  success = (signed int)tmp_if_expr_11;
  poptFreeContext(popt_context);
  return success;
}

// rmdPrintAndExit
// file rmd_parseargs.c line 487
static void rmdPrintAndExit(struct poptContext_s *con, enum poptCallbackReason reason, struct poptOption *opt, const char *arg, const void *data)
{
  signed int return_value_strcmp_3;
  return_value_strcmp_3=strcmp(opt->longName, "version");
  signed int return_value_strcmp_2;
  signed int return_value_strcmp_1;
  if(return_value_strcmp_3 == 0)
    fprintf(stderr, "recordMyDesktop v%s\n\n", (const void *)"0.3.8.1");

  else
  {
    return_value_strcmp_2=strcmp(opt->longName, "help");
    if(return_value_strcmp_2 == 0)
    {
      poptPrintHelp(con, stdout, 0);
      fprintf(stdout, "\n\tIf no other options are specified, filename can be given without the -o switch.\n\n\n");
    }

    else
    {
      return_value_strcmp_1=strcmp(opt->longName, "print-config");
      if(return_value_strcmp_1 == 0)
        fprintf(stdout, "\nrecordMyDesktop was compiled with the following options:\n\nJack:\t\t\tEnabled\nDefault Audio Backend:\tALSA\n\n\n");

    }
  }
  exit(0);
}

// rmdPurgeCache
// file rmd_cache.h line 77
signed int rmdPurgeCache(struct _CacheData *cache_data_t, signed int sound)
{
  struct stat buff;
  char *fname;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(cache_data_t->imgdata);
  void *return_value_malloc_2;
  return_value_malloc_2=malloc(return_value_strlen_1 + (unsigned long int)10);
  fname = (char *)return_value_malloc_2;
  strcpy(fname, cache_data_t->imgdata);
  signed int exit_value = 0;
  signed int nth_cache = 1;
  signed int return_value_stat_3;
  do
  {
    return_value_stat_3=stat(fname, &buff);
    if(!(return_value_stat_3 == 0))
      break;

    signed int return_value_remove_4;
    return_value_remove_4=remove(fname);
    if(!(return_value_remove_4 == 0))
    {
      fprintf(stderr, "Couldn't remove temporary file %s", cache_data_t->imgdata);
      exit_value = 1;
    }

    rmdCacheFileN(cache_data_t->imgdata, &fname, nth_cache);
    nth_cache = nth_cache + 1;
  }
  while((_Bool)1);
  free((void *)fname);
  if(!(sound == 0))
  {
    signed int return_value_remove_5;
    return_value_remove_5=remove(cache_data_t->audiodata);
    if(!(return_value_remove_5 == 0))
    {
      fprintf(stderr, "Couldn't remove temporary file %s", cache_data_t->audiodata);
      exit_value = 1;
    }

  }

  signed int return_value_remove_6;
  return_value_remove_6=remove(cache_data_t->specsfile);
  if(!(return_value_remove_6 == 0))
  {
    fprintf(stderr, "Couldn't remove temporary file %s", cache_data_t->specsfile);
    exit_value = 1;
  }

  signed int return_value_remove_7;
  return_value_remove_7=remove(cache_data_t->projname);
  if(!(return_value_remove_7 == 0))
  {
    fprintf(stderr, "Couldn't remove temporary directory %s", cache_data_t->projname);
    exit_value = 1;
  }

  return exit_value;
}

// rmdQueryExtensions
// file rmd_queryextensions.h line 46
void rmdQueryExtensions(struct _XDisplay *dpy, struct _ProgArgs *args, signed int *damage_event, signed int *damage_error, signed int *shm_opcode)
{
  signed int xf_event_basep;
  signed int xf_error_basep;
  signed int shm_event_base;
  signed int shm_error_base;
  signed int shape_event_base;
  signed int shape_error_base;
  signed int return_value_XDamageQueryExtension_1;
  if(args->full_shots == 0)
  {
    return_value_XDamageQueryExtension_1=XDamageQueryExtension(dpy, damage_event, damage_error);
    if(return_value_XDamageQueryExtension_1 == 0)
    {
      fprintf(stderr, "XDamage extension not found!!!\nTry again using the --full-shots option, though\nenabling XDamage is highly recommended,\nfor performance reasons.\n");
      exit(4);
    }

  }

  signed int return_value_XQueryExtension_2;
  if(args->noshared == 0)
  {
    return_value_XQueryExtension_2=XQueryExtension(dpy, "MIT-SHM", shm_opcode, &shm_event_base, &shm_error_base);
    if(return_value_XQueryExtension_2 == 0)
    {
      args->noshared = 1;
      fprintf(stderr, "Shared Memory extension not present!\nTry again using the --no-shared option\n");
      exit(5);
    }

  }

  signed int return_value_XFixesQueryExtension_3;
  if(!(args->xfixes_cursor == 0))
  {
    return_value_XFixesQueryExtension_3=XFixesQueryExtension(dpy, &xf_event_basep, &xf_error_basep);
    if(return_value_XFixesQueryExtension_3 == 0)
    {
      args->xfixes_cursor = 0;
      fprintf(stderr, "Xfixes extension not present!\nPlease run with the -dummy-cursor or --no-cursor option.\n");
      exit(6);
    }

  }

  signed int return_value_XShapeQueryExtension_4;
  if(args->noframe == 0)
  {
    return_value_XShapeQueryExtension_4=XShapeQueryExtension(dpy, &shape_event_base, &shape_error_base);
    if(return_value_XShapeQueryExtension_4 == 0)
    {
      fprintf(stderr, "XShape Not Found!!!\nFrame won't be available.\n");
      args->noframe = 1;
    }

  }

}

// rmdReadFrame
// file rmd_load_cache.c line 96
static signed int rmdReadFrame(struct _CachedFrame *frame, struct _IO_FILE *ucfp, struct gzFile_s **ifp)
{
  signed int index_entry_size = (signed int)sizeof(unsigned int) /*4ul*/ ;
  if(frame->header->Ynum >= 1u)
  {
    signed int return_value_rmdReadZF_1;
    return_value_rmdReadZF_1=rmdReadZF((void *)frame->YBlocks, (unsigned long int)index_entry_size, (unsigned long int)frame->header->Ynum, ucfp, ifp);
    if(!((unsigned int)return_value_rmdReadZF_1 == frame->header->Ynum * (unsigned int)index_entry_size))
      return -1;

  }

  if(frame->header->Unum >= 1u)
  {
    signed int return_value_rmdReadZF_2;
    return_value_rmdReadZF_2=rmdReadZF((void *)frame->UBlocks, (unsigned long int)index_entry_size, (unsigned long int)frame->header->Unum, ucfp, ifp);
    if(!((unsigned int)return_value_rmdReadZF_2 == frame->header->Unum * (unsigned int)index_entry_size))
      return -1;

  }

  if(frame->header->Vnum >= 1u)
  {
    signed int return_value_rmdReadZF_3;
    return_value_rmdReadZF_3=rmdReadZF((void *)frame->VBlocks, (unsigned long int)index_entry_size, (unsigned long int)frame->header->Vnum, ucfp, ifp);
    if(!((unsigned int)return_value_rmdReadZF_3 == frame->header->Vnum * (unsigned int)index_entry_size))
      return -1;

  }

  if(frame->header->Ynum >= 1u)
  {
    signed int return_value_rmdReadZF_4;
    return_value_rmdReadZF_4=rmdReadZF((void *)frame->YData, (unsigned long int)0x0100, (unsigned long int)frame->header->Ynum, ucfp, ifp);
    if(!((unsigned int)return_value_rmdReadZF_4 == 256u * frame->header->Ynum))
      return -2;

  }

  if(frame->header->Unum >= 1u)
  {
    signed int return_value_rmdReadZF_5;
    return_value_rmdReadZF_5=rmdReadZF((void *)frame->UData, (unsigned long int)0x0040, (unsigned long int)frame->header->Unum, ucfp, ifp);
    if(!((unsigned int)return_value_rmdReadZF_5 == 64u * frame->header->Unum))
      return -2;

  }

  if(frame->header->Vnum >= 1u)
  {
    signed int return_value_rmdReadZF_6;
    return_value_rmdReadZF_6=rmdReadZF((void *)frame->VData, (unsigned long int)0x0040, (unsigned long int)frame->header->Vnum, ucfp, ifp);
    if(!((unsigned int)return_value_rmdReadZF_6 == 64u * frame->header->Vnum))
      return -2;

  }

  return 0;
}

// rmdReadSpecsFile
// file rmd_specsfile.h line 56
signed int rmdReadSpecsFile(struct _ProgData *pdata)
{
  struct _IO_FILE *fp;
  fp=fopen(pdata->cache_data->specsfile, "rb");
  if(fp == ((struct _IO_FILE *)NULL))
    return 1;

  else
  {
    char Cached_Version[256l];
    free((void *)pdata->args.filename);
    void *return_value_malloc_1;
    return_value_malloc_1=malloc((unsigned long int)512);
    pdata->args.filename = (char *)return_value_malloc_1;
    signed int return_value_fscanf_2;
    return_value_fscanf_2=fscanf(fp, "recordMyDesktop = %s\n", (const void *)Cached_Version);
    if(!(return_value_fscanf_2 == 1))
    {
      fprintf(stderr, "Error reading VERSION attribute!!!\n");
      return 1;
    }

    signed int return_value_fscanf_3;
    return_value_fscanf_3=fscanf(fp, "Width = %hu\n", &pdata->brwin.rrect.width);
    if(!(return_value_fscanf_3 == 1))
    {
      fprintf(stderr, "Error reading Width attribute!!!\n");
      return 1;
    }

    signed int return_value_fscanf_4;
    return_value_fscanf_4=fscanf(fp, "Height = %hu\n", &pdata->brwin.rrect.height);
    if(!(return_value_fscanf_4 == 1))
    {
      fprintf(stderr, "Error reading Height attribute!!!\n");
      return 1;
    }

    signed int return_value_fscanf_5;
    return_value_fscanf_5=fscanf(fp, "Filename = %s\n", pdata->args.filename);
    if(!(return_value_fscanf_5 == 1))
    {
      fprintf(stderr, "Error reading Filename attribute!!!\n");
      return 1;
    }

    signed int return_value_fscanf_6;
    return_value_fscanf_6=fscanf(fp, "FPS = %f\n", &pdata->args.fps);
    if(!(return_value_fscanf_6 == 1))
    {
      fprintf(stderr, "Error reading FPS attribute!!!\n");
      return 1;
    }

    signed int return_value_fscanf_7;
    return_value_fscanf_7=fscanf(fp, "NoSound = %d\n", &pdata->args.nosound);
    if(!(return_value_fscanf_7 == 1))
    {
      fprintf(stderr, "Error reading NoSound attribute!!!\n");
      return 1;
    }

    signed int return_value_fscanf_8;
    return_value_fscanf_8=fscanf(fp, "Frequency = %d\n", &pdata->args.frequency);
    if(!(return_value_fscanf_8 == 1))
    {
      fprintf(stderr, "Error reading Frequency attribute!!!\n");
      return 1;
    }

    signed int return_value_fscanf_9;
    return_value_fscanf_9=fscanf(fp, "Channels = %d\n", &pdata->args.channels);
    if(!(return_value_fscanf_9 == 1))
    {
      fprintf(stderr, "Error reading Channels attribute!!!\n");
      return 1;
    }

    signed int return_value_fscanf_10;
    return_value_fscanf_10=fscanf(fp, "BufferSize = %lu\n", (unsigned long int *)&pdata->args.buffsize);
    if(!(return_value_fscanf_10 == 1))
    {
      fprintf(stderr, "Error reading BufferSize attribute!!!\n");
      return 1;
    }

    signed int return_value_fscanf_11;
    return_value_fscanf_11=fscanf(fp, "SoundFrameSize = %d\n", &pdata->sound_framesize);
    if(!(return_value_fscanf_11 == 1))
    {
      fprintf(stderr, "Error reading SoundFrameSize attribute!!!\n");
      return 1;
    }

    signed int return_value_fscanf_12;
    return_value_fscanf_12=fscanf(fp, "PeriodSize = %lu\n", (unsigned long int *)&pdata->periodsize);
    if(!(return_value_fscanf_12 == 1))
    {
      fprintf(stderr, "Error reading PeriodSize attribute!!!\n");
      return 1;
    }

    signed int return_value_fscanf_13;
    return_value_fscanf_13=fscanf(fp, "UsedJack = %u\n", &pdata->args.use_jack);
    if(!(return_value_fscanf_13 == 1))
    {
      fprintf(stderr, "Error reading UsedJack attribute!!!\n");
      return 1;
    }

    signed int return_value_fscanf_14;
    return_value_fscanf_14=fscanf(fp, "v_bitrate = %d\n", &pdata->args.v_bitrate);
    if(!(return_value_fscanf_14 == 1))
    {
      fprintf(stderr, "Error reading v_bitrate attribute!!!\n");
      return 1;
    }

    signed int return_value_fscanf_15;
    return_value_fscanf_15=fscanf(fp, "v_quality = %d\n", &pdata->args.v_quality);
    if(!(return_value_fscanf_15 == 1))
    {
      fprintf(stderr, "Error reading v_quality attribute!!!\n");
      return 1;
    }

    signed int return_value_fscanf_16;
    return_value_fscanf_16=fscanf(fp, "s_quality = %d\n", &pdata->args.s_quality);
    if(!(return_value_fscanf_16 == 1))
    {
      fprintf(stderr, "Error reading s_quality attribute!!!\n");
      return 1;
    }

    signed int return_value_fscanf_17;
    return_value_fscanf_17=fscanf(fp, "ZeroCompression = %d\n", &pdata->args.zerocompression);
    if(!(return_value_fscanf_17 == 1))
    {
      fprintf(stderr, "Error reading ZeroCompression attribute!!!\n");
      return 1;
    }

  }
  fclose(fp);
  return 0;
}

// rmdReadZF
// file rmd_load_cache.c line 85
static signed int rmdReadZF(void *buffer, unsigned long int size, unsigned long int nmemb, struct _IO_FILE *ucfp, struct gzFile_s **ifp)
{
  signed int return_value_gzread_2;
  if(ifp == ((struct gzFile_s **)NULL) && ucfp == ((struct _IO_FILE *)NULL) || !(ifp == ((struct gzFile_s **)NULL)) && !(ucfp == ((struct _IO_FILE *)NULL)))
    return -1;

  else
    if(!(ucfp == ((struct _IO_FILE *)NULL)))
    {
      unsigned long int return_value_fread_1;
      return_value_fread_1=fread(buffer, size, nmemb, ucfp);
      return (signed int)(size * return_value_fread_1);
    }

    else
    {
      return_value_gzread_2=gzread((struct gzFile_s *)ifp, buffer, (unsigned int)(size * nmemb));
      return return_value_gzread_2;
    }
}

// rmdRectInsert
// file rmd_rectinsert.h line 46
signed int rmdRectInsert(struct _RectArea **root, struct anonymous_17 *xrect)
{
  signed int total_insertions = 0;
  struct _RectArea *temp = (struct _RectArea *)(void *)0;
  struct _RectArea *newnode;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct _RectArea) /*24ul*/ );
  newnode = (struct _RectArea *)return_value_malloc_1;
  xrect->width = xrect->width + (unsigned short int)((signed int)xrect->width % 2 | (signed int)xrect->x % 2);
  xrect->height = xrect->height + (unsigned short int)((signed int)xrect->height % 2 | (signed int)xrect->y % 2);
  xrect->width = xrect->width + (unsigned short int)((signed int)xrect->width % 2);
  xrect->height = xrect->height + (unsigned short int)((signed int)xrect->height % 2);
  xrect->x = xrect->x - (signed short int)((signed int)xrect->x % 2);
  xrect->y = xrect->y - (signed short int)((signed int)xrect->y % 2);
  newnode->rect.x = xrect->x;
  newnode->rect.y = xrect->y;
  newnode->rect.width = xrect->width;
  newnode->rect.height = xrect->height;
  newnode->next = (struct _RectArea *)(void *)0;
  newnode->prev = newnode->next;
  signed int return_value_rmdRectInsert_2;
  signed int return_value_rmdRectInsert_3;
  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_9;
  _Bool tmp_if_expr_8;
  _Bool tmp_if_expr_7;
  _Bool tmp_if_expr_6;
  signed int return_value_rmdRectInsert_11;
  signed int return_value_rmdRectInsert_12;
  signed int return_value_rmdRectInsert_13;
  if(*root == ((struct _RectArea *)NULL))
  {
    *root = newnode;
    total_insertions = 1;
  }

  else
  {
    struct anonymous_17 xrect_return[2l];
    signed int nrects = 0;
    signed int insert_ok = 1;
    signed int i = 0;
    temp = *root;
    while(!(insert_ok == 0))
    {
      signed int collres;
      collres=rmdCollideRects(&temp->rect, xrect, &xrect_return[(signed long int)0], &nrects);
      if(collres == 0)
        insert_ok = 1;

      else
      {
        i = 0;
        for( ; !(i >= nrects); i = i + 1)
        {
          xrect_return[(signed long int)i].width = xrect_return[(signed long int)i].width + (unsigned short int)((signed int)xrect_return[(signed long int)i].width % 2 | (signed int)xrect_return[(signed long int)i].x % 2);
          xrect_return[(signed long int)i].height = xrect_return[(signed long int)i].height + (unsigned short int)((signed int)xrect_return[(signed long int)i].height % 2 | (signed int)xrect_return[(signed long int)i].y % 2);
          xrect_return[(signed long int)i].width = xrect_return[(signed long int)i].width + (unsigned short int)((signed int)xrect_return[(signed long int)i].width % 2);
          xrect_return[(signed long int)i].height = xrect_return[(signed long int)i].height + (unsigned short int)((signed int)xrect_return[(signed long int)i].height % 2);
          xrect_return[(signed long int)i].x = xrect_return[(signed long int)i].x - (signed short int)((signed int)xrect_return[(signed long int)i].x % 2);
          xrect_return[(signed long int)i].y = xrect_return[(signed long int)i].y - (signed short int)((signed int)xrect_return[(signed long int)i].y % 2);
        }
        insert_ok = 0;
        if(!(collres == 1))
        {
          if(collres == 2)
            goto __CPROVER_DUMP_L18;

          if(collres == -1)
            goto __CPROVER_DUMP_L19;

          if(collres == -2)
            goto __CPROVER_DUMP_L36;

          if(collres == -10)
            goto __CPROVER_DUMP_L42;

        }

        else
        {
          total_insertions = total_insertions - 1;
          if(!(temp->prev == ((struct _RectArea *)NULL)))
          {
            if(!(temp->next == ((struct _RectArea *)NULL)))
            {
              struct _RectArea *temp1 = temp->next;
              temp->prev->next = temp->next;
              temp->next->prev = temp->prev;
              free((void *)temp);
              if((signed int)xrect->width >= 1)
              {
                if((signed int)xrect->height >= 1)
                {
                  return_value_rmdRectInsert_2=rmdRectInsert(&temp1, xrect);
                  total_insertions = total_insertions + return_value_rmdRectInsert_2;
                }

              }

            }

            else
            {
              temp->prev->next = newnode;
              newnode->prev = temp->prev;
              total_insertions = total_insertions + 1;
              free((void *)temp);
            }
          }

          else
          {
            if(!((*root)->next == ((struct _RectArea *)NULL)))
            {
              *root = (*root)->next;
              (*root)->prev = (struct _RectArea *)(void *)0;
              if((signed int)xrect->width >= 1)
              {
                if((signed int)xrect->height >= 1)
                {
                  return_value_rmdRectInsert_3=rmdRectInsert(root, xrect);
                  total_insertions = total_insertions + return_value_rmdRectInsert_3;
                }

              }

            }

            else
            {
              if((signed int)xrect->width >= 1)
                tmp_if_expr_4 = (signed int)xrect->height > 0 ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr_4 = (_Bool)0;
              if(tmp_if_expr_4)
              {
                *root = newnode;
                total_insertions = total_insertions + 1;
              }

              else
              {
                *root = (struct _RectArea *)(void *)0;
                total_insertions = total_insertions + 1;
              }
            }
            free((void *)temp);
          }
          goto __CPROVER_DUMP_L49;

        __CPROVER_DUMP_L18:
          ;
          free((void *)newnode);
          goto __CPROVER_DUMP_L49;

        __CPROVER_DUMP_L19:
          ;
          if((signed int)xrect_return[0l].width >= 1)
            tmp_if_expr_9 = (signed int)xrect_return[(signed long int)0].height > 0 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_9 = (_Bool)0;
          if(tmp_if_expr_9)
          {
            temp->rect.x = xrect_return[(signed long int)0].x;
            temp->rect.y = xrect_return[(signed long int)0].y;
            temp->rect.width = xrect_return[(signed long int)0].width;
            temp->rect.height = xrect_return[(signed long int)0].height;
            if(temp->next == ((struct _RectArea *)NULL))
            {
              temp->next = newnode;
              newnode->prev = temp;
              total_insertions = total_insertions + 1;
            }

            else
              insert_ok = 1;
          }

          else
          {
            if(temp->prev == ((struct _RectArea *)NULL))
              tmp_if_expr_8 = temp->next != (struct _RectArea *)(void *)0 ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr_8 = (_Bool)0;
            if(tmp_if_expr_8)
            {
              *root = (*root)->next;
              (*root)->prev = (struct _RectArea *)(void *)0;
            }

            else
            {
              if(temp->next == ((struct _RectArea *)NULL))
                tmp_if_expr_7 = temp->prev != (struct _RectArea *)(void *)0 ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr_7 = (_Bool)0;
              if(tmp_if_expr_7)
              {
                temp->prev->next = newnode;
                newnode->prev = temp->prev;
              }

              else
              {
                if(temp->next == ((struct _RectArea *)NULL))
                  tmp_if_expr_6 = temp->prev == (struct _RectArea *)(void *)0 ? (_Bool)1 : (_Bool)0;

                else
                  tmp_if_expr_6 = (_Bool)0;
                if(tmp_if_expr_6)
                  *root = newnode;

                else
                {
                  total_insertions = total_insertions - 1;
                  temp->next->prev = temp->prev;
                  temp->prev->next = temp->next;
                  signed int return_value_rmdRectInsert_5;
                  return_value_rmdRectInsert_5=rmdRectInsert(&temp->next, xrect);
                  total_insertions = total_insertions + return_value_rmdRectInsert_5;
                }
              }
            }
            free((void *)temp);
          }
          goto __CPROVER_DUMP_L49;

        __CPROVER_DUMP_L36:
          ;
          if(temp->next == ((struct _RectArea *)NULL))
          {
            total_insertions = total_insertions + nrects;
            newnode->rect.x = xrect_return[(signed long int)0].x;
            newnode->rect.y = xrect_return[(signed long int)0].y;
            newnode->rect.width = xrect_return[(signed long int)0].width;
            newnode->rect.height = xrect_return[(signed long int)0].height;
            temp->next = newnode;
            newnode->prev = temp;
            if(nrects >= 2)
            {
              struct _RectArea *newnode1;
              void *return_value_malloc_10;
              return_value_malloc_10=malloc(sizeof(struct _RectArea) /*24ul*/ );
              newnode1 = (struct _RectArea *)return_value_malloc_10;
              newnode1->rect.x = xrect_return[(signed long int)1].x;
              newnode1->rect.y = xrect_return[(signed long int)1].y;
              newnode1->rect.width = xrect_return[(signed long int)1].width;
              newnode1->rect.height = xrect_return[(signed long int)1].height;
              newnode->next = newnode1;
              newnode1->prev = newnode;
              newnode1->next = (struct _RectArea *)(void *)0;
            }

          }

          else
          {
            i = 0;
            for( ; !(i >= nrects); i = i + 1)
              if((signed int)xrect_return[(signed long int)i].width >= 1)
              {
                if((signed int)xrect_return[(signed long int)i].height >= 1)
                {
                  return_value_rmdRectInsert_11=rmdRectInsert(&temp->next, &xrect_return[(signed long int)i]);
                  total_insertions = total_insertions + return_value_rmdRectInsert_11;
                }

              }

          }
          goto __CPROVER_DUMP_L49;

        __CPROVER_DUMP_L42:
          ;
          if(temp->prev == ((struct _RectArea *)NULL))
          {
            if(temp->next == ((struct _RectArea *)NULL))
            {
              newnode->rect.x = xrect_return[(signed long int)0].x;
              newnode->rect.y = xrect_return[(signed long int)0].y;
              newnode->rect.width = xrect_return[(signed long int)0].width;
              newnode->rect.height = xrect_return[(signed long int)0].height;
              *root = newnode;
              free((void *)temp);
            }

            else
            {
              total_insertions = total_insertions - 1;
              *root = temp->next;
              (*root)->prev = (struct _RectArea *)(void *)0;
              free((void *)temp);
              if((signed int)xrect_return[0l].width >= 1)
              {
                if((signed int)xrect_return[0l].height >= 1)
                {
                  return_value_rmdRectInsert_12=rmdRectInsert(root, &xrect_return[(signed long int)0]);
                  total_insertions = total_insertions + return_value_rmdRectInsert_12;
                }

              }

            }
          }

          else
            if(temp->next == ((struct _RectArea *)NULL))
            {
              newnode->rect.x = xrect_return[(signed long int)0].x;
              newnode->rect.y = xrect_return[(signed long int)0].y;
              newnode->rect.width = xrect_return[(signed long int)0].width;
              newnode->rect.height = xrect_return[(signed long int)0].height;
              temp->prev->next = newnode;
              newnode->prev = temp->prev;
              free((void *)temp);
            }

            else
            {
              total_insertions = total_insertions - 1;
              struct _RectArea *rmdRectInsert__1__2__1__1__2__9__temp1 = temp->next;
              temp->prev->next = temp->next;
              temp->next->prev = temp->prev;
              free((void *)temp);
              if((signed int)xrect_return[0l].width >= 1)
              {
                if((signed int)xrect_return[0l].height >= 1)
                {
                  return_value_rmdRectInsert_13=rmdRectInsert(&rmdRectInsert__1__2__1__1__2__9__temp1, &xrect_return[(signed long int)0]);
                  total_insertions = total_insertions + return_value_rmdRectInsert_13;
                }

              }

            }
        }
      }

    __CPROVER_DUMP_L49:
      ;
      if(!(insert_ok == 0))
      {
        if(temp->next == ((struct _RectArea *)NULL))
        {
          temp->next = newnode;
          newnode->prev = temp;
          total_insertions = total_insertions + 1;
          break;
        }

        else
          temp = temp->next;
      }

      else
        break;
    }
  }
  return total_insertions;
}

// rmdRegisterCallbacks
// file rmd_register_callbacks.c line 60
void rmdRegisterCallbacks(struct _ProgData *pdata)
{
  struct sigaction pause_act;
  struct sigaction end_act;
  pdata_running = &pdata->running;
  pdata_paused = &pdata->paused;
  pdata_aborted = &pdata->aborted;
  pdata_pause_state_changed = &pdata->pause_state_changed;
  sigfillset(&pause_act.sa_mask);
  pause_act.sa_flags = 0x10000000;
  pause_act.__sigaction_handler.sa_handler = rmdSetPaused;
  sigaction(10, &pause_act, (struct sigaction *)(void *)0);
  sigfillset(&end_act.sa_mask);
  end_act.sa_flags = 0x10000000;
  end_act.__sigaction_handler.sa_handler = rmdSetRunning;
  sigaction(2, &end_act, (struct sigaction *)(void *)0);
  sigaction(15, &end_act, (struct sigaction *)(void *)0);
  sigaction(6, &end_act, (struct sigaction *)(void *)0);
}

// rmdRegisterShortcut
// file rmd_shortcuts.h line 51
signed int rmdRegisterShortcut(struct _XDisplay *dpy, unsigned long int root, const char *shortcut, struct _HotKey *hotkey)
{
  signed int keycode = 0;
  signed int i;
  signed int j;
  unsigned long int key = (unsigned long int)0;
  unsigned int modifier_mask = (unsigned int)0;
  unsigned int numlock_mask = (unsigned int)0;
  char *keystr = (char *)(void *)0;
  struct anonymous_95 *modmap;
  char *return_value_strstr_1;
  return_value_strstr_1=strstr(shortcut, "Shift");
  if(!(return_value_strstr_1 == ((char *)NULL)))
    modifier_mask = modifier_mask | (unsigned int)(1 << 0);

  char *return_value_strstr_2;
  return_value_strstr_2=strstr(shortcut, "Control");
  if(!(return_value_strstr_2 == ((char *)NULL)))
    modifier_mask = modifier_mask | (unsigned int)(1 << 2);

  char *return_value_strstr_3;
  return_value_strstr_3=strstr(shortcut, "Mod1");
  if(!(return_value_strstr_3 == ((char *)NULL)))
    modifier_mask = modifier_mask | (unsigned int)(1 << 3);

  char *return_value_strstr_4;
  return_value_strstr_4=strstr(shortcut, "Mod2");
  if(!(return_value_strstr_4 == ((char *)NULL)))
    modifier_mask = modifier_mask | (unsigned int)(1 << 4);

  char *return_value_strstr_5;
  return_value_strstr_5=strstr(shortcut, "Mod3");
  if(!(return_value_strstr_5 == ((char *)NULL)))
    modifier_mask = modifier_mask | (unsigned int)(1 << 5);

  char *return_value_strstr_6;
  return_value_strstr_6=strstr(shortcut, "Mod4");
  if(!(return_value_strstr_6 == ((char *)NULL)))
    modifier_mask = modifier_mask | (unsigned int)(1 << 6);

  char *return_value_strstr_7;
  return_value_strstr_7=strstr(shortcut, "Mod5");
  if(!(return_value_strstr_7 == ((char *)NULL)))
    modifier_mask = modifier_mask | (unsigned int)(1 << 7);

  unsigned char return_value_XKeysymToKeycode_8;
  if(modifier_mask == 0u)
    return 1;

  else
  {
    keystr=rindex(shortcut, 43);
    if(!(keystr == ((char *)NULL)))
    {
      keystr = keystr + 1l;
      key=XStringToKeysym(keystr);
      if(key == 0ul)
        return 1;

      else
      {
        return_value_XKeysymToKeycode_8=XKeysymToKeycode(dpy, key);
        keycode = (signed int)return_value_XKeysymToKeycode_8;
      }
    }

    else
      return 1;
    modmap=XGetModifierMapping(dpy);
    i = 0;
    for( ; !(i >= 8); i = i + 1)
    {
      j = 0;
      for( ; !(j >= modmap->max_keypermod); j = j + 1)
      {
        unsigned char return_value_XKeysymToKeycode_9;
        return_value_XKeysymToKeycode_9=XKeysymToKeycode(dpy, (unsigned long int)0xff7f);
        if(modmap->modifiermap[(signed long int)(modmap->max_keypermod * i + j)] == return_value_XKeysymToKeycode_9)
          numlock_mask = (unsigned int)(1 << i);

      }
    }
    XFreeModifiermap(modmap);
    hotkey->modnum = 0;
    hotkey->key = keycode;
    XGrabKey(dpy, keycode, modifier_mask, root, 1, 1, 1);
    hotkey->mask[(signed long int)0] = modifier_mask;
    hotkey->modnum = hotkey->modnum + 1;
    XGrabKey(dpy, keycode, (unsigned int)(1 << 1) | modifier_mask, root, 1, 1, 1);
    hotkey->mask[(signed long int)1] = (unsigned int)(1 << 1) | modifier_mask;
    hotkey->modnum = hotkey->modnum + 1;
    if(!(numlock_mask == 0u))
    {
      XGrabKey(dpy, keycode, numlock_mask | modifier_mask, root, 1, 1, 1);
      hotkey->mask[(signed long int)2] = numlock_mask | modifier_mask;
      hotkey->modnum = hotkey->modnum + 1;
      XGrabKey(dpy, keycode, numlock_mask | (unsigned int)(1 << 1) | modifier_mask, root, 1, 1, 1);
      hotkey->mask[(signed long int)3] = numlock_mask | (unsigned int)(1 << 1) | modifier_mask;
      hotkey->modnum = hotkey->modnum + 1;
    }

    return 0;
  }
}

// rmdRescue
// file rmd_rescue.h line 39
signed int rmdRescue(const char *path)
{
  signed int i = 0;
  signed int offset_x;
  signed int offset_y;
  unsigned short int width;
  unsigned short int height;
  struct _ProgData pdata;
  struct _EncData enc_data;
  struct _CacheData cache_data;
  rmdSetupDefaultArgs(&pdata.args);
  pdata.enc_data = &enc_data;
  pdata.cache_data = &cache_data;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(path);
  void *return_value_malloc_2;
  return_value_malloc_2=malloc(return_value_strlen_1 + (unsigned long int)2);
  cache_data.projname = (char *)return_value_malloc_2;
  strcpy(cache_data.projname, path);
  strcat(cache_data.projname, "/");
  unsigned long int return_value_strlen_3;
  return_value_strlen_3=strlen(cache_data.projname);
  void *return_value_malloc_4;
  return_value_malloc_4=malloc(return_value_strlen_3 + (unsigned long int)11);
  cache_data.imgdata = (char *)return_value_malloc_4;
  strcpy(cache_data.imgdata, cache_data.projname);
  strcat(cache_data.imgdata, "img.out");
  unsigned long int return_value_strlen_5;
  return_value_strlen_5=strlen(cache_data.projname);
  void *return_value_malloc_6;
  return_value_malloc_6=malloc(return_value_strlen_5 + (unsigned long int)10);
  cache_data.audiodata = (char *)return_value_malloc_6;
  strcpy(cache_data.audiodata, cache_data.projname);
  strcat(cache_data.audiodata, "audio.pcm");
  unsigned long int return_value_strlen_7;
  return_value_strlen_7=strlen(cache_data.projname);
  void *return_value_malloc_8;
  return_value_malloc_8=malloc(return_value_strlen_7 + (unsigned long int)10);
  cache_data.specsfile = (char *)return_value_malloc_8;
  strcpy(cache_data.specsfile, cache_data.projname);
  strcat(cache_data.specsfile, "specs.txt");
  signed int return_value_rmdReadSpecsFile_9;
  return_value_rmdReadSpecsFile_9=rmdReadSpecsFile(&pdata);
  if(!(return_value_rmdReadSpecsFile_9 == 0))
    return 1;

  else
  {
    width = (unsigned short int)(((signed int)pdata.brwin.rrect.width + 15 >> 4) << 4);
    height = (unsigned short int)(((signed int)pdata.brwin.rrect.height + 15 >> 4) << 4);
    offset_x = ((signed int)width - (signed int)pdata.brwin.rrect.width) / 2 & ~1;
    offset_y = ((signed int)height - (signed int)pdata.brwin.rrect.height) / 2 & ~1;
    void *return_value_malloc_10;
    return_value_malloc_10=malloc((unsigned long int)((signed int)height * (signed int)width));
    enc_data.yuv.y = (unsigned char *)return_value_malloc_10;
    void *return_value_malloc_11;
    return_value_malloc_11=malloc((unsigned long int)(((signed int)height * (signed int)width) / 4));
    enc_data.yuv.u = (unsigned char *)return_value_malloc_11;
    void *return_value_malloc_12;
    return_value_malloc_12=malloc((unsigned long int)(((signed int)height * (signed int)width) / 4));
    enc_data.yuv.v = (unsigned char *)return_value_malloc_12;
    enc_data.yuv.y_width = (signed int)width;
    enc_data.yuv.y_height = (signed int)height;
    enc_data.yuv.y_stride = (signed int)width;
    enc_data.yuv.uv_width = (signed int)width / 2;
    enc_data.yuv.uv_height = (signed int)height / 2;
    enc_data.yuv.uv_stride = (signed int)width / 2;
    enc_data.x_offset = offset_x;
    enc_data.y_offset = offset_y;
    i = 0;
    for( ; !(i >= enc_data.yuv.y_height * enc_data.yuv.y_width); i = i + 1)
      enc_data.yuv.y[(signed long int)i] = (unsigned char)0;
    i = 0;
    for( ; !(i >= enc_data.yuv.uv_height * enc_data.yuv.uv_width); i = i + 1)
    {
      enc_data.yuv.u[(signed long int)i] = (unsigned char)127;
      enc_data.yuv.v[(signed long int)i] = enc_data.yuv.u[(signed long int)i];
    }
    void *return_value_malloc_13;
    return_value_malloc_13=malloc(sizeof(unsigned int) /*4ul*/  * (unsigned long int)(enc_data.yuv.y_width / 0x0010) * (unsigned long int)(enc_data.yuv.y_height / 0x0010));
    yblocks = (unsigned int *)return_value_malloc_13;
    void *return_value_malloc_14;
    return_value_malloc_14=malloc(sizeof(unsigned int) /*4ul*/  * (unsigned long int)(enc_data.yuv.y_width / 0x0010) * (unsigned long int)(enc_data.yuv.y_height / 0x0010));
    ublocks = (unsigned int *)return_value_malloc_14;
    void *return_value_malloc_15;
    return_value_malloc_15=malloc(sizeof(unsigned int) /*4ul*/  * (unsigned long int)(enc_data.yuv.y_width / 0x0010) * (unsigned long int)(enc_data.yuv.y_height / 0x0010));
    vblocks = (unsigned int *)return_value_malloc_15;
    pdata.frametime = (unsigned int)((float)1000000 / pdata.args.fps);
    pthread_mutex_init(&pdata.theora_lib_mutex, (const union anonymous_141 *)(void *)0);
    pthread_mutex_init(&pdata.vorbis_lib_mutex, (const union anonymous_141 *)(void *)0);
    pthread_mutex_init(&pdata.libogg_mutex, (const union anonymous_141 *)(void *)0);
    pthread_cond_init(&pdata.theora_lib_clean, (const union anonymous_141 *)(void *)0);
    pthread_cond_init(&pdata.vorbis_lib_clean, (const union anonymous_141 *)(void *)0);
    pdata.v_encoding_clean = 1;
    pdata.th_encoding_clean = pdata.v_encoding_clean;
    pdata.avd = 0;
    pdata.sound_buffer = (struct _SndBuffer *)(void *)0;
    pdata.running = (signed int)!(0 != 0);
    pdata.aborted = 0;
    rmdRegisterCallbacks(&pdata);
    fprintf(stderr, "Restoring %s!!!\n", path);
    rmdEncodeCache(&pdata);
    fprintf(stderr, "Done!!!\n");
    fprintf(stderr, "Goodbye!\n");
    rmdCleanUp();
    return 0;
  }
}

// rmdRoundf
// file rmd_math.c line 31
double rmdRoundf(double val)
{
  float tmp_if_expr_3;
  float return_value_ceilf_1;
  float return_value_floorf_2;
  if(val < 0.0)
  {
    return_value_ceilf_1=ceilf((float)(val - 0.5));
    tmp_if_expr_3 = return_value_ceilf_1;
  }

  else
  {
    return_value_floorf_2=floorf((float)(val + 0.5));
    tmp_if_expr_3 = return_value_floorf_2;
  }
  return (double)tmp_if_expr_3;
}

// rmdSetBRWindow
// file rmd_setbrwindow.h line 47
signed int rmdSetBRWindow(struct _XDisplay *dpy, struct _BRWindow *brwin, struct _DisplaySpecs *specs, struct _ProgArgs *args)
{
  unsigned int tmp_if_expr_1;
  unsigned int tmp_if_expr_2;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_4;
  signed int tmp_if_expr_5;
  signed int tmp_if_expr_6;
  _Bool tmp_if_expr_7;
  if(args->windowid == 0ul)
  {
    brwin->windowid = specs->root;
    brwin->rect.y = (signed short int)0;
    brwin->rect.x = brwin->rect.y;
    brwin->rect.width = (unsigned short int)specs->width;
    brwin->rect.height = (unsigned short int)specs->height;
    brwin->rrect.x = (signed short int)args->x;
    brwin->rrect.y = (signed short int)args->y;
    if(!(args->width == 0))
      tmp_if_expr_1 = (unsigned int)args->width;

    else
      tmp_if_expr_1 = specs->width - (unsigned int)brwin->rrect.x;
    brwin->rrect.width = (unsigned short int)tmp_if_expr_1;
    if(!(args->height == 0))
      tmp_if_expr_2 = (unsigned int)args->height;

    else
      tmp_if_expr_2 = specs->height - (unsigned int)brwin->rrect.y;
    brwin->rrect.height = (unsigned short int)tmp_if_expr_2;
    if(!(specs->width >= (unsigned int)(signed int)brwin->rrect.x + (unsigned int)(signed int)brwin->rrect.width))
      tmp_if_expr_3 = (_Bool)1;

    else
      tmp_if_expr_3 = (unsigned int)((signed int)brwin->rrect.y + (signed int)brwin->rrect.height) > specs->height ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_3)
    {
      fprintf(stderr, "Window size specification out of bounds!(current resolution:%dx%d)\n", specs->width, specs->height);
      return 0;
    }

  }

  else
  {
    unsigned long int wchid;
    signed int transl_x;
    signed int transl_y;
    struct anonymous attribs;
    XGetWindowAttributes(dpy, args->windowid, &attribs);
    if(attribs.map_state == 0 || attribs.map_state == 1)
    {
      fprintf(stderr, "Window must be mapped and visible!\n");
      return 0;
    }

    XTranslateCoordinates(dpy, specs->root, args->windowid, attribs.x, attribs.y, &transl_x, &transl_y, &wchid);
    brwin->rect.x = (signed short int)(attribs.x - transl_x);
    brwin->rect.y = (signed short int)(attribs.y - transl_y);
    brwin->rect.width = (unsigned short int)attribs.width;
    brwin->rect.height = (unsigned short int)attribs.height;
    if(!(specs->width >= (unsigned int)(signed int)brwin->rect.x + (unsigned int)(signed int)brwin->rect.width))
      tmp_if_expr_4 = (_Bool)1;

    else
      tmp_if_expr_4 = (unsigned int)((signed int)brwin->rect.y + (signed int)brwin->rect.height) > specs->height ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_4)
    {
      fprintf(stderr, "Window must be on visible screen area!\n");
      return 0;
    }

    brwin->rrect.x = (signed short int)((signed int)brwin->rect.x + args->x);
    brwin->rrect.y = (signed short int)((signed int)brwin->rect.y + args->y);
    if(!(args->width == 0))
      tmp_if_expr_5 = args->width;

    else
      tmp_if_expr_5 = (signed int)brwin->rect.width - args->x;
    brwin->rrect.width = (unsigned short int)tmp_if_expr_5;
    if(!(args->height == 0))
      tmp_if_expr_6 = args->height;

    else
      tmp_if_expr_6 = (signed int)brwin->rect.height - args->y;
    brwin->rrect.height = (unsigned short int)tmp_if_expr_6;
    if(!((signed int)brwin->rect.width >= args->x + (signed int)brwin->rrect.width))
      tmp_if_expr_7 = (_Bool)1;

    else
      tmp_if_expr_7 = args->y + (signed int)brwin->rrect.height > (signed int)brwin->rect.height ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_7)
    {
      fprintf(stderr, "Specified Area is larger than window!\n");
      return 0;
    }

  }
  fprintf(stderr, "Initial recording window is set to:\nX:%d   Y:%d    Width:%d    Height:%d\n", brwin->rrect.x, brwin->rrect.y, brwin->rrect.width, brwin->rrect.height);
  rmdSizePack2_8_16(&brwin->rrect.x, &brwin->rrect.width, (unsigned short int)specs->width);
  rmdSizePack2_8_16(&brwin->rrect.y, &brwin->rrect.height, (unsigned short int)specs->height);
  fprintf(stderr, "Adjusted recording window is set to:\nX:%d   Y:%d    Width:%d    Height:%d\n", brwin->rrect.x, brwin->rrect.y, brwin->rrect.width, brwin->rrect.height);
  brwin->nbytes = (((signed int)brwin->rrect.width + 15 >> 4) << 4) * (((signed int)brwin->rrect.height + 15 >> 4) << 4) * (specs->depth == 16 ? 2 : 4);
  return (signed int)!(0 != 0);
}

// rmdSetPaused
// file rmd_register_callbacks.c line 43
static void rmdSetPaused(signed int signum)
{
  *pdata_pause_state_changed = (signed int)!(0 != 0);
}

// rmdSetRunning
// file rmd_register_callbacks.c line 48
static void rmdSetRunning(signed int signum)
{
  if(*pdata_paused == 0)
  {
    *pdata_running = 0;
    if(signum == 6)
      *pdata_aborted = (signed int)!(0 != 0);

  }

}

// rmdSetupDefaultArgs
// file rmd_initialize_data.h line 52
void rmdSetupDefaultArgs(struct _ProgArgs *args)
{
  args->delay = 0;
  args->windowid = (unsigned long int)0;
  args->x = 0;
  args->y = 0;
  args->width = 0;
  args->height = 0;
  args->rescue_path = (const char *)(void *)0;
  args->nosound = 0;
  args->full_shots = 0;
  args->follow_mouse = 0;
  args->encOnTheFly = 0;
  args->nowmcheck = 0;
  args->overwrite = 0;
  args->use_jack = 0;
  args->noshared = 0;
  args->no_encode = 0;
  args->noframe = 0;
  args->jack_nports = (unsigned int)0;
  args->jack_ringbuffer_secs = (float)3.0;
  args->zerocompression = 1;
  args->no_quick_subsample = 1;
  args->cursor_color = 1;
  args->have_dummy_cursor = 0;
  args->xfixes_cursor = 1;
  args->fps = (float)15;
  args->channels = (unsigned int)1;
  args->frequency = (unsigned int)22050;
  args->buffsize = (unsigned long int)4096;
  args->v_bitrate = 0;
  args->v_quality = 63;
  args->s_quality = 10;
  char *return_value_getenv_5;
  return_value_getenv_5=getenv("DISPLAY");
  if(!(return_value_getenv_5 == ((char *)NULL)))
  {
    char *return_value_getenv_1;
    return_value_getenv_1=getenv("DISPLAY");
    unsigned long int return_value_strlen_2;
    return_value_strlen_2=strlen(return_value_getenv_1);
    void *return_value_malloc_3;
    return_value_malloc_3=malloc(return_value_strlen_2 + (unsigned long int)1);
    args->display = (char *)return_value_malloc_3;
    char *return_value_getenv_4;
    return_value_getenv_4=getenv("DISPLAY");
    strcpy(args->display, return_value_getenv_4);
  }

  else
    args->display = (char *)(void *)0;
  memset((void *)args->jack_port_names, 0, sizeof(char *[100l]) /*800ul*/ );
  unsigned long int return_value_strlen_6;
  return_value_strlen_6=strlen("hw:0,0");
  void *return_value_malloc_7;
  return_value_malloc_7=malloc(return_value_strlen_6 + (unsigned long int)1);
  args->device = (char *)return_value_malloc_7;
  strcpy(args->device, "hw:0,0");
  void *return_value_malloc_8;
  return_value_malloc_8=malloc((unsigned long int)5);
  args->workdir = (char *)return_value_malloc_8;
  strcpy(args->workdir, "/tmp");
  void *return_value_malloc_9;
  return_value_malloc_9=malloc((unsigned long int)15);
  args->pause_shortcut = (char *)return_value_malloc_9;
  strcpy(args->pause_shortcut, "Control+Mod1+p");
  void *return_value_malloc_10;
  return_value_malloc_10=malloc((unsigned long int)15);
  args->stop_shortcut = (char *)return_value_malloc_10;
  strcpy(args->stop_shortcut, "Control+Mod1+s");
  void *return_value_malloc_11;
  return_value_malloc_11=malloc((unsigned long int)8);
  args->filename = (char *)return_value_malloc_11;
  strcpy(args->filename, "out.ogv");
}

// rmdSetupPorts
// file rmd_jack.c line 90
static signed int rmdSetupPorts(struct _JackData *jdata)
{
  signed int i = 0;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct _jack_port *) /*8ul*/  * (unsigned long int)jdata->nports);
  jdata->ports = (struct _jack_port **)return_value_malloc_1;
  void *return_value_malloc_2;
  return_value_malloc_2=malloc(sizeof(float *) /*8ul*/  * (unsigned long int)jdata->nports);
  jdata->portbuf = (float **)return_value_malloc_2;
  memset((void *)jdata->portbuf, 0, sizeof(float *) /*8ul*/  * (unsigned long int)jdata->nports);
  i = 0;
  for( ; !((unsigned int)i >= jdata->nports); i = i + 1)
  {
    char name[64l];
    char num[8l];
    strcpy(name, "input_");
    snprintf(num, (unsigned long int)8, "%d", i + 1);
    strcat(name, num);
    jdata->ports[(signed long int)i]=jack_port_register(jdata->client, name, "32 bit float mono audio", (unsigned long int)1, (unsigned long int)0);
    if(jdata->ports[(signed long int)i] == ((struct _jack_port *)NULL))
    {
      fprintf(stderr, "Cannot register input port \"%s\"!\n", (const void *)name);
      return 1;
    }

    const char *return_value_jack_port_name_4;
    return_value_jack_port_name_4=jack_port_name(jdata->ports[(signed long int)i]);
    signed int return_value_jack_connect_5;
    return_value_jack_connect_5=jack_connect(jdata->client, jdata->port_names[(signed long int)i], return_value_jack_port_name_4);
    if(!(return_value_jack_connect_5 == 0))
    {
      const char *return_value_jack_port_name_3;
      return_value_jack_port_name_3=jack_port_name(jdata->ports[(signed long int)i]);
      fprintf(stderr, "Cannot connect input port %s to %s\n", return_value_jack_port_name_3, jdata->port_names[(signed long int)i]);
      return 1;
    }

  }
  return 0;
}

// rmdSizePack2_8_16
// file rmd_setbrwindow.c line 45
static void rmdSizePack2_8_16(signed short int *start, unsigned short int *size, unsigned short int limit)
{
  signed int octoffset;
  signed int hexoffset;
  *size = *size + (unsigned short int)((signed int)*size % 2 | (signed int)*start % 2);
  *size = *size + (unsigned short int)((signed int)*size % 2);
  *start = *start - (signed short int)((signed int)*start % 2);
  octoffset = (signed int)*size % 8;
  _Bool tmp_if_expr_1;
  if(octoffset == 2)
    *size = *size - (unsigned short int)2;

  else
    if(octoffset == 6)
    {
      if((signed int)limit >= 2 + (signed int)*start + (signed int)*size)
        *size = *size + (unsigned short int)2;

      else
        if((signed int)*start >= 2)
        {
          *start = *start - (signed short int)2;
          *size = *size + (unsigned short int)2;
        }

        else
        {
          *start = *start + (signed short int)2;
          *size = *size - (unsigned short int)4;
        }
    }

    else
      if(octoffset == 4)
      {
        if((signed int)limit >= 2 + (signed int)*start + (signed int)*size)
          tmp_if_expr_1 = (signed int)*start >= 2 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_1 = (_Bool)0;
        if(tmp_if_expr_1)
        {
          *start = *start - (signed short int)2;
          *size = *size + (unsigned short int)4;
        }

        else
          if((signed int)limit >= 4 + (signed int)*start + (signed int)*size)
            *size = *size + (unsigned short int)4;

          else
            if((signed int)*start >= 4)
            {
              *start = *start - (signed short int)4;
              *size = *size + (unsigned short int)4;
            }

            else
            {
              *start = *start + (signed short int)2;
              *size = *size - (unsigned short int)4;
            }
      }

  hexoffset = (signed int)*size % 16;
  _Bool tmp_if_expr_2;
  if(!(hexoffset == 0))
  {
    if((signed int)limit >= 4 + (signed int)*start + (signed int)*size)
      tmp_if_expr_2 = (signed int)*start >= 4 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_2 = (_Bool)0;
    if(tmp_if_expr_2)
    {
      *start = *start - (signed short int)4;
      *size = *size + (unsigned short int)8;
    }

    else
      if((signed int)limit >= 8 + (signed int)*start + (signed int)*size)
        *size = *size + (unsigned short int)8;

      else
        if((signed int)*start >= 8)
        {
          *start = *start - (signed short int)8;
          *size = *size + (unsigned short int)8;
        }

        else
        {
          *start = *start + (signed short int)4;
          *size = *size - (unsigned short int)8;
        }
  }

}

// rmdStartJackClient
// file rmd_jack.h line 44
signed int rmdStartJackClient(struct _JackData *jdata)
{
  float ring_buffer_size = (float)0.0;
  signed int pid;
  char pidbuf[8l];
  char rmd_client_name[32l];
  strcpy(rmd_client_name, "recordMyDesktop-");
  pid=getpid();
  snprintf(pidbuf, (unsigned long int)8, "%d", pid);
  strcat(rmd_client_name, pidbuf);
  jdata->client=(jack_client_new)(rmd_client_name);
  if(jdata->client == ((struct _jack_client *)NULL))
  {
    fprintf(stderr, "Could not create new client!\nMake sure that Jack server is running!\n");
    return 15;
  }

  else
  {
    jdata->frequency=jack_get_sample_rate(jdata->client);
    jdata->buffersize=jack_get_buffer_size(jdata->client);
    ring_buffer_size = jdata->ringbuffer_secs * (float)jdata->frequency * (float)sizeof(float) /*4ul*/  * (float)jdata->nports;
    jdata->sound_buffer=(jack_ringbuffer_create)((unsigned long int)(signed int)((double)ring_buffer_size + 0.5));
    jack_set_process_callback(jdata->client, rmdJackCapture, (void *)jdata);
    jack_on_shutdown(jdata->client, rmdJackShutdown, (void *)jdata);
    signed int return_value_jack_activate_1;
    return_value_jack_activate_1=jack_activate(jdata->client);
    if(!(return_value_jack_activate_1 == 0))
    {
      fprintf(stderr, "cannot activate client!\n");
      return 16;
    }

    else
    {
      signed int return_value_rmdSetupPorts_2;
      return_value_rmdSetupPorts_2=rmdSetupPorts(jdata);
      if(!(return_value_rmdSetupPorts_2 == 0))
      {
        jack_client_close(jdata->client);
        return 17;
      }

      else
        return 0;
    }
  }
}

// rmdStopJackClient
// file rmd_jack.c line 194
signed int rmdStopJackClient(struct _JackData *jdata)
{
  signed int ret = 0;
  (jack_ringbuffer_free)(jdata->sound_buffer);
  signed int return_value_jack_client_close_1;
  return_value_jack_client_close_1=jack_client_close(jdata->client);
  if(!(return_value_jack_client_close_1 == 0))
  {
    fprintf(stderr, "Cannot close Jack client!\n");
    ret = 1;
  }

  return ret;
}

// rmdSwapCacheFilesRead
// file rmd_cache.c line 76
signed int rmdSwapCacheFilesRead(char *name, signed int n, struct gzFile_s ***fp, struct _IO_FILE **ucfp)
{
  char *newname;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(name);
  void *return_value_malloc_2;
  return_value_malloc_2=malloc(return_value_strlen_1 + (unsigned long int)10);
  newname = (char *)return_value_malloc_2;
  rmdCacheFileN(name, &newname, n);
  if(*fp == ((struct gzFile_s **)NULL))
  {
    fclose(*ucfp);
    *ucfp=fopen(newname, "rb");
  }

  else
  {
    gzclose((struct gzFile_s *)*fp);
    struct gzFile_s *return_value_gzopen_3;
    return_value_gzopen_3=gzopen(newname, "rb");
    *fp = (struct gzFile_s **)return_value_gzopen_3;
  }
  free((void *)newname);
  _Bool tmp_if_expr_4;
  if(*fp == ((struct gzFile_s **)NULL))
    tmp_if_expr_4 = *ucfp == (struct _IO_FILE *)(void *)0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_4 = (_Bool)0;
  return (signed int)tmp_if_expr_4;
}

// rmdSwapCacheFilesWrite
// file rmd_cache.c line 59
signed int rmdSwapCacheFilesWrite(char *name, signed int n, struct gzFile_s ***fp, struct _IO_FILE **ucfp)
{
  char *newname;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(name);
  void *return_value_malloc_2;
  return_value_malloc_2=malloc(return_value_strlen_1 + (unsigned long int)10);
  newname = (char *)return_value_malloc_2;
  rmdCacheFileN(name, &newname, n);
  if(*fp == ((struct gzFile_s **)NULL))
  {
    fflush(*ucfp);
    fclose(*ucfp);
    *ucfp=fopen(newname, "wb");
  }

  else
  {
    gzflush((struct gzFile_s *)*fp, 4);
    gzclose((struct gzFile_s *)*fp);
    struct gzFile_s *return_value_gzopen_3;
    return_value_gzopen_3=gzopen(newname, "wb0f");
    *fp = (struct gzFile_s **)return_value_gzopen_3;
  }
  free((void *)newname);
  _Bool tmp_if_expr_4;
  if(*fp == ((struct gzFile_s **)NULL))
    tmp_if_expr_4 = *ucfp == (struct _IO_FILE *)(void *)0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_4 = (_Bool)0;
  return (signed int)tmp_if_expr_4;
}

// rmdSyncEncodeImageBuffer
// file rmd_encode_image_buffer.c line 80
void rmdSyncEncodeImageBuffer(struct _ProgData *pdata)
{
  signed int return_value_theora_encode_YUVin_2;
  return_value_theora_encode_YUVin_2=theora_encode_YUVin(&pdata->enc_data->m_th_st, &pdata->enc_data->yuv);
  if(!(return_value_theora_encode_YUVin_2 == 0))
    fprintf(stderr, "Encoder not ready!\n");

  else
  {
    signed int return_value_theora_encode_packetout_1;
    return_value_theora_encode_packetout_1=theora_encode_packetout(&pdata->enc_data->m_th_st, (signed int)!(pdata->running != 0), &pdata->enc_data->m_ogg_pckt1);
    if(return_value_theora_encode_packetout_1 == 1)
    {
      pthread_mutex_lock(&pdata->libogg_mutex);
      ogg_stream_packetin(&pdata->enc_data->m_ogg_ts, &pdata->enc_data->m_ogg_pckt1);
      if(pdata->running == 0)
        pdata->enc_data->m_ogg_ts.e_o_s = 1;

      pthread_mutex_unlock(&pdata->libogg_mutex);
      pdata->avd = pdata->avd + (signed int)pdata->frametime;
    }

  }
}

// rmdSyncEncodeSoundBuffer
// file rmd_encode_sound_buffer.c line 146
void rmdSyncEncodeSoundBuffer(struct _ProgData *pdata, signed char *buff)
{
  float **vorbis_buffer;
  signed int count = 0;
  signed int i;
  signed int j;
  signed int sampread;
  unsigned long int tmp_if_expr_1;
  if(!(buff == ((signed char *)NULL)))
    tmp_if_expr_1 = pdata->periodsize;

  else
    tmp_if_expr_1 = (unsigned long int)0;
  sampread = (signed int)tmp_if_expr_1;
  vorbis_buffer=vorbis_analysis_buffer(&pdata->enc_data->m_vo_dsp, sampread);
  if(pdata->args.use_jack == 0)
  {
    i = 0;
    for( ; !(i >= sampread); i = i + 1)
    {
      j = 0;
      for( ; !((unsigned int)j >= pdata->args.channels); j = j + 1)
      {
        vorbis_buffer[(signed long int)j][(signed long int)i] = (float)((signed int)buff[(signed long int)(count + 1)] << 8 | 0x00ff & (signed int)buff[(signed long int)count]) / 32768.f;
        count = count + 2;
      }
    }
  }

  else
  {
    j = 0;
    for( ; !((unsigned int)j >= pdata->args.channels); j = j + 1)
    {
      i = 0;
      for( ; !(i >= sampread); i = i + 1)
      {
        vorbis_buffer[(signed long int)j][(signed long int)i] = ((float *)buff)[(signed long int)count];
        count = count + 1;
      }
    }
  }
  vorbis_analysis_wrote(&pdata->enc_data->m_vo_dsp, sampread);
  pthread_mutex_lock(&pdata->libogg_mutex);
  signed int return_value_vorbis_analysis_blockout_2;
  signed int return_value_vorbis_bitrate_flushpacket_3;
  do
  {
    return_value_vorbis_analysis_blockout_2=vorbis_analysis_blockout(&pdata->enc_data->m_vo_dsp, &pdata->enc_data->m_vo_block);
    if(!(return_value_vorbis_analysis_blockout_2 == 1))
      break;

    vorbis_analysis(&pdata->enc_data->m_vo_block, (struct anonymous_126 *)(void *)0);
    vorbis_bitrate_addblock(&pdata->enc_data->m_vo_block);
    do
    {
      return_value_vorbis_bitrate_flushpacket_3=vorbis_bitrate_flushpacket(&pdata->enc_data->m_vo_dsp, &pdata->enc_data->m_ogg_pckt2);
      if(return_value_vorbis_bitrate_flushpacket_3 == 0)
        break;

      ogg_stream_packetin(&pdata->enc_data->m_ogg_vs, &pdata->enc_data->m_ogg_pckt2);
    }
    while((_Bool)1);
  }
  while((_Bool)1);
  pthread_mutex_unlock(&pdata->libogg_mutex);
  if(pdata->running == 0)
    pdata->enc_data->m_ogg_vs.e_o_s = 1;

  pdata->avd = pdata->avd - (signed int)pdata->periodtime;
}

// rmdThreads
// file rmd_threads.h line 40
void rmdThreads(struct _ProgData *pdata)
{
  unsigned long int image_capture_t;
  unsigned long int image_encode_t;
  unsigned long int image_cache_t;
  unsigned long int sound_capture_t;
  unsigned long int sound_encode_t;
  unsigned long int sound_cache_t;
  unsigned long int flush_to_ogg_t;
  unsigned long int timer_t;
  if(pdata->args.delay >= 1)
  {
    fprintf(stderr, "Will sleep for %d seconds now.\n", pdata->args.delay);
    sleep((unsigned int)pdata->args.delay);
  }

  pthread_create(&image_capture_t, (const union pthread_attr_t *)(void *)0, (void * (*)(void *))(void *)rmdGetFrame, (void *)pdata);
  if(!(pdata->args.encOnTheFly == 0))
    pthread_create(&image_encode_t, (const union pthread_attr_t *)(void *)0, (void * (*)(void *))(void *)rmdEncodeImageBuffer, (void *)pdata);

  else
    pthread_create(&image_cache_t, (const union pthread_attr_t *)(void *)0, (void * (*)(void *))(void *)rmdCacheImageBuffer, (void *)pdata);
  if(pdata->args.nosound == 0)
  {
    if(pdata->args.use_jack == 0)
      pthread_create(&sound_capture_t, (const union pthread_attr_t *)(void *)0, (void * (*)(void *))(void *)rmdCaptureSound, (void *)pdata);

    if(!(pdata->args.encOnTheFly == 0))
      pthread_create(&sound_encode_t, (const union pthread_attr_t *)(void *)0, (void * (*)(void *))(void *)rmdEncodeSoundBuffer, (void *)pdata);

    else
      pthread_create(&sound_cache_t, (const union pthread_attr_t *)(void *)0, (void * (*)(void *))(void *)rmdCacheSoundBuffer, (void *)pdata);
  }

  if(!(pdata->args.encOnTheFly == 0))
    pthread_create(&flush_to_ogg_t, (const union pthread_attr_t *)(void *)0, (void * (*)(void *))(void *)rmdFlushToOgg, (void *)pdata);

  rmdRegisterCallbacks(pdata);
  pdata->timer_alive = 1;
  pthread_create(&timer_t, (const union pthread_attr_t *)(void *)0, (void * (*)(void *))(void *)rmdTimer, (void *)pdata);
  fprintf(stderr, "Capturing!\n");
  if(!(pdata->args.use_jack == 0))
    pdata->jdata->capture_started = 1;

  pthread_join(image_capture_t, (void **)(void *)0);
  fprintf(stderr, "Shutting down.");
  while(pdata->th_enc_thread_waiting == 0)
  {
    if(!(pdata->th_encoding_clean == 0))
      break;

    usleep((unsigned int)10000);
    pthread_mutex_lock(&pdata->img_buff_ready_mutex);
    pthread_cond_signal(&pdata->image_buffer_ready);
    pthread_mutex_unlock(&pdata->img_buff_ready_mutex);
  }
  if(!(pdata->args.encOnTheFly == 0))
    pthread_join(image_encode_t, (void **)(void *)0);

  else
    pthread_join(image_cache_t, (void **)(void *)0);
  fprintf(stderr, ".");
  if(pdata->args.nosound == 0)
  {
    if(!(pdata->args.use_jack == 0))
      rmdStopJackClient(pdata->jdata);

    if(pdata->args.use_jack == 0)
      pthread_join(sound_capture_t, (void **)(void *)0);

    fprintf(stderr, ".");
    while((_Bool)1)
    {
      if(pdata->v_enc_thread_waiting == 0)
      {
        if(!(pdata->v_encoding_clean == 0))
          goto __CPROVER_DUMP_L17;

      }

      usleep((unsigned int)10000);
      pthread_mutex_lock(&pdata->snd_buff_ready_mutex);
      pthread_cond_signal(&pdata->sound_data_read);
      pthread_mutex_unlock(&pdata->snd_buff_ready_mutex);
    }

  __CPROVER_DUMP_L17:
    ;
    if(!(pdata->args.encOnTheFly == 0))
      pthread_join(sound_encode_t, (void **)(void *)0);

    else
      pthread_join(sound_cache_t, (void **)(void *)0);
  }

  else
    fprintf(stderr, "..");
  if(!(pdata->args.encOnTheFly == 0))
    pthread_join(flush_to_ogg_t, (void **)(void *)0);

  fprintf(stderr, ".");
  pdata->timer_alive = 0;
  pthread_join(timer_t, (void **)(void *)0);
}

// rmdTimer
// file rmd_timer.h line 41
void * rmdTimer(struct _ProgData *pdata)
{
  unsigned long int secs_tw = (unsigned long int)((float)1 / pdata->args.fps);
  unsigned long int usecs_tw = (unsigned long int)((float)1000000 / pdata->args.fps - (float)(secs_tw * (unsigned long int)1000000));
  while(!(pdata->timer_alive == 0))
  {
    if(!(pdata->pause_state_changed == 0))
    {
      pdata->pause_state_changed = 0;
      if(pdata->paused == 0)
      {
        pdata->paused = (signed int)!(0 != 0);
        fprintf(stderr, "STATE:PAUSED\n");
        fflush(stderr);
      }

      else
      {
        pdata->paused = 0;
        fprintf(stderr, "STATE:RECORDING\n");
        fflush(stderr);
        pthread_mutex_lock(&pdata->pause_mutex);
        pthread_cond_broadcast(&pdata->pause_cond);
        pthread_mutex_unlock(&pdata->pause_mutex);
      }
    }

    if(pdata->paused == 0)
    {
      pdata->frames_total = pdata->frames_total + 1u;
      if(!(pdata->capture_busy == 0))
        pdata->frames_lost = pdata->frames_lost + 1u;

    }

    pthread_mutex_lock(&pdata->time_mutex);
    pthread_cond_broadcast(&pdata->time_cond);
    pthread_mutex_unlock(&pdata->time_mutex);
    if(!(secs_tw == 0ul))
      sleep((unsigned int)secs_tw);

    usleep((unsigned int)usecs_tw);
  }
  signed int *return_value___errno_location_1;
  return_value___errno_location_1=__errno_location();
  pthread_exit((void *)&(*return_value___errno_location_1));
}

// rmdUpdateImage
// file rmd_update_image.h line 58
void rmdUpdateImage(struct _XDisplay *dpy, struct anonymous_45 *yuv, struct _DisplaySpecs *specs, struct _RectArea **root, struct _BRWindow *brwin, struct _EncData *enc, char *datatemp, signed int noshmem, struct anonymous_34 *shminfo, signed int shm_opcode, signed int no_quick_subsample)
{
  struct _RectArea *temp;
  unsigned char *dtap = (unsigned char *)datatemp;
  temp = *root;
  _Bool tmp_if_expr_1;
  _Bool tmp_if_expr_8;
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_5;
  _Bool tmp_if_expr_6;
  _Bool tmp_if_expr_7;
  if(!(temp == ((struct _RectArea *)NULL)))
    while((_Bool)1)
    {
      if(!(noshmem == 0))
        rmdGetZPixmap(dpy, specs->root, datatemp, (signed int)temp->rect.x, (signed int)temp->rect.y, (signed int)temp->rect.width, (signed int)temp->rect.height);

      else
        rmdGetZPixmapSHM(dpy, specs->root, shminfo, shm_opcode, datatemp, (signed int)temp->rect.x, (signed int)temp->rect.y, (signed int)temp->rect.width, (signed int)temp->rect.height);
      if(specs->depth == 24)
        tmp_if_expr_1 = (_Bool)1;

      else
        tmp_if_expr_1 = specs->depth == 32 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_1)
      {
        signed int k;
        signed int i;
        unsigned int t_val;
        unsigned char *yuv_y = yuv->y + (signed long int)(((signed int)temp->rect.x - (signed int)brwin->rrect.x) + enc->x_offset) + (signed long int)((((signed int)temp->rect.y - (signed int)brwin->rrect.y) + enc->y_offset) * yuv->y_width);
        unsigned char *_yr = Yr;
        unsigned char *_yg = Yg;
        unsigned char *_yb = Yb;
        unsigned int *datapi = (unsigned int *)dtap;
        k = 0;
        for( ; !(k >= (signed int)temp->rect.height); k = k + 1)
        {
          i = 0;
          for( ; !(i >= (signed int)temp->rect.width); i = i + 1)
          {
            t_val = *datapi;
            *yuv_y = (unsigned char)((signed int)_yr[(signed long int)((t_val & (unsigned int)0x00ff0000) >> 16)] + (signed int)_yg[(signed long int)((t_val & (unsigned int)0x0000ff00) >> 8)] + (signed int)_yb[(signed long int)(t_val & (unsigned int)0x000000ff)]);
            datapi = datapi + 1l;
            yuv_y = yuv_y + 1l;
          }
          yuv_y = yuv_y + (signed long int)(yuv->y_width - (signed int)temp->rect.width);
        }
        signed int rmdUpdateImage__1__1__1__3__1__1__2__k;
        signed int rmdUpdateImage__1__1__1__3__1__1__2__i;
        unsigned int rmdUpdateImage__1__1__1__3__1__1__2__t_val;
        unsigned char *yuv_u = yuv->u + (signed long int)((((signed int)temp->rect.x - (signed int)brwin->rrect.x) + enc->x_offset) / 2) + (signed long int)(((((signed int)temp->rect.y - (signed int)brwin->rrect.y) + enc->y_offset) * yuv->uv_width) / 2);
        unsigned char *yuv_v = yuv->v + (signed long int)((((signed int)temp->rect.x - (signed int)brwin->rrect.x) + enc->x_offset) / 2) + (signed long int)(((((signed int)temp->rect.y - (signed int)brwin->rrect.y) + enc->y_offset) * yuv->uv_width) / 2);
        unsigned char *_ur = Ur;
        unsigned char *_ug = Ug;
        unsigned char *_ubvr = UbVr;
        unsigned char *_vg = Vg;
        unsigned char *_vb = Vb;
        unsigned int *rmdUpdateImage__1__1__1__3__1__1__2__datapi = (unsigned int *)dtap;
        unsigned int *datapi_next = (unsigned int *)(void *)0;
        if(no_quick_subsample == 1)
          datapi_next = rmdUpdateImage__1__1__1__3__1__1__2__datapi + (signed long int)temp->rect.width;

        rmdUpdateImage__1__1__1__3__1__1__2__k = 0;
        for( ; !(rmdUpdateImage__1__1__1__3__1__1__2__k >= (signed int)temp->rect.height); rmdUpdateImage__1__1__1__3__1__1__2__k = rmdUpdateImage__1__1__1__3__1__1__2__k + 2)
        {
          rmdUpdateImage__1__1__1__3__1__1__2__i = 0;
          for( ; !(rmdUpdateImage__1__1__1__3__1__1__2__i >= (signed int)temp->rect.width); rmdUpdateImage__1__1__1__3__1__1__2__i = rmdUpdateImage__1__1__1__3__1__1__2__i + 2)
          {
            if(no_quick_subsample == 1)
            {
              unsigned int t1;
              unsigned int t2;
              unsigned int t3;
              unsigned int t4;
              t1 = *rmdUpdateImage__1__1__1__3__1__1__2__datapi;
              t2 = rmdUpdateImage__1__1__1__3__1__1__2__datapi[(signed long int)1];
              t3 = *datapi_next;
              t4 = datapi_next[(signed long int)1];
              rmdUpdateImage__1__1__1__3__1__1__2__t_val = (((t1 & (unsigned int)0x00ff0000) + (t2 & (unsigned int)0x00ff0000) + (t3 & (unsigned int)0x00ff0000) + (t4 & (unsigned int)0x00ff0000)) / (unsigned int)4 & (unsigned int)0x00ff0000) + (((t1 & (unsigned int)0x0000ff00) + (t2 & (unsigned int)0x0000ff00) + (t3 & (unsigned int)0x0000ff00) + (t4 & (unsigned int)0x0000ff00)) / (unsigned int)4 & (unsigned int)0x0000ff00) + (((t1 & (unsigned int)0x000000ff) + (t2 & (unsigned int)0x000000ff) + (t3 & (unsigned int)0x000000ff) + (t4 & (unsigned int)0x000000ff)) / (unsigned int)4 & (unsigned int)0x000000ff);
            }

            else
              rmdUpdateImage__1__1__1__3__1__1__2__t_val = *rmdUpdateImage__1__1__1__3__1__1__2__datapi;
            *yuv_u = (unsigned char)((signed int)_ur[(signed long int)((rmdUpdateImage__1__1__1__3__1__1__2__t_val & (unsigned int)0x00ff0000) >> 16)] + (signed int)_ug[(signed long int)((rmdUpdateImage__1__1__1__3__1__1__2__t_val & (unsigned int)0x0000ff00) >> 8)] + (signed int)_ubvr[(signed long int)(rmdUpdateImage__1__1__1__3__1__1__2__t_val & (unsigned int)0x000000ff)]);
            *yuv_v = (unsigned char)((signed int)_ubvr[(signed long int)((rmdUpdateImage__1__1__1__3__1__1__2__t_val & (unsigned int)0x00ff0000) >> 16)] + (signed int)_vg[(signed long int)((rmdUpdateImage__1__1__1__3__1__1__2__t_val & (unsigned int)0x0000ff00) >> 8)] + (signed int)_vb[(signed long int)(rmdUpdateImage__1__1__1__3__1__1__2__t_val & (unsigned int)0x000000ff)]);
            rmdUpdateImage__1__1__1__3__1__1__2__datapi = rmdUpdateImage__1__1__1__3__1__1__2__datapi + (signed long int)2;
            if(no_quick_subsample == 1)
              datapi_next = datapi_next + (signed long int)2;

            yuv_u = yuv_u + 1l;
            yuv_v = yuv_v + 1l;
          }
          yuv_u = yuv_u + (signed long int)((yuv->y_width - (signed int)temp->rect.width) / 2);
          yuv_v = yuv_v + (signed long int)((yuv->y_width - (signed int)temp->rect.width) / 2);
          rmdUpdateImage__1__1__1__3__1__1__2__datapi = rmdUpdateImage__1__1__1__3__1__1__2__datapi + (signed long int)temp->rect.width;
          if(no_quick_subsample == 1)
            datapi_next = datapi_next + (signed long int)temp->rect.width;

        }
      }

      else
        if(specs->depth == 16)
        {
          signed int rmdUpdateImage__1__1__1__3__1__2__1__k;
          signed int rmdUpdateImage__1__1__1__3__1__2__1__i;
          unsigned short int rmdUpdateImage__1__1__1__3__1__2__1__t_val;
          unsigned char *rmdUpdateImage__1__1__1__3__1__2__1__yuv_y = yuv->y + (signed long int)(((signed int)temp->rect.x - (signed int)brwin->rrect.x) + enc->x_offset) + (signed long int)((((signed int)temp->rect.y - (signed int)brwin->rrect.y) + enc->y_offset) * yuv->y_width);
          unsigned char *rmdUpdateImage__1__1__1__3__1__2__1___yr = Yr;
          unsigned char *rmdUpdateImage__1__1__1__3__1__2__1___yg = Yg;
          unsigned char *rmdUpdateImage__1__1__1__3__1__2__1___yb = Yb;
          unsigned short int *rmdUpdateImage__1__1__1__3__1__2__1__datapi = (unsigned short int *)dtap;
          rmdUpdateImage__1__1__1__3__1__2__1__k = 0;
          for( ; !(rmdUpdateImage__1__1__1__3__1__2__1__k >= (signed int)temp->rect.height); rmdUpdateImage__1__1__1__3__1__2__1__k = rmdUpdateImage__1__1__1__3__1__2__1__k + 1)
          {
            rmdUpdateImage__1__1__1__3__1__2__1__i = 0;
            for( ; !(rmdUpdateImage__1__1__1__3__1__2__1__i >= (signed int)temp->rect.width); rmdUpdateImage__1__1__1__3__1__2__1__i = rmdUpdateImage__1__1__1__3__1__2__1__i + 1)
            {
              rmdUpdateImage__1__1__1__3__1__2__1__t_val = *rmdUpdateImage__1__1__1__3__1__2__1__datapi;
              *rmdUpdateImage__1__1__1__3__1__2__1__yuv_y = (unsigned char)((signed int)rmdUpdateImage__1__1__1__3__1__2__1___yr[(signed long int)((((signed int)rmdUpdateImage__1__1__1__3__1__2__1__t_val & 0xf800) >> 11) * 8)] + (signed int)rmdUpdateImage__1__1__1__3__1__2__1___yg[(signed long int)((((signed int)rmdUpdateImage__1__1__1__3__1__2__1__t_val & 0x7e0) >> 5) * 4)] + (signed int)rmdUpdateImage__1__1__1__3__1__2__1___yb[(signed long int)(((signed int)rmdUpdateImage__1__1__1__3__1__2__1__t_val & 0x1f) * 8)]);
              rmdUpdateImage__1__1__1__3__1__2__1__datapi = rmdUpdateImage__1__1__1__3__1__2__1__datapi + 1l;
              rmdUpdateImage__1__1__1__3__1__2__1__yuv_y = rmdUpdateImage__1__1__1__3__1__2__1__yuv_y + 1l;
            }
            rmdUpdateImage__1__1__1__3__1__2__1__yuv_y = rmdUpdateImage__1__1__1__3__1__2__1__yuv_y + (signed long int)(yuv->y_width - (signed int)temp->rect.width);
          }
          signed int rmdUpdateImage__1__1__1__3__1__2__2__k;
          signed int rmdUpdateImage__1__1__1__3__1__2__2__i;
          unsigned short int rmdUpdateImage__1__1__1__3__1__2__2__t_val;
          unsigned char *rmdUpdateImage__1__1__1__3__1__2__2__yuv_u = yuv->u + (signed long int)((((signed int)temp->rect.x - (signed int)brwin->rrect.x) + enc->x_offset) / 2) + (signed long int)(((((signed int)temp->rect.y - (signed int)brwin->rrect.y) + enc->y_offset) * yuv->uv_width) / 2);
          unsigned char *rmdUpdateImage__1__1__1__3__1__2__2__yuv_v = yuv->v + (signed long int)((((signed int)temp->rect.x - (signed int)brwin->rrect.x) + enc->x_offset) / 2) + (signed long int)(((((signed int)temp->rect.y - (signed int)brwin->rrect.y) + enc->y_offset) * yuv->uv_width) / 2);
          unsigned char *rmdUpdateImage__1__1__1__3__1__2__2___ur = Ur;
          unsigned char *rmdUpdateImage__1__1__1__3__1__2__2___ug = Ug;
          unsigned char *rmdUpdateImage__1__1__1__3__1__2__2___ubvr = UbVr;
          unsigned char *rmdUpdateImage__1__1__1__3__1__2__2___vg = Vg;
          unsigned char *rmdUpdateImage__1__1__1__3__1__2__2___vb = Vb;
          unsigned short int *rmdUpdateImage__1__1__1__3__1__2__2__datapi = (unsigned short int *)dtap;
          unsigned short int *rmdUpdateImage__1__1__1__3__1__2__2__datapi_next = (unsigned short int *)(void *)0;
          if(no_quick_subsample == 1)
            rmdUpdateImage__1__1__1__3__1__2__2__datapi_next = rmdUpdateImage__1__1__1__3__1__2__2__datapi + (signed long int)temp->rect.width;

          rmdUpdateImage__1__1__1__3__1__2__2__k = 0;
          for( ; !(rmdUpdateImage__1__1__1__3__1__2__2__k >= (signed int)temp->rect.height); rmdUpdateImage__1__1__1__3__1__2__2__k = rmdUpdateImage__1__1__1__3__1__2__2__k + 2)
          {
            rmdUpdateImage__1__1__1__3__1__2__2__i = 0;
            for( ; !(rmdUpdateImage__1__1__1__3__1__2__2__i >= (signed int)temp->rect.width); rmdUpdateImage__1__1__1__3__1__2__2__i = rmdUpdateImage__1__1__1__3__1__2__2__i + 2)
            {
              if(no_quick_subsample == 1)
              {
                unsigned short int rmdUpdateImage__1__1__1__3__1__2__2__2__1__1__1__1__1__t1;
                unsigned short int rmdUpdateImage__1__1__1__3__1__2__2__2__1__1__1__1__1__t2;
                unsigned short int rmdUpdateImage__1__1__1__3__1__2__2__2__1__1__1__1__1__t3;
                unsigned short int rmdUpdateImage__1__1__1__3__1__2__2__2__1__1__1__1__1__t4;
                rmdUpdateImage__1__1__1__3__1__2__2__2__1__1__1__1__1__t1 = *rmdUpdateImage__1__1__1__3__1__2__2__datapi;
                rmdUpdateImage__1__1__1__3__1__2__2__2__1__1__1__1__1__t2 = rmdUpdateImage__1__1__1__3__1__2__2__datapi[(signed long int)1];
                rmdUpdateImage__1__1__1__3__1__2__2__2__1__1__1__1__1__t3 = *rmdUpdateImage__1__1__1__3__1__2__2__datapi_next;
                rmdUpdateImage__1__1__1__3__1__2__2__2__1__1__1__1__1__t4 = rmdUpdateImage__1__1__1__3__1__2__2__datapi_next[(signed long int)1];
                rmdUpdateImage__1__1__1__3__1__2__2__t_val = (unsigned short int)(((((signed int)rmdUpdateImage__1__1__1__3__1__2__2__2__1__1__1__1__1__t1 & 0xf800) + ((signed int)rmdUpdateImage__1__1__1__3__1__2__2__2__1__1__1__1__1__t2 & 0xf800) + ((signed int)rmdUpdateImage__1__1__1__3__1__2__2__2__1__1__1__1__1__t3 & 0xf800) + ((signed int)rmdUpdateImage__1__1__1__3__1__2__2__2__1__1__1__1__1__t4 & 0xf800)) / 4 & 0xf800) + ((((signed int)rmdUpdateImage__1__1__1__3__1__2__2__2__1__1__1__1__1__t1 & 0x7e0) + ((signed int)rmdUpdateImage__1__1__1__3__1__2__2__2__1__1__1__1__1__t2 & 0x7e0) + ((signed int)rmdUpdateImage__1__1__1__3__1__2__2__2__1__1__1__1__1__t3 & 0x7e0) + ((signed int)rmdUpdateImage__1__1__1__3__1__2__2__2__1__1__1__1__1__t4 & 0x7e0)) / 4 & 0x7e0) + ((((signed int)rmdUpdateImage__1__1__1__3__1__2__2__2__1__1__1__1__1__t1 & 0x1f) + ((signed int)rmdUpdateImage__1__1__1__3__1__2__2__2__1__1__1__1__1__t2 & 0x1f) + ((signed int)rmdUpdateImage__1__1__1__3__1__2__2__2__1__1__1__1__1__t3 & 0x1f) + ((signed int)rmdUpdateImage__1__1__1__3__1__2__2__2__1__1__1__1__1__t4 & 0x1f)) / 4 & 0x1f));
              }

              else
                rmdUpdateImage__1__1__1__3__1__2__2__t_val = *rmdUpdateImage__1__1__1__3__1__2__2__datapi;
              *rmdUpdateImage__1__1__1__3__1__2__2__yuv_u = (unsigned char)((signed int)rmdUpdateImage__1__1__1__3__1__2__2___ur[(signed long int)((((signed int)rmdUpdateImage__1__1__1__3__1__2__2__t_val & 0xf800) >> 11) * 8)] + (signed int)rmdUpdateImage__1__1__1__3__1__2__2___ug[(signed long int)((((signed int)rmdUpdateImage__1__1__1__3__1__2__2__t_val & 0x7e0) >> 5) * 4)] + (signed int)rmdUpdateImage__1__1__1__3__1__2__2___ubvr[(signed long int)(((signed int)rmdUpdateImage__1__1__1__3__1__2__2__t_val & 0x1f) * 8)]);
              *rmdUpdateImage__1__1__1__3__1__2__2__yuv_v = (unsigned char)((signed int)rmdUpdateImage__1__1__1__3__1__2__2___ubvr[(signed long int)((((signed int)rmdUpdateImage__1__1__1__3__1__2__2__t_val & 0xf800) >> 11) * 8)] + (signed int)rmdUpdateImage__1__1__1__3__1__2__2___vg[(signed long int)((((signed int)rmdUpdateImage__1__1__1__3__1__2__2__t_val & 0x7e0) >> 5) * 4)] + (signed int)rmdUpdateImage__1__1__1__3__1__2__2___vb[(signed long int)(((signed int)rmdUpdateImage__1__1__1__3__1__2__2__t_val & 0x1f) * 8)]);
              rmdUpdateImage__1__1__1__3__1__2__2__datapi = rmdUpdateImage__1__1__1__3__1__2__2__datapi + (signed long int)2;
              if(no_quick_subsample == 1)
                rmdUpdateImage__1__1__1__3__1__2__2__datapi_next = rmdUpdateImage__1__1__1__3__1__2__2__datapi_next + (signed long int)2;

              rmdUpdateImage__1__1__1__3__1__2__2__yuv_u = rmdUpdateImage__1__1__1__3__1__2__2__yuv_u + 1l;
              rmdUpdateImage__1__1__1__3__1__2__2__yuv_v = rmdUpdateImage__1__1__1__3__1__2__2__yuv_v + 1l;
            }
            rmdUpdateImage__1__1__1__3__1__2__2__yuv_u = rmdUpdateImage__1__1__1__3__1__2__2__yuv_u + (signed long int)((yuv->y_width - (signed int)temp->rect.width) / 2);
            rmdUpdateImage__1__1__1__3__1__2__2__yuv_v = rmdUpdateImage__1__1__1__3__1__2__2__yuv_v + (signed long int)((yuv->y_width - (signed int)temp->rect.width) / 2);
            rmdUpdateImage__1__1__1__3__1__2__2__datapi = rmdUpdateImage__1__1__1__3__1__2__2__datapi + (signed long int)temp->rect.width;
            if(no_quick_subsample == 1)
              rmdUpdateImage__1__1__1__3__1__2__2__datapi_next = rmdUpdateImage__1__1__1__3__1__2__2__datapi_next + (signed long int)temp->rect.width;

          }
        }

      temp = temp->next;
      if(temp == ((struct _RectArea *)NULL))
        break;

    }

}

// rmdValidateArguments
// file rmd_parseargs.c line 435
static signed int rmdValidateArguments(const struct _ProgArgs *args)
{
  signed int success = (signed int)!(0 != 0);
  if(!(args->x >= 0))
  {
    fprintf(stdout, "-x must not be less than 0.\n");
    success = 0;
  }

  if(!(args->y >= 0))
  {
    fprintf(stdout, "-y must not be less than 0.\n");
    success = 0;
  }

  if(!(args->width >= 0))
  {
    fprintf(stdout, "--width must be larger than 0.\n");
    success = 0;
  }

  if(!(args->height >= 0))
  {
    fprintf(stdout, "--height must be larger than 0.\n");
    success = 0;
  }

  if(args->fps <= 0.000000f)
  {
    fprintf(stdout, "--fps must be larger than 0.\n");
    success = 0;
  }

  _Bool tmp_if_expr_1;
  if(!(args->v_quality >= 0))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = args->v_quality > 63 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_1)
  {
    fprintf(stdout, "--v_quality must be within the inclusive range [0-63].\n");
    success = 0;
  }

  _Bool tmp_if_expr_2;
  if(!(args->v_bitrate >= 0))
    tmp_if_expr_2 = (_Bool)1;

  else
    tmp_if_expr_2 = args->v_quality > 2000000 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_2)
  {
    fprintf(stdout, "--v_bitrate must be within the inclusive range [0-2000000].\n");
    success = 0;
  }

  if(!(args->frequency >= 1u))
  {
    fprintf(stdout, "--frequency must be larger than 0.\n");
    success = 0;
  }

  if(!(args->channels >= 1u))
  {
    fprintf(stdout, "--channels must be larger than 0.\n");
    success = 0;
  }

  if(!(args->buffsize >= 1ul))
  {
    fprintf(stdout, "--buffer-size must be larger than 0.\n");
    success = 0;
  }

  if(args->jack_ringbuffer_secs <= 0.000000f)
  {
    fprintf(stdout, "--jack-buffer-size must be larger than 0.\n");
    success = 0;
  }

  return success;
}

// rmdWMCheck
// file rmd_wm_check.c line 36
char * rmdWMCheck(struct _XDisplay *dpy, unsigned long int root)
{
  unsigned long int *wm_child = (unsigned long int *)(void *)0;
  unsigned long int nwm_atom;
  unsigned long int utf8_string;
  unsigned long int wm_name_atom;
  unsigned long int rt;
  unsigned long int nbytes;
  unsigned long int nitems;
  char *wm_name_str = (char *)(void *)0;
  signed int fmt;
  utf8_string=XInternAtom(dpy, "UTF8_STRING", 0);
  nwm_atom=XInternAtom(dpy, "_NET_SUPPORTING_WM_CHECK", 1);
  wm_name_atom=XInternAtom(dpy, "_NET_WM_NAME", 1);
  _Bool tmp_if_expr_3;
  signed int return_value_XGetWindowProperty_2;
  if(!(nwm_atom == 0ul) && !(wm_name_atom == 0ul))
  {
    signed int return_value_XGetWindowProperty_1;
    return_value_XGetWindowProperty_1=XGetWindowProperty(dpy, root, nwm_atom, (signed long int)0, (signed long int)100, 0, (unsigned long int)33, &rt, &fmt, &nitems, &nbytes, (unsigned char **)(void *)&wm_child);
    if(!(return_value_XGetWindowProperty_1 == 0))
      fprintf(stderr, "Error while trying to get a window to identify the window manager.\n");

    if(wm_child == ((unsigned long int *)NULL))
      tmp_if_expr_3 = (_Bool)1;

    else
    {
      return_value_XGetWindowProperty_2=XGetWindowProperty(dpy, *wm_child, wm_name_atom, (signed long int)0, (signed long int)100, 0, utf8_string, &rt, &fmt, &nitems, &nbytes, (unsigned char **)(void *)&wm_name_str);
      tmp_if_expr_3 = return_value_XGetWindowProperty_2 != 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_3)
      fprintf(stderr, "Warning!!!\nYour window manager appears to be non-compliant!\n");

  }

  fprintf(stderr, "Your window manager appears to be %s\n\n", wm_name_str != (char *)(void *)0 ? wm_name_str : "Unknown");
  return wm_name_str;
}

// rmdWMIsCompositing
// file rmd_wm_is_compositing.h line 46
signed int rmdWMIsCompositing(struct _XDisplay *dpy, signed int screen)
{
  unsigned long int win;
  unsigned long int atom;
  char buf[32l];
  char *window_manager;
  window_manager=rmdWMCheck(dpy, (&((struct anonymous_146 *)dpy)->screens[(signed long int)screen])->root);
  if(window_manager == ((char *)NULL))
    return 0;

  else
    free((void *)window_manager);
  snprintf(buf, sizeof(char [32l]) /*32ul*/ , "_NET_WM_CM_S%d", screen);
  atom=XInternAtom(dpy, buf, 1);
  if(atom == 0ul)
    return 0;

  else
  {
    win=XGetSelectionOwner(dpy, atom);
    return (signed int)(win != (unsigned long int)0L);
  }
}

// rmdWriteSpecsFile
// file rmd_specsfile.h line 42
signed int rmdWriteSpecsFile(struct _ProgData *pdata)
{
  struct _IO_FILE *fp;
  fp=fopen(pdata->cache_data->specsfile, "wb");
  if(fp == ((struct _IO_FILE *)NULL))
    return 1;

  else
  {
    fprintf(fp, "recordMyDesktop = %s\n", (const void *)"0.3.8.1");
    fprintf(fp, "Width = %hu\n", pdata->brwin.rrect.width);
    fprintf(fp, "Height = %hu\n", pdata->brwin.rrect.height);
    fprintf(fp, "Filename = %s\n", pdata->args.filename);
    fprintf(fp, "FPS = %f\n", pdata->args.fps);
    fprintf(fp, "NoSound = %d\n", pdata->args.nosound);
    fprintf(fp, "Frequency = %d\n", pdata->args.frequency);
    fprintf(fp, "Channels = %d\n", pdata->args.channels);
    fprintf(fp, "BufferSize = %lu\n", (unsigned long int)pdata->args.buffsize);
    fprintf(fp, "SoundFrameSize = %d\n", pdata->sound_framesize);
    fprintf(fp, "PeriodSize = %lu\n", (unsigned long int)pdata->periodsize);
    fprintf(fp, "UsedJack = %d\n", pdata->args.use_jack);
    fprintf(fp, "v_bitrate = %d\n", pdata->args.v_bitrate);
    fprintf(fp, "v_quality = %d\n", pdata->args.v_quality);
    fprintf(fp, "s_quality = %d\n", pdata->args.s_quality);
    fprintf(fp, "ZeroCompression = %d\n", pdata->args.zerocompression);
  }
  fclose(fp);
  return 0;
}

// write_ogg_page_to_file
// file skeleton.c line 81
extern signed int write_ogg_page_to_file(struct anonymous_15 *og, struct _IO_FILE *out)
{
  signed int written;
  unsigned long int return_value_fwrite_1;
  return_value_fwrite_1=fwrite((const void *)og->header, (unsigned long int)1, (unsigned long int)og->header_len, out);
  written = (signed int)return_value_fwrite_1;
  unsigned long int return_value_fwrite_2;
  if(written >= 1)
  {
    return_value_fwrite_2=fwrite((const void *)og->body, (unsigned long int)1, (unsigned long int)og->body_len, out);
    written = written + (signed int)return_value_fwrite_2;
  }

  return written;
}

