// #anon_enum_res_goahead=0_res_nextns=1_res_modified=2_res_done=3_res_error=4
// file /usr/include/resolv.h line 71
enum anonymous_4 { res_goahead=0, res_nextns=1, res_modified=2, res_done=3, res_error=4 };

// tag-#anon#ST[*{*{SYM#tag-SPF_dns_rr_struct#}_SYM#tag-SPF_dns_rr_struct#_}_*{SYM#tag-SPF_dns_rr_struct#}_SYM#tag-SPF_dns_rr_struct#__'zone'|S32'num_zone'|S32'zone_buf_len'|*{SYM#tag-SPF_dns_rr_struct#}_SYM#tag-SPF_dns_rr_struct#_'nxdomain']
// file spf_dns_zone.c line 73
struct anonymous_9;

// tag-#anon#ST[*{*{SYM#tag-_SPF_dns_cache_bucket_t#}_SYM#tag-_SPF_dns_cache_bucket_t#_}_*{SYM#tag-_SPF_dns_cache_bucket_t#}_SYM#tag-_SPF_dns_cache_bucket_t#__'cache'|S32'cache_size'|U32'_pad0'|SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'|ARR40{S8}_S8_'__size'|S64'__align']#'cache_lock'|S32'hash_mask'|S32'max_hash_len'|S64'min_ttl'|S64'err_ttl'|S64'txt_ttl'|S64'rdns_ttl'|S32'conserve_cache'|U32'_pad1']
// file spf_dns_cache.c line 88
struct anonymous_1;

// tag-#anon#ST[*{cS8}_cS8_'domain'|S32'rr_type'|S32'herrno'|*{cS8}_cS8_'data']
// file spf_dns_test.c line 48
struct anonymous_7;

// tag-#anon#ST[ARR16{S64}_S64_'fds_bits']
// file /usr/include/x86_64-linux-gnu/sys/select.h line 64
struct anonymous_10;

// tag-#anon#ST[SYM#tag-in_addr#'addr'|U32'mask']
// file /usr/include/resolv.h line 121
struct anonymous_3;

// tag-#anon#ST[U16'nscount'|ARR3{U16}_U16_'nsmap'|ARR3{S32}_S32_'nssocks'|U16'nscount6'|U16'nsinit'|ARR3{*{SYM#tag-sockaddr_in6#}_SYM#tag-sockaddr_in6#_}_*{SYM#tag-sockaddr_in6#}_SYM#tag-sockaddr_in6#__'nsaddrs'|ARR2{U32}_U32_'_initstamp']
// file /usr/include/resolv.h line 134
struct anonymous_2;

// tag-#anon#UN[ARR16{U8}_U8_'__u6_addr8'|ARR8{U16}_U16_'__u6_addr16'|ARR4{U32}_U32_'__u6_addr32']
// file /usr/include/netinet/in.h line 211
union anonymous_12;

// tag-#anon#UN[ARR4{S8}_S8_'__size'|S32'__align']
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 130
union anonymous;

// tag-#anon#UN[ARR52{S8}_S8_'pad'|SYM#tag-#anon#ST[U16'nscount'|ARR3{U16}_U16_'nsmap'|ARR3{S32}_S32_'nssocks'|U16'nscount6'|U16'nsinit'|ARR3{*{SYM#tag-sockaddr_in6#}_SYM#tag-sockaddr_in6#_}_*{SYM#tag-sockaddr_in6#}_SYM#tag-sockaddr_in6#__'nsaddrs'|ARR2{U32}_U32_'_initstamp']#'_ext']
// file /usr/include/resolv.h line 132
union anonymous_5;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'|ARR40{S8}_S8_'__size'|S64'__align']
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous_0;

// tag-#anon#UN[SYM#tag-in_addr#'a'|ARR1{S8}_S8_'ptr'|ARR1{S8}_S8_'mx'|ARR1{S8}_S8_'txt'|SYM#tag-in6_addr#'aaaa']
// file ../../src/include/spf_dns_rr.h line 31
union anonymous_13;

// tag-#anon#UN[SYM#tag-sockaddr_in#'in'|SYM#tag-sockaddr_un#'un'|U896'_pad']
// file spfd.c line 167
union anonymous_14;

// tag-#anon#UN[r*{SYM#tag-sockaddr#}_SYM#tag-sockaddr#_'__sockaddr__'|r*{SYM#tag-sockaddr_at#}_SYM#tag-sockaddr_at#_'__sockaddr_at__'|r*{SYM#tag-sockaddr_ax25#}_SYM#tag-sockaddr_ax25#_'__sockaddr_ax25__'|r*{SYM#tag-sockaddr_dl#}_SYM#tag-sockaddr_dl#_'__sockaddr_dl__'|r*{SYM#tag-sockaddr_eon#}_SYM#tag-sockaddr_eon#_'__sockaddr_eon__'|r*{SYM#tag-sockaddr_in#}_SYM#tag-sockaddr_in#_'__sockaddr_in__'|r*{SYM#tag-sockaddr_in6#}_SYM#tag-sockaddr_in6#_'__sockaddr_in6__'|r*{SYM#tag-sockaddr_inarp#}_SYM#tag-sockaddr_inarp#_'__sockaddr_inarp__'|r*{SYM#tag-sockaddr_ipx#}_SYM#tag-sockaddr_ipx#_'__sockaddr_ipx__'|r*{SYM#tag-sockaddr_iso#}_SYM#tag-sockaddr_iso#_'__sockaddr_iso__'|r*{SYM#tag-sockaddr_ns#}_SYM#tag-sockaddr_ns#_'__sockaddr_ns__'|r*{SYM#tag-sockaddr_un#}_SYM#tag-sockaddr_un#_'__sockaddr_un__'|r*{SYM#tag-sockaddr_x25#}_SYM#tag-sockaddr_x25#_'__sockaddr_x25__']
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
union anonymous_15;

// tag-#anon#UN[r*{SYM#tag-sockaddr#}_SYM#tag-sockaddr#_'__sockaddr__'|r*{SYM#tag-sockaddr_at#}_SYM#tag-sockaddr_at#_'__sockaddr_at__'|r*{SYM#tag-sockaddr_ax25#}_SYM#tag-sockaddr_ax25#_'__sockaddr_ax25__'|r*{SYM#tag-sockaddr_dl#}_SYM#tag-sockaddr_dl#_'__sockaddr_dl__'|r*{SYM#tag-sockaddr_eon#}_SYM#tag-sockaddr_eon#_'__sockaddr_eon__'|r*{SYM#tag-sockaddr_in#}_SYM#tag-sockaddr_in#_'__sockaddr_in__'|r*{SYM#tag-sockaddr_in6#}_SYM#tag-sockaddr_in6#_'__sockaddr_in6__'|r*{SYM#tag-sockaddr_inarp#}_SYM#tag-sockaddr_inarp#_'__sockaddr_inarp__'|r*{SYM#tag-sockaddr_ipx#}_SYM#tag-sockaddr_ipx#_'__sockaddr_ipx__'|r*{SYM#tag-sockaddr_iso#}_SYM#tag-sockaddr_iso#_'__sockaddr_iso__'|r*{SYM#tag-sockaddr_ns#}_SYM#tag-sockaddr_ns#_'__sockaddr_ns__'|r*{SYM#tag-sockaddr_un#}_SYM#tag-sockaddr_un#_'__sockaddr_un__'|r*{SYM#tag-sockaddr_x25#}_SYM#tag-sockaddr_x25#_'__sockaddr_x25__']_transparent
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
union anonymous_8;

// tag-SPF_cidr_enum
// file spf_compile.c line 48
enum SPF_cidr_enum { CIDR_NONE=0, CIDR_OPTIONAL=1, CIDR_ONLY=2 };

// tag-SPF_data_cidr_struct
// file ../../src/include/spf_record.h line 130
struct SPF_data_cidr_struct;

// tag-SPF_data_str_struct
// file ../../src/include/spf_record.h line 104
struct SPF_data_str_struct;

// tag-SPF_data_union
// file ../../src/include/spf_record.h line 141
union SPF_data_union;

// tag-SPF_data_var_struct
// file ../../src/include/spf_record.h line 115
struct SPF_data_var_struct;

// tag-SPF_dns_rr_struct
// file ../../src/include/spf_dns_rr.h line 50
struct SPF_dns_rr_struct;

// tag-SPF_dns_server_struct
// file ../../src/include/spf_dns.h line 81
struct SPF_dns_server_struct;

// tag-SPF_domspec_enum
// file spf_compile.c line 53
enum SPF_domspec_enum { DOMSPEC_NONE=0, DOMSPEC_OPTIONAL=1, DOMSPEC_REQUIRED=2 };

// tag-SPF_errcode_t
// file ../../src/include/spf_response.h line 119
enum SPF_errcode_t { SPF_E_SUCCESS=0, SPF_E_NO_MEMORY=1, SPF_E_NOT_SPF=2, SPF_E_SYNTAX=3, SPF_E_MOD_W_PREF=4, SPF_E_INVALID_CHAR=5, SPF_E_UNKNOWN_MECH=6, SPF_E_INVALID_OPT=7, SPF_E_INVALID_CIDR=8, SPF_E_MISSING_OPT=9, SPF_E_INTERNAL_ERROR=10, SPF_E_INVALID_ESC=11, SPF_E_INVALID_VAR=12, SPF_E_BIG_SUBDOM=13, SPF_E_INVALID_DELIM=14, SPF_E_BIG_STRING=15, SPF_E_BIG_MECH=16, SPF_E_BIG_MOD=17, SPF_E_BIG_DNS=18, SPF_E_INVALID_IP4=19, SPF_E_INVALID_IP6=20, SPF_E_INVALID_PREFIX=21, SPF_E_RESULT_UNKNOWN=22, SPF_E_UNINIT_VAR=23, SPF_E_MOD_NOT_FOUND=24, SPF_E_NOT_CONFIG=25, SPF_E_DNS_ERROR=26, SPF_E_BAD_HOST_IP=27, SPF_E_BAD_HOST_TLD=28, SPF_E_MECH_AFTER_ALL=29, SPF_E_INCLUDE_RETURNED_NONE=30, SPF_E_RECURSIVE=31, SPF_E_MULTIPLE_RECORDS=32 };

// tag-SPF_error_struct
// file ../../src/include/spf_response.h line 157
struct SPF_error_struct;

// tag-SPF_macro_struct
// file ../../src/include/spf_record.h line 23
struct SPF_macro_struct;

// tag-SPF_mech_struct
// file ../../src/include/spf_record.h line 174
struct SPF_mech_struct;

// tag-SPF_mechtype_struct
// file spf_compile.c line 70
struct SPF_mechtype_struct;

// tag-SPF_mod_struct
// file ../../src/include/spf_record.h line 187
struct SPF_mod_struct;

// tag-SPF_reason_enum
// file ../../src/include/spf_response.h line 100
enum SPF_reason_enum { SPF_REASON_NONE=0, SPF_REASON_FAILURE=1, SPF_REASON_LOCALHOST=2, SPF_REASON_LOCAL_POLICY=3, SPF_REASON_MECH=4, SPF_REASON_DEFAULT=5, SPF_REASON_2MX=6 };

// tag-SPF_record_struct
// file ../../src/include/spf_record.h line 22
struct SPF_record_struct;

// tag-SPF_request_struct
// file ../../src/include/spf_request.h line 19
struct SPF_request_struct;

// tag-SPF_response_struct
// file ../../src/include/spf_response.h line 164
struct SPF_response_struct;

// tag-SPF_result_enum
// file ../../src/include/spf_response.h line 79
enum SPF_result_enum { SPF_RESULT_INVALID=0, SPF_RESULT_NEUTRAL=1, SPF_RESULT_PASS=2, SPF_RESULT_FAIL=3, SPF_RESULT_SOFTFAIL=4, SPF_RESULT_NONE=5, SPF_RESULT_TEMPERROR=6, SPF_RESULT_PERMERROR=7 };

// tag-SPF_server_dnstype_enum
// file ../../src/include/spf_server.h line 72
enum SPF_server_dnstype_enum { SPF_DNS_RESOLV=0, SPF_DNS_CACHE=1, SPF_DNS_ZONE=2 };

// tag-SPF_server_struct
// file ../../src/include/spf_server.h line 19
struct SPF_server_struct;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 156
struct _IO_marker;

// tag-_SPF_dns_cache_bucket_t
// file spf_dns_cache.c line 83
struct _SPF_dns_cache_bucket_t;

// tag-__ns_class
// file /usr/include/arpa/nameser.h line 321
enum __ns_class { ns_c_invalid=0, ns_c_in=1, ns_c_2=2, ns_c_chaos=3, ns_c_hs=4, ns_c_none=254, ns_c_any=255, ns_c_max=65536 };

// tag-__ns_msg
// file /usr/include/arpa/nameser.h line 114
struct __ns_msg;

// tag-__ns_rr
// file /usr/include/arpa/nameser.h line 138
struct __ns_rr;

// tag-__ns_sect
// file /usr/include/arpa/nameser.h line 98
enum __ns_sect { ns_s_qd=0, ns_s_zn=0, ns_s_an=1, ns_s_pr=1, ns_s_ns=2, ns_s_ud=2, ns_s_ar=3, ns_s_max=4 };

// tag-__ns_type
// file /usr/include/arpa/nameser.h line 252
enum __ns_type { ns_t_invalid=0, ns_t_a=1, ns_t_ns=2, ns_t_md=3, ns_t_mf=4, ns_t_cname=5, ns_t_soa=6, ns_t_mb=7, ns_t_mg=8, ns_t_mr=9, ns_t_null=10, ns_t_wks=11, ns_t_ptr=12, ns_t_hinfo=13, ns_t_minfo=14, ns_t_mx=15, ns_t_txt=16, ns_t_rp=17, ns_t_afsdb=18, ns_t_x25=19, ns_t_isdn=20, ns_t_rt=21, ns_t_nsap=22, ns_t_nsap_ptr=23, ns_t_sig=24, ns_t_key=25, ns_t_px=26, ns_t_gpos=27, ns_t_aaaa=28, ns_t_loc=29, ns_t_nxt=30, ns_t_eid=31, ns_t_nimloc=32, ns_t_srv=33, ns_t_atma=34, ns_t_naptr=35, ns_t_kx=36, ns_t_cert=37, ns_t_a6=38, ns_t_dname=39, ns_t_sink=40, ns_t_opt=41, ns_t_apl=42, ns_t_tkey=249, ns_t_tsig=250, ns_t_ixfr=251, ns_t_axfr=252, ns_t_mailb=253, ns_t_maila=254, ns_t_any=255, ns_t_zxfr=256, ns_t_max=65536 };

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-__res_state
// file /usr/include/resolv.h line 104
struct __res_state;

// tag-_config_t
// file spfd.c line 134
struct _config_t;

// tag-_ns_flagdata
// file arpa_nameser.h line 172
struct _ns_flagdata;

// tag-_request_t
// file spfd.c line 165
struct _request_t;

// tag-_state_t
// file spfd.c line 189
struct _state_t;

// tag-group
// file /usr/include/grp.h line 42
struct group;

// tag-in6_addr
// file /usr/include/netinet/in.h line 209
struct in6_addr;

// tag-in_addr
// file /usr/include/netinet/in.h line 31
struct in_addr;

// tag-option
// file /usr/include/getopt.h line 104
struct option;

// tag-passwd
// file /usr/include/pwd.h line 49
struct passwd;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-res_sym
// file /usr/include/resolv.h line 176
struct res_sym;

// tag-sockaddr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 153
struct sockaddr;

// tag-sockaddr_at
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_at;

// tag-sockaddr_ax25
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ax25;

// tag-sockaddr_dl
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_dl;

// tag-sockaddr_eon
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_eon;

// tag-sockaddr_in
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_in;

// tag-sockaddr_in6
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_in6;

// tag-sockaddr_inarp
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_inarp;

// tag-sockaddr_ipx
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ipx;

// tag-sockaddr_iso
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_iso;

// tag-sockaddr_ns
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ns;

// tag-sockaddr_un
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_un;

// tag-sockaddr_x25
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_x25;

// tag-timeval
// file /usr/include/x86_64-linux-gnu/bits/time.h line 30
struct timeval;

#ifndef NULL
#define NULL ((void*)0)
#endif

// SPF_c_ensure_capacity
// file spf_compile.c line 107
static signed int SPF_c_ensure_capacity(void **datap, unsigned long int *sizep, unsigned long int length);
// SPF_c_mech_add
// file spf_compile.c line 824
static enum SPF_errcode_t SPF_c_mech_add(struct SPF_server_struct *spf_server, struct SPF_record_struct *spf_record, struct SPF_response_struct *spf_response, const struct SPF_mechtype_struct *mechtype, signed int prefix, const char **mech_value);
// SPF_c_mod_add
// file spf_compile.c line 982
static enum SPF_errcode_t SPF_c_mod_add(struct SPF_server_struct *spf_server, struct SPF_record_struct *spf_record, struct SPF_response_struct *spf_response, const char *mod_name, unsigned long int name_len, const char **mod_value);
// SPF_c_parse_cidr
// file spf_compile.c line 213
static enum SPF_errcode_t SPF_c_parse_cidr(struct SPF_response_struct *spf_response, struct SPF_data_cidr_struct *data, const char *src, unsigned long int *src_len);
// SPF_c_parse_cidr_ip4
// file spf_compile.c line 175
static enum SPF_errcode_t SPF_c_parse_cidr_ip4(struct SPF_response_struct *spf_response, unsigned char *maskp, const char *src);
// SPF_c_parse_cidr_ip6
// file spf_compile.c line 133
static enum SPF_errcode_t SPF_c_parse_cidr_ip6(struct SPF_response_struct *spf_response, unsigned char *maskp, const char *src);
// SPF_c_parse_domainspec
// file spf_compile.c line 671
static enum SPF_errcode_t SPF_c_parse_domainspec(struct SPF_server_struct *spf_server, struct SPF_response_struct *spf_response, union SPF_data_union *data, unsigned long int *data_used, unsigned long int data_avail, const char *src, unsigned long int src_len, enum SPF_errcode_t big_err, enum SPF_cidr_enum cidr_ok, signed int is_mod);
// SPF_c_parse_ip4
// file spf_compile.c line 727
static enum SPF_errcode_t SPF_c_parse_ip4(struct SPF_response_struct *spf_response, struct SPF_mech_struct *mech, const char *start);
// SPF_c_parse_ip6
// file spf_compile.c line 776
static enum SPF_errcode_t SPF_c_parse_ip6(struct SPF_response_struct *spf_response, struct SPF_mech_struct *mech, const char *start);
// SPF_c_parse_macro
// file spf_compile.c line 506
static enum SPF_errcode_t SPF_c_parse_macro(struct SPF_server_struct *spf_server, struct SPF_response_struct *spf_response, union SPF_data_union *data, unsigned long int *data_used, unsigned long int data_avail, const char *src, unsigned long int src_len, enum SPF_errcode_t big_err, signed int is_mod);
// SPF_c_parse_var
// file spf_compile.c line 272
static enum SPF_errcode_t SPF_c_parse_var(struct SPF_response_struct *spf_response, struct SPF_data_var_struct *data, const char *src, signed int is_mod);
// SPF_data_len
// file ../../src/include/spf_internal.h line 107
static inline unsigned long int SPF_data_len(union SPF_data_union *data);
// SPF_data_len_link1
// file ../../src/include/spf_internal.h line 107
static inline unsigned long int SPF_data_len_link1(union SPF_data_union *data_link1);
// SPF_data_len_link2
// file ../../src/include/spf_internal.h line 107
static inline unsigned long int SPF_data_len_link2(union SPF_data_union *data_link2);
// SPF_data_len_link3
// file ../../src/include/spf_internal.h line 107
static inline unsigned long int SPF_data_len_link3(union SPF_data_union *data_link3);
// SPF_data_next
// file ../../src/include/spf_internal.h line 110
static inline union SPF_data_union * SPF_data_next(union SPF_data_union *data);
// SPF_data_next_link1
// file ../../src/include/spf_internal.h line 110
static inline union SPF_data_union * SPF_data_next_link1(union SPF_data_union *data_link1);
// SPF_data_next_link2
// file ../../src/include/spf_internal.h line 110
static inline union SPF_data_union * SPF_data_next_link2(union SPF_data_union *data_link2);
// SPF_data_next_link3
// file ../../src/include/spf_internal.h line 110
static inline union SPF_data_union * SPF_data_next_link3(union SPF_data_union *data_link3);
// SPF_data_str
// file ../../src/include/spf_internal.h line 114
static inline char * SPF_data_str(union SPF_data_union *data);
// SPF_data_str_link1
// file ../../src/include/spf_internal.h line 114
static inline char * SPF_data_str_link1(union SPF_data_union *data_link1);
// SPF_data_str_link2
// file ../../src/include/spf_internal.h line 114
static inline char * SPF_data_str_link2(union SPF_data_union *data_link2);
// SPF_debug_handler_object
//
void SPF_debug_handler_object(const char *, signed int, const char *);
// SPF_debug_stdio
// file ../../src/include/spf_log.h line 90
void SPF_debug_stdio(const char *file, signed int line, const char *errmsg);
// SPF_debug_syslog
// file spf_log_syslog.c line 71
void SPF_debug_syslog(const char *file, signed int line, const char *errmsg);
// SPF_debugv
// file spf_log.c line 150
void SPF_debugv(const char *file, signed int line, const char *format, void **ap);
// SPF_debugx
// file ../../src/include/spf_log.h line 56
void SPF_debugx(const char *file, signed int line, const char *format, ...);
// SPF_debugx2
// file spf_log.c line 194
void SPF_debugx2(const char *format, ...);
// SPF_delim_valid
// file spf_expand.c line 65
static inline signed int SPF_delim_valid(union SPF_data_union *d, char c);
// SPF_dns_cache_bucket_add
// file spf_dns_cache.c line 295
static enum SPF_errcode_t SPF_dns_cache_bucket_add(struct anonymous_1 *spfhook, struct SPF_dns_rr_struct *rr, signed int idx);
// SPF_dns_cache_bucket_find
// file spf_dns_cache.c line 239
static struct _SPF_dns_cache_bucket_t * SPF_dns_cache_bucket_find(struct anonymous_1 *spfhook, const char *domain, enum __ns_type rr_type, signed int idx);
// SPF_dns_cache_free
// file spf_dns_cache.c line 435
static void SPF_dns_cache_free(struct SPF_dns_server_struct *spf_dns_server);
// SPF_dns_cache_lookup
// file spf_dns_cache.c line 368
static struct SPF_dns_rr_struct * SPF_dns_cache_lookup(struct SPF_dns_server_struct *spf_dns_server, const char *domain, enum __ns_type rr_type, signed int should_cache);
// SPF_dns_cache_new
// file spf_dns_cache.c line 487
struct SPF_dns_server_struct * SPF_dns_cache_new(struct SPF_dns_server_struct *layer_below, const char *name, signed int debug, signed int cache_bits);
// SPF_dns_cache_rr_fixup
// file spf_dns_cache.c line 315
static enum SPF_errcode_t SPF_dns_cache_rr_fixup(struct anonymous_1 *spfhook, struct SPF_dns_rr_struct *cached_rr, const char *domain, enum __ns_type rr_type);
// SPF_dns_cache_set_ttl
// file spf_dns_cache.c line 555
void SPF_dns_cache_set_ttl(struct SPF_dns_server_struct *spf_dns_server, signed long int min_ttl, signed long int err_ttl, signed long int txt_ttl, signed long int rdns_ttl);
// SPF_dns_debug_post
// file spf_dns.c line 59
static void SPF_dns_debug_post(struct SPF_dns_server_struct *spf_dns_server, struct SPF_dns_rr_struct *spfrr);
// SPF_dns_debug_pre
// file spf_dns.c line 48
static void SPF_dns_debug_pre(struct SPF_dns_server_struct *spf_dns_server, const char *domain, enum __ns_type rr_type, signed int should_cache);
// SPF_dns_free
// file spf_dns.c line 116
void SPF_dns_free(struct SPF_dns_server_struct *spf_dns_server);
// SPF_dns_get_client_dom
// file spf_dns.c line 206
char * SPF_dns_get_client_dom(struct SPF_dns_server_struct *spf_dns_server, struct SPF_request_struct *sr);
// SPF_dns_lookup
// file spf_dns.c line 133
struct SPF_dns_rr_struct * SPF_dns_lookup(struct SPF_dns_server_struct *spf_dns_server, const char *domain, enum __ns_type rr_type, signed int should_cache);
// SPF_dns_null_free
// file spf_dns_null.c line 52
static void SPF_dns_null_free(struct SPF_dns_server_struct *spf_dns_server);
// SPF_dns_null_lookup
// file spf_dns_null.c line 42
static struct SPF_dns_rr_struct * SPF_dns_null_lookup(struct SPF_dns_server_struct *spf_dns_server, const char *domain, enum __ns_type rr_type, signed int should_cache);
// SPF_dns_null_new
// file spf_dns_null.c line 59
struct SPF_dns_server_struct * SPF_dns_null_new(struct SPF_dns_server_struct *spf_dns_server_below, const char *name, signed int debug);
// SPF_dns_resolv_debug
// file spf_dns_resolv.c line 112
static void SPF_dns_resolv_debug(struct SPF_dns_server_struct *spf_dns_server, struct __ns_rr rr, const unsigned char *responsebuf, unsigned long int responselen, const unsigned char *rdata, unsigned long int rdlen);
// SPF_dns_resolv_free
// file spf_dns_resolv.c line 605
static void SPF_dns_resolv_free(struct SPF_dns_server_struct *spf_dns_server);
// SPF_dns_resolv_init_key
// file spf_dns_resolv.c line 104
static void SPF_dns_resolv_init_key(void);
// SPF_dns_resolv_lookup
// file spf_dns_resolv.c line 218
static struct SPF_dns_rr_struct * SPF_dns_resolv_lookup(struct SPF_dns_server_struct *spf_dns_server, const char *domain, enum __ns_type rr_type, signed int should_cache);
// SPF_dns_resolv_new
// file spf_dns_resolv.c line 617
struct SPF_dns_server_struct * SPF_dns_resolv_new(struct SPF_dns_server_struct *layer_below, const char *name, signed int debug);
// SPF_dns_resolv_thread_term
// file spf_dns_resolv.c line 93
static void SPF_dns_resolv_thread_term(void *arg);
// SPF_dns_rlookup
// file spf_dns.c line 150
struct SPF_dns_rr_struct * SPF_dns_rlookup(struct SPF_dns_server_struct *spf_dns_server, struct in_addr ipv4, enum __ns_type rr_type, signed int should_cache);
// SPF_dns_rlookup6
// file spf_dns.c line 171
struct SPF_dns_rr_struct * SPF_dns_rlookup6(struct SPF_dns_server_struct *spf_dns_server, struct in6_addr ipv6, enum __ns_type rr_type, signed int should_cache);
// SPF_dns_rr_buf_realloc
// file ../../src/include/spf_dns_rr.h line 82
enum SPF_errcode_t SPF_dns_rr_buf_realloc(struct SPF_dns_rr_struct *spfrr, signed int idx, unsigned long int len);
// SPF_dns_rr_dup
// file ../../src/include/spf_dns_rr.h line 84
enum SPF_errcode_t SPF_dns_rr_dup(struct SPF_dns_rr_struct **dstp, struct SPF_dns_rr_struct *src);
// SPF_dns_rr_free
// file ../../src/include/spf_dns_rr.h line 74
void SPF_dns_rr_free(struct SPF_dns_rr_struct *spfrr);
// SPF_dns_rr_new
// file spf_dns_rr.c line 93
struct SPF_dns_rr_struct * SPF_dns_rr_new(void);
// SPF_dns_rr_new_init
// file ../../src/include/spf_dns_rr.h line 75
struct SPF_dns_rr_struct * SPF_dns_rr_new_init(struct SPF_dns_server_struct *spf_dns_server, const char *domain, enum __ns_type rr_type, signed int ttl, signed int herrno);
// SPF_dns_rr_new_nxdomain
// file ../../src/include/spf_dns_rr.h line 79
struct SPF_dns_rr_struct * SPF_dns_rr_new_nxdomain(struct SPF_dns_server_struct *spf_dns_server, const char *domain);
// SPF_dns_set_conserve_cache
// file spf_dns_cache.c line 577
void SPF_dns_set_conserve_cache(struct SPF_dns_server_struct *spf_dns_server, signed int conserve_cache);
// SPF_dns_test_new
// file spf_dns_test.c line 437
struct SPF_dns_server_struct * SPF_dns_test_new(struct SPF_dns_server_struct *layer_below, const char *name, signed int debug);
// SPF_dns_zone_add_str
// file ../../src/include/spf_dns_zone.h line 79
enum SPF_errcode_t SPF_dns_zone_add_str(struct SPF_dns_server_struct *spf_dns_server, const char *domain, enum __ns_type rr_type, signed int herrno, const char *data);
// SPF_dns_zone_find
// file spf_dns_zone.c line 96
static struct SPF_dns_rr_struct * SPF_dns_zone_find(struct SPF_dns_server_struct *spf_dns_server, const char *domain, enum __ns_type rr_type, signed int exact);
// SPF_dns_zone_free
// file spf_dns_zone.c line 312
static void SPF_dns_zone_free(struct SPF_dns_server_struct *spf_dns_server);
// SPF_dns_zone_lookup
// file spf_dns_zone.c line 164
static struct SPF_dns_rr_struct * SPF_dns_zone_lookup(struct SPF_dns_server_struct *spf_dns_server, const char *domain, enum __ns_type rr_type, signed int should_cache);
// SPF_dns_zone_new
// file ../../src/include/spf_dns_zone.h line 70
struct SPF_dns_server_struct * SPF_dns_zone_new(struct SPF_dns_server_struct *layer_below, const char *name, signed int debug);
// SPF_error_code
// file ../../src/include/spf_response.h line 220
enum SPF_errcode_t SPF_error_code(struct SPF_error_struct *err);
// SPF_error_errorp
// file ../../src/include/spf_response.h line 222
char SPF_error_errorp(struct SPF_error_struct *err);
// SPF_error_handler_object
//
void SPF_error_handler_object(const char *, signed int, const char *);
// SPF_error_message
// file ../../src/include/spf_response.h line 221
const char * SPF_error_message(struct SPF_error_struct *err);
// SPF_error_stdio
// file ../../src/include/spf_log.h line 87
void SPF_error_stdio(const char *file, signed int line, const char *errmsg);
// SPF_error_syslog
// file spf_log_syslog.c line 38
void SPF_error_syslog(const char *file, signed int line, const char *errmsg);
// SPF_errorv
// file spf_log.c line 109
void SPF_errorv(const char *file, signed int line, const char *format, void **ap);
// SPF_errorx
// file ../../src/include/spf_log.h line 41
void SPF_errorx(const char *file, signed int line, const char *format, ...);
// SPF_errorx2
// file spf_log.c line 167
void SPF_errorx2(const char *format, ...);
// SPF_get_lib_version
// file spf_utils.c line 38
void SPF_get_lib_version(signed int *major, signed int *minor, signed int *patch);
// SPF_i_done
// file spf_interpret.c line 388
enum SPF_errcode_t SPF_i_done(struct SPF_response_struct *spf_response, enum SPF_result_enum result, enum SPF_reason_enum reason, enum SPF_errcode_t err);
// SPF_i_match_domain
// file spf_interpret.c line 549
static signed int SPF_i_match_domain(struct SPF_server_struct *spf_server, const char *hostname, const char *domain);
// SPF_i_match_ip4
// file spf_interpret.c line 458
static signed int SPF_i_match_ip4(struct SPF_server_struct *spf_server, struct SPF_request_struct *spf_request, struct SPF_mech_struct *mech, struct in_addr ipv4);
// SPF_i_match_ip6
// file spf_interpret.c line 499
static signed int SPF_i_match_ip6(struct SPF_server_struct *spf_server, struct SPF_request_struct *spf_request, struct SPF_mech_struct *mech, struct in6_addr ipv6);
// SPF_i_mech_cidr
// file spf_interpret.c line 424
static signed int SPF_i_mech_cidr(struct SPF_request_struct *spf_request, struct SPF_mech_struct *mech);
// SPF_i_set_explanation
// file spf_interpret.c line 44
static enum SPF_errcode_t SPF_i_set_explanation(struct SPF_response_struct *spf_response);
// SPF_i_set_header_comment
// file spf_interpret.c line 137
static enum SPF_errcode_t SPF_i_set_header_comment(struct SPF_response_struct *spf_response);
// SPF_i_set_received_spf
// file spf_interpret.c line 273
static enum SPF_errcode_t SPF_i_set_received_spf(struct SPF_response_struct *spf_response);
// SPF_i_set_smtp_comment
// file spf_interpret.c line 85
static enum SPF_errcode_t SPF_i_set_smtp_comment(struct SPF_response_struct *spf_response);
// SPF_info_handler_object
//
void SPF_info_handler_object(const char *, signed int, const char *);
// SPF_info_stdio
// file ../../src/include/spf_log.h line 89
void SPF_info_stdio(const char *file, signed int line, const char *errmsg);
// SPF_info_syslog
// file spf_log_syslog.c line 65
void SPF_info_syslog(const char *file, signed int line, const char *errmsg);
// SPF_infov
// file spf_log.c line 137
void SPF_infov(const char *file, signed int line, const char *format, void **ap);
// SPF_infox
// file spf_log.c line 70
void SPF_infox(const char *file, signed int line, const char *format, ...);
// SPF_infox2
// file spf_log.c line 185
void SPF_infox2(const char *format, ...);
// SPF_macro_data
// file ../../src/include/spf_internal.h line 134
static inline union SPF_data_union * SPF_macro_data(struct SPF_macro_struct *mac);
// SPF_macro_data_link1
// file ../../src/include/spf_internal.h line 134
static inline union SPF_data_union * SPF_macro_data_link1(struct SPF_macro_struct *mac_link1);
// SPF_macro_free
// file ../../src/include/spf_record.h line 231
void SPF_macro_free(struct SPF_macro_struct *mac);
// SPF_mech_data
// file ../../src/include/spf_internal.h line 97
static inline union SPF_data_union * SPF_mech_data(struct SPF_mech_struct *mech);
// SPF_mech_data_link1
// file ../../src/include/spf_internal.h line 97
static inline union SPF_data_union * SPF_mech_data_link1(struct SPF_mech_struct *mech_link1);
// SPF_mech_data_link2
// file ../../src/include/spf_internal.h line 97
static inline union SPF_data_union * SPF_mech_data_link2(struct SPF_mech_struct *mech_link2);
// SPF_mech_data_len
// file ../../src/include/spf_internal.h line 87
static inline unsigned long int SPF_mech_data_len(struct SPF_mech_struct *mech);
// SPF_mech_data_len_link1
// file ../../src/include/spf_internal.h line 87
static inline unsigned long int SPF_mech_data_len_link1(struct SPF_mech_struct *mech_link1);
// SPF_mech_data_len_link2
// file ../../src/include/spf_internal.h line 87
static inline unsigned long int SPF_mech_data_len_link2(struct SPF_mech_struct *mech_link2);
// SPF_mech_end_data
// file ../../src/include/spf_internal.h line 99
static inline union SPF_data_union * SPF_mech_end_data(struct SPF_mech_struct *mech);
// SPF_mech_end_data_link1
// file ../../src/include/spf_internal.h line 99
static inline union SPF_data_union * SPF_mech_end_data_link1(struct SPF_mech_struct *mech_link1);
// SPF_mech_end_data_link2
// file ../../src/include/spf_internal.h line 99
static inline union SPF_data_union * SPF_mech_end_data_link2(struct SPF_mech_struct *mech_link2);
// SPF_mech_ip4_data
// file ../../src/include/spf_internal.h line 102
static inline struct in_addr * SPF_mech_ip4_data(struct SPF_mech_struct *mech);
// SPF_mech_ip4_data_link1
// file ../../src/include/spf_internal.h line 102
static inline struct in_addr * SPF_mech_ip4_data_link1(struct SPF_mech_struct *mech_link1);
// SPF_mech_ip4_data_link2
// file ../../src/include/spf_internal.h line 102
static inline struct in_addr * SPF_mech_ip4_data_link2(struct SPF_mech_struct *mech_link2);
// SPF_mech_ip6_data
// file ../../src/include/spf_internal.h line 104
static inline struct in6_addr * SPF_mech_ip6_data(struct SPF_mech_struct *mech);
// SPF_mech_ip6_data_link1
// file ../../src/include/spf_internal.h line 104
static inline struct in6_addr * SPF_mech_ip6_data_link1(struct SPF_mech_struct *mech_link1);
// SPF_mech_ip6_data_link2
// file ../../src/include/spf_internal.h line 104
static inline struct in6_addr * SPF_mech_ip6_data_link2(struct SPF_mech_struct *mech_link2);
// SPF_mech_next
// file ../../src/include/spf_internal.h line 93
static inline struct SPF_mech_struct * SPF_mech_next(struct SPF_mech_struct *mech);
// SPF_mech_next_link1
// file ../../src/include/spf_internal.h line 93
static inline struct SPF_mech_struct * SPF_mech_next_link1(struct SPF_mech_struct *mech_link1);
// SPF_mech_next_link2
// file ../../src/include/spf_internal.h line 93
static inline struct SPF_mech_struct * SPF_mech_next_link2(struct SPF_mech_struct *mech_link2);
// SPF_mechtype_find
// file spf_compile.c line 95
static const struct SPF_mechtype_struct * SPF_mechtype_find(signed int mech_type);
// SPF_mod_data
// file ../../src/include/spf_internal.h line 125
static inline union SPF_data_union * SPF_mod_data(struct SPF_mod_struct *mod);
// SPF_mod_data_link1
// file ../../src/include/spf_internal.h line 125
static inline union SPF_data_union * SPF_mod_data_link1(struct SPF_mod_struct *mod_link1);
// SPF_mod_data_link2
// file ../../src/include/spf_internal.h line 125
static inline union SPF_data_union * SPF_mod_data_link2(struct SPF_mod_struct *mod_link2);
// SPF_mod_end_data
// file ../../src/include/spf_internal.h line 129
static inline union SPF_data_union * SPF_mod_end_data(struct SPF_mod_struct *mod);
// SPF_mod_len
// file ../../src/include/spf_internal.h line 117
static inline unsigned long int SPF_mod_len(struct SPF_mod_struct *mod);
// SPF_mod_len_link1
// file ../../src/include/spf_internal.h line 117
static inline unsigned long int SPF_mod_len_link1(struct SPF_mod_struct *mod_link1);
// SPF_mod_name
// file ../../src/include/spf_internal.h line 123
static inline char * SPF_mod_name(struct SPF_mod_struct *mod);
// SPF_mod_name_link1
// file ../../src/include/spf_internal.h line 123
static inline char * SPF_mod_name_link1(struct SPF_mod_struct *mod_link1);
// SPF_mod_name_link2
// file ../../src/include/spf_internal.h line 123
static inline char * SPF_mod_name_link2(struct SPF_mod_struct *mod_link2);
// SPF_mod_next
// file ../../src/include/spf_internal.h line 119
static inline struct SPF_mod_struct * SPF_mod_next(struct SPF_mod_struct *mod);
// SPF_mod_next_link1
// file ../../src/include/spf_internal.h line 119
static inline struct SPF_mod_struct * SPF_mod_next_link1(struct SPF_mod_struct *mod_link1);
// SPF_print_sizeof
// file spf_print.c line 82
void SPF_print_sizeof(void);
// SPF_recalloc
// file ../../src/include/spf_internal.h line 148
enum SPF_errcode_t SPF_recalloc(char **bufp, unsigned long int *buflenp, unsigned long int buflen);
// SPF_record_compile
// file spf_compile.c line 1180
enum SPF_errcode_t SPF_record_compile(struct SPF_server_struct *spf_server, struct SPF_response_struct *spf_response, struct SPF_record_struct **spf_recordp, const char *record);
// SPF_record_compile_macro
// file spf_compile.c line 1499
enum SPF_errcode_t SPF_record_compile_macro(struct SPF_server_struct *spf_server, struct SPF_response_struct *spf_response, struct SPF_macro_struct **spf_macrop, const char *record);
// SPF_record_expand_data
// file spf_expand.c line 81
enum SPF_errcode_t SPF_record_expand_data(struct SPF_server_struct *spf_server, struct SPF_request_struct *spf_request, struct SPF_response_struct *spf_response, union SPF_data_union *data, unsigned long int data_len, char **bufp, unsigned long int *buflenp);
// SPF_record_find_mod_data
// file spf_record.c line 80
static enum SPF_errcode_t SPF_record_find_mod_data(struct SPF_record_struct *spf_record, const char *mod_name, union SPF_data_union **datap, unsigned long int *datalenp);
// SPF_record_find_mod_value
// file ../../src/include/spf_record.h line 238
enum SPF_errcode_t SPF_record_find_mod_value(struct SPF_server_struct *spf_server, struct SPF_request_struct *spf_request, struct SPF_response_struct *spf_response, struct SPF_record_struct *spf_record, const char *mod_name, char **bufp, unsigned long int *buflenp);
// SPF_record_free
// file ../../src/include/spf_record.h line 230
void SPF_record_free(struct SPF_record_struct *rp);
// SPF_record_interpret
// file spf_interpret.c line 585
enum SPF_errcode_t SPF_record_interpret(struct SPF_record_struct *spf_record, struct SPF_request_struct *spf_request, struct SPF_response_struct *spf_response, signed int depth);
// SPF_record_lint
// file spf_compile.c line 1055
static void SPF_record_lint(struct SPF_server_struct *spf_server, struct SPF_response_struct *spf_response, struct SPF_record_struct *spf_record);
// SPF_record_new
// file ../../src/include/spf_record.h line 228
struct SPF_record_struct * SPF_record_new(struct SPF_server_struct *spf_server, const char *text);
// SPF_record_print
// file spf_print.c line 45
enum SPF_errcode_t SPF_record_print(struct SPF_record_struct *spf_record);
// SPF_record_stringify
// file spf_id2str.c line 245
enum SPF_errcode_t SPF_record_stringify(struct SPF_record_struct *spf_record, char **bufp, unsigned long int *buflenp);
// SPF_record_stringify_data
// file spf_id2str.c line 44
static enum SPF_errcode_t SPF_record_stringify_data(union SPF_data_union *data, union SPF_data_union *data_end, char **p_p, char *p_end, signed int is_mod, signed int cidr_ok, signed int debug);
// SPF_request_free
// file ../../src/include/spf_request.h line 54
void SPF_request_free(struct SPF_request_struct *sr);
// SPF_request_get_client_dom
// file ../../src/include/spf_request.h line 69
const char * SPF_request_get_client_dom(struct SPF_request_struct *sr);
// SPF_request_get_exp
// file spf_get_exp.c line 83
enum SPF_errcode_t SPF_request_get_exp(struct SPF_server_struct *spf_server, struct SPF_request_struct *spf_request, struct SPF_response_struct *spf_response, struct SPF_record_struct *spf_record, char **bufp, unsigned long int *buflenp);
// SPF_request_get_rec_dom
// file ../../src/include/spf_request.h line 67
const char * SPF_request_get_rec_dom(struct SPF_request_struct *sr);
// SPF_request_is_loopback
// file spf_request.c line 212
signed int SPF_request_is_loopback(struct SPF_request_struct *sr);
// SPF_request_new
// file ../../src/include/spf_request.h line 53
struct SPF_request_struct * SPF_request_new(struct SPF_server_struct *spf_server);
// SPF_request_prepare
// file spf_request.c line 228
static enum SPF_errcode_t SPF_request_prepare(struct SPF_request_struct *sr);
// SPF_request_query_fallback
// file ../../src/include/spf_request.h line 77
enum SPF_errcode_t SPF_request_query_fallback(struct SPF_request_struct *spf_request, struct SPF_response_struct **spf_responsep, const char *record);
// SPF_request_query_mailfrom
// file ../../src/include/spf_request.h line 72
enum SPF_errcode_t SPF_request_query_mailfrom(struct SPF_request_struct *spf_request, struct SPF_response_struct **spf_responsep);
// SPF_request_query_rcptto
// file ../../src/include/spf_request.h line 74
enum SPF_errcode_t SPF_request_query_rcptto(struct SPF_request_struct *spf_request, struct SPF_response_struct **spf_responsep, const char *rcpt_to);
// SPF_request_query_record
// file spf_request.c line 241
static enum SPF_errcode_t SPF_request_query_record(struct SPF_request_struct *spf_request, struct SPF_response_struct *spf_response, struct SPF_record_struct *spf_record, enum SPF_errcode_t err);
// SPF_request_set_env_from
// file ../../src/include/spf_request.h line 65
signed int SPF_request_set_env_from(struct SPF_request_struct *sr, const char *from);
// SPF_request_set_helo_dom
// file ../../src/include/spf_request.h line 63
enum SPF_errcode_t SPF_request_set_helo_dom(struct SPF_request_struct *sr, const char *dom);
// SPF_request_set_ipv4
// file spf_request.c line 71
enum SPF_errcode_t SPF_request_set_ipv4(struct SPF_request_struct *sr, struct in_addr addr);
// SPF_request_set_ipv4_str
// file ../../src/include/spf_request.h line 59
enum SPF_errcode_t SPF_request_set_ipv4_str(struct SPF_request_struct *sr, const char *astr);
// SPF_request_set_ipv6
// file spf_request.c line 83
enum SPF_errcode_t SPF_request_set_ipv6(struct SPF_request_struct *sr, struct in6_addr addr);
// SPF_request_set_ipv6_str
// file ../../src/include/spf_request.h line 61
enum SPF_errcode_t SPF_request_set_ipv6_str(struct SPF_request_struct *sr, const char *astr);
// SPF_response_add_error
// file ../../src/include/spf_response.h line 234
enum SPF_errcode_t SPF_response_add_error(struct SPF_response_struct *rp, enum SPF_errcode_t code, const char *format, ...);
// SPF_response_add_error_idx
// file spf_response.c line 247
enum SPF_errcode_t SPF_response_add_error_idx(struct SPF_response_struct *rp, enum SPF_errcode_t code, const char *text, signed int idx, const char *format, ...);
// SPF_response_add_error_ptr
// file ../../src/include/spf_response.h line 226
enum SPF_errcode_t SPF_response_add_error_ptr(struct SPF_response_struct *rp, enum SPF_errcode_t code, const char *text, const char *tptr, const char *format, ...);
// SPF_response_add_error_v
// file spf_response.c line 187
static enum SPF_errcode_t SPF_response_add_error_v(struct SPF_response_struct *rp, enum SPF_errcode_t code, signed int is_error, const char *text, signed int idx, const char *format, void **ap);
// SPF_response_add_warn
// file ../../src/include/spf_response.h line 245
enum SPF_errcode_t SPF_response_add_warn(struct SPF_response_struct *rp, enum SPF_errcode_t code, const char *format, ...);
// SPF_response_add_warn_idx
// file spf_response.c line 273
enum SPF_errcode_t SPF_response_add_warn_idx(struct SPF_response_struct *rp, enum SPF_errcode_t code, const char *text, signed int idx, const char *format, ...);
// SPF_response_add_warn_ptr
// file spf_response.c line 264
enum SPF_errcode_t SPF_response_add_warn_ptr(struct SPF_response_struct *rp, enum SPF_errcode_t code, const char *text, const char *tptr, const char *format, ...);
// SPF_response_choose
// file spf_response.c line 78
static struct SPF_response_struct * SPF_response_choose(struct SPF_response_struct *yes, struct SPF_response_struct *no);
// SPF_response_combine
// file ../../src/include/spf_response.h line 198
struct SPF_response_struct * SPF_response_combine(struct SPF_response_struct *main, struct SPF_response_struct *r2mx);
// SPF_response_errcode
// file ../../src/include/spf_response.h line 204
enum SPF_errcode_t SPF_response_errcode(struct SPF_response_struct *rp);
// SPF_response_errors
// file ../../src/include/spf_response.h line 214
signed int SPF_response_errors(struct SPF_response_struct *rp);
// SPF_response_free
// file ../../src/include/spf_response.h line 197
void SPF_response_free(struct SPF_response_struct *rp);
// SPF_response_get_explanation
// file spf_response.c line 177
const char * SPF_response_get_explanation(struct SPF_response_struct *rp);
// SPF_response_get_header_comment
// file ../../src/include/spf_response.h line 207
const char * SPF_response_get_header_comment(struct SPF_response_struct *rp);
// SPF_response_get_received_spf
// file spf_response.c line 153
const char * SPF_response_get_received_spf(struct SPF_response_struct *rp);
// SPF_response_get_received_spf_value
// file spf_response.c line 159
const char * SPF_response_get_received_spf_value(struct SPF_response_struct *rp);
// SPF_response_get_smtp_comment
// file ../../src/include/spf_response.h line 208
const char * SPF_response_get_smtp_comment(struct SPF_response_struct *rp);
// SPF_response_message
// file ../../src/include/spf_response.h line 218
struct SPF_error_struct * SPF_response_message(struct SPF_response_struct *rp, signed int idx);
// SPF_response_messages
// file ../../src/include/spf_response.h line 212
signed int SPF_response_messages(struct SPF_response_struct *rp);
// SPF_response_new
// file ../../src/include/spf_response.h line 196
struct SPF_response_struct * SPF_response_new(struct SPF_request_struct *spf_request);
// SPF_response_reason
// file ../../src/include/spf_response.h line 203
enum SPF_reason_enum SPF_response_reason(struct SPF_response_struct *rp);
// SPF_response_result
// file ../../src/include/spf_response.h line 202
enum SPF_result_enum SPF_response_result(struct SPF_response_struct *rp);
// SPF_response_warnings
// file spf_response.c line 302
signed int SPF_response_warnings(struct SPF_response_struct *rp);
// SPF_sanitize
// file ../../src/include/spf_internal.h line 138
char * SPF_sanitize(struct SPF_server_struct *spf_server, char *str);
// SPF_server_free
// file spf_server.c line 200
void SPF_server_free(struct SPF_server_struct *sp);
// SPF_server_get_default_explanation
// file spf_get_exp.c line 47
static enum SPF_errcode_t SPF_server_get_default_explanation(struct SPF_server_struct *spf_server, struct SPF_request_struct *spf_request, struct SPF_response_struct *spf_response, char **bufp, unsigned long int *buflenp);
// SPF_server_get_max_dns_mech
// file spf_server.c line 504
signed int SPF_server_get_max_dns_mech(struct SPF_server_struct *s);
// SPF_server_get_max_dns_mx
// file ../../src/include/spf_server.h line 105
signed int SPF_server_get_max_dns_mx(struct SPF_server_struct *s);
// SPF_server_get_max_dns_ptr
// file ../../src/include/spf_server.h line 104
signed int SPF_server_get_max_dns_ptr(struct SPF_server_struct *s);
// SPF_server_get_record
// file ../../src/include/spf_server.h line 89
enum SPF_errcode_t SPF_server_get_record(struct SPF_server_struct *spf_server, struct SPF_request_struct *spf_request, struct SPF_response_struct *spf_response, struct SPF_record_struct **spf_recordp);
// SPF_server_new
// file ../../src/include/spf_server.h line 76
struct SPF_server_struct * SPF_server_new(enum SPF_server_dnstype_enum dnstype, signed int debug);
// SPF_server_new_common_post
// file spf_server.c line 102
static void SPF_server_new_common_post(struct SPF_server_struct *sp);
// SPF_server_new_common_pre
// file spf_server.c line 85
static void SPF_server_new_common_pre(struct SPF_server_struct *sp, signed int debug);
// SPF_server_new_dns
// file spf_server.c line 180
struct SPF_server_struct * SPF_server_new_dns(struct SPF_dns_server_struct *dns, signed int debug);
// SPF_server_set_explanation
// file ../../src/include/spf_server.h line 83
enum SPF_errcode_t SPF_server_set_explanation(struct SPF_server_struct *sp, const char *exp, struct SPF_response_struct **spf_responsep);
// SPF_server_set_localpolicy
// file ../../src/include/spf_server.h line 85
enum SPF_errcode_t SPF_server_set_localpolicy(struct SPF_server_struct *sp, const char *policy, signed int use_default_whitelist, struct SPF_response_struct **spf_responsep);
// SPF_server_set_max_dns_mech
// file ../../src/include/spf_server.h line 103
enum SPF_errcode_t SPF_server_set_max_dns_mech(struct SPF_server_struct *s, signed int n);
// SPF_server_set_max_dns_mx
// file spf_server.c line 506
enum SPF_errcode_t SPF_server_set_max_dns_mx(struct SPF_server_struct *s, signed int n);
// SPF_server_set_max_dns_ptr
// file spf_server.c line 505
enum SPF_errcode_t SPF_server_set_max_dns_ptr(struct SPF_server_struct *s, signed int n);
// SPF_server_set_rec_dom
// file ../../src/include/spf_server.h line 79
enum SPF_errcode_t SPF_server_set_rec_dom(struct SPF_server_struct *sp, const char *dom);
// SPF_server_set_rec_dom_ghbn
// file spf_server.c line 68
static enum SPF_errcode_t SPF_server_set_rec_dom_ghbn(struct SPF_server_struct *sp);
// SPF_server_set_sanitize
// file ../../src/include/spf_server.h line 81
enum SPF_errcode_t SPF_server_set_sanitize(struct SPF_server_struct *sp, signed int sanitize);
// SPF_strerror
// file ../../src/include/spf.h line 74
const char * SPF_strerror(enum SPF_errcode_t spf_c_err);
// SPF_strreason
// file ../../src/include/spf.h line 80
const char * SPF_strreason(enum SPF_reason_enum reason);
// SPF_strresult
// file ../../src/include/spf.h line 78
const char * SPF_strresult(enum SPF_result_enum result);
// SPF_strrrtype
// file ../../src/include/spf.h line 89
const char * SPF_strrrtype(enum __ns_type rr_type);
// SPF_voidp2spfhook
// file spf_dns_cache.c line 113
static inline struct anonymous_1 * SPF_voidp2spfhook(void *hook);
// SPF_voidp2spfhook_link1
// file spf_dns_zone.c line 83
static inline struct anonymous_9 * SPF_voidp2spfhook_link1(void *hook_link1);
// SPF_warning_handler_object
//
void SPF_warning_handler_object(const char *, signed int, const char *);
// SPF_warning_stdio
// file ../../src/include/spf_log.h line 88
void SPF_warning_stdio(const char *file, signed int line, const char *errmsg);
// SPF_warning_syslog
// file spf_log_syslog.c line 52
void SPF_warning_syslog(const char *file, signed int line, const char *errmsg);
// SPF_warningv
// file spf_log.c line 124
void SPF_warningv(const char *file, signed int line, const char *format, void **ap);
// SPF_warningx
// file ../../src/include/spf_log.h line 46
void SPF_warningx(const char *file, signed int line, const char *format, ...);
// SPF_warningx2
// file spf_log.c line 176
void SPF_warningx2(const char *format, ...);
// W
// file spfd.c line 364
static inline const char * W(const char *c);
// __ctype_b_loc
// file /usr/include/ctype.h line 79
extern const unsigned short int ** __ctype_b_loc(void);
// __dn_expand
// file arpa_nameser.h line 64
signed int __dn_expand(const unsigned char *, const unsigned char *, const unsigned char *, char *, signed int);
// __dn_skipname
// file arpa_nameser.h line 68
signed int __dn_skipname(const unsigned char *, const unsigned char *);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// __ns_get16
// file __ns_get16.c line 15
unsigned int __ns_get16(const unsigned char *src);
// __ns_initparse
// file __ns_initparse.c line 100
signed int __ns_initparse(const unsigned char *msg, signed int msglen, struct __ns_msg *handle);
// __ns_msg_getflag
// file __ns_msg_getflag.c line 15
signed int __ns_msg_getflag(struct __ns_msg handle, signed int flag);
// __ns_name_compress
// file __ns_name_uncompress.c line 613
signed int __ns_name_compress(const char *src, unsigned char *dst, unsigned long int dstsiz, const unsigned char **dnptrs, const unsigned char **lastdnptr);
// __ns_name_ntol
// file __ns_name_uncompress.c line 344
signed int __ns_name_ntol(const unsigned char *src, unsigned char *dst, unsigned long int dstsiz);
// __ns_name_ntop
// file __ns_name_uncompress.c line 106
signed int __ns_name_ntop(const unsigned char *src, char *dst, unsigned long int dstsiz);
// __ns_name_pack
// file __ns_name_uncompress.c line 485
signed int __ns_name_pack(const unsigned char *src, unsigned char *dst, signed int dstsiz, const unsigned char **dnptrs, const unsigned char **lastdnptr);
// __ns_name_pton
// file __ns_name_uncompress.c line 209
signed int __ns_name_pton(const char *src, unsigned char *dst, unsigned long int dstsiz);
// __ns_name_rollback
// file __ns_name_uncompress.c line 628
void __ns_name_rollback(const unsigned char *src, const unsigned char **dnptrs, const unsigned char **lastdnptr);
// __ns_name_skip
// file __ns_name_uncompress.c line 647
signed int __ns_name_skip(const unsigned char **ptrptr, const unsigned char *eom);
// __ns_name_uncompress
// file __ns_name_uncompress.c line 585
signed int __ns_name_uncompress(const unsigned char *msg, const unsigned char *eom, const unsigned char *src, char *dst, unsigned long int dstsiz);
// __ns_name_unpack
// file __ns_name_uncompress.c line 394
signed int __ns_name_unpack(const unsigned char *msg, const unsigned char *eom, const unsigned char *src, unsigned char *dst, unsigned long int dstsiz);
// __ns_parserr
// file __ns_initparse.c line 137
signed int __ns_parserr(struct __ns_msg *handle, enum __ns_sect section, signed int rrnum, struct __ns_rr *rr);
// __ns_skiprr
// file __ns_initparse.c line 76
signed int __ns_skiprr(const unsigned char *ptr, const unsigned char *eom, enum __ns_sect section, signed int count);
// __res_nclose
// file /usr/include/resolv.h line 385
void __res_nclose(struct __res_state *);
// __res_ninit
// file /usr/include/resolv.h line 366
signed int __res_ninit(struct __res_state *);
// __res_nquery
// file /usr/include/resolv.h line 374
signed int __res_nquery(struct __res_state *, const char *, signed int, signed int, unsigned char *, signed int);
// _align_ptr
// file ../../src/include/spf_internal.h line 76
static inline char * _align_ptr(char *s);
// _align_ptr_link1
// file ../../src/include/spf_internal.h line 76
static inline char * _align_ptr_link1(char *s_link1);
// _align_ptr_link2
// file ../../src/include/spf_internal.h line 76
static inline char * _align_ptr_link2(char *s_link2);
// _align_ptr_link3
// file ../../src/include/spf_internal.h line 76
static inline char * _align_ptr_link3(char *s_link3);
// _align_ptr_link4
// file ../../src/include/spf_internal.h line 76
static inline char * _align_ptr_link4(char *s_link4);
// _align_sz
// file ../../src/include/spf_internal.h line 74
static inline unsigned long int _align_sz(unsigned long int s);
// _align_sz_link1
// file ../../src/include/spf_internal.h line 74
static inline unsigned long int _align_sz_link1(unsigned long int s_link1);
// _align_sz_link2
// file ../../src/include/spf_internal.h line 74
static inline unsigned long int _align_sz_link2(unsigned long int s_link2);
// abort
// file /usr/include/stdlib.h line 515
extern void abort(void);
// accept
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 243
extern signed int accept(signed int, union anonymous_8, unsigned int *);
// atol
// file /usr/include/stdlib.h line 150
extern signed long int atol(const char *);
// bind
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 123
extern signed int bind(signed int, union anonymous_8, unsigned int);
// calloc
// file /usr/include/stdlib.h line 468
extern void * calloc(unsigned long int, unsigned long int);
// crc32str
// file spf_dns_cache.c line 218
static inline signed int crc32str(unsigned int accum, const char *str, signed int max_hash_len);
// daemon_bind_inet_tcp
// file spfd.c line 595
static signed int daemon_bind_inet_tcp();
// daemon_bind_inet_udp
// file spfd.c line 571
static signed int daemon_bind_inet_udp();
// daemon_bind_unix
// file spfd.c line 632
static signed int daemon_bind_unix();
// daemon_config
// file spfd.c line 502
static void daemon_config(signed int argc, char **argv);
// daemon_get_group
// file spfd.c line 486
static unsigned int daemon_get_group(const char *arg);
// daemon_get_user
// file spfd.c line 469
static unsigned int daemon_get_user(const char *arg);
// daemon_init
// file spfd.c line 665
static void daemon_init();
// daemon_main
// file spfd.c line 862
static void daemon_main();
// decode_bitstring
// file __ns_name_uncompress.c line 803
static signed int decode_bitstring(const char **cpp, char *dn, const char *eom);
// dn_find
// file __ns_name_uncompress.c line 744
static signed int dn_find(const unsigned char *domain, const unsigned char *msg, const unsigned char * const *dnptrs, const unsigned char * const *lastdnptr);
// encode_bitsring
// file __ns_name_uncompress.c line 851
static signed int encode_bitsring(const char **bp, const char *end, char **labelp, char **dst, const char *eom);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// fdopen
// file /usr/include/stdio.h line 306
extern struct _IO_FILE * fdopen(signed int, const char *);
// feof
// file /usr/include/stdio.h line 828
extern signed int feof(struct _IO_FILE *);
// fflush
// file /usr/include/stdio.h line 242
extern signed int fflush(struct _IO_FILE *);
// fgets
// file /usr/include/stdio.h line 622
extern char * fgets(char *, signed int, struct _IO_FILE *);
// find_field
// file spfd.c line 730
static char ** find_field(struct _request_t *req, const char *key);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// getgrgid
// file /usr/include/grp.h line 102
extern struct group * getgrgid(unsigned int);
// getgrnam
// file /usr/include/grp.h line 108
extern struct group * getgrnam(const char *);
// gethostname
// file /usr/include/unistd.h line 882
extern signed int gethostname(char *, unsigned long int);
// getopt_long
// file /usr/include/getopt.h line 173
extern signed int getopt_long(signed int, char * const *, const char *, struct option *, signed int *);
// getpwnam
// file /usr/include/pwd.h line 116
extern struct passwd * getpwnam(const char *);
// getpwuid
// file /usr/include/pwd.h line 110
extern struct passwd * getpwuid(unsigned int);
// handle_datagram
// file spfd.c line 748
static void * handle_datagram(void *arg);
// handle_stream
// file spfd.c line 811
static void * handle_stream(void *arg);
// hstrerror
// file /usr/include/netdb.h line 95
extern const char * hstrerror(signed int);
// htonl
// file /usr/include/netinet/in.h line 377
extern unsigned int htonl(unsigned int);
// htons
// file /usr/include/netinet/in.h line 379
extern unsigned short int htons(unsigned short int);
// inet_ntop
// file /usr/include/arpa/inet.h line 64
extern const char * inet_ntop(signed int, const void *, char *, unsigned int);
// inet_pton
// file /usr/include/arpa/inet.h line 58
extern signed int inet_pton(signed int, const char *, void *);
// labellen
// file __ns_name_uncompress.c line 956
static signed int labellen(const unsigned char *lp);
// listen
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 233
extern signed int listen(signed int, signed int);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// memcmp
// file /usr/include/string.h line 65
extern signed int memcmp(const void *, const void *, unsigned long int);
// memcpy
// file /usr/include/string.h line 42
extern void * memcpy(void *, const void *, unsigned long int);
// memmove
// file /usr/include/string.h line 46
extern void * memmove(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 62
extern void * memset(void *, signed int, unsigned long int);
// mklower
// file __ns_name_uncompress.c line 728
static signed int mklower(signed int ch);
// ns_get16
// file /usr/include/arpa/nameser.h line 473
unsigned int ns_get16(const unsigned char *);
// ns_initparse
// file /usr/include/arpa/nameser.h line 477
signed int ns_initparse(const unsigned char *, signed int, struct __ns_msg *);
// ns_msg_getflag
// file /usr/include/arpa/nameser.h line 472
signed int ns_msg_getflag(struct __ns_msg, signed int);
// ns_name_uncompress
// file /usr/include/arpa/nameser.h line 498
signed int ns_name_uncompress(const unsigned char *, const unsigned char *, const unsigned char *, char *, unsigned long int);
// ns_parserr
// file /usr/include/arpa/nameser.h line 480
signed int ns_parserr(struct __ns_msg *, enum __ns_sect, signed int, struct __ns_rr *);
// ntohl
// file /usr/include/netinet/in.h line 374
extern unsigned int ntohl(unsigned int);
// perror
// file /usr/include/stdio.h line 846
extern void perror(const char *);
// printable
// file __ns_name_uncompress.c line 719
static signed int printable(signed int ch);
// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// pthread_attr_destroy
// file /usr/include/pthread.h line 290
extern signed int pthread_attr_destroy(union pthread_attr_t *);
// pthread_attr_init
// file /usr/include/pthread.h line 287
extern signed int pthread_attr_init(union pthread_attr_t *);
// pthread_attr_setdetachstate
// file /usr/include/pthread.h line 299
extern signed int pthread_attr_setdetachstate(union pthread_attr_t *, signed int);
// pthread_create
// file /usr/include/pthread.h line 233
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_getspecific
// file /usr/include/pthread.h line 1119
extern void * pthread_getspecific(unsigned int);
// pthread_key_create
// file /usr/include/pthread.h line 1111
extern signed int pthread_key_create(unsigned int *, void (*)(void *));
// pthread_mutex_destroy
// file /usr/include/pthread.h line 754
extern signed int pthread_mutex_destroy(union anonymous_0 *);
// pthread_mutex_init
// file /usr/include/pthread.h line 749
extern signed int pthread_mutex_init(union anonymous_0 *, const union anonymous *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 762
extern signed int pthread_mutex_lock(union anonymous_0 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 773
extern signed int pthread_mutex_unlock(union anonymous_0 *);
// pthread_once
// file /usr/include/pthread.h line 494
extern signed int pthread_once(signed int *, void (*)(void));
// pthread_setspecific
// file /usr/include/pthread.h line 1122
extern signed int pthread_setspecific(unsigned int, const void *);
// realloc
// file /usr/include/stdlib.h line 480
extern void * realloc(void *, unsigned long int);
// recvfrom
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 174
extern signed long int recvfrom(signed int, void *, unsigned long int, signed int, union anonymous_8, unsigned int *);
// request_check
// file spfd.c line 249
static const char * request_check(struct _request_t *req);
// request_format
// file spfd.c line 372
static void request_format(struct _request_t *req);
// request_handle
// file spfd.c line 410
static void request_handle(struct _request_t *req);
// request_query
// file spfd.c line 266
static void request_query(struct _request_t *req);
// response_print
// file spfd.c line 228
static void response_print(const char *context, struct SPF_response_struct *spf_response);
// response_print_errors
// file spfd.c line 200
static void response_print_errors(const char *context, struct SPF_response_struct *spf_response, enum SPF_errcode_t err);
// select
// file /usr/include/x86_64-linux-gnu/sys/select.h line 106
extern signed int select(signed int, struct anonymous_10 *, struct anonymous_10 *, struct anonymous_10 *, struct timeval *);
// send
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 149
extern signed long int send(signed int, const void *, unsigned long int, signed int);
// sendto
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 163
extern signed long int sendto(signed int, const void *, unsigned long int, signed int, union anonymous_8, unsigned int);
// setsection
// file __ns_initparse.c line 198
static void setsection(struct __ns_msg *msg, enum __ns_sect sect);
// setsockopt
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 226
extern signed int setsockopt(signed int, signed int, signed int, const void *, unsigned int);
// snprintf
// file /usr/include/stdio.h line 386
extern signed int snprintf(char *, unsigned long int, const char *, ...);
// socket
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 113
extern signed int socket(signed int, signed int, signed int);
// special
// file __ns_name_uncompress.c line 694
static signed int special(signed int ch);
// sprintf
// file /usr/include/stdio.h line 364
extern signed int sprintf(char *, const char *, ...);
// strcasecmp
// file /usr/include/string.h line 529
extern signed int strcasecmp(const char *, const char *);
// strchr
// file /usr/include/string.h line 231
extern char * strchr(const char *, signed int);
// strcmp
// file /usr/include/string.h line 140
extern signed int strcmp(const char *, const char *);
// strcpy
// file /usr/include/string.h line 125
extern char * strcpy(char *, const char *);
// strcspn
// file /usr/include/string.h line 280
extern unsigned long int strcspn(const char *, const char *);
// strdup
// file /usr/include/string.h line 171
extern char * strdup(const char *);
// strerror
// file /usr/include/string.h line 408
extern char * strerror(signed int);
// strlen
// file /usr/include/string.h line 394
extern unsigned long int strlen(const char *);
// strncasecmp
// file /usr/include/string.h line 533
extern signed int strncasecmp(const char *, const char *, unsigned long int);
// strncmp
// file /usr/include/string.h line 143
extern signed int strncmp(const char *, const char *, unsigned long int);
// strncpy
// file /usr/include/string.h line 128
extern char * strncpy(char *, const char *, unsigned long int);
// strrchr
// file /usr/include/string.h line 258
extern char * strrchr(const char *, signed int);
// strstr
// file /usr/include/string.h line 337
extern char * strstr(const char *, const char *);
// strtol
// file /usr/include/stdlib.h line 183
extern signed long int strtol(const char *, char ** restrict , signed int);
// strtoul
// file /usr/include/stdlib.h line 187
extern unsigned long int strtoul(const char *, char ** restrict , signed int);
// syslog
// file /usr/include/x86_64-linux-gnu/sys/syslog.h line 190
extern void syslog(signed int, const char *, ...);
// time
// file /usr/include/time.h line 192
extern signed long int time(signed long int *);
// tolower
// file /usr/include/ctype.h line 124
extern signed int tolower(signed int);
// toupper
// file /usr/include/ctype.h line 127
extern signed int toupper(signed int);
// unlink
// file /usr/include/unistd.h line 829
extern signed int unlink(const char *);
// usage
// file spfd.c line 443
void usage(void);
// vsnprintf
// file /usr/include/stdio.h line 390
extern signed int vsnprintf(char *, unsigned long int, const char *, void **);

struct anonymous_9
{
  // zone
  struct SPF_dns_rr_struct **zone;
  // num_zone
  signed int num_zone;
  // zone_buf_len
  signed int zone_buf_len;
  // nxdomain
  struct SPF_dns_rr_struct *nxdomain;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous_0
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct anonymous_1
{
  // cache
  struct _SPF_dns_cache_bucket_t **cache;
  // cache_size
  signed int cache_size;
  // cache_lock
  union anonymous_0 cache_lock;
  // hash_mask
  signed int hash_mask;
  // max_hash_len
  signed int max_hash_len;
  // min_ttl
  signed long int min_ttl;
  // err_ttl
  signed long int err_ttl;
  // txt_ttl
  signed long int txt_ttl;
  // rdns_ttl
  signed long int rdns_ttl;
  // conserve_cache
  signed int conserve_cache;
};

struct anonymous_7
{
  // domain
  const char *domain;
  // rr_type
  signed int rr_type;
  // herrno
  signed int herrno;
  // data
  const char *data;
};

struct anonymous_10
{
  // fds_bits
  signed long int fds_bits[16l];
};

struct in_addr
{
  // s_addr
  unsigned int s_addr;
};

struct anonymous_3
{
  // addr
  struct in_addr addr;
  // mask
  unsigned int mask;
};

union anonymous_12
{
  // __u6_addr8
  unsigned char __u6_addr8[16l];
  // __u6_addr16
  unsigned short int __u6_addr16[8l];
  // __u6_addr32
  unsigned int __u6_addr32[4l];
};

struct in6_addr
{
  // __in6_u
  union anonymous_12 __in6_u;
};

struct sockaddr_in6
{
  // sin6_family
  unsigned short int sin6_family;
  // sin6_port
  unsigned short int sin6_port;
  // sin6_flowinfo
  unsigned int sin6_flowinfo;
  // sin6_addr
  struct in6_addr sin6_addr;
  // sin6_scope_id
  unsigned int sin6_scope_id;
};

struct anonymous_2
{
  // nscount
  unsigned short int nscount;
  // nsmap
  unsigned short int nsmap[3l];
  // nssocks
  signed int nssocks[3l];
  // nscount6
  unsigned short int nscount6;
  // nsinit
  unsigned short int nsinit;
  // nsaddrs
  struct sockaddr_in6 *nsaddrs[3l];
  // _initstamp
  unsigned int _initstamp[2l];
};

union anonymous
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

union anonymous_5
{
  // pad
  char pad[52l];
  // _ext
  struct anonymous_2 _ext;
};

union anonymous_13
{
  // a
  struct in_addr a;
  // ptr
  char ptr[1l];
  // mx
  char mx[1l];
  // txt
  char txt[1l];
  // aaaa
  struct in6_addr aaaa;
};

struct sockaddr
{
  // sa_family
  unsigned short int sa_family;
  // sa_data
  char sa_data[14l];
};

struct sockaddr_in
{
  // sin_family
  unsigned short int sin_family;
  // sin_port
  unsigned short int sin_port;
  // sin_addr
  struct in_addr sin_addr;
  // sin_zero
  unsigned char sin_zero[8l];
};

struct sockaddr_un
{
  // sun_family
  unsigned short int sun_family;
  // sun_path
  char sun_path[108l];
};

union anonymous_14
{
  // in
  struct sockaddr_in in;
  // un
  struct sockaddr_un un;
};

union anonymous_15
{
  // __sockaddr__
  struct sockaddr * restrict __sockaddr__;
  // __sockaddr_at__
  struct sockaddr_at * restrict __sockaddr_at__;
  // __sockaddr_ax25__
  struct sockaddr_ax25 * restrict __sockaddr_ax25__;
  // __sockaddr_dl__
  struct sockaddr_dl * restrict __sockaddr_dl__;
  // __sockaddr_eon__
  struct sockaddr_eon * restrict __sockaddr_eon__;
  // __sockaddr_in__
  struct sockaddr_in * restrict __sockaddr_in__;
  // __sockaddr_in6__
  struct sockaddr_in6 * restrict __sockaddr_in6__;
  // __sockaddr_inarp__
  struct sockaddr_inarp * restrict __sockaddr_inarp__;
  // __sockaddr_ipx__
  struct sockaddr_ipx * restrict __sockaddr_ipx__;
  // __sockaddr_iso__
  struct sockaddr_iso * restrict __sockaddr_iso__;
  // __sockaddr_ns__
  struct sockaddr_ns * restrict __sockaddr_ns__;
  // __sockaddr_un__
  struct sockaddr_un * restrict __sockaddr_un__;
  // __sockaddr_x25__
  struct sockaddr_x25 * restrict __sockaddr_x25__;
};

union anonymous_8
{
  // __sockaddr__
  struct sockaddr * restrict __sockaddr__;
  // __sockaddr_at__
  struct sockaddr_at * restrict __sockaddr_at__;
  // __sockaddr_ax25__
  struct sockaddr_ax25 * restrict __sockaddr_ax25__;
  // __sockaddr_dl__
  struct sockaddr_dl * restrict __sockaddr_dl__;
  // __sockaddr_eon__
  struct sockaddr_eon * restrict __sockaddr_eon__;
  // __sockaddr_in__
  struct sockaddr_in * restrict __sockaddr_in__;
  // __sockaddr_in6__
  struct sockaddr_in6 * restrict __sockaddr_in6__;
  // __sockaddr_inarp__
  struct sockaddr_inarp * restrict __sockaddr_inarp__;
  // __sockaddr_ipx__
  struct sockaddr_ipx * restrict __sockaddr_ipx__;
  // __sockaddr_iso__
  struct sockaddr_iso * restrict __sockaddr_iso__;
  // __sockaddr_ns__
  struct sockaddr_ns * restrict __sockaddr_ns__;
  // __sockaddr_un__
  struct sockaddr_un * restrict __sockaddr_un__;
  // __sockaddr_x25__
  struct sockaddr_x25 * restrict __sockaddr_x25__;
} __attribute__ ((__transparent_union__));

struct SPF_data_cidr_struct
{
  // parm_type
  unsigned char parm_type;
  // ipv4
  unsigned char ipv4;
  // ipv6
  unsigned char ipv6;
  // __unused0
  unsigned char __unused0;
};

struct SPF_data_str_struct
{
  // parm_type
  unsigned char parm_type;
  // len
  unsigned char len;
  // __unused0
  unsigned char __unused0;
  // __unused1
  unsigned char __unused1;
};

struct SPF_data_var_struct
{
  // parm_type
  unsigned char parm_type;
  // num_rhs
  unsigned char num_rhs;
  // rev
  unsigned short int rev : 1;
  // url_encode
  unsigned short int url_encode : 1;
  // delim_dot
  unsigned short int delim_dot : 1;
  // delim_dash
  unsigned short int delim_dash : 1;
  // delim_plus
  unsigned short int delim_plus : 1;
  // delim_equal
  unsigned short int delim_equal : 1;
  // delim_bar
  unsigned short int delim_bar : 1;
  // delim_under
  unsigned short int delim_under : 1;
};

union SPF_data_union
{
  // dv
  struct SPF_data_var_struct dv;
  // ds
  struct SPF_data_str_struct ds;
  // dc
  struct SPF_data_cidr_struct dc;
};

struct SPF_dns_rr_struct
{
  // domain
  char *domain;
  // domain_buf_len
  unsigned long int domain_buf_len;
  // rr_type
  enum __ns_type rr_type;
  // num_rr
  signed int num_rr;
  // rr
  union anonymous_13 **rr;
  // rr_buf_len
  unsigned long int *rr_buf_len;
  // rr_buf_num
  signed int rr_buf_num;
  // ttl
  signed long int ttl;
  // utc_ttl
  signed long int utc_ttl;
  // herrno
  signed int herrno;
  // hook
  void *hook;
  // source
  struct SPF_dns_server_struct *source;
};

struct SPF_dns_server_struct
{
  // destroy
  void (*destroy)(struct SPF_dns_server_struct *);
  // lookup
  struct SPF_dns_rr_struct * (*lookup)(struct SPF_dns_server_struct *, const char *, enum __ns_type, signed int);
  // get_spf
  enum SPF_errcode_t (*get_spf)(struct SPF_server_struct *, struct SPF_request_struct *, struct SPF_response_struct *, struct SPF_record_struct **);
  // get_exp
  enum SPF_errcode_t (*get_exp)(struct SPF_server_struct *, const char *, char **, unsigned long int *);
  // add_cache
  signed int (*add_cache)(struct SPF_server_struct *, struct SPF_dns_rr_struct);
  // layer_below
  struct SPF_dns_server_struct *layer_below;
  // name
  const char *name;
  // debug
  signed int debug;
  // hook
  void *hook;
};

struct SPF_error_struct
{
  // code
  enum SPF_errcode_t code;
  // message
  char *message;
  // is_error
  char is_error;
};

struct SPF_macro_struct
{
  // macro_len
  unsigned long int macro_len;
};

struct SPF_mech_struct
{
  // prefix_type
  unsigned char prefix_type;
  // mech_type
  unsigned char mech_type;
  // mech_len
  unsigned short int mech_len;
};

struct SPF_mechtype_struct
{
  // mech_type
  unsigned char mech_type;
  // is_dns_mech
  unsigned char is_dns_mech;
  // has_domainspec
  enum SPF_domspec_enum has_domainspec;
  // has_cidr
  enum SPF_cidr_enum has_cidr;
};

struct SPF_mod_struct
{
  // name_len
  unsigned short int name_len;
  // data_len
  unsigned short int data_len;
};

struct SPF_record_struct
{
  // spf_server
  struct SPF_server_struct *spf_server;
  // version
  unsigned char version;
  // num_mech
  unsigned char num_mech;
  // num_mod
  unsigned char num_mod;
  // num_dns_mech
  unsigned char num_dns_mech;
  // mech_first
  struct SPF_mech_struct *mech_first;
  // mech_size
  unsigned long int mech_size;
  // mech_len
  unsigned long int mech_len;
  // mod_first
  struct SPF_mod_struct *mod_first;
  // mod_size
  unsigned long int mod_size;
  // mod_len
  unsigned long int mod_len;
};

struct SPF_request_struct
{
  // spf_server
  struct SPF_server_struct *spf_server;
  // client_ver
  signed int client_ver;
  // ipv4
  struct in_addr ipv4;
  // ipv6
  struct in6_addr ipv6;
  // env_from
  char *env_from;
  // helo_dom
  char *helo_dom;
  // rcpt_to_dom
  char *rcpt_to_dom;
  // use_local_policy
  char use_local_policy;
  // use_helo
  char use_helo;
  // env_from_lp
  char *env_from_lp;
  // env_from_dp
  char *env_from_dp;
  // client_dom
  char *client_dom;
  // cur_dom
  const char *cur_dom;
};

struct SPF_response_struct
{
  // spf_request
  struct SPF_request_struct *spf_request;
  // spf_record_exp
  struct SPF_record_struct *spf_record_exp;
  // result
  enum SPF_result_enum result;
  // reason
  enum SPF_reason_enum reason;
  // err
  enum SPF_errcode_t err;
  // received_spf
  char *received_spf;
  // received_spf_value
  char *received_spf_value;
  // header_comment
  char *header_comment;
  // smtp_comment
  char *smtp_comment;
  // explanation
  char *explanation;
  // errors
  struct SPF_error_struct *errors;
  // errors_size
  unsigned short int errors_size;
  // errors_length
  unsigned short int errors_length;
  // num_errors
  unsigned short int num_errors;
  // num_dns_mech
  signed int num_dns_mech;
};

struct SPF_server_struct
{
  // resolver
  struct SPF_dns_server_struct *resolver;
  // local_policy
  struct SPF_record_struct *local_policy;
  // explanation
  struct SPF_macro_struct *explanation;
  // rec_dom
  char *rec_dom;
  // max_dns_mech
  signed int max_dns_mech;
  // max_dns_ptr
  signed int max_dns_ptr;
  // max_dns_mx
  signed int max_dns_mx;
  // sanitize
  signed int sanitize;
  // debug
  signed int debug;
  // destroy_resolver
  signed int destroy_resolver;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct _SPF_dns_cache_bucket_t
{
  // next
  struct _SPF_dns_cache_bucket_t *next;
  // rr
  struct SPF_dns_rr_struct *rr;
};

struct __ns_msg
{
  // _msg
  const unsigned char *_msg;
  // _eom
  const unsigned char *_eom;
  // _id
  unsigned short int _id;
  // _flags
  unsigned short int _flags;
  // _counts
  unsigned short int _counts[4l];
  // _sections
  const unsigned char *_sections[4l];
  // _sect
  enum __ns_sect _sect;
  // _rrnum
  signed int _rrnum;
  // _msg_ptr
  const unsigned char *_msg_ptr;
};

struct __ns_rr
{
  // name
  char name[1025l];
  // type
  unsigned short int type;
  // rr_class
  unsigned short int rr_class;
  // ttl
  unsigned int ttl;
  // rdlength
  unsigned short int rdlength;
  // rdata
  const unsigned char *rdata;
};

struct __res_state
{
  // retrans
  signed int retrans;
  // retry
  signed int retry;
  // options
  unsigned long int options;
  // nscount
  signed int nscount;
  // nsaddr_list
  struct sockaddr_in nsaddr_list[3l];
  // id
  unsigned short int id;
  // dnsrch
  char *dnsrch[7l];
  // defdname
  char defdname[256l];
  // pfcode
  unsigned long int pfcode;
  // ndots
  unsigned int ndots : 4;
  // nsort
  unsigned int nsort : 4;
  // ipv6_unavail
  unsigned int ipv6_unavail : 1;
  // unused
  unsigned int unused : 23;
  // sort_list
  struct anonymous_3 sort_list[10l];
  // qhook
  enum anonymous_4 (*qhook)(struct sockaddr_in * const *, const unsigned char **, signed int *, unsigned char *, signed int, signed int *);
  // rhook
  enum anonymous_4 (*rhook)(struct sockaddr_in *, const unsigned char *, signed int, unsigned char *, signed int, signed int *);
  // res_h_errno
  signed int res_h_errno;
  // _vcsock
  signed int _vcsock;
  // _flags
  unsigned int _flags;
  // _u
  union anonymous_5 _u;
};

struct _config_t
{
  // tcpport
  signed int tcpport;
  // udpport
  signed int udpport;
  // path
  char *path;
  // pathuser
  unsigned int pathuser;
  // pathgroup
  unsigned int pathgroup;
  // pathmode
  signed int pathmode;
  // setuser
  unsigned int setuser;
  // setgroup
  unsigned int setgroup;
  // debug
  signed int debug;
  // sec_mx
  signed int sec_mx;
  // fallback
  char *fallback;
  // rec_dom
  char *rec_dom;
  // sanitize
  signed int sanitize;
  // max_lookup
  signed int max_lookup;
  // localpolicy
  char *localpolicy;
  // use_trusted
  signed int use_trusted;
  // explanation
  char *explanation;
};

struct _ns_flagdata
{
  // mask
  signed int mask;
  // shift
  signed int shift;
};

struct _request_t
{
  // sock
  signed int sock;
  // addr
  union anonymous_14 addr;
  // addrlen
  unsigned int addrlen;
  // data
  char *data;
  // datalen
  signed int datalen;
  // ip
  char *ip;
  // helo
  char *helo;
  // sender
  char *sender;
  // rcpt_to
  char *rcpt_to;
  // spf_err
  enum SPF_errcode_t spf_err;
  // spf_request
  struct SPF_request_struct *spf_request;
  // spf_response
  struct SPF_response_struct *spf_response;
  // fmt
  char fmt[4096l];
  // fmtlen
  signed int fmtlen;
};

struct _state_t
{
  // sock_udp
  signed int sock_udp;
  // sock_tcp
  signed int sock_tcp;
  // sock_unix
  signed int sock_unix;
};

struct group
{
  // gr_name
  char *gr_name;
  // gr_passwd
  char *gr_passwd;
  // gr_gid
  unsigned int gr_gid;
  // gr_mem
  char **gr_mem;
};

struct option
{
  // name
  const char *name;
  // has_arg
  signed int has_arg;
  // flag
  signed int *flag;
  // val
  signed int val;
};

struct passwd
{
  // pw_name
  char *pw_name;
  // pw_passwd
  char *pw_passwd;
  // pw_uid
  unsigned int pw_uid;
  // pw_gid
  unsigned int pw_gid;
  // pw_gecos
  char *pw_gecos;
  // pw_dir
  char *pw_dir;
  // pw_shell
  char *pw_shell;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct res_sym
{
  // number
  signed int number;
  // name
  char *name;
  // humanname
  char *humanname;
};

struct timeval
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};


// SPF_debug_handler
// file spf_log_default.c line 32
void (*SPF_debug_handler)(const char *, signed int, const char *);
// SPF_debug_handler
// file spf_log_default.c line 32
void (*SPF_debug_handler)(const char *, signed int, const char *) = SPF_debug_stdio;
// SPF_dns_db
// file spf_dns_test.c line 59
static const struct anonymous_7 SPF_dns_db[175l] = { { .domain="localhost", .rr_type=1, .herrno=0, .data="127.0.0.1" },
    { .domain="example.com", .rr_type=1, .herrno=0, .data="192.0.2.3" },
    { .domain="example.com", .rr_type=15, .herrno=0, .data="mx.example.org" },
    { .domain="example.com", .rr_type=16, .herrno=0, .data="v=spf1 mx -all" },
    { .domain="3.2.0.192.in-addr.arpa", .rr_type=12, .herrno=0,
    .data="mx.example.org" },
    { .domain="1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.8.5.d.a.0.8.0.0.0.2.5.0.f.5.in6.arpa", .rr_type=12,
    .herrno=0, .data="mx.example.org" },
    { .domain="noexist.example.com", .rr_type=1, .herrno=1,
    .data=(const char *)(void *)0 },
    { .domain="mx.example.org", .rr_type=1, .herrno=0, .data="192.0.2.3" },
    { .domain="mx.example.org", .rr_type=28, .herrno=0,
    .data="5f05:2000:80ad:5800::1" },
    { .domain="email.example.com", .rr_type=16, .herrno=0,
    .data="v=spf1 -all" },
    { .domain="*.example.com", .rr_type=255, .herrno=1,
    .data=(const char *)(void *)0 },
    { .domain="*.example.org", .rr_type=255, .herrno=1,
    .data=(const char *)(void *)0 },
    { .domain="*.example.net", .rr_type=255, .herrno=1,
    .data=(const char *)(void *)0 },
    { .domain="01.spf1-test.mailzone.com", .rr_type=16, .herrno=0,
    .data="v=spf1                                                             " },
    { .domain="02.spf1-test.mailzone.com", .rr_type=16, .herrno=0,
    .data="v=spf1                                             -all       " },
    { .domain="03.spf1-test.mailzone.com", .rr_type=16, .herrno=0,
    .data="v=spf1                                             ~all" },
    { .domain="05.spf1-test.mailzone.com", .rr_type=16, .herrno=0,
    .data="v=spf1                                             default=deny   " },
    { .domain="06.spf1-test.mailzone.com", .rr_type=16, .herrno=0,
    .data="v=spf1                                             ?all " },
    { .domain="07.spf1-test.mailzone.com", .rr_type=16, .herrno=0,
    .data="v=spf2                                             default=bogus   " },
    { .domain="08.spf1-test.mailzone.com", .rr_type=16, .herrno=0,
    .data="v=spf1                       -all      ?all  " },
    { .domain="09.spf1-test.mailzone.com", .rr_type=16, .herrno=0,
    .data="v=spf1    scope=header-from scope=envelope         -all  " },
    { .domain="10.spf1-test.mailzone.com", .rr_type=16, .herrno=0,
    .data="v=spf1 mx                                          -all" },
    { .domain="10.spf1-test.mailzone.com", .rr_type=15, .herrno=0,
    .data="mx02.spf1-test.mailzone.com" },
    { .domain="10.spf1-test.mailzone.com", .rr_type=15, .herrno=0,
    .data="mx03.spf1-test.mailzone.com" },
    { .domain="10.spf1-test.mailzone.com", .rr_type=15, .herrno=0,
    .data="mx01.spf1-test.mailzone.com" },
    { .domain="11.spf1-test.mailzone.com", .rr_type=16, .herrno=0,
    .data="v=spf1    mx:spf1-test.mailzone.com                          -all" },
    { .domain="12.spf1-test.mailzone.com", .rr_type=16, .herrno=0,
    .data="v=spf1 mx mx:spf1-test.mailzone.com                          -all" },
    { .domain="12.spf1-test.mailzone.com", .rr_type=15, .herrno=0,
    .data="mx02.spf1-test.mailzone.com" },
    { .domain="12.spf1-test.mailzone.com", .rr_type=15, .herrno=0,
    .data="mx03.spf1-test.mailzone.com" },
    { .domain="12.spf1-test.mailzone.com", .rr_type=15, .herrno=0,
    .data="mx01.spf1-test.mailzone.com" },
    { .domain="13.spf1-test.mailzone.com", .rr_type=16, .herrno=0,
    .data="v=spf1    mx:spf1-test.mailzone.com mx:fallback-relay.spf1-test.mailzone.com -all" },
    { .domain="14.spf1-test.mailzone.com", .rr_type=16, .herrno=0,
    .data="v=spf1 mx mx:spf1-test.mailzone.com mx:fallback-relay.spf1-test.mailzone.com -all" },
    { .domain="14.spf1-test.mailzone.com", .rr_type=15, .herrno=0,
    .data="mx03.spf1-test.mailzone.com" },
    { .domain="14.spf1-test.mailzone.com", .rr_type=15, .herrno=0,
    .data="mx01.spf1-test.mailzone.com" },
    { .domain="14.spf1-test.mailzone.com", .rr_type=15, .herrno=0,
    .data="mx02.spf1-test.mailzone.com" },
    { .domain="20.spf1-test.mailzone.com", .rr_type=1, .herrno=0,
    .data="192.0.2.120" },
    { .domain="20.spf1-test.mailzone.com", .rr_type=16, .herrno=0,
    .data="v=spf1 a                                           -all" },
    { .domain="21.spf1-test.mailzone.com", .rr_type=16, .herrno=0,
    .data="v=spf1   a:spf1-test.mailzone.com                            -all" },
    { .domain="21.spf1-test.mailzone.com", .rr_type=1, .herrno=0,
    .data="192.0.2.121" },
    { .domain="22.spf1-test.mailzone.com", .rr_type=16, .herrno=0,
    .data="v=spf1 a a:spf1-test.mailzone.com                            -all" },
    { .domain="22.spf1-test.mailzone.com", .rr_type=1, .herrno=0,
    .data="192.0.2.122" },
    { .domain="30.spf1-test.mailzone.com", .rr_type=16, .herrno=0,
    .data="v=spf1 ptr                                         -all" },
    { .domain="30.spf1-test.mailzone.com", .rr_type=1, .herrno=0,
    .data="208.210.124.130" },
    { .domain="31.spf1-test.mailzone.com", .rr_type=16, .herrno=0,
    .data="v=spf1     ptr:spf1-test.mailzone.com                        -all" },
    { .domain="31.spf1-test.mailzone.com", .rr_type=1, .herrno=0,
    .data="208.210.124.131" },
    { .domain="32.spf1-test.mailzone.com", .rr_type=16, .herrno=0,
    .data="v=spf1 ptr ptr:spf1-test.mailzone.com                        -all" },
    { .domain="32.spf1-test.mailzone.com", .rr_type=1, .herrno=0,
    .data="208.210.124.132" },
    { .domain="40.spf1-test.mailzone.com", .rr_type=16, .herrno=0,
    .data="v=spf1 exists:%{ir}.%{v}._spf.%{d}                    -all" },
    { .domain="41.spf1-test.mailzone.com", .rr_type=16, .herrno=0,
    .data="v=spf1 exists:%{ir}.%{v}._spf.spf1-test.mailzone.com            -all" },
    { .domain="42.spf1-test.mailzone.com", .rr_type=16, .herrno=0,
    .data="v=spf1 exists:%{ir}.%{v}._spf.%{d} exists:%{ir}.%{v}._spf.%{d3} -all" },
    { .domain="45.spf1-test.mailzone.com", .rr_type=16, .herrno=0,
    .data="v=spf1 -a a:spf1-test.mailzone.com                           -all" },
    { .domain="45.spf1-test.mailzone.com", .rr_type=1, .herrno=0,
    .data="192.0.2.147" },
    { .domain="45.spf1-test.mailzone.com", .rr_type=1, .herrno=0,
    .data="192.0.2.145" },
    { .domain="45.spf1-test.mailzone.com", .rr_type=1, .herrno=0,
    .data="192.0.2.146" },
    { .domain="50.spf1-test.mailzone.com", .rr_type=16, .herrno=0,
    .data="v=spf1 include                                     -all" },
    { .domain="51.spf1-test.mailzone.com", .rr_type=16, .herrno=0,
    .data="v=spf1 include:42.spf1-test.mailzone.com                  -all" },
    { .domain="52.spf1-test.mailzone.com", .rr_type=16, .herrno=0,
    .data="v=spf1 include:53.spf1-test.mailzone.com                  -all" },
    { .domain="53.spf1-test.mailzone.com", .rr_type=16, .herrno=0,
    .data="v=spf1 include:42.spf1-test.mailzone.com                  -all" },
    { .domain="54.spf1-test.mailzone.com", .rr_type=16, .herrno=0,
    .data="v=spf1 include:42.spf1-test.mailzone.com                  -all" },
    { .domain="55.spf1-test.mailzone.com", .rr_type=16, .herrno=0,
    .data="v=spf1 include:56.spf1-test.mailzone.com                  -all" },
    { .domain="57.spf1-test.mailzone.com", .rr_type=16, .herrno=0,
    .data="v=spf1 include:spf1-test.mailzone.com         -all" },
    { .domain="58.spf1-test.mailzone.com", .rr_type=16, .herrno=0,
    .data="v=spf1 include:59.spf1-test.mailzone.com                  -all" },
    { .domain="59.spf1-test.mailzone.com", .rr_type=16, .herrno=0,
    .data="v=spf1 include:58.spf1-test.mailzone.com                  -all" },
    { .domain="70.spf1-test.mailzone.com", .rr_type=16, .herrno=0,
    .data="v=spf1 exists:%{lr+=}.lp._spf.spf1-test.mailzone.com -all" },
    { .domain="80.spf1-test.mailzone.com", .rr_type=16, .herrno=0,
    .data="v=spf1 a mx exists:%{ir}.%{v}._spf.80.spf1-test.mailzone.com ptr -all" },
    { .domain="80.spf1-test.mailzone.com", .rr_type=1, .herrno=0,
    .data="208.210.124.180" },
    { .domain="90.spf1-test.mailzone.com", .rr_type=16, .herrno=0,
    .data="v=spf1  ip4:192.0.2.128/25 -all" },
    { .domain="91.spf1-test.mailzone.com", .rr_type=16, .herrno=0,
    .data="v=spf1 -ip4:192.0.2.128/25 ip4:192.0.2.0/24 -all" },
    { .domain="92.spf1-test.mailzone.com", .rr_type=16, .herrno=0,
    .data="v=spf1 ?ip4:192.0.2.192/26 ip4:192.0.2.128/25 -ip4:192.0.2.0/24 -all" },
    { .domain="95.spf1-test.mailzone.com", .rr_type=16, .herrno=0,
    .data="v=spf1 exists:%{p}.whitelist.spf1-test.mailzone.com -all" },
    { .domain="96.spf1-test.mailzone.com", .rr_type=16, .herrno=0,
    .data="v=spf1 -exists:%{d}.blacklist.spf1-test.mailzone.com -all" },
    { .domain="97.spf1-test.mailzone.com", .rr_type=16, .herrno=0,
    .data="v=spf1 exists:%{p}.whitelist.spf1-test.mailzone.com -exists:%{d}.blacklist.spf1-test.mailzone.com -all" },
    { .domain="98.spf1-test.mailzone.com", .rr_type=16, .herrno=0,
    .data="v=spf1 a/26 mx/26 -all" },
    { .domain="98.spf1-test.mailzone.com", .rr_type=15, .herrno=0,
    .data="80.spf1-test.mailzone.com" },
    { .domain="98.spf1-test.mailzone.com", .rr_type=1, .herrno=0,
    .data="192.0.2.98" },
    { .domain="99.spf1-test.mailzone.com", .rr_type=16, .herrno=0,
    .data="v=spf1 -all exp=99txt.spf1-test.mailzone.com moo" },
    { .domain="99txt.spf1-test.mailzone.com", .rr_type=16,
    .herrno=0, .data="u=%{u} s=%{s} d=%{d} t=%{t} h=%{h} i=%{i} %% U=%{U} S=%{S} D=%{D} T=%{T} H=%{H} I=%{I} %% moo" },
    { .domain="100.spf1-test.mailzone.com", .rr_type=16, .herrno=0,
    .data="v=spf1      redirect=98.spf1-test.mailzone.com" },
    { .domain="101.spf1-test.mailzone.com", .rr_type=16, .herrno=0,
    .data="v=spf1 -all redirect=98.spf1-test.mailzone.com" },
    { .domain="102.spf1-test.mailzone.com", .rr_type=16, .herrno=0,
    .data="v=spf1 ?all redirect=98.spf1-test.mailzone.com" },
    { .domain="103.spf1-test.mailzone.com", .rr_type=16, .herrno=0,
    .data="v=spf1      redirect=98.%{d3}" },
    { .domain="104.spf1-test.mailzone.com", .rr_type=16, .herrno=0,
    .data="v=spf1      redirect=105.%{d3}" },
    { .domain="105.spf1-test.mailzone.com", .rr_type=16, .herrno=0,
    .data="v=spf1      redirect=106.%{d3}" },
    { .domain="106.spf1-test.mailzone.com", .rr_type=16, .herrno=0,
    .data="v=spf1      redirect=107.%{d3}" },
    { .domain="107.spf1-test.mailzone.com", .rr_type=16, .herrno=0,
    .data="v=spf1       include:104.%{d3}" },
    { .domain="110.spf1-test.mailzone.com", .rr_type=16, .herrno=0,
    .data="v=spf1 some:unrecognized=mechanism some=unrecognized:modifier -all" },
    { .domain="111.spf1-test.mailzone.com", .rr_type=16, .herrno=0,
    .data="v=spf1 mx -a gpg ~all exp=111txt.spf1-test.mailzone.com" },
    { .domain="111.spf1-test.mailzone.com", .rr_type=15, .herrno=0,
    .data="mx01.spf1-test.mailzone.com" },
    { .domain="111.spf1-test.mailzone.com", .rr_type=1, .herrno=0,
    .data="192.0.2.200" },
    { .domain="111txt.2.0.192.in-addr._spf.spf1-test.mailzone.com", .rr_type=16,
    .herrno=0, .data="explanation text" },
    { .domain="112.spf1-test.mailzone.com", .rr_type=16, .herrno=0,
    .data="v=spf1 a mp3 ~all" },
    { .domain="112.spf1-test.mailzone.com", .rr_type=1, .herrno=0,
    .data="192.0.2.200" },
    { .domain="113.spf1-test.mailzone.com", .rr_type=16, .herrno=0,
    .data="v=spf1 a mp3: ~all" },
    { .domain="113.spf1-test.mailzone.com", .rr_type=1, .herrno=0,
    .data="192.0.2.200" },
    { .domain="114.spf1-test.mailzone.com", .rr_type=16, .herrno=0,
    .data="v=spf1 mx -a gpg=test ~all exp=114txt.spf1-test.mailzone.com" },
    { .domain="114.spf1-test.mailzone.com", .rr_type=15, .herrno=0,
    .data="mx01.spf1-test.mailzone.com" },
    { .domain="114.spf1-test.mailzone.com", .rr_type=1, .herrno=0,
    .data="192.0.2.200" },
    { .domain="114txt.spf1-test.mailzone.com", .rr_type=16,
    .herrno=0, .data="explanation text" },
    { .domain="115.spf1-test.mailzone.com", .rr_type=16, .herrno=0,
    .data="v=spf1 a mp3=yes -all" },
    { .domain="115.spf1-test.mailzone.com", .rr_type=1, .herrno=0,
    .data="192.0.2.200" },
    { .domain="116.spf1-test.mailzone.com", .rr_type=16, .herrno=0,
    .data="v=spf1 redirect=116rdr.spf1-test.mailzone.com a" },
    { .domain="116.spf1-test.mailzone.com", .rr_type=1, .herrno=0,
    .data="192.0.2.200" },
    { .domain="116rdr.spf1-test.mailzone.com", .rr_type=16,
    .herrno=0, .data="v=spf1 -all" },
    { .domain="117.spf1-test.mailzone.com", .rr_type=16, .herrno=0,
    .data=" v=spf1 +all" },
    { .domain="118.spf1-test.mailzone.com", .rr_type=16, .herrno=0,
    .data="v=spf1 -all exp=" },
    { .domain="mx01.spf1-test.mailzone.com", .rr_type=1,
    .herrno=0, .data="192.0.2.10" },
    { .domain="mx01.spf1-test.mailzone.com", .rr_type=1,
    .herrno=0, .data="192.0.2.11" },
    { .domain="mx01.spf1-test.mailzone.com", .rr_type=1,
    .herrno=0, .data="192.0.2.12" },
    { .domain="mx01.spf1-test.mailzone.com", .rr_type=1,
    .herrno=0, .data="192.0.2.13" },
    { .domain="mx02.spf1-test.mailzone.com", .rr_type=1,
    .herrno=0, .data="192.0.2.20" },
    { .domain="mx02.spf1-test.mailzone.com", .rr_type=1,
    .herrno=0, .data="192.0.2.21" },
    { .domain="mx02.spf1-test.mailzone.com", .rr_type=1,
    .herrno=0, .data="192.0.2.22" },
    { .domain="mx02.spf1-test.mailzone.com", .rr_type=1,
    .herrno=0, .data="192.0.2.23" },
    { .domain="mx03.spf1-test.mailzone.com", .rr_type=1,
    .herrno=0, .data="192.0.2.30" },
    { .domain="mx03.spf1-test.mailzone.com", .rr_type=1,
    .herrno=0, .data="192.0.2.31" },
    { .domain="mx03.spf1-test.mailzone.com", .rr_type=1,
    .herrno=0, .data="192.0.2.32" },
    { .domain="mx03.spf1-test.mailzone.com", .rr_type=1,
    .herrno=0, .data="192.0.2.33" },
    { .domain="mx04.spf1-test.mailzone.com", .rr_type=1,
    .herrno=0, .data="192.0.2.40" },
    { .domain="mx04.spf1-test.mailzone.com", .rr_type=1,
    .herrno=0, .data="192.0.2.41" },
    { .domain="mx04.spf1-test.mailzone.com", .rr_type=1,
    .herrno=0, .data="192.0.2.42" },
    { .domain="mx04.spf1-test.mailzone.com", .rr_type=1,
    .herrno=0, .data="192.0.2.43" },
    { .domain="56.spf1-test.mailzone.com", .rr_type=16, .herrno=4,
    .data=(const char *)(void *)0 },
    { .domain="80.spf1-test.mailzone.com", .rr_type=15, .herrno=4,
    .data=(const char *)(void *)0 },
    { .domain="servfail.spf1-test.mailzone.com", .rr_type=16,
    .herrno=2, .data=(const char *)(void *)0 },
    { .domain="spf1-test.mailzone.com", .rr_type=15, .herrno=0,
    .data="mx02.spf1-test.mailzone.com" },
    { .domain="spf1-test.mailzone.com", .rr_type=15, .herrno=0,
    .data="mx03.spf1-test.mailzone.com" },
    { .domain="spf1-test.mailzone.com", .rr_type=15, .herrno=0,
    .data="mx01.spf1-test.mailzone.com" },
    { .domain="spf1-test.mailzone.com", .rr_type=1, .herrno=0,
    .data="208.210.124.192" },
    { .domain="spf1-test.mailzone.com", .rr_type=1, .herrno=0,
    .data="192.0.2.200" },
    { .domain="fallback-relay.spf1-test.mailzone.com", .rr_type=15,
    .herrno=0, .data="mx04.spf1-test.mailzone.com" },
    { .domain="www1.cnn.com", .rr_type=1, .herrno=0, .data="64.236.24.4" },
    { .domain="4.24.236.64.in-addr.arpa", .rr_type=12, .herrno=0,
    .data="www1.cnn.com" },
    { .domain="130.124.210.208.in-addr.arpa", .rr_type=12,
    .herrno=0, .data="30.spf1-test.mailzone.com" },
    { .domain="131.124.210.208.in-addr.arpa", .rr_type=12,
    .herrno=0, .data="31.spf1-test.mailzone.com" },
    { .domain="192.124.210.208.in-addr.arpa", .rr_type=12,
    .herrno=0, .data="spf1-test.mailzone.com" },
    { .domain="100.2.0.192.in-addr._spf.40.spf1-test.mailzone.com", .rr_type=1,
    .herrno=0, .data="127.0.0.2" },
    { .domain="110.2.0.192.in-addr._spf.spf1-test.mailzone.com", .rr_type=1,
    .herrno=0, .data="127.0.0.2" },
    { .domain="111.2.0.192.in-addr._spf.spf1-test.mailzone.com", .rr_type=1,
    .herrno=0, .data="127.0.0.2" },
    { .domain="101.2.0.192.in-addr._spf.40.spf1-test.mailzone.com", .rr_type=1,
    .herrno=0, .data="127.0.0.2" },
    { .domain="130.2.0.192.in-addr._spf.42.spf1-test.mailzone.com", .rr_type=1,
    .herrno=0, .data="127.0.0.2" },
    { .domain="131.2.0.192.in-addr._spf.42.spf1-test.mailzone.com", .rr_type=1,
    .herrno=0, .data="127.0.0.2" },
    { .domain="80.2.0.192.in-addr._spf.80.spf1-test.mailzone.com", .rr_type=1,
    .herrno=0, .data="127.0.0.2" },
    { .domain="96.spf1-test.mailzone.com.blacklist.spf1-test.mailzone.com", .rr_type=1,
    .herrno=0, .data="127.0.0.2" },
    { .domain="97.spf1-test.mailzone.com.blacklist.spf1-test.mailzone.com", .rr_type=1,
    .herrno=0, .data="127.0.0.2" },
    { .domain="bob.lp._spf.spf1-test.mailzone.com", .rr_type=1,
    .herrno=0, .data="127.0.0.2" },
    { .domain="postmaster.lp._spf.spf1-test.mailzone.com", .rr_type=1,
    .herrno=0, .data="127.0.0.2" },
    { .domain="1.bob.lp._spf.spf1-test.mailzone.com", .rr_type=1,
    .herrno=0, .data="127.0.0.2" },
    { .domain="2.bob.lp._spf.spf1-test.mailzone.com", .rr_type=1,
    .herrno=0, .data="127.0.0.2" },
    { .domain="1.joe.lp._spf.spf1-test.mailzone.com", .rr_type=1,
    .herrno=1, .data=(const char *)(void *)0 },
    { .domain="100.2.0.192.in-addr._spf.42.spf1-test.mailzone.com", .rr_type=1,
    .herrno=1, .data=(const char *)(void *)0 },
    { .domain="100.2.0.192.in-addr._spf.spf1-test.mailzone.com", .rr_type=1,
    .herrno=1, .data=(const char *)(void *)0 },
    { .domain="102.2.0.192.in-addr._spf.40.spf1-test.mailzone.com", .rr_type=1,
    .herrno=1, .data=(const char *)(void *)0 },
    { .domain="110.2.0.192.in-addr._spf.42.spf1-test.mailzone.com", .rr_type=1,
    .herrno=1, .data=(const char *)(void *)0 },
    { .domain="130.2.0.192.in-addr._spf.spf1-test.mailzone.com", .rr_type=1,
    .herrno=1, .data=(const char *)(void *)0 },
    { .domain="131.2.0.192.in-addr._spf.spf1-test.mailzone.com", .rr_type=1,
    .herrno=1, .data=(const char *)(void *)0 },
    { .domain="4.24.236.64.in-addr._spf.80.spf1-test.mailzone.com", .rr_type=1,
    .herrno=1, .data=(const char *)(void *)0 },
    { .domain="droid.lp._spf.spf1-test.mailzone.com", .rr_type=1,
    .herrno=1, .data=(const char *)(void *)0 },
    { .domain="joe-2.lp._spf.spf1-test.mailzone.com", .rr_type=1,
    .herrno=1, .data=(const char *)(void *)0 },
    { .domain="moe-1.lp._spf.spf1-test.mailzone.com", .rr_type=1,
    .herrno=1, .data=(const char *)(void *)0 },
    { .domain="unknown.whitelist.spf1-test.mailzone.com", .rr_type=1,
    .herrno=1, .data=(const char *)(void *)0 },
    { .domain="180.124.210.208.in-addr.arpa", .rr_type=12,
    .herrno=0, .data="80.spf1-test.mailzone.com" },
    { .domain="80.spf1-test.mailzone.com.whitelist.spf1-test.mailzone.com", .rr_type=1,
    .herrno=0, .data="127.0.0.2" },
    { .domain="1.124.210.208.in-addr.arpa", .rr_type=12, .herrno=0,
    .data="pobox-gw.icgroup.com" },
    { .domain="pobox-gw.icgroup.com", .rr_type=1, .herrno=0,
    .data="208.210.124.1" },
    { .domain="pobox-gw.icgroup.com.whitelist.spf1-test.mailzone.com", .rr_type=1,
    .herrno=1, .data=(const char *)(void *)0 },
    { .domain="200.2.0.192.in-addr._spf.51.spf1-test.mailzone.com", .rr_type=1,
    .herrno=1, .data=(const char *)(void *)0 },
    { .domain="200.2.0.192.in-addr._spf.spf1-test.mailzone.com", .rr_type=1,
    .herrno=1, .data=(const char *)(void *)0 },
    { .domain="130.2.0.192.in-addr._spf.51.spf1-test.mailzone.com", .rr_type=1,
    .herrno=1, .data=(const char *)(void *)0 },
    { .domain="200.2.0.192.in-addr._spf.42.spf1-test.mailzone.com", .rr_type=1,
    .herrno=1, .data=(const char *)(void *)0 },
    { .domain="spf1-test.mailzone.com", .rr_type=16, .herrno=1,
    .data=(const char *)(void *)0 },
    { .domain="spf.trusted-forwarder.org", .rr_type=16, .herrno=0,
    .data="v=spf1 exists:%{ir}.wl.trusted-forwarder.org exists:%{p}.wl.trusted-forwarder.org" },
    { .domain="*.spf1-text.mailzone.com", .rr_type=255, .herrno=1,
    .data=(const char *)(void *)0 },
    { .domain="cat.com", .rr_type=16, .herrno=4, .data=(const char *)(void *)0 },
    { .domain="bar.com", .rr_type=16, .herrno=4, .data=(const char *)(void *)0 },
    { .domain="1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.8.5.d.a.0.8.0.0.0.2.5.0.f.5.in6.arpa", .rr_type=12,
    .herrno=0, .data="mx.example.org" } };
// SPF_error_handler
// file spf_log_default.c line 29
void (*SPF_error_handler)(const char *, signed int, const char *);
// SPF_error_handler
// file spf_log_default.c line 29
void (*SPF_error_handler)(const char *, signed int, const char *) = SPF_error_stdio;
// SPF_info_handler
// file spf_log_default.c line 31
void (*SPF_info_handler)(const char *, signed int, const char *);
// SPF_info_handler
// file spf_log_default.c line 31
void (*SPF_info_handler)(const char *, signed int, const char *) = SPF_info_stdio;
// SPF_warning_handler
// file spf_log_default.c line 30
void (*SPF_warning_handler)(const char *, signed int, const char *);
// SPF_warning_handler
// file spf_log_default.c line 30
void (*SPF_warning_handler)(const char *, signed int, const char *) = SPF_warning_stdio;
// _ns_flagdata
// file __ns_initparse.c line 56
struct _ns_flagdata _ns_flagdata[16l] = { { .mask=0x8000, .shift=15 }, { .mask=0x7800, .shift=11 }, { .mask=0x0400, .shift=10 }, { .mask=0x0200, .shift=9 }, { .mask=0x0100, .shift=8 }, { .mask=0x0080, .shift=7 }, { .mask=0x0040, .shift=6 }, { .mask=0x0020, .shift=5 }, { .mask=0x0010, .shift=4 }, { .mask=0x000f, .shift=0 }, { .mask=0x0000, .shift=0 }, { .mask=0x0000, .shift=0 }, { .mask=0x0000, .shift=0 }, { .mask=0x0000, .shift=0 }, { .mask=0x0000, .shift=0 }, { .mask=0x0000, .shift=0 } };
// client_ver_ipv4
// file spf_expand.c line 60
static const char client_ver_ipv4[8l] = { 'i', 'n', '-', 'a', 'd', 'd', 'r', 0 };
// client_ver_ipv6
// file spf_expand.c line 61
static const char client_ver_ipv6[4l] = { 'i', 'p', '6', 0 };
// crc_32_tab
// file spf_dns_cache.c line 162
const unsigned int crc_32_tab[256l] = { (const unsigned int)0x00000000L, (const unsigned int)0x77073096L, (const unsigned int)0xee0e612cL, (const unsigned int)0x990951baL, (const unsigned int)0x076dc419L, (const unsigned int)0x706af48fL, (const unsigned int)0xe963a535L, (const unsigned int)0x9e6495a3L, (const unsigned int)0x0edb8832L, (const unsigned int)0x79dcb8a4L, (const unsigned int)0xe0d5e91eL, (const unsigned int)0x97d2d988L, (const unsigned int)0x09b64c2bL, (const unsigned int)0x7eb17cbdL, (const unsigned int)0xe7b82d07L, (const unsigned int)0x90bf1d91L, (const unsigned int)0x1db71064L, (const unsigned int)0x6ab020f2L, (const unsigned int)0xf3b97148L, (const unsigned int)0x84be41deL, (const unsigned int)0x1adad47dL, (const unsigned int)0x6ddde4ebL, (const unsigned int)0xf4d4b551L, (const unsigned int)0x83d385c7L, (const unsigned int)0x136c9856L, (const unsigned int)0x646ba8c0L, (const unsigned int)0xfd62f97aL, (const unsigned int)0x8a65c9ecL, (const unsigned int)0x14015c4fL, (const unsigned int)0x63066cd9L, (const unsigned int)0xfa0f3d63L, (const unsigned int)0x8d080df5L, (const unsigned int)0x3b6e20c8L, (const unsigned int)0x4c69105eL, (const unsigned int)0xd56041e4L, (const unsigned int)0xa2677172L, (const unsigned int)0x3c03e4d1L, (const unsigned int)0x4b04d447L, (const unsigned int)0xd20d85fdL, (const unsigned int)0xa50ab56bL, (const unsigned int)0x35b5a8faL, (const unsigned int)0x42b2986cL, (const unsigned int)0xdbbbc9d6L, (const unsigned int)0xacbcf940L, (const unsigned int)0x32d86ce3L, (const unsigned int)0x45df5c75L, (const unsigned int)0xdcd60dcfL, (const unsigned int)0xabd13d59L, (const unsigned int)0x26d930acL, (const unsigned int)0x51de003aL, (const unsigned int)0xc8d75180L, (const unsigned int)0xbfd06116L, (const unsigned int)0x21b4f4b5L, (const unsigned int)0x56b3c423L, (const unsigned int)0xcfba9599L, (const unsigned int)0xb8bda50fL, (const unsigned int)0x2802b89eL, (const unsigned int)0x5f058808L, (const unsigned int)0xc60cd9b2L, (const unsigned int)0xb10be924L, (const unsigned int)0x2f6f7c87L, (const unsigned int)0x58684c11L, (const unsigned int)0xc1611dabL, (const unsigned int)0xb6662d3dL, (const unsigned int)0x76dc4190L, (const unsigned int)0x01db7106L, (const unsigned int)0x98d220bcL, (const unsigned int)0xefd5102aL, (const unsigned int)0x71b18589L, (const unsigned int)0x06b6b51fL, (const unsigned int)0x9fbfe4a5L, (const unsigned int)0xe8b8d433L, (const unsigned int)0x7807c9a2L, (const unsigned int)0x0f00f934L, (const unsigned int)0x9609a88eL, (const unsigned int)0xe10e9818L, (const unsigned int)0x7f6a0dbbL, (const unsigned int)0x086d3d2dL, (const unsigned int)0x91646c97L, (const unsigned int)0xe6635c01L, (const unsigned int)0x6b6b51f4L, (const unsigned int)0x1c6c6162L, (const unsigned int)0x856530d8L, (const unsigned int)0xf262004eL, (const unsigned int)0x6c0695edL, (const unsigned int)0x1b01a57bL, (const unsigned int)0x8208f4c1L, (const unsigned int)0xf50fc457L, (const unsigned int)0x65b0d9c6L, (const unsigned int)0x12b7e950L, (const unsigned int)0x8bbeb8eaL, (const unsigned int)0xfcb9887cL, (const unsigned int)0x62dd1ddfL, (const unsigned int)0x15da2d49L, (const unsigned int)0x8cd37cf3L, (const unsigned int)0xfbd44c65L, (const unsigned int)0x4db26158L, (const unsigned int)0x3ab551ceL, (const unsigned int)0xa3bc0074L, (const unsigned int)0xd4bb30e2L, (const unsigned int)0x4adfa541L, (const unsigned int)0x3dd895d7L, (const unsigned int)0xa4d1c46dL, (const unsigned int)0xd3d6f4fbL, (const unsigned int)0x4369e96aL, (const unsigned int)0x346ed9fcL, (const unsigned int)0xad678846L, (const unsigned int)0xda60b8d0L, (const unsigned int)0x44042d73L, (const unsigned int)0x33031de5L, (const unsigned int)0xaa0a4c5fL, (const unsigned int)0xdd0d7cc9L, (const unsigned int)0x5005713cL, (const unsigned int)0x270241aaL, (const unsigned int)0xbe0b1010L, (const unsigned int)0xc90c2086L, (const unsigned int)0x5768b525L, (const unsigned int)0x206f85b3L, (const unsigned int)0xb966d409L, (const unsigned int)0xce61e49fL, (const unsigned int)0x5edef90eL, (const unsigned int)0x29d9c998L, (const unsigned int)0xb0d09822L, (const unsigned int)0xc7d7a8b4L, (const unsigned int)0x59b33d17L, (const unsigned int)0x2eb40d81L, (const unsigned int)0xb7bd5c3bL, (const unsigned int)0xc0ba6cadL, (const unsigned int)0xedb88320L, (const unsigned int)0x9abfb3b6L, (const unsigned int)0x03b6e20cL, (const unsigned int)0x74b1d29aL, (const unsigned int)0xead54739L, (const unsigned int)0x9dd277afL, (const unsigned int)0x04db2615L, (const unsigned int)0x73dc1683L, (const unsigned int)0xe3630b12L, (const unsigned int)0x94643b84L, (const unsigned int)0x0d6d6a3eL, (const unsigned int)0x7a6a5aa8L, (const unsigned int)0xe40ecf0bL, (const unsigned int)0x9309ff9dL, (const unsigned int)0x0a00ae27L, (const unsigned int)0x7d079eb1L, (const unsigned int)0xf00f9344L, (const unsigned int)0x8708a3d2L, (const unsigned int)0x1e01f268L, (const unsigned int)0x6906c2feL, (const unsigned int)0xf762575dL, (const unsigned int)0x806567cbL, (const unsigned int)0x196c3671L, (const unsigned int)0x6e6b06e7L, (const unsigned int)0xfed41b76L, (const unsigned int)0x89d32be0L, (const unsigned int)0x10da7a5aL, (const unsigned int)0x67dd4accL, (const unsigned int)0xf9b9df6fL, (const unsigned int)0x8ebeeff9L, (const unsigned int)0x17b7be43L, (const unsigned int)0x60b08ed5L, (const unsigned int)0xd6d6a3e8L, (const unsigned int)0xa1d1937eL, (const unsigned int)0x38d8c2c4L, (const unsigned int)0x4fdff252L, (const unsigned int)0xd1bb67f1L, (const unsigned int)0xa6bc5767L, (const unsigned int)0x3fb506ddL, (const unsigned int)0x48b2364bL, (const unsigned int)0xd80d2bdaL, (const unsigned int)0xaf0a1b4cL, (const unsigned int)0x36034af6L, (const unsigned int)0x41047a60L, (const unsigned int)0xdf60efc3L, (const unsigned int)0xa867df55L, (const unsigned int)0x316e8eefL, (const unsigned int)0x4669be79L, (const unsigned int)0xcb61b38cL, (const unsigned int)0xbc66831aL, (const unsigned int)0x256fd2a0L, (const unsigned int)0x5268e236L, (const unsigned int)0xcc0c7795L, (const unsigned int)0xbb0b4703L, (const unsigned int)0x220216b9L, (const unsigned int)0x5505262fL, (const unsigned int)0xc5ba3bbeL, (const unsigned int)0xb2bd0b28L, (const unsigned int)0x2bb45a92L, (const unsigned int)0x5cb36a04L, (const unsigned int)0xc2d7ffa7L, (const unsigned int)0xb5d0cf31L, (const unsigned int)0x2cd99e8bL, (const unsigned int)0x5bdeae1dL, (const unsigned int)0x9b64c2b0L, (const unsigned int)0xec63f226L, (const unsigned int)0x756aa39cL, (const unsigned int)0x026d930aL, (const unsigned int)0x9c0906a9L, (const unsigned int)0xeb0e363fL, (const unsigned int)0x72076785L, (const unsigned int)0x05005713L, (const unsigned int)0x95bf4a82L, (const unsigned int)0xe2b87a14L, (const unsigned int)0x7bb12baeL, (const unsigned int)0x0cb61b38L, (const unsigned int)0x92d28e9bL, (const unsigned int)0xe5d5be0dL, (const unsigned int)0x7cdcefb7L, (const unsigned int)0x0bdbdf21L, (const unsigned int)0x86d3d2d4L, (const unsigned int)0xf1d4e242L, (const unsigned int)0x68ddb3f8L, (const unsigned int)0x1fda836eL, (const unsigned int)0x81be16cdL, (const unsigned int)0xf6b9265bL, (const unsigned int)0x6fb077e1L, (const unsigned int)0x18b74777L, (const unsigned int)0x88085ae6L, (const unsigned int)0xff0f6a70L, (const unsigned int)0x66063bcaL, (const unsigned int)0x11010b5cL, (const unsigned int)0x8f659effL, (const unsigned int)0xf862ae69L, (const unsigned int)0x616bffd3L, (const unsigned int)0x166ccf45L, (const unsigned int)0xa00ae278L, (const unsigned int)0xd70dd2eeL, (const unsigned int)0x4e048354L, (const unsigned int)0x3903b3c2L, (const unsigned int)0xa7672661L, (const unsigned int)0xd06016f7L, (const unsigned int)0x4969474dL, (const unsigned int)0x3e6e77dbL, (const unsigned int)0xaed16a4aL, (const unsigned int)0xd9d65adcL, (const unsigned int)0x40df0b66L, (const unsigned int)0x37d83bf0L, (const unsigned int)0xa9bcae53L, (const unsigned int)0xdebb9ec5L, (const unsigned int)0x47b2cf7fL, (const unsigned int)0x30b5ffe9L, (const unsigned int)0xbdbdf21cL, (const unsigned int)0xcabac28aL, (const unsigned int)0x53b39330L, (const unsigned int)0x24b4a3a6L, (const unsigned int)0xbad03605L, (const unsigned int)0xcdd70693L, (const unsigned int)0x54de5729L, (const unsigned int)0x23d967bfL, (const unsigned int)0xb3667a2eL, (const unsigned int)0xc4614ab8L, (const unsigned int)0x5d681b02L, (const unsigned int)0x2a6f2b94L, (const unsigned int)0xb40bbe37L, (const unsigned int)0xc30c8ea1L, (const unsigned int)0x5a05df1bL, (const unsigned int)0x2d02ef8dL };
// digits
// file __ns_name_uncompress.c line 61
static const char digits[11l] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 0 };
// digitvalue
// file __ns_name_uncompress.c line 63
static const char digitvalue[256l] = { (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)0, (const char)1, (const char)2, (const char)3, (const char)4, (const char)5, (const char)6, (const char)7, (const char)8, (const char)9, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)10, (const char)11, (const char)12, (const char)13, (const char)14, (const char)15, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)10, (const char)11, (const char)12, (const char)13, (const char)14, (const char)15, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1, (const char)-1 };
// in6addr_any
// file /usr/include/netinet/in.h line 227
extern struct in6_addr in6addr_any;
// longopts
// file spfd.c line 420
static struct option longopts[10l] = { { .name="debug", .has_arg=1, .flag=(signed int *)(void *)0, .val=100 },
    { .name="tcpport", .has_arg=1, .flag=(signed int *)(void *)0, .val=116 },
    { .name="udpport", .has_arg=1, .flag=(signed int *)(void *)0, .val=112 },
    { .name="path", .has_arg=1, .flag=(signed int *)(void *)0, .val=102 },
    { .name="pathuser", .has_arg=1, .flag=(signed int *)(void *)0, .val=120 },
    { .name="pathgroup", .has_arg=1, .flag=(signed int *)(void *)0, .val=121 },
    { .name="pathmode", .has_arg=1, .flag=(signed int *)(void *)0, .val=109 },
    { .name="setuser", .has_arg=1, .flag=(signed int *)(void *)0, .val=117 },
    { .name="setgroup", .has_arg=1, .flag=(signed int *)(void *)0, .val=103 },
    { .name="help", .has_arg=0, .flag=(signed int *)(void *)0, .val=104 } };
// ns_sects
// file spf_dns_resolv.c line 72
static struct res_sym ns_sects[4l] = { { .number=0, .name="QUESTION", .humanname="Question" },
    { .number=1, .name="ANSWER", .humanname="Answer" },
    { .number=2, .name="AUTHORITY", .humanname="Authority" },
    { .number=3, .name="ADDITIONAL", .humanname="Additional" } };
// num_ns_sect
// file spf_dns_resolv.c line 79
static const signed int num_ns_sect = (const signed int)(sizeof(struct res_sym [4l]) /*96ul*/  / sizeof(struct res_sym) /*24ul*/ );
// optarg
// file /usr/include/getopt.h line 57
extern char *optarg;
// res_state_control
// file spf_dns_resolv.c line 89
static signed int res_state_control = 0;
// res_state_key
// file spf_dns_resolv.c line 90
static unsigned int res_state_key;
// shortopts
// file spfd.c line 441
static const char *shortopts = "d:t:p:f:x:y:m:u:g:h:";
// spf_mechtypes
// file spf_compile.c line 78
static const struct SPF_mechtype_struct spf_mechtypes[10l] = { { .mech_type=(unsigned char)0, .is_dns_mech=(unsigned char)0, .has_domainspec=(enum SPF_domspec_enum)0,
    .has_cidr=(enum SPF_cidr_enum)0 },
    { .mech_type=(unsigned char)1, .is_dns_mech=(unsigned char)1, .has_domainspec=(enum SPF_domspec_enum)1,
    .has_cidr=(enum SPF_cidr_enum)1 },
    { .mech_type=(unsigned char)2, .is_dns_mech=(unsigned char)1, .has_domainspec=(enum SPF_domspec_enum)1,
    .has_cidr=(enum SPF_cidr_enum)1 },
    { .mech_type=(unsigned char)3, .is_dns_mech=(unsigned char)1, .has_domainspec=(enum SPF_domspec_enum)1,
    .has_cidr=(enum SPF_cidr_enum)0 },
    { .mech_type=(unsigned char)4, .is_dns_mech=(unsigned char)1, .has_domainspec=(enum SPF_domspec_enum)2,
    .has_cidr=(enum SPF_cidr_enum)0 },
    { .mech_type=(unsigned char)5, .is_dns_mech=(unsigned char)0, .has_domainspec=(enum SPF_domspec_enum)2,
    .has_cidr=(enum SPF_cidr_enum)1 },
    { .mech_type=(unsigned char)6, .is_dns_mech=(unsigned char)0, .has_domainspec=(enum SPF_domspec_enum)2,
    .has_cidr=(enum SPF_cidr_enum)1 },
    { .mech_type=(unsigned char)7, .is_dns_mech=(unsigned char)1, .has_domainspec=(enum SPF_domspec_enum)2,
    .has_cidr=(enum SPF_cidr_enum)0 },
    { .mech_type=(unsigned char)8, .is_dns_mech=(unsigned char)0, .has_domainspec=(enum SPF_domspec_enum)0,
    .has_cidr=(enum SPF_cidr_enum)0 },
    { .mech_type=(unsigned char)9, .is_dns_mech=(unsigned char)1, .has_domainspec=(enum SPF_domspec_enum)2,
    .has_cidr=(enum SPF_cidr_enum)0 } };
// spf_server
// file spfd.c line 195
static struct SPF_server_struct *spf_server;
// spfd_config
// file spfd.c line 196
static struct _config_t spfd_config;
// spfd_state
// file spfd.c line 197
static struct _state_t spfd_state;
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// stdout
// file /usr/include/stdio.h line 169
extern struct _IO_FILE *stdout;

// SPF_c_ensure_capacity
// file spf_compile.c line 107
static signed int SPF_c_ensure_capacity(void **datap, unsigned long int *sizep, unsigned long int length)
{
  unsigned long int size = *sizep;
  if(!(size >= length))
    size = length + length / (unsigned long int)4;

  if(!(*sizep >= size))
  {
    void *tmp;
    tmp=realloc(*datap, size);
    if(tmp == NULL)
      return -1;

    *datap = tmp;
    *sizep = size;
  }

  return 0;
}

// SPF_c_mech_add
// file spf_compile.c line 824
static enum SPF_errcode_t SPF_c_mech_add(struct SPF_server_struct *spf_server, struct SPF_record_struct *spf_record, struct SPF_response_struct *spf_response, const struct SPF_mechtype_struct *mechtype, signed int prefix, const char **mech_value)
{
  /* tag-#anon#lUN[F64'd'|S64'l'|lARR4096{S8}_S8_'buf'] */
union anonymous_11
{
  // d
  double d;
  // l
  signed long int l;
  // buf
  char buf[4096l];
};

/* */
  ;
  union anonymous_11 u;
  struct SPF_mech_struct *spf_mechanism = (struct SPF_mech_struct *)u.buf;
  union SPF_data_union *data;
  unsigned long int data_len;
  unsigned long int len;
  unsigned long int src_len;
  enum SPF_errcode_t err;
  memset((void *)u.buf, 66, sizeof(char [4096l]) /*4096ul*/ );
  memset((void *)spf_mechanism, 0, sizeof(struct SPF_mech_struct) /*4ul*/ );
  if(!(spf_server->debug == 0))
    SPF_debugx("spf_compile.c", 847, "SPF_c_mech_add: type=%d, value=%s", mechtype->mech_type, *mech_value);

  spf_mechanism->prefix_type = (unsigned char)prefix;
  spf_mechanism->mech_type = mechtype->mech_type;
  spf_mechanism->mech_len = (unsigned short int)0;
  len = sizeof(struct SPF_mech_struct) /*4ul*/ ;
  enum SPF_errcode_t return_value_SPF_response_add_error_ptr_3;
  if(spf_record->mech_len + len >= 512ul)
    return (enum SPF_errcode_t)SPF_E_BIG_MECH;

  else
  {
    data=SPF_mech_data(spf_mechanism);
    data_len = (unsigned long int)0;
    src_len=strcspn(*mech_value, " ");
    switch((signed int)mechtype->mech_type)
    {
      case 5:
      {
        if((signed int)*(*mech_value) == 58)
        {
          err=SPF_c_parse_ip4(spf_response, spf_mechanism, *mech_value);
          data_len = sizeof(struct in_addr) /*4ul*/ ;
        }

        else
        {
          err = (enum SPF_errcode_t)SPF_E_MISSING_OPT;
          SPF_response_add_error_ptr(spf_response, err, (const char *)(void *)0, *mech_value, "Mechanism requires a value.");
        }
        break;
      }
      case 6:
      {
        if((signed int)*(*mech_value) == 58)
        {
          err=SPF_c_parse_ip6(spf_response, spf_mechanism, *mech_value);
          data_len = sizeof(struct in6_addr) /*16ul*/ ;
        }

        else
        {
          err = (enum SPF_errcode_t)SPF_E_MISSING_OPT;
          SPF_response_add_error_ptr(spf_response, err, (const char *)(void *)0, *mech_value, "Mechanism requires a value.");
        }
        break;
      }
      default:
      {
        _Bool tmp_if_expr_2;
        if((signed int)*(*mech_value) == 58)
          tmp_if_expr_2 = (_Bool)1;

        else
          tmp_if_expr_2 = (signed int)*(*mech_value) == 61 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_2)
        {
          if((signed int)mechtype->has_domainspec == DOMSPEC_NONE)
          {
            err = (enum SPF_errcode_t)SPF_E_INVALID_OPT;
            SPF_response_add_error_ptr(spf_response, err, (const char *)(void *)0, *mech_value, "Mechanism does not permit a value.");
          }

          else
          {
            *mech_value = *mech_value + 1l;
            src_len = src_len - 1ul;
            err=SPF_c_parse_domainspec(spf_server, spf_response, data, &data_len, (unsigned long int)511, *mech_value, src_len, (enum SPF_errcode_t)SPF_E_BIG_MECH, mechtype->has_cidr, 0);
          }
        }

        else
          if((signed int)*(*mech_value) == 47)
          {
            if((signed int)mechtype->has_domainspec == DOMSPEC_REQUIRED)
            {
              err = (enum SPF_errcode_t)SPF_E_MISSING_OPT;
              SPF_response_add_error_ptr(spf_response, err, (const char *)(void *)0, *mech_value, "Mechanism requires a value.");
            }

            else
              if((signed int)mechtype->has_cidr == CIDR_NONE)
              {
                err = (enum SPF_errcode_t)SPF_E_INVALID_CIDR;
                SPF_response_add_error_ptr(spf_response, err, (const char *)(void *)0, *mech_value, "Mechanism does not permit a CIDR.");
              }

              else
                err=SPF_c_parse_domainspec(spf_server, spf_response, data, &data_len, (unsigned long int)511, *mech_value, src_len, (enum SPF_errcode_t)SPF_E_BIG_MECH, (enum SPF_cidr_enum)CIDR_ONLY, 0);
          }

          else
          {
            _Bool tmp_if_expr_1;
            if((signed int)*(*mech_value) == 32)
              tmp_if_expr_1 = (_Bool)1;

            else
              tmp_if_expr_1 = (signed int)*(*mech_value) == 0 ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr_1)
            {
              if((signed int)mechtype->has_domainspec == DOMSPEC_REQUIRED)
              {
                err = (enum SPF_errcode_t)SPF_E_MISSING_OPT;
                SPF_response_add_error_ptr(spf_response, err, (const char *)(void *)0, *mech_value, "Mechanism requires a value.");
              }

              else
                err = (enum SPF_errcode_t)SPF_E_SUCCESS;
            }

            else
            {
              err = (enum SPF_errcode_t)SPF_E_SYNTAX;
              SPF_response_add_error_ptr(spf_response, err, (const char *)(void *)0, *mech_value, "Unknown character '%c' after mechanism.", *(*mech_value));
            }
          }
        spf_mechanism->mech_len = (unsigned short int)data_len;
      }
    }
    len = len + data_len;
    if((signed int)err == SPF_E_SUCCESS)
    {
      if(!(mechtype->is_dns_mech == 0))
        spf_record->num_dns_mech = spf_record->num_dns_mech + 1;

      signed int return_value_SPF_c_ensure_capacity_4;
      return_value_SPF_c_ensure_capacity_4=SPF_c_ensure_capacity((void **)&spf_record->mech_first, &spf_record->mech_size, spf_record->mech_len + len);
      if(!(return_value_SPF_c_ensure_capacity_4 >= 0))
      {
        return_value_SPF_response_add_error_ptr_3=SPF_response_add_error_ptr(spf_response, (enum SPF_errcode_t)SPF_E_NO_MEMORY, (const char *)(void *)0, (const char *)(void *)0, "Failed to allocate memory for mechanism");
        return return_value_SPF_response_add_error_ptr_3;
      }

      memcpy((void *)((char *)spf_record->mech_first + (signed long int)spf_record->mech_len), (const void *)spf_mechanism, len);
      spf_record->mech_len = spf_record->mech_len + len;
      spf_record->num_mech = spf_record->num_mech + 1;
    }

    *mech_value = *mech_value + (signed long int)src_len;
    return err;
  }
}

// SPF_c_mod_add
// file spf_compile.c line 982
static enum SPF_errcode_t SPF_c_mod_add(struct SPF_server_struct *spf_server, struct SPF_record_struct *spf_record, struct SPF_response_struct *spf_response, const char *mod_name, unsigned long int name_len, const char **mod_value)
{
  /* tag-#anon#lUN[F64'd'|S64'l'|lARR4096{S8}_S8_'buf'] */
union anonymous_11
{
  // d
  double d;
  // l
  signed long int l;
  // buf
  char buf[4096l];
};

/* */
  ;
  union anonymous_11 u;
  struct SPF_mod_struct *spf_modifier = (struct SPF_mod_struct *)u.buf;
  union SPF_data_union *data;
  unsigned long int data_len;
  unsigned long int len;
  unsigned long int src_len;
  enum SPF_errcode_t err;
  if(!(spf_server->debug == 0))
    SPF_debugx("spf_compile.c", 1002, "Adding modifier name=%lu@%s, value=%s", (unsigned long int)name_len, mod_name, *mod_value);

  memset((void *)u.buf, 65, sizeof(char [4096l]) /*4096ul*/ );
  memset((void *)spf_modifier, 0, sizeof(struct SPF_mod_struct) /*4ul*/ );
  enum SPF_errcode_t return_value_SPF_response_add_error_ptr_2;
  if(name_len >= 512ul)
    return (enum SPF_errcode_t)SPF_E_BIG_MOD;

  else
  {
    spf_modifier->name_len = (unsigned short int)name_len;
    spf_modifier->data_len = (unsigned short int)0;
    len=_align_sz(sizeof(struct SPF_mod_struct) /*4ul*/  + name_len);
    if(spf_record->mod_len + len >= 512ul)
      return (enum SPF_errcode_t)SPF_E_BIG_MOD;

    else
    {
      char *return_value_SPF_mod_name_1;
      return_value_SPF_mod_name_1=SPF_mod_name(spf_modifier);
      memcpy((void *)return_value_SPF_mod_name_1, (const void *)mod_name, name_len);
      data=SPF_mod_data(spf_modifier);
      data_len = (unsigned long int)0;
      src_len=strcspn(*mod_value, " ");
      err=SPF_c_parse_macro(spf_server, spf_response, data, &data_len, (unsigned long int)511, *mod_value, src_len, (enum SPF_errcode_t)SPF_E_BIG_MOD, 1);
      spf_modifier->data_len = (unsigned short int)data_len;
      len = len + data_len;
      if((signed int)err == SPF_E_SUCCESS)
      {
        signed int return_value_SPF_c_ensure_capacity_3;
        return_value_SPF_c_ensure_capacity_3=SPF_c_ensure_capacity((void **)&spf_record->mod_first, &spf_record->mod_size, spf_record->mod_len + len);
        if(!(return_value_SPF_c_ensure_capacity_3 >= 0))
        {
          return_value_SPF_response_add_error_ptr_2=SPF_response_add_error_ptr(spf_response, (enum SPF_errcode_t)SPF_E_NO_MEMORY, (const char *)(void *)0, (const char *)(void *)0, "Failed to allocate memory for modifier");
          return return_value_SPF_response_add_error_ptr_2;
        }

        memcpy((void *)((char *)spf_record->mod_first + (signed long int)spf_record->mod_len), (const void *)spf_modifier, len);
        spf_record->mod_len = spf_record->mod_len + len;
        spf_record->num_mod = spf_record->num_mod + 1;
      }

      return err;
    }
  }
}

// SPF_c_parse_cidr
// file spf_compile.c line 213
static enum SPF_errcode_t SPF_c_parse_cidr(struct SPF_response_struct *spf_response, struct SPF_data_cidr_struct *data, const char *src, unsigned long int *src_len)
{
  enum SPF_errcode_t err;
  unsigned long int idx;
  memset((void *)data, 0, sizeof(struct SPF_data_cidr_struct) /*4ul*/ );
  data->parm_type = (unsigned char)11;
  idx = *src_len - (unsigned long int)1;
  const unsigned short int **return_value___ctype_b_loc_1;
  for( ; idx >= 1ul; idx = idx - 1ul)
  {
    return_value___ctype_b_loc_1=__ctype_b_loc();
    if((2048 & (signed int)(*return_value___ctype_b_loc_1)[(signed long int)(signed int)(unsigned char)src[(signed long int)idx]]) == 0)
      break;

  }
  const unsigned short int **return_value___ctype_b_loc_2;
  if(!(idx >= *src_len + 18446744073709551615ul))
  {
    if((signed int)src[(signed long int)idx] == 47)
    {
      _Bool tmp_if_expr_3;
      if(idx >= 1ul)
        tmp_if_expr_3 = (signed int)src[(signed long int)(idx - (unsigned long int)1)] == 47 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_3 = (_Bool)0;
      if(tmp_if_expr_3)
      {
        err=SPF_c_parse_cidr_ip6(spf_response, &data->ipv6, &src[(signed long int)idx]);
        if(!(err == /*enum*/SPF_E_SUCCESS))
          return err;

        *src_len = idx - (unsigned long int)1;
        idx = *src_len - (unsigned long int)1;
        for( ; idx >= 1ul; idx = idx - 1ul)
        {
          return_value___ctype_b_loc_2=__ctype_b_loc();
          if((2048 & (signed int)(*return_value___ctype_b_loc_2)[(signed long int)(signed int)(unsigned char)src[(signed long int)idx]]) == 0)
            break;

        }
        if(!(idx >= *src_len + 18446744073709551615ul))
        {
          if((signed int)src[(signed long int)idx] == 47)
          {
            err=SPF_c_parse_cidr_ip4(spf_response, &data->ipv4, &src[(signed long int)idx]);
            if(!(err == /*enum*/SPF_E_SUCCESS))
              return err;

            *src_len = idx;
          }

        }

      }

      else
      {
        err=SPF_c_parse_cidr_ip4(spf_response, &data->ipv4, &src[(signed long int)idx]);
        if(!(err == /*enum*/SPF_E_SUCCESS))
          return err;

        *src_len = idx;
      }
    }

  }

  return (enum SPF_errcode_t)SPF_E_SUCCESS;
}

// SPF_c_parse_cidr_ip4
// file spf_compile.c line 175
static enum SPF_errcode_t SPF_c_parse_cidr_ip4(struct SPF_response_struct *spf_response, unsigned char *maskp, const char *src)
{
  signed int mask;
  unsigned long int return_value_strtoul_1;
  return_value_strtoul_1=strtoul(src + (signed long int)1, (char ** restrict )(void *)0, 10);
  mask = (signed int)return_value_strtoul_1;
  if(mask >= 33)
  {
    enum SPF_errcode_t return_value_SPF_response_add_error_ptr_2;
    return_value_SPF_response_add_error_ptr_2=SPF_response_add_error_ptr(spf_response, (enum SPF_errcode_t)SPF_E_INVALID_CIDR, (const char *)(void *)0, src, "Invalid IPv4 CIDR netmask (>32)");
    return return_value_SPF_response_add_error_ptr_2;
  }

  else
    if(mask == 0)
    {
      enum SPF_errcode_t return_value_SPF_response_add_error_ptr_3;
      return_value_SPF_response_add_error_ptr_3=SPF_response_add_error_ptr(spf_response, (enum SPF_errcode_t)SPF_E_INVALID_CIDR, (const char *)(void *)0, src, "Invalid IPv4 CIDR netmask (=0)");
      return return_value_SPF_response_add_error_ptr_3;
    }

    else
      if(mask == 32)
        mask = 0;

  *maskp = (unsigned char)mask;
  return (enum SPF_errcode_t)SPF_E_SUCCESS;
}

// SPF_c_parse_cidr_ip6
// file spf_compile.c line 133
static enum SPF_errcode_t SPF_c_parse_cidr_ip6(struct SPF_response_struct *spf_response, unsigned char *maskp, const char *src)
{
  signed int mask;
  unsigned long int return_value_strtoul_1;
  return_value_strtoul_1=strtoul(src + (signed long int)1, (char ** restrict )(void *)0, 10);
  mask = (signed int)return_value_strtoul_1;
  if(mask >= 129)
  {
    enum SPF_errcode_t return_value_SPF_response_add_error_ptr_2;
    return_value_SPF_response_add_error_ptr_2=SPF_response_add_error_ptr(spf_response, (enum SPF_errcode_t)SPF_E_INVALID_CIDR, (const char *)(void *)0, src, "Invalid IPv6 CIDR netmask (>128)");
    return return_value_SPF_response_add_error_ptr_2;
  }

  else
    if(mask == 0)
    {
      enum SPF_errcode_t return_value_SPF_response_add_error_ptr_3;
      return_value_SPF_response_add_error_ptr_3=SPF_response_add_error_ptr(spf_response, (enum SPF_errcode_t)SPF_E_INVALID_CIDR, (const char *)(void *)0, src, "Invalid IPv6 CIDR netmask (=0)");
      return return_value_SPF_response_add_error_ptr_3;
    }

    else
      if(mask == 128)
        mask = 0;

  *maskp = (unsigned char)mask;
  return (enum SPF_errcode_t)SPF_E_SUCCESS;
}

// SPF_c_parse_domainspec
// file spf_compile.c line 671
static enum SPF_errcode_t SPF_c_parse_domainspec(struct SPF_server_struct *spf_server, struct SPF_response_struct *spf_response, union SPF_data_union *data, unsigned long int *data_used, unsigned long int data_avail, const char *src, unsigned long int src_len, enum SPF_errcode_t big_err, enum SPF_cidr_enum cidr_ok, signed int is_mod)
{
  enum SPF_errcode_t err;
  unsigned long int len;
  if(!(spf_server->debug == 0))
    SPF_debugx("spf_compile.c", 689, "Parsing domainspec starting at %s, cidr is %s", src, (signed int)cidr_ok == CIDR_OPTIONAL ? "optional" : ((signed int)cidr_ok == CIDR_ONLY ? "only" : ((signed int)cidr_ok == CIDR_NONE ? "forbidden" : "ERROR!")));

  if((signed int)cidr_ok == CIDR_OPTIONAL || (signed int)cidr_ok == CIDR_ONLY)
  {
    err=SPF_c_parse_cidr(spf_response, &data->dc, src, &src_len);
    if(!((signed int)err == SPF_E_SUCCESS))
      return err;

    _Bool tmp_if_expr_4;
    if(!((signed int)data->dc.ipv4 == 0))
      tmp_if_expr_4 = (_Bool)1;

    else
      tmp_if_expr_4 = (signed int)data->dc.ipv6 != 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_4)
    {
      len=SPF_data_len(data);
      do
      {
        unsigned long int return_value__align_sz_2;
        return_value__align_sz_2=_align_sz(len);
        if(!(data_avail >= *data_used + return_value__align_sz_2))
        {
          enum SPF_errcode_t return_value_SPF_response_add_error_ptr_1;
          return_value_SPF_response_add_error_ptr_1=SPF_response_add_error_ptr(spf_response, big_err, (const char *)(void *)0, src, "SPF domainspec too long (%d chars, %d max)", *data_used + len, data_avail);
          return return_value_SPF_response_add_error_ptr_1;
        }

        unsigned long int return_value__align_sz_3;
        return_value__align_sz_3=_align_sz(len);
        *data_used = *data_used + return_value__align_sz_3;
      }
      while((_Bool)0);
      data=SPF_data_next(data);
    }

    if((signed int)cidr_ok == CIDR_ONLY && src_len >= 1ul)
    {
      enum SPF_errcode_t return_value_SPF_response_add_error_ptr_5;
      return_value_SPF_response_add_error_ptr_5=SPF_response_add_error_ptr(spf_response, (enum SPF_errcode_t)SPF_E_INVALID_CIDR, (const char *)(void *)0, src, "Invalid CIDR after mechanism");
      return return_value_SPF_response_add_error_ptr_5;
    }

  }

  enum SPF_errcode_t return_value_SPF_c_parse_macro_6;
  return_value_SPF_c_parse_macro_6=SPF_c_parse_macro(spf_server, spf_response, data, data_used, data_avail, src, src_len, big_err, is_mod);
  return return_value_SPF_c_parse_macro_6;
}

// SPF_c_parse_ip4
// file spf_compile.c line 727
static enum SPF_errcode_t SPF_c_parse_ip4(struct SPF_response_struct *spf_response, struct SPF_mech_struct *mech, const char *start)
{
  const char *end;
  const char *p;
  char buf[46l];
  unsigned long int len;
  enum SPF_errcode_t err;
  unsigned char mask;
  struct in_addr *addr;
  start = start + 1l;
  len=strcspn(start, " ");
  end = start + (signed long int)len;
  p = end - (signed long int)1;
  mask = (unsigned char)0;
  const unsigned short int **return_value___ctype_b_loc_1;
  do
  {
    return_value___ctype_b_loc_1=__ctype_b_loc();
    if((2048 & (signed int)(*return_value___ctype_b_loc_1)[(signed long int)(signed int)(unsigned char)*p]) == 0)
      break;

    p = p - 1l;
  }
  while((_Bool)1);
  if(!(p == end + -1l))
  {
    if((signed int)*p == 47)
    {
      err=SPF_c_parse_cidr_ip4(spf_response, &mask, p);
      if(!(err == /*enum*/SPF_E_SUCCESS))
        return err;

      end = p;
    }

  }

  mech->mech_len = (unsigned short int)mask;
  len = (unsigned long int)(end - start);
  enum SPF_errcode_t return_value_SPF_response_add_error_ptr_3;
  if(len >= 46ul)
    return (enum SPF_errcode_t)SPF_E_INVALID_IP4;

  else
  {
    memcpy((void *)buf, (const void *)start, len);
    buf[(signed long int)len] = (char)0;
    addr=SPF_mech_ip4_data(mech);
    signed int return_value_inet_pton_2;
    return_value_inet_pton_2=inet_pton(2, buf, (void *)addr);
    err = (enum SPF_errcode_t)return_value_inet_pton_2;
    if(!((signed int)err >= 1))
    {
      return_value_SPF_response_add_error_ptr_3=SPF_response_add_error_ptr(spf_response, (enum SPF_errcode_t)SPF_E_INVALID_IP4, (const char *)(void *)0, buf, (const char *)(void *)0);
      return return_value_SPF_response_add_error_ptr_3;
    }

    return (enum SPF_errcode_t)SPF_E_SUCCESS;
  }
}

// SPF_c_parse_ip6
// file spf_compile.c line 776
static enum SPF_errcode_t SPF_c_parse_ip6(struct SPF_response_struct *spf_response, struct SPF_mech_struct *mech, const char *start)
{
  const char *end;
  const char *p;
  char buf[46l];
  unsigned long int len;
  signed int err;
  unsigned char mask;
  struct in6_addr *addr;
  start = start + 1l;
  len=strcspn(start, " ");
  end = start + (signed long int)len;
  p = end - (signed long int)1;
  mask = (unsigned char)0;
  const unsigned short int **return_value___ctype_b_loc_1;
  do
  {
    return_value___ctype_b_loc_1=__ctype_b_loc();
    if((2048 & (signed int)(*return_value___ctype_b_loc_1)[(signed long int)(signed int)(unsigned char)*p]) == 0)
      break;

    p = p - 1l;
  }
  while((_Bool)1);
  if(!(p == end + -1l))
  {
    if((signed int)*p == 47)
    {
      enum SPF_errcode_t return_value_SPF_c_parse_cidr_ip6_2;
      return_value_SPF_c_parse_cidr_ip6_2=SPF_c_parse_cidr_ip6(spf_response, &mask, p);
      err = (signed int)return_value_SPF_c_parse_cidr_ip6_2;
      if(!(err == 0))
        return (enum SPF_errcode_t)err;

      end = p;
    }

  }

  mech->mech_len = (unsigned short int)mask;
  len = (unsigned long int)(end - start);
  enum SPF_errcode_t return_value_SPF_response_add_error_ptr_3;
  if(len >= 46ul)
    return (enum SPF_errcode_t)SPF_E_INVALID_IP6;

  else
  {
    memcpy((void *)buf, (const void *)start, len);
    buf[(signed long int)len] = (char)0;
    addr=SPF_mech_ip6_data(mech);
    err=inet_pton(10, buf, (void *)addr);
    if(!(err >= 1))
    {
      return_value_SPF_response_add_error_ptr_3=SPF_response_add_error_ptr(spf_response, (enum SPF_errcode_t)SPF_E_INVALID_IP6, (const char *)(void *)0, buf, (const char *)(void *)0);
      return return_value_SPF_response_add_error_ptr_3;
    }

    return (enum SPF_errcode_t)SPF_E_SUCCESS;
  }
}

// SPF_c_parse_macro
// file spf_compile.c line 506
static enum SPF_errcode_t SPF_c_parse_macro(struct SPF_server_struct *spf_server, struct SPF_response_struct *spf_response, union SPF_data_union *data, unsigned long int *data_used, unsigned long int data_avail, const char *src, unsigned long int src_len, enum SPF_errcode_t big_err, signed int is_mod)
{
  enum SPF_errcode_t err;
  unsigned long int idx;
  unsigned long int len;
  char *dst;
  unsigned long int ds_avail;
  unsigned long int ds_len;
  if(!(spf_server->debug == 0))
    SPF_debugx("spf_compile.c", 523, "Parsing macro starting at %s", src);

  idx = (unsigned long int)0;
  do
  {
    data->ds.parm_type = (unsigned char)12;
    data->ds.len = (unsigned char)0;
    data->ds.__unused0 = (unsigned char)0xba;
    data->ds.__unused1 = (unsigned char)0xbe;
    dst=SPF_data_str(data);
    ds_avail = data_avail - *data_used;
    ds_len = (unsigned long int)0;
  }
  while((_Bool)0);
  enum SPF_errcode_t return_value_SPF_response_add_error_ptr_1;
  enum SPF_errcode_t return_value_SPF_response_add_error_ptr_2;
  enum SPF_errcode_t return_value_SPF_response_add_error_ptr_4;
  enum SPF_errcode_t return_value_SPF_response_add_error_ptr_6;
  enum SPF_errcode_t return_value_SPF_response_add_error_ptr_10;
  enum SPF_errcode_t return_value_SPF_response_add_error_ptr_17;
  while(!(idx >= src_len))
  {
    if(spf_server->debug >= 4)
      SPF_debugx("spf_compile.c", 543, "Current data is at %p", data);

    len=strcspn(&src[(signed long int)idx], " %");
    if(len >= 1ul)
    {
      if(!(src_len >= idx + len))
        len = src_len - idx;

      if(spf_server->debug >= 4)
        SPF_debugx("spf_compile.c", 554, "Adding string literal (%lu): '%*.*s'", (unsigned long int)len, (signed int)len, (signed int)len, &src[(signed long int)idx]);

      do
        if(!(ds_avail >= ds_len + len))
        {
          return_value_SPF_response_add_error_ptr_1=SPF_response_add_error_ptr(spf_response, (enum SPF_errcode_t)SPF_E_BIG_STRING, (const char *)(void *)0, src, "String literal fragment too long (%d chars, %d max)", ds_len, ds_avail);
          return return_value_SPF_response_add_error_ptr_1;
        }

      while((_Bool)0);
      memcpy((void *)dst, (const void *)&src[(signed long int)idx], len);
      ds_len = ds_len + len;
      dst = dst + (signed long int)len;
      idx = idx + len;
    }

    if(idx == src_len)
      break;

    idx = idx + 1ul;
    if(!((signed int)src[(signed long int)idx] == 37))
    {
      if((signed int)src[(signed long int)idx] == 95)
        goto __CPROVER_DUMP_L12;

      if((signed int)src[(signed long int)idx] == 45)
        goto __CPROVER_DUMP_L15;

      if((signed int)src[(signed long int)idx] == 123)
        goto __CPROVER_DUMP_L21;

    }

    else
    {
      if(spf_server->debug >= 4)
        SPF_debugx("spf_compile.c", 580, "Adding literal %%");

      do
        if(!(ds_avail >= 1ul + ds_len))
        {
          return_value_SPF_response_add_error_ptr_2=SPF_response_add_error_ptr(spf_response, (enum SPF_errcode_t)SPF_E_BIG_STRING, (const char *)(void *)0, src, "String literal fragment too long (%d chars, %d max)", ds_len, ds_avail);
          return return_value_SPF_response_add_error_ptr_2;
        }

      while((_Bool)0);
      char *tmp_post_3 = dst;
      dst = dst + 1l;
      *tmp_post_3 = (char)37;
      ds_len = ds_len + 1ul;
      idx = idx + 1ul;
      continue;

    __CPROVER_DUMP_L12:
      ;
      if(spf_server->debug >= 4)
        SPF_debugx("spf_compile.c", 589, "Adding literal space");

      do
        if(!(ds_avail >= 1ul + ds_len))
        {
          return_value_SPF_response_add_error_ptr_4=SPF_response_add_error_ptr(spf_response, (enum SPF_errcode_t)SPF_E_BIG_STRING, (const char *)(void *)0, src, "String literal fragment too long (%d chars, %d max)", ds_len, ds_avail);
          return return_value_SPF_response_add_error_ptr_4;
        }

      while((_Bool)0);
      char *tmp_post_5 = dst;
      dst = dst + 1l;
      *tmp_post_5 = (char)32;
      ds_len = ds_len + 1ul;
      idx = idx + 1ul;
      continue;

    __CPROVER_DUMP_L15:
      ;
      if(spf_server->debug >= 4)
        SPF_debugx("spf_compile.c", 598, "Adding escaped space");

      do
        if(!(ds_avail >= 3ul + ds_len))
        {
          return_value_SPF_response_add_error_ptr_6=SPF_response_add_error_ptr(spf_response, (enum SPF_errcode_t)SPF_E_BIG_STRING, (const char *)(void *)0, src, "String literal fragment too long (%d chars, %d max)", ds_len, ds_avail);
          return return_value_SPF_response_add_error_ptr_6;
        }

      while((_Bool)0);
      char *tmp_post_7 = dst;
      dst = dst + 1l;
      *tmp_post_7 = (char)37;
      char *tmp_post_8 = dst;
      dst = dst + 1l;
      *tmp_post_8 = (char)50;
      char *tmp_post_9 = dst;
      dst = dst + 1l;
      *tmp_post_9 = (char)48;
      ds_len = ds_len + (unsigned long int)3;
      idx = idx + 1ul;
      continue;
    }
    if(spf_server->debug >= 4)
      SPF_debugx("spf_compile.c", 608, "Adding illegal %%-follower '%c' at %d", src[(signed long int)idx], idx);

    do
      if(!(ds_avail >= 1ul + ds_len))
      {
        return_value_SPF_response_add_error_ptr_10=SPF_response_add_error_ptr(spf_response, (enum SPF_errcode_t)SPF_E_BIG_STRING, (const char *)(void *)0, src, "String literal fragment too long (%d chars, %d max)", ds_len, ds_avail);
        return return_value_SPF_response_add_error_ptr_10;
      }

    while((_Bool)0);
    char *tmp_post_11 = dst;
    dst = dst + 1l;
    *tmp_post_11 = (char)37;
    ds_len = ds_len + 1ul;
    continue;

  __CPROVER_DUMP_L21:
    ;
    do
      if(ds_len >= 1ul)
      {
        if(ds_len >= 256ul)
        {
          enum SPF_errcode_t return_value_SPF_response_add_error_ptr_12;
          return_value_SPF_response_add_error_ptr_12=SPF_response_add_error_ptr(spf_response, (enum SPF_errcode_t)SPF_E_BIG_STRING, (const char *)(void *)0, src, "String literal too long (%d chars, %d max)", ds_len, 255);
          return return_value_SPF_response_add_error_ptr_12;
        }

        data->ds.len = (unsigned char)ds_len;
        len = sizeof(union SPF_data_union) /*4ul*/  + ds_len;
        do
        {
          unsigned long int return_value__align_sz_14;
          return_value__align_sz_14=_align_sz(len);
          if(!(data_avail >= *data_used + return_value__align_sz_14))
          {
            enum SPF_errcode_t return_value_SPF_response_add_error_ptr_13;
            return_value_SPF_response_add_error_ptr_13=SPF_response_add_error_ptr(spf_response, big_err, (const char *)(void *)0, src, "SPF domainspec too long (%d chars, %d max)", *data_used + len, data_avail);
            return return_value_SPF_response_add_error_ptr_13;
          }

          unsigned long int return_value__align_sz_15;
          return_value__align_sz_15=_align_sz(len);
          *data_used = *data_used + return_value__align_sz_15;
        }
        while((_Bool)0);
        data=SPF_data_next(data);
        ds_len = (unsigned long int)0;
      }

    while((_Bool)0);
    if(spf_server->debug >= 4)
      SPF_debugx("spf_compile.c", 620, "Adding macro, data is at %p", data);

    idx = idx + 1ul;
    err=SPF_c_parse_var(spf_response, &data->dv, &src[(signed long int)idx], is_mod);
    if(!((signed int)err == SPF_E_SUCCESS))
      return err;

    unsigned long int return_value_strcspn_16;
    return_value_strcspn_16=strcspn(&src[(signed long int)idx], "} ");
    idx = idx + return_value_strcspn_16;
    if((signed int)src[(signed long int)idx] == 125)
      idx = idx + 1ul;

    else
      if((signed int)src[(signed long int)idx] == 32)
      {
        return_value_SPF_response_add_error_ptr_17=SPF_response_add_error_ptr(spf_response, (enum SPF_errcode_t)SPF_E_INVALID_VAR, src, &src[(signed long int)idx], "Unterminated variable?");
        return return_value_SPF_response_add_error_ptr_17;
      }

    len=SPF_data_len(data);
    do
    {
      unsigned long int return_value__align_sz_19;
      return_value__align_sz_19=_align_sz(len);
      if(!(data_avail >= *data_used + return_value__align_sz_19))
      {
        enum SPF_errcode_t return_value_SPF_response_add_error_ptr_18;
        return_value_SPF_response_add_error_ptr_18=SPF_response_add_error_ptr(spf_response, big_err, (const char *)(void *)0, src, "SPF domainspec too long (%d chars, %d max)", *data_used + len, data_avail);
        return return_value_SPF_response_add_error_ptr_18;
      }

      unsigned long int return_value__align_sz_20;
      return_value__align_sz_20=_align_sz(len);
      *data_used = *data_used + return_value__align_sz_20;
    }
    while((_Bool)0);
    data=SPF_data_next(data);
    if(spf_server->debug >= 4)
      SPF_debugx("spf_compile.c", 641, "Next data is at %p", data);

    do
    {
      data->ds.parm_type = (unsigned char)12;
      data->ds.len = (unsigned char)0;
      data->ds.__unused0 = (unsigned char)0xba;
      data->ds.__unused1 = (unsigned char)0xbe;
      dst=SPF_data_str(data);
      ds_avail = data_avail - *data_used;
      ds_len = (unsigned long int)0;
    }
    while((_Bool)0);
  }
  do
    if(ds_len >= 1ul)
    {
      if(ds_len >= 256ul)
      {
        enum SPF_errcode_t return_value_SPF_response_add_error_ptr_21;
        return_value_SPF_response_add_error_ptr_21=SPF_response_add_error_ptr(spf_response, (enum SPF_errcode_t)SPF_E_BIG_STRING, (const char *)(void *)0, src, "String literal too long (%d chars, %d max)", ds_len, 255);
        return return_value_SPF_response_add_error_ptr_21;
      }

      data->ds.len = (unsigned char)ds_len;
      len = sizeof(union SPF_data_union) /*4ul*/  + ds_len;
      do
      {
        unsigned long int return_value__align_sz_23;
        return_value__align_sz_23=_align_sz(len);
        if(!(data_avail >= *data_used + return_value__align_sz_23))
        {
          enum SPF_errcode_t return_value_SPF_response_add_error_ptr_22;
          return_value_SPF_response_add_error_ptr_22=SPF_response_add_error_ptr(spf_response, big_err, (const char *)(void *)0, src, "SPF domainspec too long (%d chars, %d max)", *data_used + len, data_avail);
          return return_value_SPF_response_add_error_ptr_22;
        }

        unsigned long int return_value__align_sz_24;
        return_value__align_sz_24=_align_sz(len);
        *data_used = *data_used + return_value__align_sz_24;
      }
      while((_Bool)0);
      data=SPF_data_next(data);
      ds_len = (unsigned long int)0;
    }

  while((_Bool)0);
  return (enum SPF_errcode_t)SPF_E_SUCCESS;
}

// SPF_c_parse_var
// file spf_compile.c line 272
static enum SPF_errcode_t SPF_c_parse_var(struct SPF_response_struct *spf_response, struct SPF_data_var_struct *data, const char *src, signed int is_mod)
{
  const char *token;
  const char *p;
  char c;
  signed int val;
  memset((void *)data, 0, sizeof(struct SPF_data_var_struct) /*4ul*/ );
  p = src;
  c = *p;
  const unsigned short int **return_value___ctype_b_loc_2;
  return_value___ctype_b_loc_2=__ctype_b_loc();
  if(!((256 & (signed int)(*return_value___ctype_b_loc_2)[(signed long int)(signed int)(unsigned char)c]) == 0))
  {
    data->url_encode = (unsigned short int)1;
    signed int return_value_tolower_1;
    return_value_tolower_1=tolower((signed int)c);
    c = (char)return_value_tolower_1;
  }

  else
    data->url_encode = (unsigned short int)0;
  enum SPF_errcode_t return_value_SPF_response_add_error_ptr_3;
  enum SPF_errcode_t return_value_SPF_response_add_error_ptr_4;
  enum SPF_errcode_t return_value_SPF_response_add_error_ptr_5;
  enum SPF_errcode_t return_value_SPF_response_add_error_ptr_6;
  switch((signed int)c)
  {
    case 108:
    {
      data->parm_type = (unsigned char)0;
      break;
    }
    case 115:
    {
      data->parm_type = (unsigned char)1;
      break;
    }
    case 111:
    {
      data->parm_type = (unsigned char)2;
      break;
    }
    case 100:
    {
      data->parm_type = (unsigned char)3;
      break;
    }
    case 105:
    {
      data->parm_type = (unsigned char)4;
      break;
    }
    case 99:
    {
      if(is_mod == 0)
      {
        return_value_SPF_response_add_error_ptr_3=SPF_response_add_error_ptr(spf_response, (enum SPF_errcode_t)SPF_E_INVALID_VAR, (const char *)(void *)0, p, "'%c' macro is only valid in modifiers", c);
        return return_value_SPF_response_add_error_ptr_3;
      }

      data->parm_type = (unsigned char)5;
      break;
    }
    case 116:
    {
      if(is_mod == 0)
      {
        return_value_SPF_response_add_error_ptr_4=SPF_response_add_error_ptr(spf_response, (enum SPF_errcode_t)SPF_E_INVALID_VAR, (const char *)(void *)0, p, "'%c' macro is only valid in modifiers", c);
        return return_value_SPF_response_add_error_ptr_4;
      }

      data->parm_type = (unsigned char)6;
      break;
    }
    case 112:
    {
      data->parm_type = (unsigned char)7;
      break;
    }
    case 118:
    {
      data->parm_type = (unsigned char)8;
      break;
    }
    case 104:
    {
      data->parm_type = (unsigned char)9;
      break;
    }
    case 114:
    {
      if(is_mod == 0)
      {
        return_value_SPF_response_add_error_ptr_5=SPF_response_add_error_ptr(spf_response, (enum SPF_errcode_t)SPF_E_INVALID_VAR, (const char *)(void *)0, p, "'%c' macro is only valid in modifiers", c);
        return return_value_SPF_response_add_error_ptr_5;
      }

      data->parm_type = (unsigned char)10;
      break;
    }
    default:
    {
      return_value_SPF_response_add_error_ptr_6=SPF_response_add_error_ptr(spf_response, (enum SPF_errcode_t)SPF_E_INVALID_VAR, (const char *)(void *)0, p, "Unknown variable '%c'", c);
      return return_value_SPF_response_add_error_ptr_6;
    }
  }
  p = p + 1l;
  token = p;
  val = 0;
  const unsigned short int **return_value___ctype_b_loc_7;
  do
  {
    return_value___ctype_b_loc_7=__ctype_b_loc();
    if((2048 & (signed int)(*return_value___ctype_b_loc_7)[(signed long int)(signed int)(unsigned char)*p]) == 0)
      break;

    val = val * 10;
    val = val + ((signed int)*p - 48);
    p = p + 1l;
  }
  while((_Bool)1);
  enum SPF_errcode_t return_value_SPF_response_add_error_ptr_8;
  if(val >= 129 || !(p == token) && !(val >= 1))
  {
    return_value_SPF_response_add_error_ptr_8=SPF_response_add_error_ptr(spf_response, (enum SPF_errcode_t)SPF_E_BIG_SUBDOM, (const char *)(void *)0, token, "Subdomain truncation depth too large");
    return return_value_SPF_response_add_error_ptr_8;
  }

  data->num_rhs = (unsigned char)val;
  token = p;
  if((signed int)*p == 114)
  {
    data->rev = (unsigned short int)1;
    p = p + 1l;
  }

  else
    data->rev = (unsigned short int)0;
  token = p;
  data->delim_dot = (unsigned short int)0;
  data->delim_dash = (unsigned short int)0;
  data->delim_plus = (unsigned short int)0;
  data->delim_equal = (unsigned short int)0;
  data->delim_bar = (unsigned short int)0;
  data->delim_under = (unsigned short int)0;
  if((signed int)*p == 125)
    data->delim_dot = (unsigned short int)1;

  enum SPF_errcode_t return_value_SPF_response_add_error_ptr_9;
  for( ; !((signed int)*p == 125); p = p + 1l)
  {
    token = p;
    switch((signed int)*p)
    {
      case 46:
      {
        data->delim_dot = (unsigned short int)1;
        break;
      }
      case 45:
      {
        data->delim_dash = (unsigned short int)1;
        break;
      }
      case 43:
      {
        data->delim_plus = (unsigned short int)1;
        break;
      }
      case 61:
      {
        data->delim_equal = (unsigned short int)1;
        break;
      }
      case 124:
      {
        data->delim_bar = (unsigned short int)1;
        break;
      }
      case 95:
      {
        data->delim_under = (unsigned short int)1;
        break;
      }
      default:
      {
        return_value_SPF_response_add_error_ptr_9=SPF_response_add_error_ptr(spf_response, (enum SPF_errcode_t)SPF_E_INVALID_DELIM, (const char *)(void *)0, p, "Invalid delimiter '%c'", *p);
        return return_value_SPF_response_add_error_ptr_9;
      }
    }
  }
  p = p + 1l;
  token = p;
  return (enum SPF_errcode_t)SPF_E_SUCCESS;
}

// SPF_data_len
// file ../../src/include/spf_internal.h line 107
static inline unsigned long int SPF_data_len(union SPF_data_union *data)
{
  signed int tmp_if_expr_1;
  if((signed int)data->ds.parm_type == 12)
    tmp_if_expr_1 = (signed int)data->ds.len;

  else
    tmp_if_expr_1 = 0;
  return sizeof(union SPF_data_union) /*4ul*/  + (unsigned long int)tmp_if_expr_1;
}

// SPF_data_len_link1
// file ../../src/include/spf_internal.h line 107
static inline unsigned long int SPF_data_len_link1(union SPF_data_union *data_link1)
{
  signed int tmp_if_expr_1_link1;
  if((signed int)data_link1->ds.parm_type == 12)
    tmp_if_expr_1_link1 = (signed int)data_link1->ds.len;

  else
    tmp_if_expr_1_link1 = 0;
  return sizeof(union SPF_data_union) /*4ul*/  + (unsigned long int)tmp_if_expr_1_link1;
}

// SPF_data_len_link2
// file ../../src/include/spf_internal.h line 107
static inline unsigned long int SPF_data_len_link2(union SPF_data_union *data_link2)
{
  signed int tmp_if_expr_1_link2;
  if((signed int)data_link2->ds.parm_type == 12)
    tmp_if_expr_1_link2 = (signed int)data_link2->ds.len;

  else
    tmp_if_expr_1_link2 = 0;
  return sizeof(union SPF_data_union) /*4ul*/  + (unsigned long int)tmp_if_expr_1_link2;
}

// SPF_data_len_link3
// file ../../src/include/spf_internal.h line 107
static inline unsigned long int SPF_data_len_link3(union SPF_data_union *data_link3)
{
  signed int tmp_if_expr_1_link3;
  if((signed int)data_link3->ds.parm_type == 12)
    tmp_if_expr_1_link3 = (signed int)data_link3->ds.len;

  else
    tmp_if_expr_1_link3 = 0;
  return sizeof(union SPF_data_union) /*4ul*/  + (unsigned long int)tmp_if_expr_1_link3;
}

// SPF_data_next
// file ../../src/include/spf_internal.h line 110
static inline union SPF_data_union * SPF_data_next(union SPF_data_union *data)
{
  unsigned long int return_value_SPF_data_len_1;
  return_value_SPF_data_len_1=SPF_data_len(data);
  char *return_value__align_ptr_2;
  return_value__align_ptr_2=_align_ptr((char *)data + (signed long int)return_value_SPF_data_len_1);
  return (union SPF_data_union *)return_value__align_ptr_2;
}

// SPF_data_next_link1
// file ../../src/include/spf_internal.h line 110
static inline union SPF_data_union * SPF_data_next_link1(union SPF_data_union *data_link1)
{
  unsigned long int return_value_SPF_data_len_1_link1;
  return_value_SPF_data_len_1_link1=SPF_data_len_link1(data_link1);
  char *return_value__align_ptr_2_link1;
  return_value__align_ptr_2_link1=_align_ptr_link1((char *)data_link1 + (signed long int)return_value_SPF_data_len_1_link1);
  return (union SPF_data_union *)return_value__align_ptr_2_link1;
}

// SPF_data_next_link2
// file ../../src/include/spf_internal.h line 110
static inline union SPF_data_union * SPF_data_next_link2(union SPF_data_union *data_link2)
{
  unsigned long int return_value_SPF_data_len_1_link2;
  return_value_SPF_data_len_1_link2=SPF_data_len_link2(data_link2);
  char *return_value__align_ptr_2_link2;
  return_value__align_ptr_2_link2=_align_ptr_link2((char *)data_link2 + (signed long int)return_value_SPF_data_len_1_link2);
  return (union SPF_data_union *)return_value__align_ptr_2_link2;
}

// SPF_data_next_link3
// file ../../src/include/spf_internal.h line 110
static inline union SPF_data_union * SPF_data_next_link3(union SPF_data_union *data_link3)
{
  unsigned long int return_value_SPF_data_len_1_link3;
  return_value_SPF_data_len_1_link3=SPF_data_len_link3(data_link3);
  char *return_value__align_ptr_2_link3;
  return_value__align_ptr_2_link3=_align_ptr_link3((char *)data_link3 + (signed long int)return_value_SPF_data_len_1_link3);
  return (union SPF_data_union *)return_value__align_ptr_2_link3;
}

// SPF_data_str
// file ../../src/include/spf_internal.h line 114
static inline char * SPF_data_str(union SPF_data_union *data)
{
  return (char *)data + (signed long int)sizeof(union SPF_data_union) /*4ul*/ ;
}

// SPF_data_str_link1
// file ../../src/include/spf_internal.h line 114
static inline char * SPF_data_str_link1(union SPF_data_union *data_link1)
{
  return (char *)data_link1 + (signed long int)sizeof(union SPF_data_union) /*4ul*/ ;
}

// SPF_data_str_link2
// file ../../src/include/spf_internal.h line 114
static inline char * SPF_data_str_link2(union SPF_data_union *data_link2)
{
  return (char *)data_link2 + (signed long int)sizeof(union SPF_data_union) /*4ul*/ ;
}

// SPF_debug_stdio
// file ../../src/include/spf_log.h line 90
void SPF_debug_stdio(const char *file, signed int line, const char *errmsg)
{
  char buf[128l];
  if(!(file == ((const char *)NULL)))
  {
    snprintf(buf, sizeof(char [128l]) /*128ul*/ , "%s:%d", file, line);
    fprintf(stderr, "%-20s Debug: %s\n", (const void *)buf, errmsg);
  }

  else
    fprintf(stderr, "Debug: %s\n", errmsg);
}

// SPF_debug_syslog
// file spf_log_syslog.c line 71
void SPF_debug_syslog(const char *file, signed int line, const char *errmsg)
{
  char buf[128l] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
  if(!(file == ((const char *)NULL)))
  {
    snprintf(buf, sizeof(char [128l]) /*128ul*/ , "%s:%d", file, line);
    syslog(2 << 3 | 7, "%-20s %s", (const void *)buf, errmsg);
  }

  else
    syslog(2 << 3 | 7, "%s", errmsg);
}

// SPF_debugv
// file spf_log.c line 150
void SPF_debugv(const char *file, signed int line, const char *format, void **ap)
{
  char errmsg[800l];
  if(!(SPF_debug_handler == ((void (*)(const char *, signed int, const char *))NULL)))
  {
    vsnprintf(errmsg, sizeof(char [800l]) /*800ul*/ , format, ap);
    SPF_debug_handler(file, line, errmsg);
  }

}

// SPF_debugx
// file ../../src/include/spf_log.h line 56
void SPF_debugx(const char *file, signed int line, const char *format, ...)
{
  char errmsg[800l];
  void **ap;
  if(!(SPF_debug_handler == ((void (*)(const char *, signed int, const char *))NULL)))
  {
    ap = (void **)&format;
    vsnprintf(errmsg, sizeof(char [800l]) /*800ul*/ , format, ap);
    ap = ((void **)NULL);
    SPF_debug_handler(file, line, errmsg);
  }

}

// SPF_debugx2
// file spf_log.c line 194
void SPF_debugx2(const char *format, ...)
{
  void **ap = (void **)&format;
  SPF_debugv((const char *)(void *)0, 0, format, ap);
  ap = ((void **)NULL);
}

// SPF_delim_valid
// file spf_expand.c line 65
static inline signed int SPF_delim_valid(union SPF_data_union *d, char c)
{
  _Bool tmp_if_expr_1;
  if((signed int)c == 46 && !(d->dv.delim_dot == 0))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = (d->dv.delim_dash != 0 ? ((signed int)c == 45 ? (_Bool)1 : (_Bool)0) : (_Bool)0) ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_2;
  if(tmp_if_expr_1)
    tmp_if_expr_2 = (_Bool)1;

  else
    tmp_if_expr_2 = (d->dv.delim_plus != 0 ? ((signed int)c == 43 ? (_Bool)1 : (_Bool)0) : (_Bool)0) ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_3;
  if(tmp_if_expr_2)
    tmp_if_expr_3 = (_Bool)1;

  else
    tmp_if_expr_3 = (d->dv.delim_equal != 0 ? ((signed int)c == 61 ? (_Bool)1 : (_Bool)0) : (_Bool)0) ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_4;
  if(tmp_if_expr_3)
    tmp_if_expr_4 = (_Bool)1;

  else
    tmp_if_expr_4 = (d->dv.delim_bar != 0 ? ((signed int)c == 124 ? (_Bool)1 : (_Bool)0) : (_Bool)0) ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_5;
  if(tmp_if_expr_4)
    tmp_if_expr_5 = (_Bool)1;

  else
    tmp_if_expr_5 = (d->dv.delim_under != 0 ? ((signed int)c == 95 ? (_Bool)1 : (_Bool)0) : (_Bool)0) ? (_Bool)1 : (_Bool)0;
  return (signed int)tmp_if_expr_5;
}

// SPF_dns_cache_bucket_add
// file spf_dns_cache.c line 295
static enum SPF_errcode_t SPF_dns_cache_bucket_add(struct anonymous_1 *spfhook, struct SPF_dns_rr_struct *rr, signed int idx)
{
  struct _SPF_dns_cache_bucket_t *bucket;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct _SPF_dns_cache_bucket_t) /*16ul*/ );
  bucket = (struct _SPF_dns_cache_bucket_t *)return_value_malloc_1;
  if(bucket == ((struct _SPF_dns_cache_bucket_t *)NULL))
    return (enum SPF_errcode_t)SPF_E_NO_MEMORY;

  else
  {
    bucket->next = spfhook->cache[(signed long int)idx];
    spfhook->cache[(signed long int)idx] = bucket;
    bucket->rr = rr;
    return (enum SPF_errcode_t)SPF_E_SUCCESS;
  }
}

// SPF_dns_cache_bucket_find
// file spf_dns_cache.c line 239
static struct _SPF_dns_cache_bucket_t * SPF_dns_cache_bucket_find(struct anonymous_1 *spfhook, const char *domain, enum __ns_type rr_type, signed int idx)
{
  struct _SPF_dns_cache_bucket_t *bucket;
  struct _SPF_dns_cache_bucket_t *prev;
  struct SPF_dns_rr_struct *rr;
  signed long int now;
  bucket = spfhook->cache[(signed long int)idx];
  prev = (struct _SPF_dns_cache_bucket_t *)(void *)0;
  time(&now);
  signed int return_value_strcmp_1;
  while(!(bucket == ((struct _SPF_dns_cache_bucket_t *)NULL)))
  {
    rr = bucket->rr;
    if(!(rr->utc_ttl >= now))
    {
      if(!(prev == ((struct _SPF_dns_cache_bucket_t *)NULL)))
        prev->next = bucket->next;

      else
        spfhook->cache[(signed long int)idx] = bucket->next;
      if(!(bucket->rr == ((struct SPF_dns_rr_struct *)NULL)))
        SPF_dns_rr_free(bucket->rr);

      free((void *)bucket);
      bucket = prev;
    }

    else
      if(rr->rr_type == rr_type)
      {
        return_value_strcmp_1=strcmp(rr->domain, domain);
        if(return_value_strcmp_1 == 0)
        {
          if(!(prev == ((struct _SPF_dns_cache_bucket_t *)NULL)))
          {
            prev->next = bucket->next;
            bucket->next = spfhook->cache[(signed long int)idx];
            spfhook->cache[(signed long int)idx] = bucket;
          }

          return bucket;
        }

      }

    prev = bucket;
    if(bucket == ((struct _SPF_dns_cache_bucket_t *)NULL))
      bucket = spfhook->cache[(signed long int)idx];

    else
      bucket = bucket->next;
  }
  return (struct _SPF_dns_cache_bucket_t *)(void *)0;
}

// SPF_dns_cache_free
// file spf_dns_cache.c line 435
static void SPF_dns_cache_free(struct SPF_dns_server_struct *spf_dns_server)
{
  struct anonymous_1 *spfhook;
  struct _SPF_dns_cache_bucket_t *bucket;
  struct _SPF_dns_cache_bucket_t *prev;
  signed int i;
  do
    if(spf_dns_server == ((struct SPF_dns_server_struct *)NULL))
      SPF_errorx("spf_dns_cache.c", 442, "%s", (const void *)"spf_dns_server is NULL");

  while((_Bool)0);
  spfhook=SPF_voidp2spfhook(spf_dns_server->hook);
  if(!(spfhook == ((struct anonymous_1 *)NULL)))
  {
    pthread_mutex_lock(&spfhook->cache_lock);
    if(!(spfhook->cache == ((struct _SPF_dns_cache_bucket_t **)NULL)))
    {
      i = 0;
      for( ; !(i >= spfhook->cache_size); i = i + 1)
      {
        bucket = spfhook->cache[(signed long int)i];
        while(!(bucket == ((struct _SPF_dns_cache_bucket_t *)NULL)))
        {
          prev = bucket;
          bucket = bucket->next;
          if(!(prev->rr == ((struct SPF_dns_rr_struct *)NULL)))
            SPF_dns_rr_free(prev->rr);

          free((void *)prev);
        }
      }
      free((void *)spfhook->cache);
      spfhook->cache = (struct _SPF_dns_cache_bucket_t **)(void *)0;
    }

    pthread_mutex_unlock(&spfhook->cache_lock);
    pthread_mutex_destroy(&spfhook->cache_lock);
    free((void *)spfhook);
  }

  free((void *)spf_dns_server);
}

// SPF_dns_cache_lookup
// file spf_dns_cache.c line 368
static struct SPF_dns_rr_struct * SPF_dns_cache_lookup(struct SPF_dns_server_struct *spf_dns_server, const char *domain, enum __ns_type rr_type, signed int should_cache)
{
  struct anonymous_1 *spfhook;
  struct _SPF_dns_cache_bucket_t *bucket;
  struct SPF_dns_rr_struct *cached_rr;
  struct SPF_dns_rr_struct *rr;
  signed int idx;
  spfhook=SPF_voidp2spfhook(spf_dns_server->hook);
  idx=crc32str((unsigned int)0, domain, spfhook->max_hash_len);
  idx = idx & spfhook->cache_size - 1;
  pthread_mutex_lock(&spfhook->cache_lock);
  bucket=SPF_dns_cache_bucket_find(spfhook, domain, rr_type, idx);
  if(!(bucket == ((struct _SPF_dns_cache_bucket_t *)NULL)))
  {
    if(!(bucket->rr == ((struct SPF_dns_rr_struct *)NULL)))
    {
      enum SPF_errcode_t return_value_SPF_dns_rr_dup_1;
      return_value_SPF_dns_rr_dup_1=SPF_dns_rr_dup(&rr, bucket->rr);
      if((signed int)return_value_SPF_dns_rr_dup_1 == SPF_E_SUCCESS)
      {
        pthread_mutex_unlock(&spfhook->cache_lock);
        return rr;
      }

      else
        if(!(rr == ((struct SPF_dns_rr_struct *)NULL)))
          SPF_dns_rr_free(rr);

    }

  }

  bucket = (struct _SPF_dns_cache_bucket_t *)(void *)0;
  pthread_mutex_unlock(&spfhook->cache_lock);
  struct SPF_dns_rr_struct *return_value_SPF_dns_rr_new_nxdomain_2;
  if(spf_dns_server->layer_below == ((struct SPF_dns_server_struct *)NULL))
  {
    return_value_SPF_dns_rr_new_nxdomain_2=SPF_dns_rr_new_nxdomain(spf_dns_server, domain);
    return return_value_SPF_dns_rr_new_nxdomain_2;
  }

  rr=SPF_dns_lookup(spf_dns_server->layer_below, domain, rr_type, should_cache);
  if(!(spfhook->conserve_cache == 0))
  {
    if(!(should_cache == 0))
      goto __CPROVER_DUMP_L5;

    return rr;
  }

  else
  {

  __CPROVER_DUMP_L5:
    ;
    pthread_mutex_lock(&spfhook->cache_lock);
    enum SPF_errcode_t return_value_SPF_dns_rr_dup_5;
    return_value_SPF_dns_rr_dup_5=SPF_dns_rr_dup(&cached_rr, rr);
    if((signed int)return_value_SPF_dns_rr_dup_5 == SPF_E_SUCCESS)
    {
      enum SPF_errcode_t return_value_SPF_dns_cache_rr_fixup_4;
      return_value_SPF_dns_cache_rr_fixup_4=SPF_dns_cache_rr_fixup(spfhook, cached_rr, domain, rr_type);
      if((signed int)return_value_SPF_dns_cache_rr_fixup_4 == SPF_E_SUCCESS)
      {
        enum SPF_errcode_t return_value_SPF_dns_cache_bucket_add_3;
        return_value_SPF_dns_cache_bucket_add_3=SPF_dns_cache_bucket_add(spfhook, cached_rr, idx);
        if((signed int)return_value_SPF_dns_cache_bucket_add_3 == SPF_E_SUCCESS)
        {
          pthread_mutex_unlock(&spfhook->cache_lock);
          return rr;
        }

      }

    }

    pthread_mutex_unlock(&spfhook->cache_lock);
    if(!(cached_rr == ((struct SPF_dns_rr_struct *)NULL)))
      SPF_dns_rr_free(cached_rr);

    return rr;
  }
}

// SPF_dns_cache_new
// file spf_dns_cache.c line 487
struct SPF_dns_server_struct * SPF_dns_cache_new(struct SPF_dns_server_struct *layer_below, const char *name, signed int debug, signed int cache_bits)
{
  struct SPF_dns_server_struct *spf_dns_server;
  struct anonymous_1 *spfhook;
  do
    if(layer_below == ((struct SPF_dns_server_struct *)NULL))
      SPF_errorx("spf_dns_cache.c", 493, "%s", (const void *)"layer_below is NULL");

  while((_Bool)0);
  if(cache_bits >= 17 || !(cache_bits >= 1))
    SPF_errorx("spf_dns_cache.c", 496, "%s", (const void *)"cache bits out of range (1..16).");

  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct SPF_dns_server_struct) /*72ul*/ );
  spf_dns_server = (struct SPF_dns_server_struct *)return_value_malloc_1;
  if(spf_dns_server == ((struct SPF_dns_server_struct *)NULL))
    return (struct SPF_dns_server_struct *)(void *)0;

  else
  {
    memset((void *)spf_dns_server, 0, sizeof(struct SPF_dns_server_struct) /*72ul*/ );
    spf_dns_server->hook=malloc(sizeof(struct anonymous_1) /*104ul*/ );
    if(spf_dns_server->hook == NULL)
    {
      free((void *)spf_dns_server);
      return (struct SPF_dns_server_struct *)(void *)0;
    }

    else
    {
      memset(spf_dns_server->hook, 0, sizeof(struct anonymous_1) /*104ul*/ );
      if(name == ((const char *)NULL))
        name = "cache";

      spf_dns_server->destroy = SPF_dns_cache_free;
      spf_dns_server->lookup = SPF_dns_cache_lookup;
      spf_dns_server->get_spf = (enum SPF_errcode_t (*)(struct SPF_server_struct *, struct SPF_request_struct *, struct SPF_response_struct *, struct SPF_record_struct **))(void *)0;
      spf_dns_server->get_exp = (enum SPF_errcode_t (*)(struct SPF_server_struct *, const char *, char **, unsigned long int *))(void *)0;
      spf_dns_server->add_cache = (signed int (*)(struct SPF_server_struct *, struct SPF_dns_rr_struct))(void *)0;
      spf_dns_server->layer_below = layer_below;
      spf_dns_server->name = name;
      spf_dns_server->debug = debug;
      spfhook=SPF_voidp2spfhook(spf_dns_server->hook);
      spfhook->cache_size = 1 << cache_bits;
      spfhook->hash_mask = spfhook->cache_size - 1;
      spfhook->max_hash_len = cache_bits > 4 ? cache_bits * 2 : 8;
      void *return_value_calloc_2;
      return_value_calloc_2=calloc((unsigned long int)spfhook->cache_size, sizeof(struct _SPF_dns_cache_bucket_t *) /*8ul*/ );
      spfhook->cache = (struct _SPF_dns_cache_bucket_t **)return_value_calloc_2;
      spfhook->min_ttl = (signed long int)30;
      spfhook->err_ttl = (signed long int)(30 * 60);
      spfhook->txt_ttl = (signed long int)(30 * 60);
      spfhook->rdns_ttl = (signed long int)(30 * 60);
      spfhook->conserve_cache = (signed int)(cache_bits < 12);
      if(spfhook->cache == ((struct _SPF_dns_cache_bucket_t **)NULL))
      {
        free((void *)spfhook);
        free((void *)spf_dns_server);
        return (struct SPF_dns_server_struct *)(void *)0;
      }

      else
      {
        pthread_mutex_init(&spfhook->cache_lock, (const union anonymous *)(void *)0);
        return spf_dns_server;
      }
    }
  }
}

// SPF_dns_cache_rr_fixup
// file spf_dns_cache.c line 315
static enum SPF_errcode_t SPF_dns_cache_rr_fixup(struct anonymous_1 *spfhook, struct SPF_dns_rr_struct *cached_rr, const char *domain, enum __ns_type rr_type)
{
  char *p;
  if((signed int)cached_rr->rr_type == ns_t_any)
    cached_rr->rr_type = rr_type;

  _Bool tmp_if_expr_3;
  if(cached_rr->domain == ((char *)NULL))
    tmp_if_expr_3 = (_Bool)1;

  else
    tmp_if_expr_3 = (signed int)cached_rr->domain[(signed long int)0] != 0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_3)
  {
    char *new_domain;
    unsigned long int new_len;
    unsigned long int return_value_strlen_1;
    return_value_strlen_1=strlen(domain);
    new_len = return_value_strlen_1 + (unsigned long int)1;
    if(!(cached_rr->domain_buf_len >= new_len))
    {
      void *return_value_realloc_2;
      return_value_realloc_2=realloc((void *)cached_rr->domain, new_len);
      new_domain = (char *)return_value_realloc_2;
      if(new_domain == ((char *)NULL))
        return (enum SPF_errcode_t)SPF_E_NO_MEMORY;

      cached_rr->domain = new_domain;
      cached_rr->domain_buf_len = new_len;
    }

    strcpy(cached_rr->domain, domain);
  }

  if(!(cached_rr->ttl >= spfhook->min_ttl))
    cached_rr->ttl = spfhook->min_ttl;

  if(!(cached_rr->ttl >= spfhook->txt_ttl))
  {
    if((signed int)cached_rr->rr_type == ns_t_txt)
      cached_rr->ttl = spfhook->txt_ttl;

  }

  if(!(cached_rr->ttl >= spfhook->err_ttl))
  {
    if(!(cached_rr->herrno == 0))
      cached_rr->ttl = spfhook->err_ttl;

  }

  if(!(cached_rr->ttl >= spfhook->rdns_ttl))
  {
    p=strstr(cached_rr->domain, ".arpa");
    if(!(p == ((char *)NULL)))
    {
      if((signed int)p[5l] == 0)
        cached_rr->ttl = spfhook->rdns_ttl;

    }

  }

  signed long int return_value_time_4;
  return_value_time_4=time((signed long int *)(void *)0);
  cached_rr->utc_ttl = cached_rr->ttl + return_value_time_4;
  return (enum SPF_errcode_t)SPF_E_SUCCESS;
}

// SPF_dns_cache_set_ttl
// file spf_dns_cache.c line 555
void SPF_dns_cache_set_ttl(struct SPF_dns_server_struct *spf_dns_server, signed long int min_ttl, signed long int err_ttl, signed long int txt_ttl, signed long int rdns_ttl)
{
  struct anonymous_1 *spfhook;
  do
    if(spf_dns_server == ((struct SPF_dns_server_struct *)NULL))
      SPF_errorx("spf_dns_cache.c", 561, "%s", (const void *)"spf_dns_server is NULL");

  while((_Bool)0);
  spfhook=SPF_voidp2spfhook(spf_dns_server->hook);
  if(!(spfhook == ((struct anonymous_1 *)NULL)))
  {
    pthread_mutex_lock(&spfhook->cache_lock);
    spfhook->min_ttl = min_ttl;
    spfhook->err_ttl = err_ttl;
    spfhook->txt_ttl = txt_ttl;
    spfhook->rdns_ttl = rdns_ttl;
    pthread_mutex_unlock(&spfhook->cache_lock);
  }

}

// SPF_dns_debug_post
// file spf_dns.c line 59
static void SPF_dns_debug_post(struct SPF_dns_server_struct *spf_dns_server, struct SPF_dns_rr_struct *spfrr)
{
  const char *tmp_if_expr_2;
  const char *return_value_inet_ntop_4;
  const char *return_value_inet_ntop_5;
  if(!(spf_dns_server->debug == 0))
  {
    char ip4_buf[16l];
    char ip6_buf[46l];
    signed int i;
    SPF_debugx("spf_dns.c", 66, "DNS[%s] found record", spf_dns_server->name);
    const char *return_value_SPF_strrrtype_1;
    return_value_SPF_strrrtype_1=SPF_strrrtype(spfrr->rr_type);
    SPF_debugx("spf_dns.c", 69, "    DOMAIN: %s  TYPE: %s (%d)", spfrr->domain, return_value_SPF_strrrtype_1, spfrr->rr_type);
    const char *tmp_if_expr_3;
    if(!(spfrr->source == ((struct SPF_dns_server_struct *)NULL)))
    {
      if(!(spfrr->source->name == ((const char *)NULL)))
        tmp_if_expr_2 = spfrr->source->name;

      else
        tmp_if_expr_2 = "(unnamed source)";
      tmp_if_expr_3 = tmp_if_expr_2;
    }

    else
      tmp_if_expr_3 = "(null source)";
    SPF_debugx("spf_dns.c", 76, "    TTL: %ld  RR found: %d  herrno: %d  source: %s", (signed long int)spfrr->ttl, spfrr->num_rr, spfrr->herrno, tmp_if_expr_3);
    i = 0;
    for( ; !(i >= spfrr->num_rr); i = i + 1)
      switch((signed int)spfrr->rr_type)
      {
        case ns_t_a:
        {
          return_value_inet_ntop_4=inet_ntop(2, (const void *)&spfrr->rr[(signed long int)i]->a, ip4_buf, (unsigned int)sizeof(char [16l]) /*16ul*/ );
          SPF_debugx("spf_dns.c", 82, "    - A: %s", return_value_inet_ntop_4);
          break;
        }
        case ns_t_ptr:
        {
          SPF_debugx("spf_dns.c", 86, "    - PTR: %s", (const void *)spfrr->rr[(signed long int)i]->ptr);
          break;
        }
        case ns_t_mx:
        {
          SPF_debugx("spf_dns.c", 90, "    - MX: %s", (const void *)spfrr->rr[(signed long int)i]->mx);
          break;
        }
        case ns_t_txt:
        {
          SPF_debugx("spf_dns.c", 94, "    - TXT: %s", (const void *)spfrr->rr[(signed long int)i]->txt);
          break;
        }
        case 99:
        {
          SPF_debugx("spf_dns.c", 98, "    - SPF: %s", (const void *)spfrr->rr[(signed long int)i]->txt);
          break;
        }
        case ns_t_aaaa:
        {
          return_value_inet_ntop_5=inet_ntop(10, (const void *)&spfrr->rr[(signed long int)i]->aaaa, ip6_buf, (unsigned int)sizeof(char [46l]) /*46ul*/ );
          SPF_debugx("spf_dns.c", 104, "    - AAAA: %s", return_value_inet_ntop_5);
          break;
        }
        default:
          SPF_debugx("spf_dns.c", 108, "    - Unknown RR type");
      }
  }

}

// SPF_dns_debug_pre
// file spf_dns.c line 48
static void SPF_dns_debug_pre(struct SPF_dns_server_struct *spf_dns_server, const char *domain, enum __ns_type rr_type, signed int should_cache)
{
  if(!(spf_dns_server->debug == 0))
  {
    const char *return_value_SPF_strrrtype_1;
    return_value_SPF_strrrtype_1=SPF_strrrtype(rr_type);
    SPF_debugx("spf_dns.c", 54, "DNS[%s] lookup: %s %s (%d)", spf_dns_server->name, domain, return_value_SPF_strrrtype_1, rr_type);
  }

}

// SPF_dns_free
// file spf_dns.c line 116
void SPF_dns_free(struct SPF_dns_server_struct *spf_dns_server)
{
  struct SPF_dns_server_struct *layer_below;
  do
    if(spf_dns_server == ((struct SPF_dns_server_struct *)NULL))
      SPF_errorx("spf_dns.c", 120, "%s", (const void *)"spf_dns_server is NULL");

  while((_Bool)0);
  layer_below = spf_dns_server->layer_below;
  if(!(spf_dns_server->destroy == ((void (*)(struct SPF_dns_server_struct *))NULL)))
  {
    spf_dns_server->destroy(spf_dns_server);
    if(!(layer_below == ((struct SPF_dns_server_struct *)NULL)))
      SPF_dns_free(layer_below);

  }

}

// SPF_dns_get_client_dom
// file spf_dns.c line 206
char * SPF_dns_get_client_dom(struct SPF_dns_server_struct *spf_dns_server, struct SPF_request_struct *sr)
{
  char *client_dom;
  struct SPF_dns_rr_struct *rr_ptr;
  struct SPF_dns_rr_struct *rr_a;
  struct SPF_dns_rr_struct *rr_aaaa;
  signed int i;
  signed int j;
  signed int max_ptr;
  do
    if(spf_dns_server == ((struct SPF_dns_server_struct *)NULL))
      SPF_errorx("spf_dns.c", 218, "%s", (const void *)"spf_dns_server is NULL");

  while((_Bool)0);
  do
    if(sr == ((struct SPF_request_struct *)NULL))
      SPF_errorx("spf_dns.c", 219, "%s", (const void *)"sr is NULL");

  while((_Bool)0);
  if(sr->client_ver == 2)
  {
    rr_ptr=SPF_dns_rlookup(spf_dns_server, sr->ipv4, (enum __ns_type)ns_t_ptr, 0);
    max_ptr = rr_ptr->num_rr;
    if(max_ptr >= 11)
      max_ptr = 10;

    i = 0;
    for( ; !(i >= max_ptr); i = i + 1)
    {
      rr_a=SPF_dns_lookup(spf_dns_server, rr_ptr->rr[(signed long int)i]->ptr, (enum __ns_type)ns_t_a, 0);
      j = 0;
      for( ; !(j >= rr_a->num_rr); j = j + 1)
        if(rr_a->rr[(signed long int)j]->a.s_addr == sr->ipv4.s_addr)
        {
          client_dom=strdup(rr_ptr->rr[(signed long int)i]->ptr);
          SPF_dns_rr_free(rr_ptr);
          SPF_dns_rr_free(rr_a);
          return client_dom;
        }

      SPF_dns_rr_free(rr_a);
    }
    SPF_dns_rr_free(rr_ptr);
  }

  else
    if(sr->client_ver == 10)
    {
      rr_ptr=SPF_dns_rlookup6(spf_dns_server, sr->ipv6, (enum __ns_type)ns_t_ptr, 0);
      max_ptr = rr_ptr->num_rr;
      if(max_ptr >= 11)
        max_ptr = 10;

      i = 0;
      for( ; !(i >= max_ptr); i = i + 1)
      {
        rr_aaaa=SPF_dns_lookup(spf_dns_server, rr_ptr->rr[(signed long int)i]->ptr, (enum __ns_type)ns_t_aaaa, 0);
        j = 0;
        for( ; !(j >= rr_aaaa->num_rr); j = j + 1)
        {
          signed int return_value_memcmp_1;
          return_value_memcmp_1=memcmp((const void *)&rr_aaaa->rr[(signed long int)j]->aaaa, (const void *)&sr->ipv6, sizeof(struct in6_addr) /*16ul*/ );
          if(return_value_memcmp_1 == 0)
          {
            client_dom=strdup(rr_ptr->rr[(signed long int)i]->ptr);
            SPF_dns_rr_free(rr_ptr);
            SPF_dns_rr_free(rr_aaaa);
            return client_dom;
          }

        }
        SPF_dns_rr_free(rr_aaaa);
      }
      SPF_dns_rr_free(rr_ptr);
    }

  char *return_value_strdup_2;
  return_value_strdup_2=strdup("unknown");
  return return_value_strdup_2;
}

// SPF_dns_lookup
// file spf_dns.c line 133
struct SPF_dns_rr_struct * SPF_dns_lookup(struct SPF_dns_server_struct *spf_dns_server, const char *domain, enum __ns_type rr_type, signed int should_cache)
{
  struct SPF_dns_rr_struct *spfrr;
  do
    if(spf_dns_server == ((struct SPF_dns_server_struct *)NULL))
      SPF_errorx("spf_dns.c", 138, "%s", (const void *)"spf_dns_server is NULL");

  while((_Bool)0);
  SPF_dns_debug_pre(spf_dns_server, domain, rr_type, should_cache);
  do
    if(spf_dns_server->lookup == ((struct SPF_dns_rr_struct * (*)(struct SPF_dns_server_struct *, const char *, enum __ns_type, signed int))NULL))
      SPF_errorx("spf_dns.c", 140, "%s", (const void *)"spf_dns_server->lookup is NULL");

  while((_Bool)0);
  spfrr=spf_dns_server->lookup(spf_dns_server, domain, rr_type, should_cache);
  if(spfrr == ((struct SPF_dns_rr_struct *)NULL))
    SPF_errorx("spf_dns.c", 144, "%s", (const void *)"SPF DNS layer return NULL during a lookup.");

  SPF_dns_debug_post(spf_dns_server, spfrr);
  return spfrr;
}

// SPF_dns_null_free
// file spf_dns_null.c line 52
static void SPF_dns_null_free(struct SPF_dns_server_struct *spf_dns_server)
{
  do
    if(spf_dns_server == ((struct SPF_dns_server_struct *)NULL))
      SPF_errorx("spf_dns_null.c", 54, "%s", (const void *)"spf_dns_server is NULL");

  while((_Bool)0);
  free((void *)spf_dns_server);
}

// SPF_dns_null_lookup
// file spf_dns_null.c line 42
static struct SPF_dns_rr_struct * SPF_dns_null_lookup(struct SPF_dns_server_struct *spf_dns_server, const char *domain, enum __ns_type rr_type, signed int should_cache)
{
  struct SPF_dns_rr_struct *return_value_SPF_dns_lookup_1;
  if(!(spf_dns_server->layer_below == ((struct SPF_dns_server_struct *)NULL)))
  {
    return_value_SPF_dns_lookup_1=SPF_dns_lookup(spf_dns_server->layer_below, domain, rr_type, should_cache);
    return return_value_SPF_dns_lookup_1;
  }

  struct SPF_dns_rr_struct *return_value_SPF_dns_rr_new_nxdomain_2;
  return_value_SPF_dns_rr_new_nxdomain_2=SPF_dns_rr_new_nxdomain(spf_dns_server, domain);
  return return_value_SPF_dns_rr_new_nxdomain_2;
}

// SPF_dns_null_new
// file spf_dns_null.c line 59
struct SPF_dns_server_struct * SPF_dns_null_new(struct SPF_dns_server_struct *spf_dns_server_below, const char *name, signed int debug)
{
  struct SPF_dns_server_struct *spf_dns_server;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct SPF_dns_server_struct) /*72ul*/ );
  spf_dns_server = (struct SPF_dns_server_struct *)return_value_malloc_1;
  if(spf_dns_server == ((struct SPF_dns_server_struct *)NULL))
    return (struct SPF_dns_server_struct *)(void *)0;

  else
  {
    memset((void *)spf_dns_server, 0, sizeof(struct SPF_dns_server_struct) /*72ul*/ );
    if(name == ((const char *)NULL))
      name = "null";

    spf_dns_server->destroy = SPF_dns_null_free;
    spf_dns_server->lookup = SPF_dns_null_lookup;
    spf_dns_server->get_spf = (enum SPF_errcode_t (*)(struct SPF_server_struct *, struct SPF_request_struct *, struct SPF_response_struct *, struct SPF_record_struct **))(void *)0;
    spf_dns_server->get_exp = (enum SPF_errcode_t (*)(struct SPF_server_struct *, const char *, char **, unsigned long int *))(void *)0;
    spf_dns_server->add_cache = (signed int (*)(struct SPF_server_struct *, struct SPF_dns_rr_struct))(void *)0;
    spf_dns_server->layer_below = spf_dns_server_below;
    spf_dns_server->name = name;
    spf_dns_server->debug = debug;
    return spf_dns_server;
  }
}

// SPF_dns_resolv_debug
// file spf_dns_resolv.c line 112
static void SPF_dns_resolv_debug(struct SPF_dns_server_struct *spf_dns_server, struct __ns_rr rr, const unsigned char *responsebuf, unsigned long int responselen, const unsigned char *rdata, unsigned long int rdlen)
{
  char ip4_buf[16l];
  char ip6_buf[46l];
  char name_buf[1025l];
  signed int prio;
  signed int err;
  const char *return_value_inet_ntop_1;
  const char *return_value_inet_ntop_2;
  signed int *return_value___errno_location_3;
  char *return_value_strerror_4;
  signed int *return_value___errno_location_5;
  signed int *return_value___errno_location_6;
  char *return_value_strerror_7;
  signed int *return_value___errno_location_8;
  unsigned int return_value_ns_get16_9;
  signed int *return_value___errno_location_10;
  char *return_value_strerror_11;
  signed int *return_value___errno_location_12;
  signed int *return_value___errno_location_13;
  char *return_value_strerror_14;
  signed int *return_value___errno_location_15;
  switch((signed int)(enum __ns_type)((signed int)rr.type + 0))
  {
    case ns_t_a:
    {
      if(!(rdlen == 4ul))
        SPF_debugx("spf_dns_resolv.c", 125, "A: wrong rdlen %lu", (unsigned long int)rdlen);

      else
      {
        return_value_inet_ntop_1=inet_ntop(2, (const void *)rdata, ip4_buf, (unsigned int)sizeof(char [16l]) /*16ul*/ );
        SPF_debugx("spf_dns_resolv.c", 129, "A: %s", return_value_inet_ntop_1);
      }
      break;
    }
    case ns_t_aaaa:
    {
      if(!(rdlen == 16ul))
        SPF_debugx("spf_dns_resolv.c", 134, "AAAA: wrong rdlen %lu", (unsigned long int)rdlen);

      else
      {
        return_value_inet_ntop_2=inet_ntop(10, (const void *)rdata, ip6_buf, (unsigned int)sizeof(char [46l]) /*46ul*/ );
        SPF_debugx("spf_dns_resolv.c", 138, "AAAA: %s", return_value_inet_ntop_2);
      }
      break;
    }
    case ns_t_ns:
    {
      err=ns_name_uncompress(responsebuf, responsebuf + (signed long int)responselen, rdata, name_buf, sizeof(char [1025l]) /*1025ul*/ );
      if(!(err >= 0))
      {
        return_value___errno_location_3=__errno_location();
        return_value_strerror_4=strerror(*return_value___errno_location_3);
        return_value___errno_location_5=__errno_location();
        SPF_debugx("spf_dns_resolv.c", 148, "ns_name_uncompress failed: err = %d  %s (%d)", err, return_value_strerror_4, *return_value___errno_location_5);
      }

      else
        SPF_debugx("spf_dns_resolv.c", 150, "NS: %s", (const void *)name_buf);
      break;
    }
    case ns_t_cname:
    {
      err=ns_name_uncompress(responsebuf, responsebuf + (signed long int)responselen, rdata, name_buf, sizeof(char [1025l]) /*1025ul*/ );
      if(!(err >= 0))
      {
        return_value___errno_location_6=__errno_location();
        return_value_strerror_7=strerror(*return_value___errno_location_6);
        return_value___errno_location_8=__errno_location();
        SPF_debugx("spf_dns_resolv.c", 160, "ns_name_uncompress failed: err = %d  %s (%d)", err, return_value_strerror_7, *return_value___errno_location_8);
      }

      else
        SPF_debugx("spf_dns_resolv.c", 162, "CNAME: %s", (const void *)name_buf);
      break;
    }
    case ns_t_mx:
    {
      if(!(rdlen >= 2ul))
      {
        SPF_debugx("spf_dns_resolv.c", 167, "MX: rdlen too short: %lu", (unsigned long int)rdlen);
        break;
      }

      return_value_ns_get16_9=ns_get16(rdata);
      prio = (signed int)return_value_ns_get16_9;
      err=ns_name_uncompress(responsebuf, responsebuf + (signed long int)responselen, rdata + (signed long int)2, name_buf, sizeof(char [1025l]) /*1025ul*/ );
      if(!(err >= 0))
      {
        return_value___errno_location_10=__errno_location();
        return_value_strerror_11=strerror(*return_value___errno_location_10);
        return_value___errno_location_12=__errno_location();
        SPF_debugx("spf_dns_resolv.c", 177, "ns_name_uncompress failed: err = %d  %s (%d)", err, return_value_strerror_11, *return_value___errno_location_12);
      }

      else
        SPF_debugx("spf_dns_resolv.c", 179, "MX: %d %s", prio, (const void *)name_buf);
      break;
    }
    case ns_t_txt:
    {
      if(!(rdlen >= 1ul))
      {
        SPF_debugx("spf_dns_resolv.c", 184, "TXT: rdlen too short: %lu", (unsigned long int)rdlen);
        break;
      }

      SPF_debugx("spf_dns_resolv.c", 190, "TXT: (%lu) \"%.*s\"", (unsigned long int)rdlen, (signed int)rdlen - 1, rdata + (signed long int)1);
      break;
    }
    case ns_t_ptr:
    {
      err=ns_name_uncompress(responsebuf, responsebuf + (signed long int)responselen, rdata, name_buf, sizeof(char [1025l]) /*1025ul*/ );
      if(!(err >= 0))
      {
        return_value___errno_location_13=__errno_location();
        return_value_strerror_14=strerror(*return_value___errno_location_13);
        return_value___errno_location_15=__errno_location();
        SPF_debugx("spf_dns_resolv.c", 200, "ns_name_uncompress failed: err = %d  %s (%d)", err, return_value_strerror_14, *return_value___errno_location_15);
      }

      else
        SPF_debugx("spf_dns_resolv.c", 202, "PTR: %s", (const void *)name_buf);
      break;
    }
    default:
      SPF_debugx("spf_dns_resolv.c", 206, "not parsed:  type: %d", (enum __ns_type)((signed int)rr.type + 0));
  }
}

// SPF_dns_resolv_free
// file spf_dns_resolv.c line 605
static void SPF_dns_resolv_free(struct SPF_dns_server_struct *spf_dns_server)
{
  do
    if(spf_dns_server == ((struct SPF_dns_server_struct *)NULL))
      SPF_errorx("spf_dns_resolv.c", 607, "%s", (const void *)"spf_dns_server is NULL");

  while((_Bool)0);
  free((void *)spf_dns_server);
}

// SPF_dns_resolv_init_key
// file spf_dns_resolv.c line 104
static void SPF_dns_resolv_init_key(void)
{
  pthread_key_create(&res_state_key, SPF_dns_resolv_thread_term);
}

// SPF_dns_resolv_lookup
// file spf_dns_resolv.c line 218
static struct SPF_dns_rr_struct * SPF_dns_resolv_lookup(struct SPF_dns_server_struct *spf_dns_server, const char *domain, enum __ns_type rr_type, signed int should_cache)
{
  struct SPF_dns_rr_struct *spfrr;
  signed int err;
  signed int i;
  signed int nrec;
  signed int cnt;
  unsigned char *responsebuf;
  unsigned long int responselen;
  struct __ns_msg ns_handle;
  struct __ns_rr rr;
  signed int ns_sect;
  char name_buf[1025l];
  unsigned long int rdlen;
  const unsigned char *rdata;
  void *res_spec;
  struct __res_state *res_state;
  do
    if(spf_dns_server == ((struct SPF_dns_server_struct *)NULL))
      SPF_errorx("spf_dns_resolv.c", 247, "%s", (const void *)"spf_dns_server is NULL");

  while((_Bool)0);
  res_spec=pthread_getspecific(res_state_key);
  if(res_spec == NULL)
  {
    void *return_value_malloc_1;
    return_value_malloc_1=malloc(sizeof(struct __res_state) /*568ul*/ );
    res_state = (struct __res_state *)return_value_malloc_1;
    if(res_state == ((struct __res_state *)NULL))
      SPF_errorx("spf_dns_resolv.c", 259, "Failed to allocate %lu bytes for res_state", (unsigned long int)sizeof(struct __res_state) /*568ul*/ );

    memset((void *)res_state, 0, sizeof(struct __res_state) /*568ul*/ );
    signed int return_value___res_ninit_2;
    return_value___res_ninit_2=__res_ninit(res_state);
    if(!(return_value___res_ninit_2 == 0))
      SPF_errorx("spf_dns_resolv.c", 262, "%s", (const void *)"Failed to call res_ninit()");

    pthread_setspecific(res_state_key, (void *)res_state);
  }

  else
    res_state = (struct __res_state *)res_spec;
  responselen = (unsigned long int)2048;
  void *return_value_malloc_3;
  return_value_malloc_3=malloc(responselen);
  responsebuf = (unsigned char *)return_value_malloc_3;
  const char *return_value_hstrerror_4;
  signed int *return_value___errno_location_7;
  char *return_value_strerror_8;
  signed int *return_value___errno_location_9;
  signed int *return_value___errno_location_17;
  char *return_value_strerror_18;
  signed int *return_value___errno_location_19;
  enum SPF_errcode_t return_value_SPF_dns_rr_buf_realloc_21;
  enum SPF_errcode_t return_value_SPF_dns_rr_buf_realloc_22;
  signed int *return_value___errno_location_23;
  char *return_value_strerror_24;
  signed int *return_value___errno_location_25;
  unsigned long int return_value_strlen_26;
  enum SPF_errcode_t return_value_SPF_dns_rr_buf_realloc_27;
  signed int *return_value___errno_location_30;
  char *return_value_strerror_31;
  signed int *return_value___errno_location_32;
  unsigned long int return_value_strlen_33;
  enum SPF_errcode_t return_value_SPF_dns_rr_buf_realloc_34;
  if(responsebuf == ((unsigned char *)NULL))
    return (struct SPF_dns_rr_struct *)(void *)0;

  else
  {
    memset((void *)responsebuf, 0, responselen);
    do
    {
      signed int dns_len;
      dns_len=__res_nquery(res_state, domain, ns_c_in, (signed int)rr_type, responsebuf, (signed int)responselen);
      if(!(dns_len >= 0))
      {
        free((void *)responsebuf);
        if(!(spf_dns_server->debug == 0))
        {
          return_value_hstrerror_4=hstrerror(res_state->res_h_errno);
          SPF_debugx("spf_dns_resolv.c", 311, "query failed: err = %d  %s (%d): %s", dns_len, return_value_hstrerror_4, res_state->res_h_errno, domain);
        }

        if(res_state->res_h_errno == 1)
        {
          if(!(spf_dns_server->layer_below == ((struct SPF_dns_server_struct *)NULL)))
          {
            struct SPF_dns_rr_struct *return_value_SPF_dns_lookup_5;
            return_value_SPF_dns_lookup_5=SPF_dns_lookup(spf_dns_server->layer_below, domain, rr_type, should_cache);
            return return_value_SPF_dns_lookup_5;
          }

        }

        struct SPF_dns_rr_struct *return_value_SPF_dns_rr_new_init_6;
        return_value_SPF_dns_rr_new_init_6=SPF_dns_rr_new_init(spf_dns_server, domain, rr_type, 0, res_state->res_h_errno);
        return return_value_SPF_dns_rr_new_init_6;
      }

      else
        if(!(responselen >= (unsigned long int)dns_len))
        {
          void *tmp;
          responselen = (unsigned long int)(dns_len + (dns_len >> 1));
          tmp=realloc((void *)responsebuf, responselen);
          if(tmp == NULL)
          {
            free((void *)responsebuf);
            return (struct SPF_dns_rr_struct *)(void *)0;
          }

          responsebuf = (unsigned char *)tmp;
        }

        else
        {
          responselen = (unsigned long int)dns_len;
          break;
        }
    }
    while((_Bool)1);
    spfrr=SPF_dns_rr_new_init(spf_dns_server, domain, rr_type, 0, 0);
    if(spfrr == ((struct SPF_dns_rr_struct *)NULL))
    {
      free((void *)responsebuf);
      return (struct SPF_dns_rr_struct *)(void *)0;
    }

    else
    {
      err=ns_initparse(responsebuf, (signed int)responselen, &ns_handle);
      if(!(err >= 0))
      {
        if(!(spf_dns_server->debug == 0))
        {
          return_value___errno_location_7=__errno_location();
          return_value_strerror_8=strerror(*return_value___errno_location_7);
          return_value___errno_location_9=__errno_location();
          SPF_debugx("spf_dns_resolv.c", 363, "ns_initparse failed: err = %d  %s (%d)", err, return_value_strerror_8, *return_value___errno_location_9);
        }

        free((void *)responsebuf);
        spfrr->herrno = 3;
        return spfrr;
      }

      if(spf_dns_server->debug >= 2)
      {
        SPF_debugx("spf_dns_resolv.c", 373, "msg id:             %d", (signed int)ns_handle._id + 0);
        signed int return_value_ns_msg_getflag_10;
        return_value_ns_msg_getflag_10=ns_msg_getflag(ns_handle, 0);
        SPF_debugx("spf_dns_resolv.c", 374, "ns_f_qr quest/resp: %d", return_value_ns_msg_getflag_10);
        signed int return_value_ns_msg_getflag_11;
        return_value_ns_msg_getflag_11=ns_msg_getflag(ns_handle, 1);
        SPF_debugx("spf_dns_resolv.c", 375, "ns_f_opcode:        %d", return_value_ns_msg_getflag_11);
        signed int return_value_ns_msg_getflag_12;
        return_value_ns_msg_getflag_12=ns_msg_getflag(ns_handle, 2);
        SPF_debugx("spf_dns_resolv.c", 376, "ns_f_aa auth ans:   %d", return_value_ns_msg_getflag_12);
        signed int return_value_ns_msg_getflag_13;
        return_value_ns_msg_getflag_13=ns_msg_getflag(ns_handle, 3);
        SPF_debugx("spf_dns_resolv.c", 377, "ns_f_tc truncated:  %d", return_value_ns_msg_getflag_13);
        signed int return_value_ns_msg_getflag_14;
        return_value_ns_msg_getflag_14=ns_msg_getflag(ns_handle, 4);
        SPF_debugx("spf_dns_resolv.c", 378, "ns_f_rd rec desire: %d", return_value_ns_msg_getflag_14);
        signed int return_value_ns_msg_getflag_15;
        return_value_ns_msg_getflag_15=ns_msg_getflag(ns_handle, 5);
        SPF_debugx("spf_dns_resolv.c", 379, "ns_f_ra rec avail:  %d", return_value_ns_msg_getflag_15);
        signed int return_value_ns_msg_getflag_16;
        return_value_ns_msg_getflag_16=ns_msg_getflag(ns_handle, 9);
        SPF_debugx("spf_dns_resolv.c", 380, "ns_f_rcode:         %d", return_value_ns_msg_getflag_16);
      }

      ns_sect = 0;
      for( ; !(ns_sect >= num_ns_sect); ns_sect = ns_sect + 1)
      {
        if(!(ns_sects[(signed long int)ns_sect].number == ns_s_an))
        {
          if(!(spf_dns_server->debug >= 2))
            goto __CPROVER_DUMP_L59;

        }

        nrec = (signed int)ns_handle._counts[(signed long int)ns_sects[(signed long int)ns_sect].number] + 0;
        if(spf_dns_server->debug >= 2)
          SPF_debugx("spf_dns_resolv.c", 397, "%s:  %d", ns_sects[(signed long int)ns_sect].name, nrec);

        spfrr->num_rr = 0;
        cnt = 0;
        i = 0;
        for( ; !(i >= nrec); i = i + 1)
        {
          err=ns_parserr(&ns_handle, (enum __ns_sect)ns_sects[(signed long int)ns_sect].number, i, &rr);
          if(!(err >= 0))
          {
            if(spf_dns_server->debug >= 2)
            {
              return_value___errno_location_17=__errno_location();
              return_value_strerror_18=strerror(*return_value___errno_location_17);
              return_value___errno_location_19=__errno_location();
              SPF_debugx("spf_dns_resolv.c", 406, "ns_parserr failed: err = %d  %s (%d)", err, return_value_strerror_18, *return_value___errno_location_19);
            }

            free((void *)responsebuf);
            spfrr->herrno = 3;
            return spfrr;
          }

          rdlen = (unsigned long int)((signed int)rr.rdlength + 0);
          if(spf_dns_server->debug >= 2)
          {
            char *tmp_if_expr_20;
            if(!((signed int)rr.name[0l] == 0))
              tmp_if_expr_20 = rr.name;

            else
              tmp_if_expr_20 = ".";
            SPF_debugx("spf_dns_resolv.c", 418, "name: %s  type: %d  class: %d  ttl: %d  rdlen: %lu", tmp_if_expr_20, (enum __ns_type)((signed int)rr.type + 0), (enum __ns_class)((signed int)rr.rr_class + 0), rr.ttl + (unsigned int)0, (unsigned long int)rdlen);
          }

          if(rdlen >= 1ul)
          {
            rdata = rr.rdata + (signed long int)0;
            if(spf_dns_server->debug >= 2)
              SPF_dns_resolv_debug(spf_dns_server, rr, responsebuf, responselen, rdata, rdlen);

            if(ns_sects[(signed long int)ns_sect].number == ns_s_an)
            {
              if(!((enum __ns_type)(signed int)rr.type == spfrr->rr_type))
              {
                if((signed int)(enum __ns_type)(signed int)rr.type == ns_t_cname)
                  goto __CPROVER_DUMP_L30;

                SPF_debugx("spf_dns_resolv.c", 436, "unexpected rr type: %d   expected: %d", (enum __ns_type)((signed int)rr.type + 0), rr_type);
              }

              else
              {

              __CPROVER_DUMP_L30:
                ;
                switch((signed int)(enum __ns_type)((signed int)rr.type + 0))
                {
                  case ns_t_a:
                  {
                    if(!(rdlen == 4ul))
                    {
                      free((void *)responsebuf);
                      return spfrr;
                    }

                    return_value_SPF_dns_rr_buf_realloc_21=SPF_dns_rr_buf_realloc(spfrr, cnt, sizeof(struct in_addr) /*4ul*/ );
                    if(!((signed int)return_value_SPF_dns_rr_buf_realloc_21 == SPF_E_SUCCESS))
                    {
                      free((void *)responsebuf);
                      return spfrr;
                    }

                    memcpy((void *)&spfrr->rr[(signed long int)cnt]->a, (const void *)rdata, sizeof(struct in_addr) /*4ul*/ );
                    cnt = cnt + 1;
                    break;
                  }
                  case ns_t_aaaa:
                  {
                    if(!(rdlen == 16ul))
                    {
                      free((void *)responsebuf);
                      return spfrr;
                    }

                    return_value_SPF_dns_rr_buf_realloc_22=SPF_dns_rr_buf_realloc(spfrr, cnt, sizeof(struct in6_addr) /*16ul*/ );
                    if(!((signed int)return_value_SPF_dns_rr_buf_realloc_22 == SPF_E_SUCCESS))
                    {
                      free((void *)responsebuf);
                      return spfrr;
                    }

                    memcpy((void *)&spfrr->rr[(signed long int)cnt]->aaaa, (const void *)rdata, sizeof(struct in6_addr) /*16ul*/ );
                    cnt = cnt + 1;
                    break;
                  }
                  case ns_t_ns:
                    break;
                  case ns_t_cname:
                    break;
                  case ns_t_mx:
                  {
                    if(!(rdlen >= 2ul))
                    {
                      free((void *)responsebuf);
                      return spfrr;
                    }

                    err=ns_name_uncompress(responsebuf, responsebuf + (signed long int)responselen, rdata + (signed long int)2, name_buf, sizeof(char [1025l]) /*1025ul*/ );
                    if(!(err >= 0))
                    {
                      if(spf_dns_server->debug >= 2)
                      {
                        return_value___errno_location_23=__errno_location();
                        return_value_strerror_24=strerror(*return_value___errno_location_23);
                        return_value___errno_location_25=__errno_location();
                        SPF_debugx("spf_dns_resolv.c", 495, "ns_name_uncompress failed: err = %d  %s (%d)", err, return_value_strerror_24, *return_value___errno_location_25);
                      }

                      free((void *)responsebuf);
                      return spfrr;
                    }

                    return_value_strlen_26=strlen(name_buf);
                    return_value_SPF_dns_rr_buf_realloc_27=SPF_dns_rr_buf_realloc(spfrr, cnt, return_value_strlen_26 + (unsigned long int)1);
                    if(!((signed int)return_value_SPF_dns_rr_buf_realloc_27 == SPF_E_SUCCESS))
                    {
                      free((void *)responsebuf);
                      return spfrr;
                    }

                    strcpy(spfrr->rr[(signed long int)cnt]->mx, name_buf);
                    cnt = cnt + 1;
                    break;
                  }
                  case ns_t_txt:
                  {
                    if(rdlen >= 2ul)
                    {
                      unsigned char *src;
                      unsigned char *dst;
                      unsigned long int len;
                      enum SPF_errcode_t return_value_SPF_dns_rr_buf_realloc_28;
                      return_value_SPF_dns_rr_buf_realloc_28=SPF_dns_rr_buf_realloc(spfrr, cnt, rdlen);
                      if(!((signed int)return_value_SPF_dns_rr_buf_realloc_28 == SPF_E_SUCCESS))
                      {
                        free((void *)responsebuf);
                        return spfrr;
                      }

                      dst = (unsigned char *)spfrr->rr[(signed long int)cnt]->txt;
                      src = (unsigned char *)rdata;
                      len = (unsigned long int)0;
                      for( ; rdlen >= 1ul; rdlen = rdlen - len)
                      {
                        len = (unsigned long int)*src;
                        src = src + 1l;
                        rdlen = rdlen - 1ul;
                        if(!(rdlen >= len))
                          len = rdlen;

                        memcpy((void *)dst, (const void *)src, len);
                        src = src + (signed long int)len;
                        dst = dst + (signed long int)len;
                      }
                      *dst = (unsigned char)0;
                    }

                    else
                    {
                      enum SPF_errcode_t return_value_SPF_dns_rr_buf_realloc_29;
                      return_value_SPF_dns_rr_buf_realloc_29=SPF_dns_rr_buf_realloc(spfrr, cnt, (unsigned long int)1);
                      if(!((signed int)return_value_SPF_dns_rr_buf_realloc_29 == SPF_E_SUCCESS))
                      {
                        free((void *)responsebuf);
                        return spfrr;
                      }

                      spfrr->rr[(signed long int)cnt]->txt[(signed long int)0] = (char)0;
                    }
                    cnt = cnt + 1;
                    break;
                  }
                  case ns_t_ptr:
                  {
                    err=ns_name_uncompress(responsebuf, responsebuf + (signed long int)responselen, rdata, name_buf, sizeof(char [1025l]) /*1025ul*/ );
                    if(!(err >= 0))
                    {
                      if(spf_dns_server->debug >= 2)
                      {
                        return_value___errno_location_30=__errno_location();
                        return_value_strerror_31=strerror(*return_value___errno_location_30);
                        return_value___errno_location_32=__errno_location();
                        SPF_debugx("spf_dns_resolv.c", 570, "ns_name_uncompress failed: err = %d  %s (%d)", err, return_value_strerror_31, *return_value___errno_location_32);
                      }

                      free((void *)responsebuf);
                      return spfrr;
                    }

                    return_value_strlen_33=strlen(name_buf);
                    return_value_SPF_dns_rr_buf_realloc_34=SPF_dns_rr_buf_realloc(spfrr, cnt, return_value_strlen_33 + (unsigned long int)1);
                    if(!((signed int)return_value_SPF_dns_rr_buf_realloc_34 == SPF_E_SUCCESS))
                    {
                      free((void *)responsebuf);
                      return spfrr;
                    }

                    strcpy(spfrr->rr[(signed long int)cnt]->ptr, name_buf);
                    cnt = cnt + 1;
                    break;
                  }
                  default:
                    ;
                }
              }
            }

          }

        }
        spfrr->num_rr = cnt;

      __CPROVER_DUMP_L59:
        ;
      }
      if(spfrr->num_rr == 0)
        spfrr->herrno = 4;

      free((void *)responsebuf);
      return spfrr;
    }
  }
}

// SPF_dns_resolv_new
// file spf_dns_resolv.c line 617
struct SPF_dns_server_struct * SPF_dns_resolv_new(struct SPF_dns_server_struct *layer_below, const char *name, signed int debug)
{
  struct SPF_dns_server_struct *spf_dns_server;
  pthread_once(&res_state_control, SPF_dns_resolv_init_key);
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct SPF_dns_server_struct) /*72ul*/ );
  spf_dns_server = (struct SPF_dns_server_struct *)return_value_malloc_1;
  if(spf_dns_server == ((struct SPF_dns_server_struct *)NULL))
    return (struct SPF_dns_server_struct *)(void *)0;

  else
  {
    memset((void *)spf_dns_server, 0, sizeof(struct SPF_dns_server_struct) /*72ul*/ );
    if(name == ((const char *)NULL))
      name = "resolv";

    spf_dns_server->destroy = SPF_dns_resolv_free;
    spf_dns_server->lookup = SPF_dns_resolv_lookup;
    spf_dns_server->get_spf = (enum SPF_errcode_t (*)(struct SPF_server_struct *, struct SPF_request_struct *, struct SPF_response_struct *, struct SPF_record_struct **))(void *)0;
    spf_dns_server->get_exp = (enum SPF_errcode_t (*)(struct SPF_server_struct *, const char *, char **, unsigned long int *))(void *)0;
    spf_dns_server->add_cache = (signed int (*)(struct SPF_server_struct *, struct SPF_dns_rr_struct))(void *)0;
    spf_dns_server->layer_below = layer_below;
    spf_dns_server->name = name;
    spf_dns_server->debug = debug;
    return spf_dns_server;
  }
}

// SPF_dns_resolv_thread_term
// file spf_dns_resolv.c line 93
static void SPF_dns_resolv_thread_term(void *arg)
{
  __res_nclose((struct __res_state *)arg);
  free(arg);
}

// SPF_dns_rlookup
// file spf_dns.c line 150
struct SPF_dns_rr_struct * SPF_dns_rlookup(struct SPF_dns_server_struct *spf_dns_server, struct in_addr ipv4, enum __ns_type rr_type, signed int should_cache)
{
  char domain[(signed long int)sizeof(char [29l]) /*29l*/ ];
  /* tag-#anon#lUN[lSYM#tag-in_addr#'ipv4'|lARR4{U8}_U8_'x'] */
union anonymous_16
{
  // ipv4
  struct in_addr ipv4;
  // x
  unsigned char x[4l];
};

/* */
  ;
  union anonymous_16 tmp;
  tmp.ipv4 = ipv4;
  snprintf(domain, sizeof(char [29l]) /*29ul*/ , "%d.%d.%d.%d.in-addr.arpa", tmp.x[(signed long int)3], tmp.x[(signed long int)2], tmp.x[(signed long int)1], tmp.x[(signed long int)0]);
  struct SPF_dns_rr_struct *return_value_SPF_dns_lookup_1;
  return_value_SPF_dns_lookup_1=SPF_dns_lookup(spf_dns_server, domain, rr_type, should_cache);
  return return_value_SPF_dns_lookup_1;
}

// SPF_dns_rlookup6
// file spf_dns.c line 171
struct SPF_dns_rr_struct * SPF_dns_rlookup6(struct SPF_dns_server_struct *spf_dns_server, struct in6_addr ipv6, enum __ns_type rr_type, signed int should_cache)
{
  char domain[75l];
  char *p;
  char *p_end;
  signed int i;
  p = domain;
  p_end = p + (signed long int)sizeof(char [75l]) /*75ul*/ ;
  i = (signed int)(sizeof(struct in6_addr) /*16ul*/  - (unsigned long int)1);
  for( ; i >= 0; i = i - 1)
  {
    signed int return_value_snprintf_1;
    return_value_snprintf_1=snprintf(p, (unsigned long int)(p_end - p), "%.1x.%.1x.", (signed int)ipv6.__in6_u.__u6_addr8[(signed long int)i] & 0xf, (signed int)ipv6.__in6_u.__u6_addr8[(signed long int)i] >> 4);
    p = p + (signed long int)return_value_snprintf_1;
  }
  signed int return_value_snprintf_2;
  return_value_snprintf_2=snprintf(p, (unsigned long int)(p_end - p), "ip6.arpa");
  p = p + (signed long int)return_value_snprintf_2;
  struct SPF_dns_rr_struct *return_value_SPF_dns_lookup_3;
  return_value_SPF_dns_lookup_3=SPF_dns_lookup(spf_dns_server, domain, rr_type, should_cache);
  return return_value_SPF_dns_lookup_3;
}

// SPF_dns_rr_buf_realloc
// file ../../src/include/spf_dns_rr.h line 82
enum SPF_errcode_t SPF_dns_rr_buf_realloc(struct SPF_dns_rr_struct *spfrr, signed int idx, unsigned long int len)
{
  union anonymous_13 **new_data;
  unsigned long int *new_buf_len;
  signed int new_num;
  void *new_rr;
  signed int j;
  if(idx >= spfrr->rr_buf_num)
  {
    new_num = spfrr->rr_buf_num + idx + (idx >> 2) + 4;
    void *return_value_realloc_1;
    return_value_realloc_1=realloc((void *)spfrr->rr, (unsigned long int)new_num * sizeof(union anonymous_13 *) /*8ul*/ );
    new_data = (union anonymous_13 **)return_value_realloc_1;
    if(new_data == ((union anonymous_13 **)NULL))
      return (enum SPF_errcode_t)SPF_E_NO_MEMORY;

    spfrr->rr = new_data;
    void *return_value_realloc_2;
    return_value_realloc_2=realloc((void *)spfrr->rr_buf_len, (unsigned long int)new_num * sizeof(unsigned long int) /*8ul*/ );
    new_buf_len = (unsigned long int *)return_value_realloc_2;
    if(new_buf_len == ((unsigned long int *)NULL))
      return (enum SPF_errcode_t)SPF_E_NO_MEMORY;

    spfrr->rr_buf_len = new_buf_len;
    j = spfrr->rr_buf_num;
    for( ; !(j >= new_num); j = j + 1)
    {
      spfrr->rr[(signed long int)j] = (union anonymous_13 *)(void *)0;
      spfrr->rr_buf_len[(signed long int)j] = (unsigned long int)0;
    }
    spfrr->rr_buf_num = new_num;
  }

  if(!(len >= sizeof(union anonymous_13) /*16ul*/ ))
    len = sizeof(union anonymous_13) /*16ul*/ ;

  if(spfrr->rr_buf_len[(signed long int)idx] >= len)
    return (enum SPF_errcode_t)SPF_E_SUCCESS;

  else
  {
    new_rr=realloc((void *)spfrr->rr[(signed long int)idx], len);
    if(new_rr == NULL)
      return (enum SPF_errcode_t)SPF_E_NO_MEMORY;

    else
    {
      spfrr->rr[(signed long int)idx] = (union anonymous_13 *)new_rr;
      spfrr->rr_buf_len[(signed long int)idx] = len;
      return (enum SPF_errcode_t)SPF_E_SUCCESS;
    }
  }
}

// SPF_dns_rr_dup
// file ../../src/include/spf_dns_rr.h line 84
enum SPF_errcode_t SPF_dns_rr_dup(struct SPF_dns_rr_struct **dstp, struct SPF_dns_rr_struct *src)
{
  struct SPF_dns_rr_struct *dst;
  enum SPF_errcode_t err;
  signed int i;
  do
    if(src == ((struct SPF_dns_rr_struct *)NULL))
      SPF_errorx("spf_dns_rr.c", 195, "%s", (const void *)"src is NULL");

  while((_Bool)0);
  do
    if(dstp == ((struct SPF_dns_rr_struct **)NULL))
      SPF_errorx("spf_dns_rr.c", 196, "%s", (const void *)"dstp is NULL");

  while((_Bool)0);
  dst=SPF_dns_rr_new_init(src->source, src->domain, src->rr_type, (signed int)src->ttl, src->herrno);
  if(dst == ((struct SPF_dns_rr_struct *)NULL))
  {
    *dstp = (struct SPF_dns_rr_struct *)(void *)0;
    return (enum SPF_errcode_t)SPF_E_NO_MEMORY;
  }

  else
  {
    *dstp = dst;
    dst->utc_ttl = src->utc_ttl;
    dst->num_rr = src->num_rr;
    i = dst->num_rr - 1;
    for( ; i >= 0; i = i - 1)
      switch((signed int)dst->rr_type)
      {
        case ns_t_a:
        {
          do
          {
            err=SPF_dns_rr_buf_realloc(dst, i, sizeof(union anonymous_13) /*16ul*/ );
            if(!(err == /*enum*/SPF_E_SUCCESS))
              return err;

          }
          while((_Bool)0);
          dst->rr[(signed long int)i]->a = src->rr[(signed long int)i]->a;
          break;
        }
        case ns_t_ptr:
        {
          do
          {
            unsigned long int return_value_strlen_1;
            return_value_strlen_1=strlen(src->rr[(signed long int)i]->ptr);
            err=SPF_dns_rr_buf_realloc(dst, i, return_value_strlen_1 + (unsigned long int)1);
            if(!(err == /*enum*/SPF_E_SUCCESS))
              return err;

          }
          while((_Bool)0);
          strcpy(dst->rr[(signed long int)i]->ptr, src->rr[(signed long int)i]->ptr);
          break;
        }
        case ns_t_mx:
        {
          do
          {
            unsigned long int return_value_strlen_2;
            return_value_strlen_2=strlen(src->rr[(signed long int)i]->mx);
            err=SPF_dns_rr_buf_realloc(dst, i, return_value_strlen_2 + (unsigned long int)1);
            if(!(err == /*enum*/SPF_E_SUCCESS))
              return err;

          }
          while((_Bool)0);
          strcpy(dst->rr[(signed long int)i]->mx, src->rr[(signed long int)i]->mx);
          break;
        }
        case ns_t_txt:

        case 99:
        {
          do
          {
            unsigned long int return_value_strlen_3;
            return_value_strlen_3=strlen(src->rr[(signed long int)i]->txt);
            err=SPF_dns_rr_buf_realloc(dst, i, return_value_strlen_3 + (unsigned long int)1);
            if(!(err == /*enum*/SPF_E_SUCCESS))
              return err;

          }
          while((_Bool)0);
          strcpy(dst->rr[(signed long int)i]->txt, src->rr[(signed long int)i]->txt);
          break;
        }
        case ns_t_aaaa:
        {
          do
          {
            err=SPF_dns_rr_buf_realloc(dst, i, sizeof(union anonymous_13) /*16ul*/ );
            if(!(err == /*enum*/SPF_E_SUCCESS))
              return err;

          }
          while((_Bool)0);
          dst->rr[(signed long int)i]->aaaa = src->rr[(signed long int)i]->aaaa;
          break;
        }
        default:
          SPF_warningx("spf_dns_rr.c", 243, "Attempt to dup unknown rr type %d", dst->rr_type);
      }
    return (enum SPF_errcode_t)SPF_E_SUCCESS;
  }
}

// SPF_dns_rr_free
// file ../../src/include/spf_dns_rr.h line 74
void SPF_dns_rr_free(struct SPF_dns_rr_struct *spfrr)
{
  signed int i;
  if(!(spfrr->domain == ((char *)NULL)))
    free((void *)spfrr->domain);

  if(!(spfrr->rr == ((union anonymous_13 **)NULL)))
  {
    i = 0;
    for( ; !(i >= spfrr->rr_buf_num); i = i + 1)
      if(!(spfrr->rr[(signed long int)i] == ((union anonymous_13 *)NULL)))
        free((void *)spfrr->rr[(signed long int)i]);

    free((void *)spfrr->rr);
  }

  if(!(spfrr->rr_buf_len == ((unsigned long int *)NULL)))
    free((void *)spfrr->rr_buf_len);

  if(!(spfrr->hook == NULL))
    free(spfrr->hook);

  free((void *)spfrr);
}

// SPF_dns_rr_new
// file spf_dns_rr.c line 93
struct SPF_dns_rr_struct * SPF_dns_rr_new(void)
{
  struct SPF_dns_rr_struct *spfrr;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct SPF_dns_rr_struct) /*88ul*/ );
  spfrr = (struct SPF_dns_rr_struct *)return_value_malloc_1;
  if(spfrr == ((struct SPF_dns_rr_struct *)NULL))
    return spfrr;

  else
  {
    memset((void *)spfrr, 0, sizeof(struct SPF_dns_rr_struct) /*88ul*/ );
    spfrr->domain = (char *)(void *)0;
    spfrr->domain_buf_len = (unsigned long int)0;
    spfrr->rr_type = (enum __ns_type)ns_t_invalid;
    spfrr->num_rr = 0;
    spfrr->ttl = (signed long int)0;
    spfrr->utc_ttl = (signed long int)0;
    spfrr->herrno = 1;
    return spfrr;
  }
}

// SPF_dns_rr_new_init
// file ../../src/include/spf_dns_rr.h line 75
struct SPF_dns_rr_struct * SPF_dns_rr_new_init(struct SPF_dns_server_struct *spf_dns_server, const char *domain, enum __ns_type rr_type, signed int ttl, signed int herrno)
{
  struct SPF_dns_rr_struct *spfrr;
  spfrr=SPF_dns_rr_new();
  if(spfrr == ((struct SPF_dns_rr_struct *)NULL))
    return spfrr;

  else
  {
    spfrr->source = spf_dns_server;
    _Bool tmp_if_expr_2;
    if(!(domain == ((const char *)NULL)))
      tmp_if_expr_2 = (signed int)domain[(signed long int)0] != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_2 = (_Bool)0;
    if(tmp_if_expr_2)
    {
      spfrr->domain=strdup(domain);
      if(spfrr->domain == ((char *)NULL))
      {
        SPF_dns_rr_free(spfrr);
        return (struct SPF_dns_rr_struct *)(void *)0;
      }

      unsigned long int return_value_strlen_1;
      return_value_strlen_1=strlen(domain);
      spfrr->domain_buf_len = return_value_strlen_1 + (unsigned long int)1;
    }

    else
    {
      spfrr->domain = (char *)(void *)0;
      spfrr->domain_buf_len = (unsigned long int)0;
    }
    spfrr->rr_type = rr_type;
    spfrr->ttl = (signed long int)ttl;
    spfrr->herrno = herrno;
    return spfrr;
  }
}

// SPF_dns_rr_new_nxdomain
// file ../../src/include/spf_dns_rr.h line 79
struct SPF_dns_rr_struct * SPF_dns_rr_new_nxdomain(struct SPF_dns_server_struct *spf_dns_server, const char *domain)
{
  struct SPF_dns_rr_struct *return_value_SPF_dns_rr_new_init_1;
  return_value_SPF_dns_rr_new_init_1=SPF_dns_rr_new_init(spf_dns_server, domain, (enum __ns_type)ns_t_any, 0, 1);
  return return_value_SPF_dns_rr_new_init_1;
}

// SPF_dns_set_conserve_cache
// file spf_dns_cache.c line 577
void SPF_dns_set_conserve_cache(struct SPF_dns_server_struct *spf_dns_server, signed int conserve_cache)
{
  struct anonymous_1 *spfhook;
  do
    if(spf_dns_server == ((struct SPF_dns_server_struct *)NULL))
      SPF_errorx("spf_dns_cache.c", 582, "%s", (const void *)"spf_dns_server is NULL");

  while((_Bool)0);
  spfhook=SPF_voidp2spfhook(spf_dns_server->hook);
  if(!(spfhook == ((struct anonymous_1 *)NULL)))
    spfhook->conserve_cache = conserve_cache;

}

// SPF_dns_test_new
// file spf_dns_test.c line 437
struct SPF_dns_server_struct * SPF_dns_test_new(struct SPF_dns_server_struct *layer_below, const char *name, signed int debug)
{
  struct SPF_dns_server_struct *spf_dns_server;
  signed int i;
  if(name == ((const char *)NULL))
    name = "test";

  spf_dns_server=SPF_dns_zone_new(layer_below, name, debug);
  if(spf_dns_server == ((struct SPF_dns_server_struct *)NULL))
    return (struct SPF_dns_server_struct *)(void *)0;

  else
  {
    i = 0;
    for( ; !((signed long int)i >= 175l); i = i + 1)
    {
      enum SPF_errcode_t return_value_SPF_dns_zone_add_str_1;
      return_value_SPF_dns_zone_add_str_1=SPF_dns_zone_add_str(spf_dns_server, SPF_dns_db[(signed long int)i].domain, (enum __ns_type)SPF_dns_db[(signed long int)i].rr_type, SPF_dns_db[(signed long int)i].herrno, SPF_dns_db[(signed long int)i].data);
      if(!((signed int)return_value_SPF_dns_zone_add_str_1 == SPF_E_SUCCESS))
        SPF_errorx("spf_dns_test.c", 455, "%s", (const void *)"Could not create test zone");

    }
    return spf_dns_server;
  }
}

// SPF_dns_zone_add_str
// file ../../src/include/spf_dns_zone.h line 79
enum SPF_errcode_t SPF_dns_zone_add_str(struct SPF_dns_server_struct *spf_dns_server, const char *domain, enum __ns_type rr_type, signed int herrno, const char *data)
{
  struct anonymous_9 *spfhook;
  struct SPF_dns_rr_struct *spfrr;
  signed int err;
  signed int cnt;
  if((signed int)rr_type == ns_t_any)
  {
    if(!(data == ((const char *)NULL)))
      SPF_errorx("spf_dns_zone.c", 201, "%s", (const void *)"RR type ANY can not have data.");

    if(herrno == 0)
      SPF_errorx("spf_dns_zone.c", 203, "%s", (const void *)"RR type ANY must return a DNS error code.");

  }

  spfhook=SPF_voidp2spfhook_link1(spf_dns_server->hook);
  spfrr=SPF_dns_zone_find(spf_dns_server, domain, rr_type, 1);
  const unsigned short int **return_value___ctype_b_loc_2;
  const unsigned short int **return_value___ctype_b_loc_3;
  if(spfrr == ((struct SPF_dns_rr_struct *)NULL))
  {
    if(spfhook->num_zone == spfhook->zone_buf_len)
    {
      signed int new_len;
      struct SPF_dns_rr_struct **new_zone;
      signed int i;
      new_len = spfhook->zone_buf_len + (spfhook->zone_buf_len >> 2) + 4;
      void *return_value_realloc_1;
      return_value_realloc_1=realloc((void *)spfhook->zone, (unsigned long int)new_len * sizeof(struct SPF_dns_rr_struct *) /*8ul*/ );
      new_zone = (struct SPF_dns_rr_struct **)return_value_realloc_1;
      if(new_zone == ((struct SPF_dns_rr_struct **)NULL))
        return (enum SPF_errcode_t)SPF_E_NO_MEMORY;

      i = spfhook->zone_buf_len;
      for( ; !(i >= new_len); i = i + 1)
        new_zone[(signed long int)i] = (struct SPF_dns_rr_struct *)(void *)0;
      spfhook->zone_buf_len = new_len;
      spfhook->zone = new_zone;
    }

    spfrr=SPF_dns_rr_new_init(spf_dns_server, domain, rr_type, 24 * 60 * 60, herrno);
    if(spfrr == ((struct SPF_dns_rr_struct *)NULL))
      return (enum SPF_errcode_t)SPF_E_NO_MEMORY;

    spfhook->zone[(signed long int)spfhook->num_zone] = spfrr;
    spfhook->num_zone = spfhook->num_zone + 1;
    if(herrno == 0)
      goto __CPROVER_DUMP_L8;

    return (enum SPF_errcode_t)SPF_E_SUCCESS;
  }

  else
  {

  __CPROVER_DUMP_L8:
    ;
    cnt = spfrr->num_rr;
    switch((signed int)rr_type)
    {
      case ns_t_a:
      {
        do
        {
          enum SPF_errcode_t SPF_dns_zone_add_str__1__3__1____err;
          SPF_dns_zone_add_str__1__3__1____err=SPF_dns_rr_buf_realloc(spfrr, cnt, sizeof(struct in_addr) /*4ul*/ );
          if(!((signed int)SPF_dns_zone_add_str__1__3__1____err == SPF_E_SUCCESS))
            return SPF_dns_zone_add_str__1__3__1____err;

        }
        while((_Bool)0);
        err=inet_pton(2, data, (void *)&spfrr->rr[(signed long int)cnt]->a);
        if(!(err >= 1))
          return (enum SPF_errcode_t)SPF_E_INVALID_IP4;

        break;
      }
      case ns_t_aaaa:
      {
        do
        {
          enum SPF_errcode_t SPF_dns_zone_add_str__1__3__2____err;
          SPF_dns_zone_add_str__1__3__2____err=SPF_dns_rr_buf_realloc(spfrr, cnt, sizeof(struct in6_addr) /*16ul*/ );
          if(!((signed int)SPF_dns_zone_add_str__1__3__2____err == SPF_E_SUCCESS))
            return SPF_dns_zone_add_str__1__3__2____err;

        }
        while((_Bool)0);
        err=inet_pton(10, data, (void *)&spfrr->rr[(signed long int)cnt]->aaaa);
        if(!(err >= 1))
          return (enum SPF_errcode_t)SPF_E_INVALID_IP6;

        break;
      }
      case ns_t_mx:
      {
        do
        {
          return_value___ctype_b_loc_2=__ctype_b_loc();
          if((2048 & (signed int)(*return_value___ctype_b_loc_2)[(signed long int)(signed int)*data]) == 0)
            break;

          data = data + 1l;
        }
        while((_Bool)1);
        do
        {
          return_value___ctype_b_loc_3=__ctype_b_loc();
          if((8192 & (signed int)(*return_value___ctype_b_loc_3)[(signed long int)(signed int)*data]) == 0)
            break;

          data = data + 1l;
        }
        while((_Bool)1);
        do
        {
          enum SPF_errcode_t SPF_dns_zone_add_str__1__3__3____err;
          unsigned long int return_value_strlen_4;
          return_value_strlen_4=strlen(data);
          SPF_dns_zone_add_str__1__3__3____err=SPF_dns_rr_buf_realloc(spfrr, cnt, return_value_strlen_4 + (unsigned long int)1);
          if(!((signed int)SPF_dns_zone_add_str__1__3__3____err == SPF_E_SUCCESS))
            return SPF_dns_zone_add_str__1__3__3____err;

        }
        while((_Bool)0);
        strcpy(spfrr->rr[(signed long int)cnt]->mx, data);
        break;
      }
      case ns_t_txt:

      case 99:
      {
        do
        {
          enum SPF_errcode_t __err;
          unsigned long int return_value_strlen_5;
          return_value_strlen_5=strlen(data);
          __err=SPF_dns_rr_buf_realloc(spfrr, cnt, return_value_strlen_5 + (unsigned long int)1);
          if(!((signed int)__err == SPF_E_SUCCESS))
            return __err;

        }
        while((_Bool)0);
        strcpy(spfrr->rr[(signed long int)cnt]->txt, data);
        break;
      }
      case ns_t_ptr:
      {
        do
        {
          enum SPF_errcode_t SPF_dns_zone_add_str__1__3__5____err;
          unsigned long int return_value_strlen_6;
          return_value_strlen_6=strlen(data);
          SPF_dns_zone_add_str__1__3__5____err=SPF_dns_rr_buf_realloc(spfrr, cnt, return_value_strlen_6 + (unsigned long int)1);
          if(!((signed int)SPF_dns_zone_add_str__1__3__5____err == SPF_E_SUCCESS))
            return SPF_dns_zone_add_str__1__3__5____err;

        }
        while((_Bool)0);
        strcpy(spfrr->rr[(signed long int)cnt]->ptr, data);
        break;
      }
      case ns_t_any:
      {
        if(!(data == ((const char *)NULL)))
          SPF_errorx("spf_dns_zone.c", 293, "%s", (const void *)"RR type ANY can not have data.");

        if(herrno == 0)
          SPF_errorx("spf_dns_zone.c", 295, "%s", (const void *)"RR type ANY must return a DNS error code.");

        SPF_errorx("spf_dns_zone.c", 296, "%s", (const void *)"RR type ANY can not have multiple RR.");
        break;
      }
      default:
        SPF_errorx("spf_dns_zone.c", 300, "%s", (const void *)"Invalid RR type");
    }
    spfrr->num_rr = cnt + 1;
    return (enum SPF_errcode_t)SPF_E_SUCCESS;
  }
}

// SPF_dns_zone_find
// file spf_dns_zone.c line 96
static struct SPF_dns_rr_struct * SPF_dns_zone_find(struct SPF_dns_server_struct *spf_dns_server, const char *domain, enum __ns_type rr_type, signed int exact)
{
  struct anonymous_9 *spfhook;
  signed int i;
  spfhook=SPF_voidp2spfhook_link1(spf_dns_server->hook);
  if(!(spf_dns_server->debug == 0))
    SPF_debugx("spf_dns_zone.c", 106, "zone: Searching for RR %s (%d)", domain, rr_type);

  _Bool tmp_if_expr_8;
  signed int return_value_strncmp_7;
  if(!(exact == 0))
    tmp_if_expr_8 = (_Bool)1;

  else
  {
    return_value_strncmp_7=strncmp(domain, "*.", (unsigned long int)2);
    tmp_if_expr_8 = return_value_strncmp_7 == 0 ? (_Bool)1 : (_Bool)0;
  }
  signed int return_value_strcasecmp_1;
  signed int return_value_strncasecmp_3;
  signed int return_value_strncasecmp_5;
  unsigned long int return_value_strlen_4;
  if(tmp_if_expr_8)
  {
    i = 0;
    for( ; !(i >= spfhook->num_zone); i = i + 1)
      if(spfhook->zone[(signed long int)i]->rr_type == rr_type)
      {
        return_value_strcasecmp_1=strcasecmp(spfhook->zone[(signed long int)i]->domain, domain);
        if(return_value_strcasecmp_1 == 0)
          return spfhook->zone[(signed long int)i];

      }

    if(!(spf_dns_server->debug == 0))
      SPF_debugx("spf_dns_zone.c", 117, "zone: Exact not found");

  }

  else
  {
    unsigned long int domain_len;
    domain_len=strlen(domain);
    if(!(domain_len == 0ul))
    {
      if((signed int)domain[-1l + (signed long int)domain_len] == 46)
        domain_len = domain_len - 1ul;

    }

    i = 0;
    for( ; !(i >= spfhook->num_zone); i = i + 1)
      if(!(spfhook->zone[(signed long int)i]->rr_type == rr_type))
      {
        if((signed int)spfhook->zone[(signed long int)i]->rr_type == ns_t_any)
          goto __CPROVER_DUMP_L13;

        if(!(spf_dns_server->debug == 0))
          SPF_debugx("spf_dns_zone.c", 133, "zone: Ignoring record rrtype %d", spfhook->zone[(signed long int)i]->rr_type);

      }

      else
      {

      __CPROVER_DUMP_L13:
        ;
        signed int return_value_strncmp_6;
        return_value_strncmp_6=strncmp(spfhook->zone[(signed long int)i]->domain, "*.", (unsigned long int)2);
        if(return_value_strncmp_6 == 0)
        {
          unsigned long int zdomain_len;
          unsigned long int return_value_strlen_2;
          return_value_strlen_2=strlen(spfhook->zone[(signed long int)i]->domain);
          zdomain_len = return_value_strlen_2 - (unsigned long int)2;
          if(domain_len >= zdomain_len)
          {
            return_value_strncasecmp_3=strncasecmp(spfhook->zone[(signed long int)i]->domain + (signed long int)2, domain + (signed long int)(domain_len - zdomain_len), zdomain_len);
            if(return_value_strncasecmp_3 == 0)
              return spfhook->zone[(signed long int)i];

          }

        }

        else
        {
          return_value_strncasecmp_5=strncasecmp(spfhook->zone[(signed long int)i]->domain, domain, domain_len);
          if(return_value_strncasecmp_5 == 0)
          {
            return_value_strlen_4=strlen(spfhook->zone[(signed long int)i]->domain);
            if(return_value_strlen_4 == domain_len)
              return spfhook->zone[(signed long int)i];

          }

        }
      }
    if(!(spf_dns_server->debug == 0))
      SPF_debugx("spf_dns_zone.c", 155, "zone: Non-exact not found");

  }
  return (struct SPF_dns_rr_struct *)(void *)0;
}

// SPF_dns_zone_free
// file spf_dns_zone.c line 312
static void SPF_dns_zone_free(struct SPF_dns_server_struct *spf_dns_server)
{
  struct anonymous_9 *spfhook;
  signed int i;
  do
    if(spf_dns_server == ((struct SPF_dns_server_struct *)NULL))
      SPF_errorx("spf_dns_zone.c", 317, "%s", (const void *)"spf_dns_server is NULL");

  while((_Bool)0);
  spfhook=SPF_voidp2spfhook_link1(spf_dns_server->hook);
  if(!(spfhook == ((struct anonymous_9 *)NULL)))
  {
    if(!(spfhook->zone == ((struct SPF_dns_rr_struct **)NULL)))
    {
      i = 0;
      for( ; !(i >= spfhook->zone_buf_len); i = i + 1)
        if(!(spfhook->zone[(signed long int)i] == ((struct SPF_dns_rr_struct *)NULL)))
          SPF_dns_rr_free(spfhook->zone[(signed long int)i]);

      free((void *)spfhook->zone);
    }

    if(!(spfhook->nxdomain == ((struct SPF_dns_rr_struct *)NULL)))
      SPF_dns_rr_free(spfhook->nxdomain);

    free((void *)spfhook);
  }

  free((void *)spf_dns_server);
}

// SPF_dns_zone_lookup
// file spf_dns_zone.c line 164
static struct SPF_dns_rr_struct * SPF_dns_zone_lookup(struct SPF_dns_server_struct *spf_dns_server, const char *domain, enum __ns_type rr_type, signed int should_cache)
{
  struct anonymous_9 *spfhook;
  struct SPF_dns_rr_struct *spfrr;
  spfrr=SPF_dns_zone_find(spf_dns_server, domain, rr_type, 0);
  if(!(spfrr == ((struct SPF_dns_rr_struct *)NULL)))
  {
    SPF_dns_rr_dup(&spfrr, spfrr);
    return spfrr;
  }

  else
  {
    if(!(spf_dns_server->layer_below == ((struct SPF_dns_server_struct *)NULL)))
    {
      struct SPF_dns_rr_struct *return_value_SPF_dns_lookup_1;
      return_value_SPF_dns_lookup_1=SPF_dns_lookup(spf_dns_server->layer_below, domain, rr_type, should_cache);
      return return_value_SPF_dns_lookup_1;
    }

    spfhook=SPF_voidp2spfhook_link1(spf_dns_server->hook);
    SPF_dns_rr_dup(&spfrr, spfhook->nxdomain);
    return spfrr;
  }
}

// SPF_dns_zone_new
// file ../../src/include/spf_dns_zone.h line 70
struct SPF_dns_server_struct * SPF_dns_zone_new(struct SPF_dns_server_struct *layer_below, const char *name, signed int debug)
{
  struct SPF_dns_server_struct *spf_dns_server;
  struct anonymous_9 *spfhook;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct SPF_dns_server_struct) /*72ul*/ );
  spf_dns_server = (struct SPF_dns_server_struct *)return_value_malloc_1;
  if(spf_dns_server == ((struct SPF_dns_server_struct *)NULL))
    return (struct SPF_dns_server_struct *)(void *)0;

  else
  {
    memset((void *)spf_dns_server, 0, sizeof(struct SPF_dns_server_struct) /*72ul*/ );
    spf_dns_server->hook=malloc(sizeof(struct anonymous_9) /*24ul*/ );
    if(spf_dns_server->hook == NULL)
    {
      free((void *)spf_dns_server);
      return (struct SPF_dns_server_struct *)(void *)0;
    }

    else
    {
      memset(spf_dns_server->hook, 0, sizeof(struct anonymous_9) /*24ul*/ );
      if(name == ((const char *)NULL))
        name = "zone";

      spf_dns_server->destroy = SPF_dns_zone_free;
      spf_dns_server->lookup = SPF_dns_zone_lookup;
      spf_dns_server->get_spf = (enum SPF_errcode_t (*)(struct SPF_server_struct *, struct SPF_request_struct *, struct SPF_response_struct *, struct SPF_record_struct **))(void *)0;
      spf_dns_server->get_exp = (enum SPF_errcode_t (*)(struct SPF_server_struct *, const char *, char **, unsigned long int *))(void *)0;
      spf_dns_server->add_cache = (signed int (*)(struct SPF_server_struct *, struct SPF_dns_rr_struct))(void *)0;
      spf_dns_server->layer_below = layer_below;
      spf_dns_server->name = name;
      spf_dns_server->debug = debug;
      spfhook=SPF_voidp2spfhook_link1(spf_dns_server->hook);
      spfhook->zone_buf_len = 32;
      spfhook->num_zone = 0;
      void *return_value_calloc_2;
      return_value_calloc_2=calloc((unsigned long int)spfhook->zone_buf_len, sizeof(struct SPF_dns_rr_struct *) /*8ul*/ );
      spfhook->zone = (struct SPF_dns_rr_struct **)return_value_calloc_2;
      if(spfhook->zone == ((struct SPF_dns_rr_struct **)NULL))
      {
        free((void *)spfhook);
        free((void *)spf_dns_server);
        return (struct SPF_dns_server_struct *)(void *)0;
      }

      else
      {
        spfhook->nxdomain=SPF_dns_rr_new_init(spf_dns_server, "", (enum __ns_type)ns_t_any, 24 * 60 * 60, 1);
        if(spfhook->nxdomain == ((struct SPF_dns_rr_struct *)NULL))
        {
          free((void *)spfhook->zone);
          free((void *)spfhook);
          free((void *)spf_dns_server);
          return (struct SPF_dns_server_struct *)(void *)0;
        }

        else
          return spf_dns_server;
      }
    }
  }
}

// SPF_error_code
// file ../../src/include/spf_response.h line 220
enum SPF_errcode_t SPF_error_code(struct SPF_error_struct *err)
{
  return err->code;
}

// SPF_error_errorp
// file ../../src/include/spf_response.h line 222
char SPF_error_errorp(struct SPF_error_struct *err)
{
  return err->is_error;
}

// SPF_error_message
// file ../../src/include/spf_response.h line 221
const char * SPF_error_message(struct SPF_error_struct *err)
{
  return err->message;
}

// SPF_error_stdio
// file ../../src/include/spf_log.h line 87
void SPF_error_stdio(const char *file, signed int line, const char *errmsg)
{
  char buf[128l];
  if(!(file == ((const char *)NULL)))
  {
    snprintf(buf, sizeof(char [128l]) /*128ul*/ , "%s:%d", file, line);
    fprintf(stderr, "%-20s Error: %s\n", (const void *)buf, errmsg);
  }

  else
    fprintf(stderr, "Error: %s\n", errmsg);
  abort();
}

// SPF_error_syslog
// file spf_log_syslog.c line 38
void SPF_error_syslog(const char *file, signed int line, const char *errmsg)
{
  char buf[128l];
  if(!(file == ((const char *)NULL)))
  {
    snprintf(buf, sizeof(char [128l]) /*128ul*/ , "%s:%d", file, line);
    syslog(2 << 3 | 3, "%-20s %s", (const void *)buf, errmsg);
  }

  else
    syslog(2 << 3 | 3, "%s", errmsg);
  abort();
}

// SPF_errorv
// file spf_log.c line 109
void SPF_errorv(const char *file, signed int line, const char *format, void **ap)
{
  char errmsg[800l];
  if(SPF_error_handler == ((void (*)(const char *, signed int, const char *))NULL))
    abort();

  vsnprintf(errmsg, sizeof(char [800l]) /*800ul*/ , format, ap);
  SPF_error_handler(file, line, errmsg);
  abort();
}

// SPF_errorx
// file ../../src/include/spf_log.h line 41
void SPF_errorx(const char *file, signed int line, const char *format, ...)
{
  char errmsg[800l];
  void **ap;
  if(SPF_error_handler == ((void (*)(const char *, signed int, const char *))NULL))
    abort();

  ap = (void **)&format;
  vsnprintf(errmsg, sizeof(char [800l]) /*800ul*/ , format, ap);
  ap = ((void **)NULL);
  SPF_error_handler(file, line, errmsg);
  abort();
}

// SPF_errorx2
// file spf_log.c line 167
void SPF_errorx2(const char *format, ...)
{
  void **ap = (void **)&format;
  SPF_errorv((const char *)(void *)0, 0, format, ap);
  ap = ((void **)NULL);
}

// SPF_get_lib_version
// file spf_utils.c line 38
void SPF_get_lib_version(signed int *major, signed int *minor, signed int *patch)
{
  *major = 1;
  *minor = 2;
  *patch = 10;
}

// SPF_i_done
// file spf_interpret.c line 388
enum SPF_errcode_t SPF_i_done(struct SPF_response_struct *spf_response, enum SPF_result_enum result, enum SPF_reason_enum reason, enum SPF_errcode_t err)
{
  struct SPF_request_struct *spf_request;
  struct SPF_server_struct *SPF_i_done__1__spf_server;
  do
    if(spf_response == ((struct SPF_response_struct *)NULL))
      SPF_errorx("spf_interpret.c", 394, "%s", (const void *)"spf_response is NULL");

  while((_Bool)0);
  spf_request = spf_response->spf_request;
  do
    if(spf_request == ((struct SPF_request_struct *)NULL))
      SPF_errorx("spf_interpret.c", 396, "%s", (const void *)"spf_request is NULL");

  while((_Bool)0);
  SPF_i_done__1__spf_server = spf_request->spf_server;
  do
    if(SPF_i_done__1__spf_server == ((struct SPF_server_struct *)NULL))
      SPF_errorx("spf_interpret.c", 398, "%s", (const void *)"spf_server is NULL");

  while((_Bool)0);
  spf_response->result = result;
  spf_response->reason = reason;
  spf_response->err = err;
  SPF_i_set_smtp_comment(spf_response);
  SPF_i_set_header_comment(spf_response);
  SPF_i_set_received_spf(spf_response);
  return err;
}

// SPF_i_match_domain
// file spf_interpret.c line 549
static signed int SPF_i_match_domain(struct SPF_server_struct *spf_server, const char *hostname, const char *domain)
{
  const char *hp;
  unsigned long int hlen;
  unsigned long int dlen;
  if(!(spf_server->debug == 0))
    SPF_debugx("spf_interpret.c", 557, "%s ?=? %s", hostname, domain);

  hlen=strlen(hostname);
  dlen=strlen(domain);
  signed int return_value_strcasecmp_1;
  if(!(hlen >= dlen))
    return 0;

  else
  {
    if(dlen == hlen)
    {
      return_value_strcasecmp_1=strcasecmp(hostname, domain);
      return (signed int)(return_value_strcasecmp_1 == 0);
    }

    hp = hostname + (signed long int)(hlen - dlen);
    if(!((signed int)hp[-1l] == 46))
      return 0;

    else
    {
      signed int return_value_strcasecmp_2;
      return_value_strcasecmp_2=strcasecmp(hp, domain);
      return (signed int)(return_value_strcasecmp_2 == 0);
    }
  }
}

// SPF_i_match_ip4
// file spf_interpret.c line 458
static signed int SPF_i_match_ip4(struct SPF_server_struct *spf_server, struct SPF_request_struct *spf_request, struct SPF_mech_struct *mech, struct in_addr ipv4)
{
  char src_ip4_buf[16l];
  char dst_ip4_buf[16l];
  char mask_ip4_buf[16l];
  struct in_addr src_ipv4;
  signed int cidr;
  signed int mask;
  if(!(spf_request->client_ver == 2))
    return 0;

  else
  {
    src_ipv4 = spf_request->ipv4;
    cidr=SPF_i_mech_cidr(spf_request, mech);
    if(cidr == 0)
      cidr = 32;

    mask = (signed int)(0xffffffff << 32 - cidr);
    unsigned int return_value_htonl_1;
    return_value_htonl_1=htonl((unsigned int)mask);
    mask = (signed int)return_value_htonl_1;
    if(!(spf_server->debug == 0))
    {
      do
      {
        const char *return_value_inet_ntop_2;
        return_value_inet_ntop_2=inet_ntop(2, (const void *)&src_ipv4.s_addr, src_ip4_buf, (unsigned int)sizeof(char [16l]) /*16ul*/ );
        if(return_value_inet_ntop_2 == ((const char *)NULL))
          snprintf(src_ip4_buf, sizeof(char [16l]) /*16ul*/ , "ip-error");

      }
      while((_Bool)0);
      do
      {
        const char *return_value_inet_ntop_3;
        return_value_inet_ntop_3=inet_ntop(2, (const void *)&ipv4.s_addr, dst_ip4_buf, (unsigned int)sizeof(char [16l]) /*16ul*/ );
        if(return_value_inet_ntop_3 == ((const char *)NULL))
          snprintf(dst_ip4_buf, sizeof(char [16l]) /*16ul*/ , "ip-error");

      }
      while((_Bool)0);
      do
      {
        const char *return_value_inet_ntop_4;
        return_value_inet_ntop_4=inet_ntop(2, (const void *)&mask, mask_ip4_buf, (unsigned int)sizeof(char [16l]) /*16ul*/ );
        if(return_value_inet_ntop_4 == ((const char *)NULL))
          snprintf(mask_ip4_buf, sizeof(char [16l]) /*16ul*/ , "ip-error");

      }
      while((_Bool)0);
      SPF_debugx("spf_interpret.c", 491, "ip_match:  %s == %s  (/%d %s):  %d", (const void *)src_ip4_buf, (const void *)dst_ip4_buf, cidr, (const void *)mask_ip4_buf, (src_ipv4.s_addr & (unsigned int)mask) == (ipv4.s_addr & (unsigned int)mask));
    }

    return (signed int)((src_ipv4.s_addr & (unsigned int)mask) == (ipv4.s_addr & (unsigned int)mask));
  }
}

// SPF_i_match_ip6
// file spf_interpret.c line 499
static signed int SPF_i_match_ip6(struct SPF_server_struct *spf_server, struct SPF_request_struct *spf_request, struct SPF_mech_struct *mech, struct in6_addr ipv6)
{
  char src_ip6_buf[46l];
  char dst_ip6_buf[46l];
  struct in6_addr src_ipv6;
  signed int cidr;
  signed int cidr_save;
  signed int mask;
  signed int i;
  signed int match;
  if(!(spf_request->client_ver == 10))
    return 0;

  else
  {
    src_ipv6 = spf_request->ipv6;
    cidr=SPF_i_mech_cidr(spf_request, mech);
    if(cidr == 0)
      cidr = 128;

    cidr_save = cidr;
    match = 1;
    i = 0;
    for( ; !(match == 0) && !((signed long int)i >= (signed long int)sizeof(unsigned char [16l]) /*16l*/ ); i = i + 1)
    {
      if(cidr >= 9)
        mask = 0xff;

      else
        if(cidr >= 1)
          mask = 0xff << 8 - cidr & 0xff;

        else
          break;
      cidr = cidr - 8;
      match = (signed int)(((signed int)src_ipv6.__in6_u.__u6_addr8[(signed long int)i] & mask) == ((signed int)ipv6.__in6_u.__u6_addr8[(signed long int)i] & mask));
    }
    if(!(spf_server->debug == 0))
    {
      do
      {
        const char *return_value_inet_ntop_1;
        return_value_inet_ntop_1=inet_ntop(10, (const void *)&src_ipv6.__in6_u.__u6_addr8, src_ip6_buf, (unsigned int)sizeof(char [46l]) /*46ul*/ );
        if(return_value_inet_ntop_1 == ((const char *)NULL))
          snprintf(src_ip6_buf, sizeof(char [46l]) /*46ul*/ , "ip-error");

      }
      while((_Bool)0);
      do
      {
        const char *return_value_inet_ntop_2;
        return_value_inet_ntop_2=inet_ntop(10, (const void *)&ipv6.__in6_u.__u6_addr8, dst_ip6_buf, (unsigned int)sizeof(char [46l]) /*46ul*/ );
        if(return_value_inet_ntop_2 == ((const char *)NULL))
          snprintf(dst_ip6_buf, sizeof(char [46l]) /*46ul*/ , "ip-error");

      }
      while((_Bool)0);
      SPF_debugx("spf_interpret.c", 542, "ip_match:  %s == %s  (/%d):  %d", (const void *)src_ip6_buf, (const void *)dst_ip6_buf, cidr_save, match);
    }

    return match;
  }
}

// SPF_i_mech_cidr
// file spf_interpret.c line 424
static signed int SPF_i_mech_cidr(struct SPF_request_struct *spf_request, struct SPF_mech_struct *mech)
{
  union SPF_data_union *data;
  do
    if(mech == ((struct SPF_mech_struct *)NULL))
      SPF_errorx("spf_interpret.c", 428, "%s", (const void *)"mech is NULL");

  while((_Bool)0);
  union SPF_data_union *return_value_SPF_mech_end_data_1;
  switch((signed int)mech->mech_type)
  {
    case 5:

    case 6:
      return (signed int)mech->mech_len;
    case 1:

    case 2:
    {
      data=SPF_mech_data_link2(mech);
      return_value_SPF_mech_end_data_1=SPF_mech_end_data_link2(mech);
      if(!(data >= return_value_SPF_mech_end_data_1))
      {
        if((signed int)data->dc.parm_type == 11)
        {
          if(spf_request->client_ver == 2)
            return (signed int)data->dc.ipv4;

          else
            if(spf_request->client_ver == 10)
              return (signed int)data->dc.ipv6;

        }

      }

    }
    default:
      return 0;
  }
}

// SPF_i_set_explanation
// file spf_interpret.c line 44
static enum SPF_errcode_t SPF_i_set_explanation(struct SPF_response_struct *spf_response)
{
  struct SPF_server_struct *SPF_i_set_explanation__1__spf_server;
  struct SPF_request_struct *spf_request;
  struct SPF_record_struct *spf_record;
  enum SPF_errcode_t err;
  char *buf;
  unsigned long int buflen;
  do
    if(spf_response == ((struct SPF_response_struct *)NULL))
      SPF_errorx("spf_interpret.c", 53, "%s", (const void *)"spf_response is NULL");

  while((_Bool)0);
  spf_request = spf_response->spf_request;
  do
    if(spf_request == ((struct SPF_request_struct *)NULL))
      SPF_errorx("spf_interpret.c", 55, "%s", (const void *)"spf_request is NULL");

  while((_Bool)0);
  SPF_i_set_explanation__1__spf_server = spf_request->spf_server;
  do
    if(SPF_i_set_explanation__1__spf_server == ((struct SPF_server_struct *)NULL))
      SPF_errorx("spf_interpret.c", 57, "%s", (const void *)"spf_server is NULL");

  while((_Bool)0);
  spf_record = spf_response->spf_record_exp;
  do
    if(spf_record == ((struct SPF_record_struct *)NULL))
      SPF_errorx("spf_interpret.c", 60, "%s", (const void *)"spf_record is NULL");

  while((_Bool)0);
  if(!(spf_response->explanation == ((char *)NULL)))
    free((void *)spf_response->explanation);

  spf_response->explanation = (char *)(void *)0;
  buflen = (unsigned long int)(4 * 80 + 1);
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(buflen);
  buf = (char *)return_value_malloc_1;
  if(buf == ((char *)NULL))
    return (enum SPF_errcode_t)SPF_E_NO_MEMORY;

  else
  {
    memset((void *)buf, 0, buflen);
    err=SPF_request_get_exp(SPF_i_set_explanation__1__spf_server, spf_request, spf_response, spf_record, &buf, &buflen);
    if(!((signed int)err == SPF_E_SUCCESS))
    {
      free((void *)buf);
      return err;
    }

    else
    {
      spf_response->explanation = buf;
      return (enum SPF_errcode_t)SPF_E_SUCCESS;
    }
  }
}

// SPF_i_set_header_comment
// file spf_interpret.c line 137
static enum SPF_errcode_t SPF_i_set_header_comment(struct SPF_response_struct *spf_response)
{
  struct SPF_server_struct *SPF_i_set_header_comment__1__spf_server;
  struct SPF_request_struct *spf_request;
  char *spf_source;
  unsigned long int len;
  char ip4_buf[16l];
  char ip6_buf[46l];
  const char *ip;
  char *buf;
  char *sender_dom;
  char *p;
  char *p_end;
  do
    if(spf_response == ((struct SPF_response_struct *)NULL))
      SPF_errorx("spf_interpret.c", 153, "%s", (const void *)"spf_response is NULL");

  while((_Bool)0);
  spf_request = spf_response->spf_request;
  do
    if(spf_request == ((struct SPF_request_struct *)NULL))
      SPF_errorx("spf_interpret.c", 155, "%s", (const void *)"spf_request is NULL");

  while((_Bool)0);
  SPF_i_set_header_comment__1__spf_server = spf_request->spf_server;
  do
    if(SPF_i_set_header_comment__1__spf_server == ((struct SPF_server_struct *)NULL))
      SPF_errorx("spf_interpret.c", 157, "%s", (const void *)"spf_server is NULL");

  while((_Bool)0);
  if(!(spf_response->header_comment == ((char *)NULL)))
    free((void *)spf_response->header_comment);

  spf_response->header_comment = (char *)(void *)0;
  sender_dom = spf_request->env_from_dp;
  if(sender_dom == ((char *)NULL))
    sender_dom = spf_request->helo_dom;

  if((signed int)spf_response->reason == SPF_REASON_LOCAL_POLICY)
    spf_source=strdup("local policy");

  else
    if((signed int)spf_response->reason == SPF_REASON_2MX)
    {
      _Bool tmp_if_expr_1;
      if(spf_request->rcpt_to_dom == ((char *)NULL))
        tmp_if_expr_1 = (_Bool)1;

      else
        tmp_if_expr_1 = (signed int)spf_request->rcpt_to_dom[(signed long int)0] == 0 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_1)
        SPF_errorx("spf_interpret.c", 173, "%s", (const void *)"RCPT TO domain is NULL");

      spf_source=strdup(spf_request->rcpt_to_dom);
    }

    else
      if(sender_dom == ((char *)NULL))
        spf_source=strdup("unknown domain");

      else
      {
        unsigned long int return_value_strlen_2;
        return_value_strlen_2=strlen(sender_dom);
        len = return_value_strlen_2 + sizeof(char [11l]) /*11ul*/ ;
        void *return_value_malloc_3;
        return_value_malloc_3=malloc(len);
        spf_source = (char *)return_value_malloc_3;
        if(!(spf_source == ((char *)NULL)))
          snprintf(spf_source, len, "domain of %s", sender_dom);

      }
  const char *return_value_SPF_strerror_11;
  if(spf_source == ((char *)NULL))
    return (enum SPF_errcode_t)SPF_E_INTERNAL_ERROR;

  else
  {
    ip = (const char *)(void *)0;
    if(spf_request->client_ver == 2)
      ip=inet_ntop(2, (const void *)&spf_request->ipv4, ip4_buf, (unsigned int)sizeof(char [16l]) /*16ul*/ );

    else
      if(spf_request->client_ver == 10)
        ip=inet_ntop(10, (const void *)&spf_request->ipv6, ip6_buf, (unsigned int)sizeof(char [46l]) /*46ul*/ );

    if(ip == ((const char *)NULL))
      ip = "(unknown ip address)";

    const char *return_value_SPF_request_get_rec_dom_4;
    return_value_SPF_request_get_rec_dom_4=SPF_request_get_rec_dom(spf_request);
    unsigned long int return_value_strlen_5;
    return_value_strlen_5=strlen(return_value_SPF_request_get_rec_dom_4);
    unsigned long int return_value_strlen_6;
    return_value_strlen_6=strlen(spf_source);
    unsigned long int return_value_strlen_7;
    return_value_strlen_7=strlen(ip);
    len = return_value_strlen_5 + return_value_strlen_6 + return_value_strlen_7 + (unsigned long int)80;
    void *return_value_malloc_8;
    return_value_malloc_8=malloc(len);
    buf = (char *)return_value_malloc_8;
    if(buf == ((char *)NULL))
    {
      free((void *)spf_source);
      return (enum SPF_errcode_t)SPF_E_INTERNAL_ERROR;
    }

    else
    {
      p = buf;
      p_end = p + (signed long int)len;
      const char *return_value_SPF_request_get_rec_dom_9;
      return_value_SPF_request_get_rec_dom_9=SPF_request_get_rec_dom(spf_request);
      signed int return_value_snprintf_10;
      return_value_snprintf_10=snprintf(p, (unsigned long int)(p_end - p), "%s: ", return_value_SPF_request_get_rec_dom_9);
      p = p + (signed long int)return_value_snprintf_10;
      switch((signed int)spf_response->result)
      {
        case SPF_RESULT_PASS:
        {
          if((signed int)spf_response->reason == SPF_REASON_LOCALHOST)
            snprintf(p, (unsigned long int)(p_end - p), "localhost is always allowed.");

          else
            if((signed int)spf_response->reason == SPF_REASON_2MX)
              snprintf(p, (unsigned long int)(p_end - p), "message received from %s which is an MX secondary for %s.", ip, spf_source);

            else
              snprintf(p, (unsigned long int)(p_end - p), "%s designates %s as permitted sender", spf_source, ip);
          break;
        }
        case SPF_RESULT_FAIL:
        {
          snprintf(p, (unsigned long int)(p_end - p), "%s does not designate %s as permitted sender", spf_source, ip);
          break;
        }
        case SPF_RESULT_SOFTFAIL:
        {
          snprintf(p, (unsigned long int)(p_end - p), "transitioning %s does not designate %s as permitted sender", spf_source, ip);
          break;
        }
        case SPF_RESULT_PERMERROR:
        {
          return_value_SPF_strerror_11=SPF_strerror(spf_response->err);
          snprintf(p, (unsigned long int)(p_end - p), "error in processing during lookup of %s: %s", spf_source, return_value_SPF_strerror_11);
          break;
        }
        case SPF_RESULT_NEUTRAL:
        {
          snprintf(p, (unsigned long int)(p_end - p), "%s is neither permitted nor denied by %s", ip, spf_source);
          break;
        }
        case SPF_RESULT_NONE:
        {
          snprintf(p, (unsigned long int)(p_end - p), "%s does not provide an SPF record", spf_source);
          break;
        }
        case SPF_RESULT_TEMPERROR:
        {
          snprintf(p, (unsigned long int)(p_end - p), "encountered temporary error during SPF processing of %s", spf_source);
          break;
        }
        default:
          snprintf(p, (unsigned long int)(p_end - p), "error: unknown SPF result %d encountered while checking %s for %s", spf_response->result, ip, spf_source);
      }
      if(!(spf_source == ((char *)NULL)))
        free((void *)spf_source);

      spf_response->header_comment=SPF_sanitize(SPF_i_set_header_comment__1__spf_server, buf);
      return (enum SPF_errcode_t)SPF_E_SUCCESS;
    }
  }
}

// SPF_i_set_received_spf
// file spf_interpret.c line 273
static enum SPF_errcode_t SPF_i_set_received_spf(struct SPF_response_struct *spf_response)
{
  struct SPF_server_struct *SPF_i_set_received_spf__1__spf_server;
  struct SPF_request_struct *spf_request;
  char ip4_buf[16l];
  char ip6_buf[46l];
  const char *ip;
  char *buf;
  unsigned long int buflen = (unsigned long int)(6 * 80);
  char *buf_value;
  char *p;
  char *p_end;
  do
    if(spf_response == ((struct SPF_response_struct *)NULL))
      SPF_errorx("spf_interpret.c", 287, "%s", (const void *)"spf_response is NULL");

  while((_Bool)0);
  spf_request = spf_response->spf_request;
  do
    if(spf_request == ((struct SPF_request_struct *)NULL))
      SPF_errorx("spf_interpret.c", 289, "%s", (const void *)"spf_request is NULL");

  while((_Bool)0);
  SPF_i_set_received_spf__1__spf_server = spf_request->spf_server;
  do
    if(SPF_i_set_received_spf__1__spf_server == ((struct SPF_server_struct *)NULL))
      SPF_errorx("spf_interpret.c", 291, "%s", (const void *)"spf_server is NULL");

  while((_Bool)0);
  if(!(spf_response->received_spf == ((char *)NULL)))
    free((void *)spf_response->received_spf);

  spf_response->received_spf = (char *)(void *)0;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(buflen);
  buf = (char *)return_value_malloc_1;
  if(buf == ((char *)NULL))
    return (enum SPF_errcode_t)SPF_E_INTERNAL_ERROR;

  else
  {
    p = buf;
    p_end = p + (signed long int)buflen;
    signed int return_value_snprintf_2;
    return_value_snprintf_2=snprintf(p, (unsigned long int)(p_end - p), "Received-SPF: ");
    p = p + (signed long int)return_value_snprintf_2;
    buf_value = p;
    do
    {
      const char *return_value_SPF_strresult_3;
      return_value_SPF_strresult_3=SPF_strresult(spf_response->result);
      signed int return_value_snprintf_4;
      return_value_snprintf_4=snprintf(p, (unsigned long int)(p_end - p), "%s (%s)", return_value_SPF_strresult_3, spf_response->header_comment);
      p = p + (signed long int)return_value_snprintf_4;
      if(!(p_end - p >= 1l))
        break;

      ip = (const char *)(void *)0;
      if(spf_request->client_ver == 2)
        ip=inet_ntop(2, (const void *)&spf_request->ipv4, ip4_buf, (unsigned int)sizeof(char [16l]) /*16ul*/ );

      else
        if(spf_request->client_ver == 10)
          ip=inet_ntop(10, (const void *)&spf_request->ipv6, ip6_buf, (unsigned int)sizeof(char [46l]) /*46ul*/ );

      if(!(ip == ((const char *)NULL)))
      {
        signed int return_value_snprintf_5;
        return_value_snprintf_5=snprintf(p, (unsigned long int)(p_end - p), " client-ip=%s;", ip);
        p = p + (signed long int)return_value_snprintf_5;
        if(!(p_end - p >= 1l))
          break;

      }

      if(!(spf_request->env_from == ((char *)NULL)))
      {
        signed int return_value_snprintf_6;
        return_value_snprintf_6=snprintf(p, (unsigned long int)(p_end - p), " envelope-from=%s;", spf_request->env_from);
        p = p + (signed long int)return_value_snprintf_6;
        if(!(p_end - p >= 1l))
          break;

      }

      if(!(spf_request->helo_dom == ((char *)NULL)))
      {
        signed int return_value_snprintf_7;
        return_value_snprintf_7=snprintf(p, (unsigned long int)(p_end - p), " helo=%s;", spf_request->helo_dom);
        p = p + (signed long int)return_value_snprintf_7;
        if(!(p_end - p >= 1l))
          break;

      }

    }
    while((_Bool)0);
    spf_response->received_spf=SPF_sanitize(SPF_i_set_received_spf__1__spf_server, buf);
    spf_response->received_spf_value = buf_value;
    return (enum SPF_errcode_t)SPF_E_SUCCESS;
  }
}

// SPF_i_set_smtp_comment
// file spf_interpret.c line 85
static enum SPF_errcode_t SPF_i_set_smtp_comment(struct SPF_response_struct *spf_response)
{
  struct SPF_server_struct *SPF_i_set_smtp_comment__1__spf_server;
  struct SPF_request_struct *spf_request;
  enum SPF_errcode_t err;
  char buf[320l];
  do
    if(spf_response == ((struct SPF_response_struct *)NULL))
      SPF_errorx("spf_interpret.c", 92, "%s", (const void *)"spf_response is NULL");

  while((_Bool)0);
  spf_request = spf_response->spf_request;
  do
    if(spf_request == ((struct SPF_request_struct *)NULL))
      SPF_errorx("spf_interpret.c", 94, "%s", (const void *)"spf_request is NULL");

  while((_Bool)0);
  SPF_i_set_smtp_comment__1__spf_server = spf_request->spf_server;
  do
    if(SPF_i_set_smtp_comment__1__spf_server == ((struct SPF_server_struct *)NULL))
      SPF_errorx("spf_interpret.c", 96, "%s", (const void *)"spf_server is NULL");

  while((_Bool)0);
  if(!(spf_response->smtp_comment == ((char *)NULL)))
    free((void *)spf_response->smtp_comment);

  spf_response->smtp_comment = (char *)(void *)0;
  const char *return_value_SPF_strreason_1;
  if(!((signed int)spf_response->result == SPF_RESULT_NEUTRAL) && !((signed int)spf_response->result == SPF_RESULT_FAIL) && !((signed int)spf_response->result == SPF_RESULT_SOFTFAIL))
  {
    if((signed int)spf_response->result == SPF_RESULT_INVALID || (signed int)spf_response->result == SPF_RESULT_PASS || (signed int)spf_response->result == SPF_RESULT_NONE || (signed int)spf_response->result == SPF_RESULT_TEMPERROR || (signed int)spf_response->result == SPF_RESULT_PERMERROR)
      goto __CPROVER_DUMP_L11;

  }

  else
  {
    err=SPF_i_set_explanation(spf_response);
    if(!((signed int)err == SPF_E_SUCCESS))
      return err;

    memset((void *)buf, 0, sizeof(char [320l]) /*320ul*/ );
    return_value_SPF_strreason_1=SPF_strreason(spf_response->reason);
    snprintf(buf, (unsigned long int)(4 * 80), "%s : Reason: %s", spf_response->explanation, return_value_SPF_strreason_1);
    buf[(signed long int)(4 * 80 - 1)] = (char)0;
    spf_response->smtp_comment=strdup(buf);
    if(spf_response->smtp_comment == ((char *)NULL))
      return (enum SPF_errcode_t)SPF_E_NO_MEMORY;

    goto __CPROVER_DUMP_L12;
  }

__CPROVER_DUMP_L11:
  ;
  goto __CPROVER_DUMP_L12;

__CPROVER_DUMP_L12:
  ;
  return (enum SPF_errcode_t)SPF_E_SUCCESS;
}

// SPF_info_stdio
// file ../../src/include/spf_log.h line 89
void SPF_info_stdio(const char *file, signed int line, const char *errmsg)
{
  printf("%s\n", errmsg);
}

// SPF_info_syslog
// file spf_log_syslog.c line 65
void SPF_info_syslog(const char *file, signed int line, const char *errmsg)
{
  syslog(2 << 3 | 6, "%s", errmsg);
}

// SPF_infov
// file spf_log.c line 137
void SPF_infov(const char *file, signed int line, const char *format, void **ap)
{
  char errmsg[800l];
  if(!(SPF_info_handler == ((void (*)(const char *, signed int, const char *))NULL)))
  {
    vsnprintf(errmsg, sizeof(char [800l]) /*800ul*/ , format, ap);
    SPF_info_handler(file, line, errmsg);
  }

}

// SPF_infox
// file spf_log.c line 70
void SPF_infox(const char *file, signed int line, const char *format, ...)
{
  char errmsg[800l];
  void **ap;
  if(!(SPF_info_handler == ((void (*)(const char *, signed int, const char *))NULL)))
  {
    ap = (void **)&format;
    vsnprintf(errmsg, sizeof(char [800l]) /*800ul*/ , format, ap);
    ap = ((void **)NULL);
    SPF_info_handler(file, line, errmsg);
  }

}

// SPF_infox2
// file spf_log.c line 185
void SPF_infox2(const char *format, ...)
{
  void **ap = (void **)&format;
  SPF_infov((const char *)(void *)0, 0, format, ap);
  ap = ((void **)NULL);
}

// SPF_macro_data
// file ../../src/include/spf_internal.h line 134
static inline union SPF_data_union * SPF_macro_data(struct SPF_macro_struct *mac)
{
  return (union SPF_data_union *)((char *)mac + (signed long int)sizeof(struct SPF_macro_struct) /*8ul*/ );
}

// SPF_macro_data_link1
// file ../../src/include/spf_internal.h line 134
static inline union SPF_data_union * SPF_macro_data_link1(struct SPF_macro_struct *mac_link1)
{
  return (union SPF_data_union *)((char *)mac_link1 + (signed long int)sizeof(struct SPF_macro_struct) /*8ul*/ );
}

// SPF_macro_free
// file ../../src/include/spf_record.h line 231
void SPF_macro_free(struct SPF_macro_struct *mac)
{
  free((void *)mac);
}

// SPF_mech_data
// file ../../src/include/spf_internal.h line 97
static inline union SPF_data_union * SPF_mech_data(struct SPF_mech_struct *mech)
{
  return (union SPF_data_union *)((char *)mech + (signed long int)sizeof(struct SPF_mech_struct) /*4ul*/ );
}

// SPF_mech_data_link1
// file ../../src/include/spf_internal.h line 97
static inline union SPF_data_union * SPF_mech_data_link1(struct SPF_mech_struct *mech_link1)
{
  return (union SPF_data_union *)((char *)mech_link1 + (signed long int)sizeof(struct SPF_mech_struct) /*4ul*/ );
}

// SPF_mech_data_link2
// file ../../src/include/spf_internal.h line 97
static inline union SPF_data_union * SPF_mech_data_link2(struct SPF_mech_struct *mech_link2)
{
  return (union SPF_data_union *)((char *)mech_link2 + (signed long int)sizeof(struct SPF_mech_struct) /*4ul*/ );
}

// SPF_mech_data_len
// file ../../src/include/spf_internal.h line 87
static inline unsigned long int SPF_mech_data_len(struct SPF_mech_struct *mech)
{
  unsigned long int tmp_if_expr_2;
  unsigned long int tmp_if_expr_1;
  if((signed int)mech->mech_type == 5)
    tmp_if_expr_2 = sizeof(struct in_addr) /*4ul*/ ;

  else
  {
    if((signed int)mech->mech_type == 6)
      tmp_if_expr_1 = sizeof(struct in6_addr) /*16ul*/ ;

    else
      tmp_if_expr_1 = (unsigned long int)mech->mech_len;
    tmp_if_expr_2 = tmp_if_expr_1;
  }
  return tmp_if_expr_2;
}

// SPF_mech_data_len_link1
// file ../../src/include/spf_internal.h line 87
static inline unsigned long int SPF_mech_data_len_link1(struct SPF_mech_struct *mech_link1)
{
  unsigned long int tmp_if_expr_2_link1;
  unsigned long int tmp_if_expr_1_link1;
  if((signed int)mech_link1->mech_type == 5)
    tmp_if_expr_2_link1 = sizeof(struct in_addr) /*4ul*/ ;

  else
  {
    if((signed int)mech_link1->mech_type == 6)
      tmp_if_expr_1_link1 = sizeof(struct in6_addr) /*16ul*/ ;

    else
      tmp_if_expr_1_link1 = (unsigned long int)mech_link1->mech_len;
    tmp_if_expr_2_link1 = tmp_if_expr_1_link1;
  }
  return tmp_if_expr_2_link1;
}

// SPF_mech_data_len_link2
// file ../../src/include/spf_internal.h line 87
static inline unsigned long int SPF_mech_data_len_link2(struct SPF_mech_struct *mech_link2)
{
  unsigned long int tmp_if_expr_2_link2;
  unsigned long int tmp_if_expr_1_link2;
  if((signed int)mech_link2->mech_type == 5)
    tmp_if_expr_2_link2 = sizeof(struct in_addr) /*4ul*/ ;

  else
  {
    if((signed int)mech_link2->mech_type == 6)
      tmp_if_expr_1_link2 = sizeof(struct in6_addr) /*16ul*/ ;

    else
      tmp_if_expr_1_link2 = (unsigned long int)mech_link2->mech_len;
    tmp_if_expr_2_link2 = tmp_if_expr_1_link2;
  }
  return tmp_if_expr_2_link2;
}

// SPF_mech_end_data
// file ../../src/include/spf_internal.h line 99
static inline union SPF_data_union * SPF_mech_end_data(struct SPF_mech_struct *mech)
{
  union SPF_data_union *return_value_SPF_mech_data_1;
  return_value_SPF_mech_data_1=SPF_mech_data(mech);
  unsigned long int return_value_SPF_mech_data_len_2;
  return_value_SPF_mech_data_len_2=SPF_mech_data_len(mech);
  return (union SPF_data_union *)((char *)return_value_SPF_mech_data_1 + (signed long int)return_value_SPF_mech_data_len_2);
}

// SPF_mech_end_data_link1
// file ../../src/include/spf_internal.h line 99
static inline union SPF_data_union * SPF_mech_end_data_link1(struct SPF_mech_struct *mech_link1)
{
  union SPF_data_union *return_value_SPF_mech_data_1_link1;
  return_value_SPF_mech_data_1_link1=SPF_mech_data_link1(mech_link1);
  unsigned long int return_value_SPF_mech_data_len_2_link1;
  return_value_SPF_mech_data_len_2_link1=SPF_mech_data_len_link1(mech_link1);
  return (union SPF_data_union *)((char *)return_value_SPF_mech_data_1_link1 + (signed long int)return_value_SPF_mech_data_len_2_link1);
}

// SPF_mech_end_data_link2
// file ../../src/include/spf_internal.h line 99
static inline union SPF_data_union * SPF_mech_end_data_link2(struct SPF_mech_struct *mech_link2)
{
  union SPF_data_union *return_value_SPF_mech_data_1_link2;
  return_value_SPF_mech_data_1_link2=SPF_mech_data_link2(mech_link2);
  unsigned long int return_value_SPF_mech_data_len_2_link2;
  return_value_SPF_mech_data_len_2_link2=SPF_mech_data_len_link2(mech_link2);
  return (union SPF_data_union *)((char *)return_value_SPF_mech_data_1_link2 + (signed long int)return_value_SPF_mech_data_len_2_link2);
}

// SPF_mech_ip4_data
// file ../../src/include/spf_internal.h line 102
static inline struct in_addr * SPF_mech_ip4_data(struct SPF_mech_struct *mech)
{
  return (struct in_addr *)((char *)mech + (signed long int)sizeof(struct SPF_mech_struct) /*4ul*/ );
}

// SPF_mech_ip4_data_link1
// file ../../src/include/spf_internal.h line 102
static inline struct in_addr * SPF_mech_ip4_data_link1(struct SPF_mech_struct *mech_link1)
{
  return (struct in_addr *)((char *)mech_link1 + (signed long int)sizeof(struct SPF_mech_struct) /*4ul*/ );
}

// SPF_mech_ip4_data_link2
// file ../../src/include/spf_internal.h line 102
static inline struct in_addr * SPF_mech_ip4_data_link2(struct SPF_mech_struct *mech_link2)
{
  return (struct in_addr *)((char *)mech_link2 + (signed long int)sizeof(struct SPF_mech_struct) /*4ul*/ );
}

// SPF_mech_ip6_data
// file ../../src/include/spf_internal.h line 104
static inline struct in6_addr * SPF_mech_ip6_data(struct SPF_mech_struct *mech)
{
  return (struct in6_addr *)((char *)mech + (signed long int)sizeof(struct SPF_mech_struct) /*4ul*/ );
}

// SPF_mech_ip6_data_link1
// file ../../src/include/spf_internal.h line 104
static inline struct in6_addr * SPF_mech_ip6_data_link1(struct SPF_mech_struct *mech_link1)
{
  return (struct in6_addr *)((char *)mech_link1 + (signed long int)sizeof(struct SPF_mech_struct) /*4ul*/ );
}

// SPF_mech_ip6_data_link2
// file ../../src/include/spf_internal.h line 104
static inline struct in6_addr * SPF_mech_ip6_data_link2(struct SPF_mech_struct *mech_link2)
{
  return (struct in6_addr *)((char *)mech_link2 + (signed long int)sizeof(struct SPF_mech_struct) /*4ul*/ );
}

// SPF_mech_next
// file ../../src/include/spf_internal.h line 93
static inline struct SPF_mech_struct * SPF_mech_next(struct SPF_mech_struct *mech)
{
  unsigned long int return_value_SPF_mech_data_len_1;
  return_value_SPF_mech_data_len_1=SPF_mech_data_len(mech);
  char *return_value__align_ptr_2;
  return_value__align_ptr_2=_align_ptr((char *)mech + (signed long int)sizeof(struct SPF_mech_struct) /*4ul*/  + (signed long int)return_value_SPF_mech_data_len_1);
  return (struct SPF_mech_struct *)return_value__align_ptr_2;
}

// SPF_mech_next_link1
// file ../../src/include/spf_internal.h line 93
static inline struct SPF_mech_struct * SPF_mech_next_link1(struct SPF_mech_struct *mech_link1)
{
  unsigned long int return_value_SPF_mech_data_len_1_link1;
  return_value_SPF_mech_data_len_1_link1=SPF_mech_data_len_link1(mech_link1);
  char *return_value__align_ptr_2_link1;
  return_value__align_ptr_2_link1=_align_ptr_link2((char *)mech_link1 + (signed long int)sizeof(struct SPF_mech_struct) /*4ul*/  + (signed long int)return_value_SPF_mech_data_len_1_link1);
  return (struct SPF_mech_struct *)return_value__align_ptr_2_link1;
}

// SPF_mech_next_link2
// file ../../src/include/spf_internal.h line 93
static inline struct SPF_mech_struct * SPF_mech_next_link2(struct SPF_mech_struct *mech_link2)
{
  unsigned long int return_value_SPF_mech_data_len_1_link2;
  return_value_SPF_mech_data_len_1_link2=SPF_mech_data_len_link2(mech_link2);
  char *return_value__align_ptr_2_link2;
  return_value__align_ptr_2_link2=_align_ptr_link3((char *)mech_link2 + (signed long int)sizeof(struct SPF_mech_struct) /*4ul*/  + (signed long int)return_value_SPF_mech_data_len_1_link2);
  return (struct SPF_mech_struct *)return_value__align_ptr_2_link2;
}

// SPF_mechtype_find
// file spf_compile.c line 95
static const struct SPF_mechtype_struct * SPF_mechtype_find(signed int mech_type)
{
  unsigned long int i = (unsigned long int)0;
  for( ; !(i >= 10ul); i = i + 1ul)
    if((signed int)spf_mechtypes[(signed long int)i].mech_type == mech_type)
      return &spf_mechtypes[(signed long int)i];

  return (const struct SPF_mechtype_struct *)(void *)0;
}

// SPF_mod_data
// file ../../src/include/spf_internal.h line 125
static inline union SPF_data_union * SPF_mod_data(struct SPF_mod_struct *mod)
{
  char *return_value__align_ptr_1;
  return_value__align_ptr_1=_align_ptr((char *)mod + (signed long int)sizeof(struct SPF_mod_struct) /*4ul*/  + (signed long int)mod->name_len);
  return (union SPF_data_union *)return_value__align_ptr_1;
}

// SPF_mod_data_link1
// file ../../src/include/spf_internal.h line 125
static inline union SPF_data_union * SPF_mod_data_link1(struct SPF_mod_struct *mod_link1)
{
  char *return_value__align_ptr_1_link1;
  return_value__align_ptr_1_link1=_align_ptr_link2((char *)mod_link1 + (signed long int)sizeof(struct SPF_mod_struct) /*4ul*/  + (signed long int)mod_link1->name_len);
  return (union SPF_data_union *)return_value__align_ptr_1_link1;
}

// SPF_mod_data_link2
// file ../../src/include/spf_internal.h line 125
static inline union SPF_data_union * SPF_mod_data_link2(struct SPF_mod_struct *mod_link2)
{
  char *return_value__align_ptr_1_link2;
  return_value__align_ptr_1_link2=_align_ptr_link4((char *)mod_link2 + (signed long int)sizeof(struct SPF_mod_struct) /*4ul*/  + (signed long int)mod_link2->name_len);
  return (union SPF_data_union *)return_value__align_ptr_1_link2;
}

// SPF_mod_end_data
// file ../../src/include/spf_internal.h line 129
static inline union SPF_data_union * SPF_mod_end_data(struct SPF_mod_struct *mod)
{
  union SPF_data_union *return_value_SPF_mod_data_1;
  return_value_SPF_mod_data_1=SPF_mod_data_link1(mod);
  return (union SPF_data_union *)((char *)return_value_SPF_mod_data_1 + (signed long int)mod->data_len);
}

// SPF_mod_len
// file ../../src/include/spf_internal.h line 117
static inline unsigned long int SPF_mod_len(struct SPF_mod_struct *mod)
{
  unsigned long int return_value__align_sz_1;
  return_value__align_sz_1=_align_sz_link1(sizeof(struct SPF_mod_struct) /*4ul*/  + (unsigned long int)mod->name_len);
  return return_value__align_sz_1 + (unsigned long int)mod->data_len;
}

// SPF_mod_len_link1
// file ../../src/include/spf_internal.h line 117
static inline unsigned long int SPF_mod_len_link1(struct SPF_mod_struct *mod_link1)
{
  unsigned long int return_value__align_sz_1_link1;
  return_value__align_sz_1_link1=_align_sz_link2(sizeof(struct SPF_mod_struct) /*4ul*/  + (unsigned long int)mod_link1->name_len);
  return return_value__align_sz_1_link1 + (unsigned long int)mod_link1->data_len;
}

// SPF_mod_name
// file ../../src/include/spf_internal.h line 123
static inline char * SPF_mod_name(struct SPF_mod_struct *mod)
{
  return (char *)mod + (signed long int)sizeof(struct SPF_mod_struct) /*4ul*/ ;
}

// SPF_mod_name_link1
// file ../../src/include/spf_internal.h line 123
static inline char * SPF_mod_name_link1(struct SPF_mod_struct *mod_link1)
{
  return (char *)mod_link1 + (signed long int)sizeof(struct SPF_mod_struct) /*4ul*/ ;
}

// SPF_mod_name_link2
// file ../../src/include/spf_internal.h line 123
static inline char * SPF_mod_name_link2(struct SPF_mod_struct *mod_link2)
{
  return (char *)mod_link2 + (signed long int)sizeof(struct SPF_mod_struct) /*4ul*/ ;
}

// SPF_mod_next
// file ../../src/include/spf_internal.h line 119
static inline struct SPF_mod_struct * SPF_mod_next(struct SPF_mod_struct *mod)
{
  unsigned long int return_value_SPF_mod_len_1;
  return_value_SPF_mod_len_1=SPF_mod_len(mod);
  char *return_value__align_ptr_2;
  return_value__align_ptr_2=_align_ptr_link2((char *)mod + (signed long int)return_value_SPF_mod_len_1);
  return (struct SPF_mod_struct *)return_value__align_ptr_2;
}

// SPF_mod_next_link1
// file ../../src/include/spf_internal.h line 119
static inline struct SPF_mod_struct * SPF_mod_next_link1(struct SPF_mod_struct *mod_link1)
{
  unsigned long int return_value_SPF_mod_len_1_link1;
  return_value_SPF_mod_len_1_link1=SPF_mod_len_link1(mod_link1);
  char *return_value__align_ptr_2_link1;
  return_value__align_ptr_2_link1=_align_ptr_link4((char *)mod_link1 + (signed long int)return_value_SPF_mod_len_1_link1);
  return (struct SPF_mod_struct *)return_value__align_ptr_2_link1;
}

// SPF_print_sizeof
// file spf_print.c line 82
void SPF_print_sizeof(void)
{
  SPF_infox("spf_print.c", 85, "sizeof(SPF_mech_t)=%lu", (unsigned long int)sizeof(struct SPF_mech_struct) /*4ul*/ );
  SPF_infox("spf_print.c", 86, "sizeof(SPF_data_t)=%lu", (unsigned long int)sizeof(union SPF_data_union) /*4ul*/ );
  SPF_infox("spf_print.c", 87, "sizeof(SPF_mod_t)=%lu", (unsigned long int)sizeof(struct SPF_mod_struct) /*4ul*/ );
}

// SPF_recalloc
// file ../../src/include/spf_internal.h line 148
enum SPF_errcode_t SPF_recalloc(char **bufp, unsigned long int *buflenp, unsigned long int buflen)
{
  char *buf;
  if(!(*buflenp >= buflen))
  {
    if(!(buflen >= 64ul))
      buflen = (unsigned long int)64;

    void *return_value_realloc_1;
    return_value_realloc_1=realloc((void *)*bufp, buflen);
    buf = (char *)return_value_realloc_1;
    if(buf == ((char *)NULL))
      return (enum SPF_errcode_t)SPF_E_NO_MEMORY;

    *bufp = buf;
    *buflenp = buflen;
  }

  else
    do
      if(*bufp == ((char *)NULL))
        SPF_errorx("spf_utils.c", 204, "%s", (const void *)"*bufp is NULL");

    while((_Bool)0);
  memset((void *)*bufp, 0, *buflenp);
  return (enum SPF_errcode_t)SPF_E_SUCCESS;
}

// SPF_record_compile
// file spf_compile.c line 1180
enum SPF_errcode_t SPF_record_compile(struct SPF_server_struct *spf_server, struct SPF_response_struct *spf_response, struct SPF_record_struct **spf_recordp, const char *record)
{
  const struct SPF_mechtype_struct *mechtype;
  struct SPF_record_struct *spf_record;
  struct SPF_error_struct *spf_error;
  enum SPF_errcode_t err;
  const char *name_start;
  unsigned long int name_len;
  const char *val_start;
  const char *val_end;
  signed int prefix;
  const char *p;
  signed int i;
  do
    if(spf_server == ((struct SPF_server_struct *)NULL))
      SPF_errorx("spf_compile.c", 1205, "%s", (const void *)"spf_server is NULL");

  while((_Bool)0);
  do
    if(spf_recordp == ((struct SPF_record_struct **)NULL))
      SPF_errorx("spf_compile.c", 1206, "%s", (const void *)"spf_recordp is NULL");

  while((_Bool)0);
  do
    if(record == ((const char *)NULL))
      SPF_errorx("spf_compile.c", 1207, "%s", (const void *)"record is NULL");

  while((_Bool)0);
  if(!(spf_server->debug == 0))
    SPF_debugx("spf_compile.c", 1210, "Compiling record %s", record);

  *spf_recordp = (struct SPF_record_struct *)(void *)0;
  p = record;
  signed int return_value_strncasecmp_2;
  return_value_strncasecmp_2=strncasecmp(p, "v=spf1", sizeof(char [7l]) /*7ul*/  - (unsigned long int)1);
  enum SPF_errcode_t return_value_SPF_response_add_error_ptr_1;
  if(!(return_value_strncasecmp_2 == 0))
  {
    return_value_SPF_response_add_error_ptr_1=SPF_response_add_error_ptr(spf_response, (enum SPF_errcode_t)SPF_E_NOT_SPF, (const char *)(void *)0, p, "Could not find a valid SPF record");
    return return_value_SPF_response_add_error_ptr_1;
  }

  p = p + (signed long int)(sizeof(char [7l]) /*7ul*/  - (unsigned long int)1);
  enum SPF_errcode_t return_value_SPF_response_add_error_ptr_3;
  if(!((signed int)*p == 0))
  {
    if(!((signed int)*p == 32))
    {
      return_value_SPF_response_add_error_ptr_3=SPF_response_add_error_ptr(spf_response, (enum SPF_errcode_t)SPF_E_NOT_SPF, (const char *)(void *)0, p, "Could not find a valid SPF record");
      return return_value_SPF_response_add_error_ptr_3;
    }

  }

  spf_record=SPF_record_new(spf_server, record);
  if(spf_record == ((struct SPF_record_struct *)NULL))
  {
    *spf_recordp = (struct SPF_record_struct *)(void *)0;
    enum SPF_errcode_t return_value_SPF_response_add_error_ptr_4;
    return_value_SPF_response_add_error_ptr_4=SPF_response_add_error_ptr(spf_response, (enum SPF_errcode_t)SPF_E_NO_MEMORY, (const char *)(void *)0, p, "Failed to allocate an SPF record");
    return return_value_SPF_response_add_error_ptr_4;
  }

  spf_record->version = (unsigned char)1;
  *spf_recordp = spf_record;
  const unsigned short int **return_value___ctype_b_loc_5;
  const unsigned short int **return_value___ctype_b_loc_9;
  signed int return_value_strncasecmp_26;
  signed int return_value_strncasecmp_24;
  signed int return_value_strncasecmp_22;
  signed int return_value_strncasecmp_20;
  signed int return_value_strncasecmp_18;
  signed int return_value_strncasecmp_16;
  signed int return_value_strncasecmp_14;
  signed int return_value_strncasecmp_12;
  signed int return_value_strncasecmp_10;
  signed int return_value_strncasecmp_29;
  while(!((signed int)*p == 0))
  {
    for( ; (signed int)*p == 32; p = p + 1l)
      ;
    if((signed int)*p == 0)
      break;

    prefix = SPF_RESULT_PERMERROR;
    switch((signed int)*p)
    {
      case 43:
      {
        prefix = SPF_RESULT_PASS;
        p = p + 1l;
        break;
      }
      case 45:
      {
        prefix = SPF_RESULT_FAIL;
        p = p + 1l;
        break;
      }
      case 126:
      {
        prefix = SPF_RESULT_SOFTFAIL;
        p = p + 1l;
        break;
      }
      case 63:
      {
        prefix = SPF_RESULT_NEUTRAL;
        p = p + 1l;
        break;
      }
      default:
        do
        {
          return_value___ctype_b_loc_5=__ctype_b_loc();
          if((4 & (signed int)(*return_value___ctype_b_loc_5)[(signed long int)(signed int)(unsigned char)*p]) == 0)
            break;

          SPF_response_add_error_ptr(spf_response, (enum SPF_errcode_t)SPF_E_INVALID_PREFIX, (const char *)(void *)0, p, "Invalid prefix '%c'", *p);
          p = p + 1l;
        }
        while((_Bool)1);
    }
    name_start = p;
    unsigned long int return_value_strcspn_6;
    return_value_strcspn_6=strcspn(p, " ");
    val_end = name_start + (signed long int)return_value_strcspn_6;
    const unsigned short int **return_value___ctype_b_loc_8;
    return_value___ctype_b_loc_8=__ctype_b_loc();
    if((1024 & (signed int)(*return_value___ctype_b_loc_8)[(signed long int)(signed int)(unsigned char)*p]) == 0)
    {
      SPF_response_add_error_ptr(spf_response, (enum SPF_errcode_t)SPF_E_INVALID_CHAR, (const char *)(void *)0, p, "Invalid character at start of mechanism");
      unsigned long int return_value_strcspn_7;
      return_value_strcspn_7=strcspn(p, " ");
      p = p + (signed long int)return_value_strcspn_7;
      continue;
    }

    do
    {
      return_value___ctype_b_loc_9=__ctype_b_loc();
      if((8 & (signed int)(*return_value___ctype_b_loc_9)[(signed long int)(signed int)(unsigned char)*p]) == 0)
      {
        if(!((signed int)*p == 95))
        {
          if(!((signed int)*p == 45))
            break;

        }

      }

      p = p + 1l;
    }
    while((_Bool)1);
    name_len = (unsigned long int)(p - name_start);
    if(!(spf_server->debug == 0))
      SPF_debugx("spf_compile.c", 1314, "Name starts at  %s", name_start);

    switch((signed int)*p)
    {
      case 58:

      case 47:

      case 32:

      case 0:
      {

      compile_mech:
        ;
        if(prefix == SPF_RESULT_PERMERROR)
          prefix = SPF_RESULT_PASS;

        _Bool tmp_if_expr_27;
        if(name_len == 1ul)
        {
          return_value_strncasecmp_26=strncasecmp(name_start, "a", name_len);
          tmp_if_expr_27 = return_value_strncasecmp_26 == 0 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_27 = (_Bool)0;
        if(tmp_if_expr_27)
          mechtype=SPF_mechtype_find(1);

        else
        {
          _Bool tmp_if_expr_25;
          if(name_len == 2ul)
          {
            return_value_strncasecmp_24=strncasecmp(name_start, "mx", name_len);
            tmp_if_expr_25 = return_value_strncasecmp_24 == 0 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_25 = (_Bool)0;
          if(tmp_if_expr_25)
            mechtype=SPF_mechtype_find(2);

          else
          {
            _Bool tmp_if_expr_23;
            if(name_len == 3ul)
            {
              return_value_strncasecmp_22=strncasecmp(name_start, "ptr", name_len);
              tmp_if_expr_23 = return_value_strncasecmp_22 == 0 ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr_23 = (_Bool)0;
            if(tmp_if_expr_23)
              mechtype=SPF_mechtype_find(3);

            else
            {
              _Bool tmp_if_expr_21;
              if(name_len == 7ul)
              {
                return_value_strncasecmp_20=strncasecmp(name_start, "include", name_len);
                tmp_if_expr_21 = return_value_strncasecmp_20 == 0 ? (_Bool)1 : (_Bool)0;
              }

              else
                tmp_if_expr_21 = (_Bool)0;
              if(tmp_if_expr_21)
                mechtype=SPF_mechtype_find(4);

              else
              {
                _Bool tmp_if_expr_19;
                if(name_len == 3ul)
                {
                  return_value_strncasecmp_18=strncasecmp(name_start, "ip4", name_len);
                  tmp_if_expr_19 = return_value_strncasecmp_18 == 0 ? (_Bool)1 : (_Bool)0;
                }

                else
                  tmp_if_expr_19 = (_Bool)0;
                if(tmp_if_expr_19)
                  mechtype=SPF_mechtype_find(5);

                else
                {
                  _Bool tmp_if_expr_17;
                  if(name_len == 3ul)
                  {
                    return_value_strncasecmp_16=strncasecmp(name_start, "ip6", name_len);
                    tmp_if_expr_17 = return_value_strncasecmp_16 == 0 ? (_Bool)1 : (_Bool)0;
                  }

                  else
                    tmp_if_expr_17 = (_Bool)0;
                  if(tmp_if_expr_17)
                    mechtype=SPF_mechtype_find(6);

                  else
                  {
                    _Bool tmp_if_expr_15;
                    if(name_len == 6ul)
                    {
                      return_value_strncasecmp_14=strncasecmp(name_start, "exists", name_len);
                      tmp_if_expr_15 = return_value_strncasecmp_14 == 0 ? (_Bool)1 : (_Bool)0;
                    }

                    else
                      tmp_if_expr_15 = (_Bool)0;
                    if(tmp_if_expr_15)
                      mechtype=SPF_mechtype_find(7);

                    else
                    {
                      _Bool tmp_if_expr_13;
                      if(name_len == 3ul)
                      {
                        return_value_strncasecmp_12=strncasecmp(name_start, "all", name_len);
                        tmp_if_expr_13 = return_value_strncasecmp_12 == 0 ? (_Bool)1 : (_Bool)0;
                      }

                      else
                        tmp_if_expr_13 = (_Bool)0;
                      if(tmp_if_expr_13)
                        mechtype=SPF_mechtype_find(8);

                      else
                      {
                        _Bool tmp_if_expr_11;
                        if(name_len == 8ul)
                        {
                          return_value_strncasecmp_10=strncasecmp(name_start, "redirect", name_len);
                          tmp_if_expr_11 = return_value_strncasecmp_10 == 0 ? (_Bool)1 : (_Bool)0;
                        }

                        else
                          tmp_if_expr_11 = (_Bool)0;
                        if(tmp_if_expr_11)
                          mechtype=SPF_mechtype_find(9);

                        else
                        {
                          SPF_response_add_error_ptr(spf_response, (enum SPF_errcode_t)SPF_E_UNKNOWN_MECH, (const char *)(void *)0, name_start, "Unknown mechanism found");
                          p = val_end;
                          goto __CPROVER_DUMP_L72;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        if(mechtype == ((const struct SPF_mechtype_struct *)NULL))
        {
          enum SPF_errcode_t return_value_SPF_response_add_error_ptr_28;
          return_value_SPF_response_add_error_ptr_28=SPF_response_add_error_ptr(spf_response, (enum SPF_errcode_t)SPF_E_INTERNAL_ERROR, (const char *)(void *)0, name_start, "Failed to find specification for a recognised mechanism");
          return return_value_SPF_response_add_error_ptr_28;
        }

        if(!(spf_server->debug == 0))
          SPF_debugx("spf_compile.c", 1408, "Adding mechanism type %d", (signed int)mechtype->mech_type);

        val_start = p;
        err=SPF_c_mech_add(spf_server, spf_record, spf_response, mechtype, prefix, &val_start);
        if((signed int)err == SPF_E_NO_MEMORY)
          return err;

        p = val_end;
        break;
      }
      case 61:
      {
        if(!(prefix == SPF_RESULT_PERMERROR))
          SPF_response_add_error_ptr(spf_response, (enum SPF_errcode_t)SPF_E_MOD_W_PREF, (const char *)(void *)0, name_start, "Modifiers may not have prefixes");

        prefix = SPF_RESULT_PERMERROR;
        return_value_strncasecmp_29=strncasecmp(name_start, "redirect=", sizeof(char [10l]) /*10ul*/  - (unsigned long int)1);
        if(return_value_strncasecmp_29 == 0)
          goto compile_mech;

        p = p + 1l;
        val_start = p;
        err=SPF_c_mod_add(spf_server, spf_record, spf_response, name_start, name_len, &val_start);
        if((signed int)err == SPF_E_NO_MEMORY)
          return err;

        p = val_end;
        break;
      }
      default:
      {
        SPF_response_add_error_ptr(spf_response, (enum SPF_errcode_t)SPF_E_INVALID_CHAR, (const char *)(void *)0, p, "Invalid character in middle of mechanism");
        p = val_end;
      }
    }

  __CPROVER_DUMP_L72:
    ;
  }
  SPF_record_lint(spf_server, spf_response, spf_record);
  signed int return_value_SPF_response_errors_34;
  return_value_SPF_response_errors_34=SPF_response_errors(spf_response);
  signed int return_value_SPF_response_messages_30;
  enum SPF_errcode_t return_value_SPF_error_code_31;
  if(return_value_SPF_response_errors_34 >= 1)
  {
    i = 0;
    do
    {
      return_value_SPF_response_messages_30=SPF_response_messages(spf_response);
      if(i >= return_value_SPF_response_messages_30)
        break;

      spf_error=SPF_response_message(spf_response, i);
      char return_value_SPF_error_errorp_32;
      return_value_SPF_error_errorp_32=SPF_error_errorp(spf_error);
      if(!(return_value_SPF_error_errorp_32 == 0))
      {
        return_value_SPF_error_code_31=SPF_error_code(spf_error);
        return return_value_SPF_error_code_31;
      }

      i = i + 1;
    }
    while((_Bool)1);
    enum SPF_errcode_t return_value_SPF_response_add_error_33;
    return_value_SPF_response_add_error_33=SPF_response_add_error(spf_response, (enum SPF_errcode_t)SPF_E_INTERNAL_ERROR, "Response has errors but can't find one!");
    return return_value_SPF_response_add_error_33;
  }

  return (enum SPF_errcode_t)SPF_E_SUCCESS;
}

// SPF_record_compile_macro
// file spf_compile.c line 1499
enum SPF_errcode_t SPF_record_compile_macro(struct SPF_server_struct *spf_server, struct SPF_response_struct *spf_response, struct SPF_macro_struct **spf_macrop, const char *record)
{
  /* tag-#anon#lUN[F64'd'|S64'l'|lARR519{S8}_S8_'buf'|U4160'_pad'] */
union anonymous_6
{
  // d
  double d;
  // l
  signed long int l;
  // buf
  char buf[(signed long int)(sizeof(struct SPF_macro_struct) * 64 + 7) /*519l*/ ];
};

/* */
  ;
  union anonymous_6 u;
  struct SPF_macro_struct *spf_macro = (struct SPF_macro_struct *)u.buf;
  union SPF_data_union *data;
  enum SPF_errcode_t err;
  unsigned long int size;
  data=SPF_macro_data(spf_macro);
  spf_macro->macro_len = (unsigned long int)0;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(record);
  err=SPF_c_parse_macro(spf_server, spf_response, data, &spf_macro->macro_len, (unsigned long int)511, record, return_value_strlen_1, (enum SPF_errcode_t)SPF_E_BIG_MOD, 1);
  if(!((signed int)err == SPF_E_SUCCESS))
    return err;

  else
  {
    size = sizeof(struct SPF_macro_struct) /*8ul*/  + spf_macro->macro_len;
    void *return_value_malloc_2;
    return_value_malloc_2=malloc(size);
    *spf_macrop = (struct SPF_macro_struct *)return_value_malloc_2;
    if(*spf_macrop == ((struct SPF_macro_struct *)NULL))
      return (enum SPF_errcode_t)SPF_E_NO_MEMORY;

    else
    {
      memcpy((void *)*spf_macrop, (const void *)u.buf, size);
      return (enum SPF_errcode_t)SPF_E_SUCCESS;
    }
  }
}

// SPF_record_expand_data
// file spf_expand.c line 81
enum SPF_errcode_t SPF_record_expand_data(struct SPF_server_struct *spf_server, struct SPF_request_struct *spf_request, struct SPF_response_struct *spf_response, union SPF_data_union *data, unsigned long int data_len, char **bufp, unsigned long int *buflenp)
{
  union SPF_data_union *d;
  union SPF_data_union *data_end;
  unsigned long int len;
  const char *p_err;
  char *p;
  char *p_end;
  const char *p_read;
  const char *p_read_end;
  char *p_write;
  char *p2;
  char *p2_end;
  const char *var;
  char *munged_var = (char *)(void *)0;
  char *url_var = (char *)(void *)0;
  char ip4_buf[16l];
  char ip6_buf[46l];
  char ip6_rbuf[65l];
  char time_buf[(signed long int)sizeof(char [11l]) /*11l*/ ];
  signed int num_found;
  signed int i;
  unsigned long int buflen;
  signed int compute_length;
  enum SPF_errcode_t err;
  do
    if(spf_server == ((struct SPF_server_struct *)NULL))
      SPF_errorx("spf_expand.c", 120, "%s", (const void *)"spf_server is NULL");

  while((_Bool)0);
  do
    if(data == ((union SPF_data_union *)NULL))
      SPF_errorx("spf_expand.c", 121, "%s", (const void *)"data is NULL");

  while((_Bool)0);
  do
    if(bufp == ((char **)NULL))
      SPF_errorx("spf_expand.c", 122, "%s", (const void *)"bufp is NULL");

  while((_Bool)0);
  do
    if(buflenp == ((unsigned long int *)NULL))
      SPF_errorx("spf_expand.c", 123, "%s", (const void *)"buflenp is NULL");

  while((_Bool)0);
  buflen = (unsigned long int)1;
  compute_length = 1;
  p = (char *)(void *)0;
  p_end = (char *)(void *)0;
  data_end = (union SPF_data_union *)((char *)data + (signed long int)data_len);
  signed long int return_value_time_3;
  do
  {

  top:
    ;
    d = data;
    while(!(d >= data_end))
    {
      if(!((signed int)d->dc.parm_type == 11))
      {
        if((signed int)d->ds.parm_type == 12)
        {
          if(!(compute_length == 0))
          {
            buflen = buflen + (unsigned long int)d->ds.len;
            goto __CPROVER_DUMP_L73;
          }

          if(!(p_end - (p + (signed long int)d->ds.len) >= 1l))
            SPF_errorx("spf_expand.c", 155, "%s", (const void *)"Failed to allocate enough memory to expand string.");

          char *return_value_SPF_data_str_1;
          return_value_SPF_data_str_1=SPF_data_str_link1(d);
          memcpy((void *)p, (const void *)return_value_SPF_data_str_1, (unsigned long int)d->ds.len);
          p = p + (signed long int)d->ds.len;
          goto __CPROVER_DUMP_L73;
        }

        var = (const char *)(void *)0;
        switch((signed int)d->dv.parm_type)
        {
          case 0:
          {
            var = spf_request->env_from_lp;
            break;
          }
          case 1:
          {
            var = spf_request->env_from;
            break;
          }
          case 2:
          {
            var = spf_request->env_from_dp;
            break;
          }
          case 3:
          {
            var = spf_request->cur_dom;
            break;
          }
          case 4:
          {
            if(!(compute_length == 0))
            {
              len = sizeof(char [65l]) /*65ul*/ ;
              if(!(d->dv.url_encode == 0))
                len = len * (unsigned long int)3;

              buflen = buflen + len;
              goto __CPROVER_DUMP_L73;
            }

            if(spf_request->client_ver == 2)
            {
              p_err=inet_ntop(2, (const void *)&spf_request->ipv4, ip4_buf, (unsigned int)sizeof(char [16l]) /*16ul*/ );
              var = ip4_buf;
            }

            else
              if(spf_request->client_ver == 10)
              {
                p2 = ip6_rbuf;
                p2_end = p2 + (signed long int)sizeof(char [65l]) /*65ul*/ ;
                i = 0;
                for( ; !((signed long int)i >= (signed long int)sizeof(unsigned char [16l]) /*16l*/ ); i = i + 1)
                {
                  signed int return_value_snprintf_2;
                  return_value_snprintf_2=snprintf(p2, (unsigned long int)(p2_end - p2), "%.1x.%.1x.", (signed int)spf_request->ipv6.__in6_u.__u6_addr8[(signed long int)i] >> 4, (signed int)spf_request->ipv6.__in6_u.__u6_addr8[(signed long int)i] & 0xf);
                  p2 = p2 + (signed long int)return_value_snprintf_2;
                }
                ip6_rbuf[(signed long int)(sizeof(struct in6_addr) /*16ul*/  * (unsigned long int)4 - (unsigned long int)1)] = (char)0;
                var = ip6_rbuf;
              }

            break;
          }
          case 5:
          {
            if(!(compute_length == 0))
            {
              len = sizeof(char [65l]) /*65ul*/ ;
              if(!(d->dv.url_encode == 0))
                len = len * (unsigned long int)3;

              buflen = buflen + len;
              goto __CPROVER_DUMP_L73;
            }

            if(spf_request->client_ver == 2)
            {
              p_err=inet_ntop(2, (const void *)&spf_request->ipv4, ip4_buf, (unsigned int)sizeof(char [16l]) /*16ul*/ );
              var = ip4_buf;
            }

            else
              if(spf_request->client_ver == 10)
              {
                p_err=inet_ntop(10, (const void *)&spf_request->ipv6, ip6_buf, (unsigned int)sizeof(char [46l]) /*46ul*/ );
                var = ip6_buf;
              }

            break;
          }
          case 6:
          {
            if(!(compute_length == 0))
            {
              len = sizeof(char [11l]) /*11ul*/ ;
              buflen = buflen + len;
              goto __CPROVER_DUMP_L73;
            }

            return_value_time_3=time((signed long int *)(void *)0);
            snprintf(time_buf, sizeof(char [11l]) /*11ul*/ , "%ld", (signed long int)return_value_time_3);
            var = time_buf;
            break;
          }
          case 7:
          {
            var=SPF_request_get_client_dom(spf_request);
            if(var == ((const char *)NULL))
              return (enum SPF_errcode_t)SPF_E_NO_MEMORY;

            break;
          }
          case 8:
          {
            if(spf_request->client_ver == 2)
              var = client_ver_ipv4;

            else
              if(spf_request->client_ver == 10)
                var = client_ver_ipv6;

            break;
          }
          case 9:
          {
            var = spf_request->helo_dom;
            break;
          }
          case 10:
          {
            var=SPF_request_get_rec_dom(spf_request);
            break;
          }
          default:
            return (enum SPF_errcode_t)SPF_E_INVALID_VAR;
        }
        if(var == ((const char *)NULL))
          return (enum SPF_errcode_t)SPF_E_UNINIT_VAR;

        len=strlen(var);
        if(!(compute_length == 0))
        {
          if(!(d->dv.url_encode == 0))
            len = len * (unsigned long int)3;

          buflen = buflen + len;
        }

        else
        {
          void *return_value_malloc_4;
          return_value_malloc_4=malloc(len + (unsigned long int)1);
          munged_var = (char *)return_value_malloc_4;
          if(munged_var == ((char *)NULL))
            return (enum SPF_errcode_t)SPF_E_NO_MEMORY;

          memset((void *)munged_var, 0, len + (unsigned long int)1);
          p_read_end = var + (signed long int)len;
          p_write = munged_var;
          if(!(d->dv.rev == 0))
          {
            p_read = p_read_end - (signed long int)1;
            while(p_read >= var)
            {
              signed int return_value_SPF_delim_valid_6;
              return_value_SPF_delim_valid_6=SPF_delim_valid(d, *p_read);
              if(!(return_value_SPF_delim_valid_6 == 0))
              {
                len = (unsigned long int)((p_read_end - p_read) - (signed long int)1);
                memcpy((void *)p_write, (const void *)(p_read + (signed long int)1), len);
                p_write = p_write + (signed long int)len;
                char *tmp_post_5 = p_write;
                p_write = p_write + 1l;
                *tmp_post_5 = (char)46;
                p_read_end = p_read;
              }

              p_read = p_read - 1l;
            }
            if(p_read_end >= p_read)
            {
              len = (unsigned long int)((p_read_end - p_read) - (signed long int)1);
              memcpy((void *)p_write, (const void *)(p_read + (signed long int)1), len);
              p_write = p_write + (signed long int)len;
              char *tmp_post_7 = p_write;
              p_write = p_write + 1l;
              *tmp_post_7 = (char)46;
            }

            p_write = p_write - 1l;
            *p_write = (char)0;
          }

          else
          {
            p_read = var;
            while(!(p_read >= p_read_end))
            {
              signed int return_value_SPF_delim_valid_10;
              return_value_SPF_delim_valid_10=SPF_delim_valid(d, *p_read);
              if(!(return_value_SPF_delim_valid_10 == 0))
              {
                char *tmp_post_8 = p_write;
                p_write = p_write + 1l;
                *tmp_post_8 = (char)46;
              }

              else
              {
                char *tmp_post_9 = p_write;
                p_write = p_write + 1l;
                *tmp_post_9 = *p_read;
              }
              p_read = p_read + 1l;
            }
            *p_write = (char)0;
          }
          if((signed int)d->dv.num_rhs >= 1)
          {
            p_read_end = munged_var + (signed long int)len;
            p_write = (munged_var + (signed long int)len) - (signed long int)1;
            num_found = 0;
            for( ; !(munged_var >= p_write); p_write = p_write - 1l)
            {
              if((signed int)*p_write == 46)
                num_found = num_found + 1;

              if(num_found == (signed int)d->dv.num_rhs)
                break;

            }
            p_write = p_write + 1l;
            len = (unsigned long int)(p_read_end - p_write);
            memmove((void *)munged_var, (const void *)p_write, len + (unsigned long int)1);
          }

          var = munged_var;
          if(!(d->dv.url_encode == 0))
          {
            void *return_value_malloc_11;
            return_value_malloc_11=malloc(len * (unsigned long int)3 + (unsigned long int)1);
            url_var = (char *)return_value_malloc_11;
            if(url_var == ((char *)NULL))
            {
              if(!(munged_var == ((char *)NULL)))
                free((void *)munged_var);

              return (enum SPF_errcode_t)SPF_E_NO_MEMORY;
            }

            p_read = var;
            p_write = url_var;
            while(!((signed int)*p_read == 0))
            {
              const unsigned short int **return_value___ctype_b_loc_16;
              return_value___ctype_b_loc_16=__ctype_b_loc();
              if(!((8 & (signed int)(*return_value___ctype_b_loc_16)[(signed long int)(signed int)(unsigned char)*p_read]) == 0))
              {
                char *tmp_post_12 = p_write;
                p_write = p_write + 1l;
                const char *tmp_post_13 = p_read;
                p_read = p_read + 1l;
                *tmp_post_12 = *tmp_post_13;
              }

              else
              {
                if((signed int)*p_read == 33 || (signed int)*p_read == 39 || (signed int)*p_read == 40 || (signed int)*p_read == 41 || (signed int)*p_read == 42 || (signed int)*p_read == 45 || (signed int)*p_read == 46 || (signed int)*p_read == 95 || (signed int)*p_read == 126)
                {
                  char *tmp_post_14 = p_write;
                  p_write = p_write + 1l;
                  const char *tmp_post_15 = p_read;
                  p_read = p_read + 1l;
                  *tmp_post_14 = *tmp_post_15;
                  goto __CPROVER_DUMP_L65;
                }

                sprintf(p_write, "%%%02x", *p_read);
                p_write = p_write + (signed long int)3;
                p_read = p_read + 1l;
              }

            __CPROVER_DUMP_L65:
              ;
            }
            *p_write = (char)0;
            var = url_var;
            len = (unsigned long int)(p_write - url_var);
          }

          signed int return_value_snprintf_17;
          return_value_snprintf_17=snprintf(p, (unsigned long int)(p_end - p), "%s", var);
          len = (unsigned long int)return_value_snprintf_17;
          p = p + (signed long int)len;
          if(!(p_end - p >= 1l))
          {
            if(!(munged_var == ((char *)NULL)))
              free((void *)munged_var);

            if(!(url_var == ((char *)NULL)))
              free((void *)url_var);

            return (enum SPF_errcode_t)SPF_E_INTERNAL_ERROR;
          }

          if(!(munged_var == ((char *)NULL)))
            free((void *)munged_var);

          munged_var = (char *)(void *)0;
          if(!(url_var == ((char *)NULL)))
            free((void *)url_var);

          url_var = (char *)(void *)0;
        }
      }


    __CPROVER_DUMP_L73:
      ;
      d=SPF_data_next_link1(d);
    }
    if(compute_length == 0)
      break;

    compute_length = 0;
    err=SPF_recalloc(bufp, buflenp, buflen);
    if(!((signed int)err == SPF_E_SUCCESS))
      return err;

    p = *bufp;
    p_end = *bufp + (signed long int)*buflenp;
  }
  while((_Bool)1);
  char *tmp_post_18 = p;
  p = p + 1l;
  *tmp_post_18 = (char)0;
  return (enum SPF_errcode_t)SPF_E_SUCCESS;
}

// SPF_record_find_mod_data
// file spf_record.c line 80
static enum SPF_errcode_t SPF_record_find_mod_data(struct SPF_record_struct *spf_record, const char *mod_name, union SPF_data_union **datap, unsigned long int *datalenp)
{
  struct SPF_mod_struct *mod;
  unsigned long int name_len;
  signed int i;
  name_len=strlen(mod_name);
  do
    if(spf_record == ((struct SPF_record_struct *)NULL))
      SPF_errorx("spf_record.c", 94, "%s", (const void *)"spf_record is NULL");

  while((_Bool)0);
  do
    if(mod_name == ((const char *)NULL))
      SPF_errorx("spf_record.c", 95, "%s", (const void *)"mod_name is NULL");

  while((_Bool)0);
  do
    if(datap == ((union SPF_data_union **)NULL))
      SPF_errorx("spf_record.c", 96, "%s", (const void *)"datap is NULL");

  while((_Bool)0);
  do
    if(datalenp == ((unsigned long int *)NULL))
      SPF_errorx("spf_record.c", 97, "%s", (const void *)"datalenp is NULL");

  while((_Bool)0);
  mod = spf_record->mod_first;
  i = 0;
  char *return_value_SPF_mod_name_1;
  signed int return_value_strncasecmp_2;
  for( ; !(i >= (signed int)spf_record->num_mod); i = i + 1)
  {
    if(name_len == (unsigned long int)mod->name_len)
    {
      return_value_SPF_mod_name_1=SPF_mod_name_link2(mod);
      return_value_strncasecmp_2=strncasecmp(return_value_SPF_mod_name_1, mod_name, name_len);
      if(return_value_strncasecmp_2 == 0)
      {
        *datap=SPF_mod_data_link2(mod);
        *datalenp = (unsigned long int)mod->data_len;
        return (enum SPF_errcode_t)0;
      }

    }

    mod=SPF_mod_next_link1(mod);
  }
  return (enum SPF_errcode_t)SPF_E_MOD_NOT_FOUND;
}

// SPF_record_find_mod_value
// file ../../src/include/spf_record.h line 238
enum SPF_errcode_t SPF_record_find_mod_value(struct SPF_server_struct *spf_server, struct SPF_request_struct *spf_request, struct SPF_response_struct *spf_response, struct SPF_record_struct *spf_record, const char *mod_name, char **bufp, unsigned long int *buflenp)
{
  union SPF_data_union *data;
  unsigned long int data_len;
  enum SPF_errcode_t err;
  do
    if(spf_record == ((struct SPF_record_struct *)NULL))
      SPF_errorx("spf_record.c", 140, "%s", (const void *)"spf_record is NULL");

  while((_Bool)0);
  do
    if(mod_name == ((const char *)NULL))
      SPF_errorx("spf_record.c", 141, "%s", (const void *)"mod_name is NULL");

  while((_Bool)0);
  do
    if(bufp == ((char **)NULL))
      SPF_errorx("spf_record.c", 142, "%s", (const void *)"bufp is NULL");

  while((_Bool)0);
  do
    if(buflenp == ((unsigned long int *)NULL))
      SPF_errorx("spf_record.c", 143, "%s", (const void *)"buflenp is NULL");

  while((_Bool)0);
  err=SPF_record_find_mod_data(spf_record, mod_name, &data, &data_len);
  if(!(err == /*enum*/SPF_E_SUCCESS))
    return err;

  else
  {
    enum SPF_errcode_t return_value_SPF_record_expand_data_1;
    return_value_SPF_record_expand_data_1=SPF_record_expand_data(spf_server, spf_request, spf_response, data, data_len, bufp, buflenp);
    return return_value_SPF_record_expand_data_1;
  }
}

// SPF_record_free
// file ../../src/include/spf_record.h line 230
void SPF_record_free(struct SPF_record_struct *rp)
{
  if(!(rp->mech_first == ((struct SPF_mech_struct *)NULL)))
    free((void *)rp->mech_first);

  if(!(rp->mod_first == ((struct SPF_mod_struct *)NULL)))
    free((void *)rp->mod_first);

  free((void *)rp);
}

// SPF_record_interpret
// file spf_interpret.c line 585
enum SPF_errcode_t SPF_record_interpret(struct SPF_record_struct *spf_record, struct SPF_request_struct *spf_request, struct SPF_response_struct *spf_response, signed int depth)
{
  struct SPF_server_struct *SPF_record_interpret__1__spf_server;
  signed int i;
  signed int j;
  signed int m;
  struct SPF_mech_struct *mech;
  union SPF_data_union *data;
  union SPF_data_union *data_end;
  struct SPF_mech_struct *local_policy;
  signed int found_all;
  char *buf = (char *)(void *)0;
  unsigned long int buf_len = (unsigned long int)0;
  enum __ns_type fetch_ns_type;
  const char *lookup;
  struct SPF_dns_rr_struct *rr_a;
  struct SPF_dns_rr_struct *rr_aaaa;
  struct SPF_dns_rr_struct *rr_ptr;
  struct SPF_dns_rr_struct *rr_mx;
  enum SPF_errcode_t err;
  struct SPF_dns_server_struct *resolver;
  struct SPF_record_struct *spf_record_subr;
  struct SPF_response_struct *save_spf_response;
  struct SPF_response_struct *spf_response_subr;
  const char *save_cur_dom;
  struct in_addr addr4;
  struct in6_addr addr6;
  signed int max_ptr;
  signed int max_mx;
  signed int max_exceeded;
  char ip4_buf[16l];
  char ip6_buf[46l];
  do
    if(spf_record == ((struct SPF_record_struct *)NULL))
      SPF_errorx("spf_interpret.c", 637, "%s", (const void *)"spf_record is NULL");

  while((_Bool)0);
  do
    if(spf_request == ((struct SPF_request_struct *)NULL))
      SPF_errorx("spf_interpret.c", 638, "%s", (const void *)"spf_request is NULL");

  while((_Bool)0);
  do
    if(spf_response == ((struct SPF_response_struct *)NULL))
      SPF_errorx("spf_interpret.c", 639, "%s", (const void *)"spf_response is NULL");

  while((_Bool)0);
  SPF_record_interpret__1__spf_server = spf_record->spf_server;
  do
    if(SPF_record_interpret__1__spf_server == ((struct SPF_server_struct *)NULL))
      SPF_errorx("spf_interpret.c", 641, "%s", (const void *)"spf_server is NULL");

  while((_Bool)0);
  do
    if(spf_response->spf_record_exp == ((struct SPF_record_struct *)NULL))
      SPF_errorx("spf_interpret.c", 643, "%s", (const void *)"spf_response->spf_record_exp is NULL");

  while((_Bool)0);
  enum SPF_errcode_t return_value_SPF_i_done_1;
  if(depth >= 21)
  {
    return_value_SPF_i_done_1=SPF_i_done(spf_response, (enum SPF_result_enum)SPF_RESULT_PERMERROR, (enum SPF_reason_enum)SPF_REASON_NONE, (enum SPF_errcode_t)SPF_E_RECURSIVE);
    return return_value_SPF_i_done_1;
  }

  enum SPF_errcode_t return_value_SPF_i_done_2;
  if(!(spf_request->client_ver == 2))
  {
    if(!(spf_request->client_ver == 10))
    {
      return_value_SPF_i_done_2=SPF_i_done(spf_response, (enum SPF_result_enum)SPF_RESULT_PERMERROR, (enum SPF_reason_enum)SPF_REASON_NONE, (enum SPF_errcode_t)SPF_E_NOT_CONFIG);
      return return_value_SPF_i_done_2;
    }

  }

  enum SPF_errcode_t return_value_SPF_i_done_3;
  if(spf_request->cur_dom == ((const char *)NULL))
  {
    return_value_SPF_i_done_3=SPF_i_done(spf_response, (enum SPF_result_enum)SPF_RESULT_PERMERROR, (enum SPF_reason_enum)SPF_REASON_NONE, (enum SPF_errcode_t)SPF_E_NOT_CONFIG);
    return return_value_SPF_i_done_3;
  }

  local_policy = (struct SPF_mech_struct *)(void *)0;
  if(!(spf_request->use_local_policy == 0))
  {
    if(!(SPF_record_interpret__1__spf_server->local_policy == ((struct SPF_record_struct *)NULL)))
    {
      mech = spf_record->mech_first;
      found_all = 0;
      m = 0;
      for( ; !(m >= (signed int)spf_record->num_mech); m = m + 1)
      {
        if((signed int)mech->mech_type == 8)
        {
          _Bool tmp_if_expr_4;
          if((signed int)mech->prefix_type == SPF_RESULT_FAIL)
            tmp_if_expr_4 = (_Bool)1;

          else
            tmp_if_expr_4 = (signed int)mech->prefix_type == SPF_RESULT_PERMERROR ? (_Bool)1 : (_Bool)0;
          _Bool tmp_if_expr_5;
          if(tmp_if_expr_4)
            tmp_if_expr_5 = (_Bool)1;

          else
            tmp_if_expr_5 = (signed int)mech->prefix_type == SPF_RESULT_SOFTFAIL ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr_5)
            found_all = 1;

        }

        if(!((signed int)mech->prefix_type == SPF_RESULT_FAIL))
        {
          if(!((signed int)mech->prefix_type == SPF_RESULT_SOFTFAIL))
            local_policy = mech;

        }

        mech=SPF_mech_next_link2(mech);
      }
      if(found_all == 0)
        local_policy = (struct SPF_mech_struct *)(void *)0;

    }

  }

  resolver = SPF_record_interpret__1__spf_server->resolver;
  mech = spf_record->mech_first;
  m = 0;
  union SPF_data_union *return_value_SPF_mech_data_40;
  unsigned long int return_value_SPF_mech_data_len_41;
  signed int return_value_strcmp_45;
  const char *return_value_SPF_strerror_46;
  enum SPF_errcode_t return_value_SPF_i_done_47;
  enum SPF_errcode_t return_value_SPF_i_done_48;
  const char *return_value_SPF_strerror_50;
  const char *return_value_SPF_strresult_51;
  const char *return_value_SPF_strreason_52;
  enum SPF_errcode_t return_value_SPF_i_done_54;
  enum SPF_errcode_t return_value_SPF_i_done_55;
  enum SPF_errcode_t return_value_SPF_i_done_56;
  enum SPF_errcode_t return_value_SPF_i_done_57;
  struct in_addr *return_value_SPF_mech_ip4_data_58;
  signed int return_value_SPF_i_match_ip4_60;
  struct in6_addr *return_value_SPF_mech_ip6_data_61;
  signed int return_value_SPF_i_match_ip6_63;
  union SPF_data_union *return_value_SPF_mech_data_64;
  unsigned long int return_value_SPF_mech_data_len_65;
  enum SPF_errcode_t return_value_SPF_i_done_69;
  enum SPF_errcode_t return_value_SPF_i_done_70;
  enum SPF_errcode_t return_value_SPF_i_done_71;
  const char *return_value_SPF_strerror_72;
  const char *return_value_SPF_strresult_73;
  const char *return_value_SPF_strreason_74;
  for( ; !(m >= (signed int)spf_record->num_mech); m = m + 1)
  {
    if(!(SPF_record_interpret__1__spf_server->max_dns_mech >= spf_response->num_dns_mech))
    {
      do
        if(!(buf == ((char *)NULL)))
        {
          free((void *)buf);
          buf = (char *)(void *)0;
        }

      while((_Bool)0);
      enum SPF_errcode_t return_value_SPF_i_done_6;
      return_value_SPF_i_done_6=SPF_i_done(spf_response, (enum SPF_result_enum)SPF_RESULT_PERMERROR, (enum SPF_reason_enum)SPF_REASON_NONE, (enum SPF_errcode_t)SPF_E_BIG_DNS);
      return return_value_SPF_i_done_6;
    }

    data=SPF_mech_data_link2(mech);
    data_end=SPF_mech_end_data_link2(mech);
    switch((signed int)mech->mech_type)
    {
      case 1:
      {
        do
          spf_response->num_dns_mech = spf_response->num_dns_mech + 1;
        while((_Bool)0);
        do
          if(!(data >= data_end))
          {
            if((signed int)data->dc.parm_type == 11)
              data=SPF_data_next_link3(data);

          }

        while((_Bool)0);
        do
          if(data == data_end)
            lookup = spf_request->cur_dom;

          else
          {
            err=SPF_record_expand_data(SPF_record_interpret__1__spf_server, spf_request, spf_response, data, (unsigned long int)((char *)data_end - (char *)data), &buf, &buf_len);
            if((signed int)err == SPF_E_NO_MEMORY)
            {
              do
                if(!(buf == ((char *)NULL)))
                {
                  free((void *)buf);
                  buf = (char *)(void *)0;
                }

              while((_Bool)0);
              enum SPF_errcode_t return_value_SPF_i_done_7;
              return_value_SPF_i_done_7=SPF_i_done(spf_response, (enum SPF_result_enum)SPF_RESULT_TEMPERROR, (enum SPF_reason_enum)SPF_REASON_NONE, err);
              return return_value_SPF_i_done_7;
            }

            if(!(err == /*enum*/SPF_E_SUCCESS))
            {
              do
                if(!(buf == ((char *)NULL)))
                {
                  free((void *)buf);
                  buf = (char *)(void *)0;
                }

              while((_Bool)0);
              enum SPF_errcode_t return_value_SPF_i_done_8;
              return_value_SPF_i_done_8=SPF_i_done(spf_response, (enum SPF_result_enum)SPF_RESULT_PERMERROR, (enum SPF_reason_enum)SPF_REASON_NONE, err);
              return return_value_SPF_i_done_8;
            }

            lookup = buf;
          }
        while((_Bool)0);
        if(spf_request->client_ver == 2)
          fetch_ns_type = (enum __ns_type)ns_t_a;

        else
          fetch_ns_type = (enum __ns_type)ns_t_aaaa;
        rr_a=SPF_dns_lookup(resolver, lookup, fetch_ns_type, 1);
        if(!(SPF_record_interpret__1__spf_server->debug == 0))
          SPF_debugx("spf_interpret.c", 783, "found %d A records for %s  (herrno: %d)", rr_a->num_rr, lookup, rr_a->herrno);

        if(rr_a->herrno == 2)
        {
          SPF_dns_rr_free(rr_a);
          do
            if(!(buf == ((char *)NULL)))
            {
              free((void *)buf);
              buf = (char *)(void *)0;
            }

          while((_Bool)0);
          enum SPF_errcode_t return_value_SPF_i_done_9;
          return_value_SPF_i_done_9=SPF_i_done(spf_response, (enum SPF_result_enum)SPF_RESULT_TEMPERROR, (enum SPF_reason_enum)SPF_REASON_NONE, (enum SPF_errcode_t)SPF_E_DNS_ERROR);
          return return_value_SPF_i_done_9;
        }

        i = 0;
        for( ; !(i >= rr_a->num_rr); i = i + 1)
          if(rr_a->rr_type == fetch_ns_type)
          {
            if(spf_request->client_ver == 2)
            {
              signed int return_value_SPF_i_match_ip4_11;
              return_value_SPF_i_match_ip4_11=SPF_i_match_ip4(SPF_record_interpret__1__spf_server, spf_request, mech, rr_a->rr[(signed long int)i]->a);
              if(!(return_value_SPF_i_match_ip4_11 == 0))
              {
                SPF_dns_rr_free(rr_a);
                do
                  if(!(buf == ((char *)NULL)))
                  {
                    free((void *)buf);
                    buf = (char *)(void *)0;
                  }

                while((_Bool)0);
                enum SPF_errcode_t return_value_SPF_i_done_10;
                return_value_SPF_i_done_10=SPF_i_done(spf_response, (enum SPF_result_enum)mech->prefix_type, (enum SPF_reason_enum)SPF_REASON_MECH, (enum SPF_errcode_t)SPF_E_SUCCESS);
                return return_value_SPF_i_done_10;
              }

            }

            else
            {
              signed int return_value_SPF_i_match_ip6_13;
              return_value_SPF_i_match_ip6_13=SPF_i_match_ip6(SPF_record_interpret__1__spf_server, spf_request, mech, rr_a->rr[(signed long int)i]->aaaa);
              if(!(return_value_SPF_i_match_ip6_13 == 0))
              {
                SPF_dns_rr_free(rr_a);
                do
                  if(!(buf == ((char *)NULL)))
                  {
                    free((void *)buf);
                    buf = (char *)(void *)0;
                  }

                while((_Bool)0);
                enum SPF_errcode_t return_value_SPF_i_done_12;
                return_value_SPF_i_done_12=SPF_i_done(spf_response, (enum SPF_result_enum)mech->prefix_type, (enum SPF_reason_enum)SPF_REASON_MECH, (enum SPF_errcode_t)SPF_E_SUCCESS);
                return return_value_SPF_i_done_12;
              }

            }
          }

        SPF_dns_rr_free(rr_a);
        break;
      }
      case 2:
      {
        do
          spf_response->num_dns_mech = spf_response->num_dns_mech + 1;
        while((_Bool)0);
        do
          if(!(data >= data_end))
          {
            if((signed int)data->dc.parm_type == 11)
              data=SPF_data_next_link3(data);

          }

        while((_Bool)0);
        do
          if(data == data_end)
            lookup = spf_request->cur_dom;

          else
          {
            err=SPF_record_expand_data(SPF_record_interpret__1__spf_server, spf_request, spf_response, data, (unsigned long int)((char *)data_end - (char *)data), &buf, &buf_len);
            if((signed int)err == SPF_E_NO_MEMORY)
            {
              do
                if(!(buf == ((char *)NULL)))
                {
                  free((void *)buf);
                  buf = (char *)(void *)0;
                }

              while((_Bool)0);
              enum SPF_errcode_t return_value_SPF_i_done_14;
              return_value_SPF_i_done_14=SPF_i_done(spf_response, (enum SPF_result_enum)SPF_RESULT_TEMPERROR, (enum SPF_reason_enum)SPF_REASON_NONE, err);
              return return_value_SPF_i_done_14;
            }

            if(!(err == /*enum*/SPF_E_SUCCESS))
            {
              do
                if(!(buf == ((char *)NULL)))
                {
                  free((void *)buf);
                  buf = (char *)(void *)0;
                }

              while((_Bool)0);
              enum SPF_errcode_t return_value_SPF_i_done_15;
              return_value_SPF_i_done_15=SPF_i_done(spf_response, (enum SPF_result_enum)SPF_RESULT_PERMERROR, (enum SPF_reason_enum)SPF_REASON_NONE, err);
              return return_value_SPF_i_done_15;
            }

            lookup = buf;
          }
        while((_Bool)0);
        rr_mx=SPF_dns_lookup(resolver, lookup, (enum __ns_type)ns_t_mx, 1);
        if(!(SPF_record_interpret__1__spf_server->debug == 0))
          SPF_debugx("spf_interpret.c", 824, "found %d MX records for %s  (herrno: %d)", rr_mx->num_rr, lookup, rr_mx->herrno);

        if(rr_mx->herrno == 2)
        {
          SPF_dns_rr_free(rr_mx);
          do
            if(!(buf == ((char *)NULL)))
            {
              free((void *)buf);
              buf = (char *)(void *)0;
            }

          while((_Bool)0);
          enum SPF_errcode_t return_value_SPF_i_done_16;
          return_value_SPF_i_done_16=SPF_i_done(spf_response, (enum SPF_result_enum)SPF_RESULT_TEMPERROR, (enum SPF_reason_enum)SPF_REASON_NONE, (enum SPF_errcode_t)SPF_E_DNS_ERROR);
          return return_value_SPF_i_done_16;
        }

        max_mx = rr_mx->num_rr;
        max_exceeded = 0;
        if(!(SPF_record_interpret__1__spf_server->max_dns_mx >= max_mx))
        {
          max_exceeded = 1;
          max_mx=SPF_server_get_max_dns_mx(SPF_record_interpret__1__spf_server);
        }

        j = 0;
        for( ; !(j >= max_mx); j = j + 1)
          if((signed int)rr_mx->rr_type == ns_t_mx)
          {
            if(spf_request->client_ver == 2)
              fetch_ns_type = (enum __ns_type)ns_t_a;

            else
              fetch_ns_type = (enum __ns_type)ns_t_aaaa;
            rr_a=SPF_dns_lookup(resolver, rr_mx->rr[(signed long int)j]->mx, fetch_ns_type, 1);
            if(!(SPF_record_interpret__1__spf_server->debug == 0))
              SPF_debugx("spf_interpret.c", 855, "%d: found %d A records for %s  (herrno: %d)", j, rr_a->num_rr, (const void *)rr_mx->rr[(signed long int)j]->mx, rr_a->herrno);

            if(rr_a->herrno == 2)
            {
              SPF_dns_rr_free(rr_mx);
              SPF_dns_rr_free(rr_a);
              do
                if(!(buf == ((char *)NULL)))
                {
                  free((void *)buf);
                  buf = (char *)(void *)0;
                }

              while((_Bool)0);
              enum SPF_errcode_t return_value_SPF_i_done_17;
              return_value_SPF_i_done_17=SPF_i_done(spf_response, (enum SPF_result_enum)SPF_RESULT_TEMPERROR, (enum SPF_reason_enum)SPF_REASON_NONE, (enum SPF_errcode_t)SPF_E_DNS_ERROR);
              return return_value_SPF_i_done_17;
            }

            i = 0;
            for( ; !(i >= rr_a->num_rr); i = i + 1)
              if(rr_a->rr_type == fetch_ns_type)
              {
                if(spf_request->client_ver == 2)
                {
                  signed int return_value_SPF_i_match_ip4_19;
                  return_value_SPF_i_match_ip4_19=SPF_i_match_ip4(SPF_record_interpret__1__spf_server, spf_request, mech, rr_a->rr[(signed long int)i]->a);
                  if(!(return_value_SPF_i_match_ip4_19 == 0))
                  {
                    SPF_dns_rr_free(rr_mx);
                    SPF_dns_rr_free(rr_a);
                    do
                      if(!(buf == ((char *)NULL)))
                      {
                        free((void *)buf);
                        buf = (char *)(void *)0;
                      }

                    while((_Bool)0);
                    enum SPF_errcode_t return_value_SPF_i_done_18;
                    return_value_SPF_i_done_18=SPF_i_done(spf_response, (enum SPF_result_enum)mech->prefix_type, (enum SPF_reason_enum)SPF_REASON_MECH, (enum SPF_errcode_t)SPF_E_SUCCESS);
                    return return_value_SPF_i_done_18;
                  }

                }

                else
                {
                  signed int return_value_SPF_i_match_ip6_21;
                  return_value_SPF_i_match_ip6_21=SPF_i_match_ip6(SPF_record_interpret__1__spf_server, spf_request, mech, rr_a->rr[(signed long int)i]->aaaa);
                  if(!(return_value_SPF_i_match_ip6_21 == 0))
                  {
                    SPF_dns_rr_free(rr_mx);
                    SPF_dns_rr_free(rr_a);
                    do
                      if(!(buf == ((char *)NULL)))
                      {
                        free((void *)buf);
                        buf = (char *)(void *)0;
                      }

                    while((_Bool)0);
                    enum SPF_errcode_t return_value_SPF_i_done_20;
                    return_value_SPF_i_done_20=SPF_i_done(spf_response, (enum SPF_result_enum)mech->prefix_type, (enum SPF_reason_enum)SPF_REASON_MECH, (enum SPF_errcode_t)SPF_E_SUCCESS);
                    return return_value_SPF_i_done_20;
                  }

                }
              }

            SPF_dns_rr_free(rr_a);
          }

        SPF_dns_rr_free(rr_mx);
        if(!(max_exceeded == 0))
        {
          do
            if(!(buf == ((char *)NULL)))
            {
              free((void *)buf);
              buf = (char *)(void *)0;
            }

          while((_Bool)0);
          enum SPF_errcode_t return_value_SPF_i_done_22;
          return_value_SPF_i_done_22=SPF_i_done(spf_response, (enum SPF_result_enum)SPF_RESULT_PERMERROR, (enum SPF_reason_enum)SPF_REASON_NONE, (enum SPF_errcode_t)SPF_E_BIG_DNS);
          return return_value_SPF_i_done_22;
        }

        break;
      }
      case 3:
      {
        do
          spf_response->num_dns_mech = spf_response->num_dns_mech + 1;
        while((_Bool)0);
        do
          if(data == data_end)
            lookup = spf_request->cur_dom;

          else
          {
            err=SPF_record_expand_data(SPF_record_interpret__1__spf_server, spf_request, spf_response, data, (unsigned long int)((char *)data_end - (char *)data), &buf, &buf_len);
            if((signed int)err == SPF_E_NO_MEMORY)
            {
              do
                if(!(buf == ((char *)NULL)))
                {
                  free((void *)buf);
                  buf = (char *)(void *)0;
                }

              while((_Bool)0);
              enum SPF_errcode_t return_value_SPF_i_done_23;
              return_value_SPF_i_done_23=SPF_i_done(spf_response, (enum SPF_result_enum)SPF_RESULT_TEMPERROR, (enum SPF_reason_enum)SPF_REASON_NONE, err);
              return return_value_SPF_i_done_23;
            }

            if(!(err == /*enum*/SPF_E_SUCCESS))
            {
              do
                if(!(buf == ((char *)NULL)))
                {
                  free((void *)buf);
                  buf = (char *)(void *)0;
                }

              while((_Bool)0);
              enum SPF_errcode_t return_value_SPF_i_done_24;
              return_value_SPF_i_done_24=SPF_i_done(spf_response, (enum SPF_result_enum)SPF_RESULT_PERMERROR, (enum SPF_reason_enum)SPF_REASON_NONE, err);
              return return_value_SPF_i_done_24;
            }

            lookup = buf;
          }
        while((_Bool)0);
        if(spf_request->client_ver == 2)
        {
          rr_ptr=SPF_dns_rlookup(resolver, spf_request->ipv4, (enum __ns_type)ns_t_ptr, 1);
          if(!(SPF_record_interpret__1__spf_server->debug == 0))
          {
            do
            {
              const char *return_value_inet_ntop_25;
              return_value_inet_ntop_25=inet_ntop(2, (const void *)&spf_request->ipv4.s_addr, ip4_buf, (unsigned int)sizeof(char [16l]) /*16ul*/ );
              if(return_value_inet_ntop_25 == ((const char *)NULL))
                snprintf(ip4_buf, sizeof(char [16l]) /*16ul*/ , "ip-error");

            }
            while((_Bool)0);
            SPF_debugx("spf_interpret.c", 911, "got %d PTR records for %s (herrno: %d)", rr_ptr->num_rr, (const void *)ip4_buf, rr_ptr->herrno);
          }

          if(rr_ptr->herrno == 2)
          {
            SPF_dns_rr_free(rr_ptr);
            do
              if(!(buf == ((char *)NULL)))
              {
                free((void *)buf);
                buf = (char *)(void *)0;
              }

            while((_Bool)0);
            enum SPF_errcode_t return_value_SPF_i_done_26;
            return_value_SPF_i_done_26=SPF_i_done(spf_response, (enum SPF_result_enum)SPF_RESULT_TEMPERROR, (enum SPF_reason_enum)SPF_REASON_NONE, (enum SPF_errcode_t)SPF_E_DNS_ERROR);
            return return_value_SPF_i_done_26;
          }

          max_ptr = rr_ptr->num_rr;
          max_exceeded = 0;
          if(!(SPF_record_interpret__1__spf_server->max_dns_ptr >= max_ptr))
          {
            max_exceeded = 1;
            max_ptr=SPF_server_get_max_dns_ptr(SPF_record_interpret__1__spf_server);
          }

          i = 0;
          for( ; !(i >= max_ptr); i = i + 1)
          {
            rr_a=SPF_dns_lookup(resolver, rr_ptr->rr[(signed long int)i]->ptr, (enum __ns_type)ns_t_a, 1);
            if(!(SPF_record_interpret__1__spf_server->debug == 0))
              SPF_debugx("spf_interpret.c", 937, "%d:  found %d A records for %s  (herrno: %d)", i, rr_a->num_rr, (const void *)rr_ptr->rr[(signed long int)i]->ptr, rr_a->herrno);

            if(rr_a->herrno == 2)
            {
              SPF_dns_rr_free(rr_ptr);
              SPF_dns_rr_free(rr_a);
              do
                if(!(buf == ((char *)NULL)))
                {
                  free((void *)buf);
                  buf = (char *)(void *)0;
                }

              while((_Bool)0);
              enum SPF_errcode_t return_value_SPF_i_done_27;
              return_value_SPF_i_done_27=SPF_i_done(spf_response, (enum SPF_result_enum)SPF_RESULT_TEMPERROR, (enum SPF_reason_enum)SPF_REASON_NONE, (enum SPF_errcode_t)SPF_E_DNS_ERROR);
              return return_value_SPF_i_done_27;
            }

            j = 0;
            for( ; !(j >= rr_a->num_rr); j = j + 1)
            {
              if(!(SPF_record_interpret__1__spf_server->debug == 0))
              {
                do
                {
                  const char *return_value_inet_ntop_28;
                  return_value_inet_ntop_28=inet_ntop(2, (const void *)&rr_a->rr[(signed long int)j]->a.s_addr, ip4_buf, (unsigned int)sizeof(char [16l]) /*16ul*/ );
                  if(return_value_inet_ntop_28 == ((const char *)NULL))
                    snprintf(ip4_buf, sizeof(char [16l]) /*16ul*/ , "ip-error");

                }
                while((_Bool)0);
                SPF_debugx("spf_interpret.c", 952, "%d: %d:  found %s", i, j, (const void *)ip4_buf);
              }

              if(rr_a->rr[(signed long int)j]->a.s_addr == spf_request->ipv4.s_addr)
              {
                signed int return_value_SPF_i_match_domain_30;
                return_value_SPF_i_match_domain_30=SPF_i_match_domain(SPF_record_interpret__1__spf_server, rr_ptr->rr[(signed long int)i]->ptr, lookup);
                if(!(return_value_SPF_i_match_domain_30 == 0))
                {
                  SPF_dns_rr_free(rr_ptr);
                  SPF_dns_rr_free(rr_a);
                  do
                    if(!(buf == ((char *)NULL)))
                    {
                      free((void *)buf);
                      buf = (char *)(void *)0;
                    }

                  while((_Bool)0);
                  enum SPF_errcode_t return_value_SPF_i_done_29;
                  return_value_SPF_i_done_29=SPF_i_done(spf_response, (enum SPF_result_enum)mech->prefix_type, (enum SPF_reason_enum)SPF_REASON_MECH, (enum SPF_errcode_t)SPF_E_SUCCESS);
                  return return_value_SPF_i_done_29;
                }

              }

            }
            SPF_dns_rr_free(rr_a);
          }
          SPF_dns_rr_free(rr_ptr);
          if(!(max_exceeded == 0))
          {
            do
              if(!(buf == ((char *)NULL)))
              {
                free((void *)buf);
                buf = (char *)(void *)0;
              }

            while((_Bool)0);
            enum SPF_errcode_t return_value_SPF_i_done_31;
            return_value_SPF_i_done_31=SPF_i_done(spf_response, (enum SPF_result_enum)SPF_RESULT_PERMERROR, (enum SPF_reason_enum)SPF_REASON_NONE, (enum SPF_errcode_t)SPF_E_BIG_DNS);
            return return_value_SPF_i_done_31;
          }

        }

        else
          if(spf_request->client_ver == 10)
          {
            rr_ptr=SPF_dns_rlookup6(resolver, spf_request->ipv6, (enum __ns_type)ns_t_ptr, 1);
            if(!(SPF_record_interpret__1__spf_server->debug == 0))
            {
              do
              {
                const char *return_value_inet_ntop_32;
                return_value_inet_ntop_32=inet_ntop(10, (const void *)&spf_request->ipv6.__in6_u.__u6_addr8, ip6_buf, (unsigned int)sizeof(char [46l]) /*46ul*/ );
                if(return_value_inet_ntop_32 == ((const char *)NULL))
                  snprintf(ip6_buf, sizeof(char [46l]) /*46ul*/ , "ip-error");

              }
              while((_Bool)0);
              SPF_debugx("spf_interpret.c", 984, "found %d PTR records for %s  (herrno: %d)", rr_ptr->num_rr, (const void *)ip6_buf, rr_ptr->herrno);
            }

            if(rr_ptr->herrno == 2)
            {
              SPF_dns_rr_free(rr_ptr);
              do
                if(!(buf == ((char *)NULL)))
                {
                  free((void *)buf);
                  buf = (char *)(void *)0;
                }

              while((_Bool)0);
              enum SPF_errcode_t return_value_SPF_i_done_33;
              return_value_SPF_i_done_33=SPF_i_done(spf_response, (enum SPF_result_enum)SPF_RESULT_TEMPERROR, (enum SPF_reason_enum)SPF_REASON_NONE, (enum SPF_errcode_t)SPF_E_DNS_ERROR);
              return return_value_SPF_i_done_33;
            }

            max_ptr = rr_ptr->num_rr;
            max_exceeded = 0;
            if(!(SPF_record_interpret__1__spf_server->max_dns_ptr >= max_ptr))
            {
              max_ptr=SPF_server_get_max_dns_ptr(SPF_record_interpret__1__spf_server);
              max_exceeded = 1;
            }

            i = 0;
            for( ; !(i >= max_ptr); i = i + 1)
            {
              rr_aaaa=SPF_dns_lookup(resolver, rr_ptr->rr[(signed long int)i]->ptr, (enum __ns_type)ns_t_aaaa, 1);
              if(!(SPF_record_interpret__1__spf_server->debug == 0))
                SPF_debugx("spf_interpret.c", 1008, "%d:  found %d AAAA records for %s  (herrno: %d)", i, rr_aaaa->num_rr, (const void *)rr_ptr->rr[(signed long int)i]->ptr, rr_aaaa->herrno);

              if(rr_aaaa->herrno == 2)
              {
                SPF_dns_rr_free(rr_ptr);
                SPF_dns_rr_free(rr_aaaa);
                do
                  if(!(buf == ((char *)NULL)))
                  {
                    free((void *)buf);
                    buf = (char *)(void *)0;
                  }

                while((_Bool)0);
                enum SPF_errcode_t return_value_SPF_i_done_34;
                return_value_SPF_i_done_34=SPF_i_done(spf_response, (enum SPF_result_enum)SPF_RESULT_TEMPERROR, (enum SPF_reason_enum)SPF_REASON_NONE, (enum SPF_errcode_t)SPF_E_DNS_ERROR);
                return return_value_SPF_i_done_34;
              }

              j = 0;
              for( ; !(j >= rr_aaaa->num_rr); j = j + 1)
              {
                if(!(SPF_record_interpret__1__spf_server->debug == 0))
                {
                  do
                  {
                    const char *return_value_inet_ntop_35;
                    return_value_inet_ntop_35=inet_ntop(10, (const void *)&rr_aaaa->rr[(signed long int)j]->aaaa.__in6_u.__u6_addr8, ip6_buf, (unsigned int)sizeof(char [46l]) /*46ul*/ );
                    if(return_value_inet_ntop_35 == ((const char *)NULL))
                      snprintf(ip6_buf, sizeof(char [46l]) /*46ul*/ , "ip-error");

                  }
                  while((_Bool)0);
                  SPF_debugx("spf_interpret.c", 1022, "%d: %d:  found %s", i, j, (const void *)ip6_buf);
                }

                signed int return_value_memcmp_38;
                return_value_memcmp_38=memcmp((const void *)&rr_aaaa->rr[(signed long int)j]->aaaa, (const void *)&spf_request->ipv6, sizeof(struct in6_addr) /*16ul*/ );
                if(return_value_memcmp_38 == 0)
                {
                  signed int return_value_SPF_i_match_domain_37;
                  return_value_SPF_i_match_domain_37=SPF_i_match_domain(SPF_record_interpret__1__spf_server, rr_ptr->rr[(signed long int)i]->ptr, lookup);
                  if(!(return_value_SPF_i_match_domain_37 == 0))
                  {
                    SPF_dns_rr_free(rr_ptr);
                    SPF_dns_rr_free(rr_aaaa);
                    do
                      if(!(buf == ((char *)NULL)))
                      {
                        free((void *)buf);
                        buf = (char *)(void *)0;
                      }

                    while((_Bool)0);
                    enum SPF_errcode_t return_value_SPF_i_done_36;
                    return_value_SPF_i_done_36=SPF_i_done(spf_response, (enum SPF_result_enum)mech->prefix_type, (enum SPF_reason_enum)SPF_REASON_MECH, (enum SPF_errcode_t)SPF_E_SUCCESS);
                    return return_value_SPF_i_done_36;
                  }

                }

              }
              SPF_dns_rr_free(rr_aaaa);
            }
            SPF_dns_rr_free(rr_ptr);
            if(!(max_exceeded == 0))
            {
              do
                if(!(buf == ((char *)NULL)))
                {
                  free((void *)buf);
                  buf = (char *)(void *)0;
                }

              while((_Bool)0);
              enum SPF_errcode_t return_value_SPF_i_done_39;
              return_value_SPF_i_done_39=SPF_i_done(spf_response, (enum SPF_result_enum)SPF_RESULT_PERMERROR, (enum SPF_reason_enum)SPF_REASON_NONE, (enum SPF_errcode_t)SPF_E_BIG_DNS);
              return return_value_SPF_i_done_39;
            }

          }

        break;
      }
      case 4:

      case 9:
      {
        do
          spf_response->num_dns_mech = spf_response->num_dns_mech + 1;
        while((_Bool)0);
        return_value_SPF_mech_data_40=SPF_mech_data_link2(mech);
        return_value_SPF_mech_data_len_41=SPF_mech_data_len_link2(mech);
        err=SPF_record_expand_data(SPF_record_interpret__1__spf_server, spf_request, spf_response, return_value_SPF_mech_data_40, return_value_SPF_mech_data_len_41, &buf, &buf_len);
        if((signed int)err == SPF_E_NO_MEMORY)
        {
          do
            if(!(buf == ((char *)NULL)))
            {
              free((void *)buf);
              buf = (char *)(void *)0;
            }

          while((_Bool)0);
          enum SPF_errcode_t return_value_SPF_i_done_42;
          return_value_SPF_i_done_42=SPF_i_done(spf_response, (enum SPF_result_enum)SPF_RESULT_TEMPERROR, (enum SPF_reason_enum)SPF_REASON_NONE, err);
          return return_value_SPF_i_done_42;
        }

        if(!(err == /*enum*/SPF_E_SUCCESS))
        {
          do
            if(!(buf == ((char *)NULL)))
            {
              free((void *)buf);
              buf = (char *)(void *)0;
            }

          while((_Bool)0);
          enum SPF_errcode_t return_value_SPF_i_done_43;
          return_value_SPF_i_done_43=SPF_i_done(spf_response, (enum SPF_result_enum)SPF_RESULT_PERMERROR, (enum SPF_reason_enum)SPF_REASON_NONE, err);
          return return_value_SPF_i_done_43;
        }

        lookup = buf;
        return_value_strcmp_45=strcmp(lookup, spf_request->cur_dom);
        if(return_value_strcmp_45 == 0)
        {
          do
            if(!(buf == ((char *)NULL)))
            {
              free((void *)buf);
              buf = (char *)(void *)0;
            }

          while((_Bool)0);
          enum SPF_errcode_t return_value_SPF_i_done_44;
          return_value_SPF_i_done_44=SPF_i_done(spf_response, (enum SPF_result_enum)SPF_RESULT_PERMERROR, (enum SPF_reason_enum)SPF_REASON_NONE, (enum SPF_errcode_t)SPF_E_RECURSIVE);
          return return_value_SPF_i_done_44;
        }

        spf_record_subr = (struct SPF_record_struct *)(void *)0;
        save_cur_dom = spf_request->cur_dom;
        spf_request->cur_dom = lookup;
        err=SPF_server_get_record(SPF_record_interpret__1__spf_server, spf_request, spf_response, &spf_record_subr);
        if(SPF_record_interpret__1__spf_server->debug >= 1)
        {
          return_value_SPF_strerror_46=SPF_strerror(err);
          SPF_debugx("spf_interpret.c", 1087, "include/redirect:  got SPF record:  %s", return_value_SPF_strerror_46);
        }

        if(!((signed int)err == SPF_E_SUCCESS))
        {
          spf_request->cur_dom = save_cur_dom;
          if(!(spf_record_subr == ((struct SPF_record_struct *)NULL)))
            SPF_record_free(spf_record_subr);

          do
            if(!(buf == ((char *)NULL)))
            {
              free((void *)buf);
              buf = (char *)(void *)0;
            }

          while((_Bool)0);
          if((signed int)err == SPF_E_DNS_ERROR)
          {
            return_value_SPF_i_done_47=SPF_i_done(spf_response, (enum SPF_result_enum)SPF_RESULT_TEMPERROR, (enum SPF_reason_enum)SPF_REASON_NONE, err);
            return return_value_SPF_i_done_47;
          }

          else
          {
            return_value_SPF_i_done_48=SPF_i_done(spf_response, (enum SPF_result_enum)SPF_RESULT_PERMERROR, (enum SPF_reason_enum)SPF_REASON_NONE, err);
            return return_value_SPF_i_done_48;
          }
        }

        do
          if(spf_record_subr == ((struct SPF_record_struct *)NULL))
            SPF_errorx("spf_interpret.c", 1100, "%s", (const void *)"spf_record_subr is NULL");

        while((_Bool)0);
        if((signed int)mech->mech_type == 9)
        {
          save_spf_response = (struct SPF_response_struct *)(void *)0;
          if(spf_response->spf_record_exp == spf_record)
            spf_response->spf_record_exp = spf_record_subr;

          do
            if(spf_response->spf_record_exp == ((struct SPF_record_struct *)NULL))
              SPF_errorx("spf_interpret.c", 1110, "%s", (const void *)"spf_response->spf_record_exp is NULL");

          while((_Bool)0);
        }

        else
        {
          save_spf_response = spf_response;
          spf_response=SPF_response_new(spf_request);
          if(spf_response == ((struct SPF_response_struct *)NULL))
          {
            if(!(spf_record_subr == ((struct SPF_record_struct *)NULL)))
              SPF_record_free(spf_record_subr);

            do
              if(!(buf == ((char *)NULL)))
              {
                free((void *)buf);
                buf = (char *)(void *)0;
              }

            while((_Bool)0);
            enum SPF_errcode_t return_value_SPF_i_done_49;
            return_value_SPF_i_done_49=SPF_i_done(spf_response, (enum SPF_result_enum)SPF_RESULT_TEMPERROR, (enum SPF_reason_enum)SPF_REASON_NONE, (enum SPF_errcode_t)SPF_E_NO_MEMORY);
            return return_value_SPF_i_done_49;
          }

          spf_response->spf_record_exp = spf_record;
          do
            if(spf_response->spf_record_exp == ((struct SPF_record_struct *)NULL))
              SPF_errorx("spf_interpret.c", 1122, "%s", (const void *)"spf_response->spf_record_exp is NULL");

          while((_Bool)0);
        }
        err=SPF_record_interpret(spf_record_subr, spf_request, spf_response, depth + 1);
        spf_request->cur_dom = save_cur_dom;
        SPF_record_free(spf_record_subr);
        spf_record_subr = (struct SPF_record_struct *)(void *)0;
        if(SPF_record_interpret__1__spf_server->debug >= 1)
        {
          return_value_SPF_strerror_50=SPF_strerror(err);
          return_value_SPF_strresult_51=SPF_strresult(spf_response->result);
          return_value_SPF_strreason_52=SPF_strreason(spf_response->reason);
          SPF_debugx("spf_interpret.c", 1143, "include/redirect:  executed SPF record:  %s  result: %s  reason: %s", return_value_SPF_strerror_50, return_value_SPF_strresult_51, return_value_SPF_strreason_52);
        }

        if((signed int)mech->mech_type == 9)
        {
          do
            if(!(buf == ((char *)NULL)))
            {
              free((void *)buf);
              buf = (char *)(void *)0;
            }

          while((_Bool)0);
          return err;
        }

        else
        {
          spf_response_subr = spf_response;
          spf_response = save_spf_response;
          save_spf_response = (struct SPF_response_struct *)(void *)0;
          enum SPF_result_enum return_value_SPF_response_result_53;
          return_value_SPF_response_result_53=SPF_response_result(spf_response_subr);
          switch((signed int)return_value_SPF_response_result_53)
          {
            case SPF_RESULT_PASS:
            {
              do
                if(!(buf == ((char *)NULL)))
                {
                  free((void *)buf);
                  buf = (char *)(void *)0;
                }

              while((_Bool)0);
              SPF_response_free(spf_response_subr);
              return_value_SPF_i_done_54=SPF_i_done(spf_response, (enum SPF_result_enum)mech->prefix_type, (enum SPF_reason_enum)SPF_REASON_MECH, (enum SPF_errcode_t)SPF_E_SUCCESS);
              return return_value_SPF_i_done_54;
            }
            case SPF_RESULT_FAIL:

            case SPF_RESULT_SOFTFAIL:

            case SPF_RESULT_NEUTRAL:
            {
              SPF_response_free(spf_response_subr);
              goto __CPROVER_DUMP_L197;
            }
            case SPF_RESULT_TEMPERROR:
            {
              err=SPF_response_errcode(spf_response_subr);
              do
                if(!(buf == ((char *)NULL)))
                {
                  free((void *)buf);
                  buf = (char *)(void *)0;
                }

              while((_Bool)0);
              SPF_response_free(spf_response_subr);
              return_value_SPF_i_done_55=SPF_i_done(spf_response, (enum SPF_result_enum)SPF_RESULT_TEMPERROR, (enum SPF_reason_enum)SPF_REASON_NONE, err);
              return return_value_SPF_i_done_55;
            }
            case SPF_RESULT_NONE:
            {
              do
                if(!(buf == ((char *)NULL)))
                {
                  free((void *)buf);
                  buf = (char *)(void *)0;
                }

              while((_Bool)0);
              SPF_response_free(spf_response_subr);
              return_value_SPF_i_done_56=SPF_i_done(spf_response, (enum SPF_result_enum)SPF_RESULT_PERMERROR, (enum SPF_reason_enum)SPF_REASON_NONE, (enum SPF_errcode_t)SPF_E_INCLUDE_RETURNED_NONE);
              return return_value_SPF_i_done_56;
            }
            case SPF_RESULT_PERMERROR:

            case SPF_RESULT_INVALID:
            {
              err=SPF_response_errcode(spf_response_subr);
              do
                if(!(buf == ((char *)NULL)))
                {
                  free((void *)buf);
                  buf = (char *)(void *)0;
                }

              while((_Bool)0);
              SPF_response_free(spf_response_subr);
              return_value_SPF_i_done_57=SPF_i_done(spf_response, (enum SPF_result_enum)SPF_RESULT_PERMERROR, (enum SPF_reason_enum)SPF_REASON_NONE, err);
              return return_value_SPF_i_done_57;
            }
            default:

              __CPROVER_DUMP_L197:
                ;
          }
        }
        break;
      }
      case 5:
      {
        return_value_SPF_mech_ip4_data_58=SPF_mech_ip4_data_link2(mech);
        memcpy((void *)&addr4, (const void *)return_value_SPF_mech_ip4_data_58, sizeof(struct in_addr) /*4ul*/ );
        return_value_SPF_i_match_ip4_60=SPF_i_match_ip4(SPF_record_interpret__1__spf_server, spf_request, mech, addr4);
        if(!(return_value_SPF_i_match_ip4_60 == 0))
        {
          do
            if(!(buf == ((char *)NULL)))
            {
              free((void *)buf);
              buf = (char *)(void *)0;
            }

          while((_Bool)0);
          enum SPF_errcode_t return_value_SPF_i_done_59;
          return_value_SPF_i_done_59=SPF_i_done(spf_response, (enum SPF_result_enum)mech->prefix_type, (enum SPF_reason_enum)SPF_REASON_MECH, (enum SPF_errcode_t)SPF_E_SUCCESS);
          return return_value_SPF_i_done_59;
        }

        break;
      }
      case 6:
      {
        return_value_SPF_mech_ip6_data_61=SPF_mech_ip6_data_link2(mech);
        memcpy((void *)&addr6, (const void *)return_value_SPF_mech_ip6_data_61, sizeof(struct in6_addr) /*16ul*/ );
        return_value_SPF_i_match_ip6_63=SPF_i_match_ip6(SPF_record_interpret__1__spf_server, spf_request, mech, addr6);
        if(!(return_value_SPF_i_match_ip6_63 == 0))
        {
          do
            if(!(buf == ((char *)NULL)))
            {
              free((void *)buf);
              buf = (char *)(void *)0;
            }

          while((_Bool)0);
          enum SPF_errcode_t return_value_SPF_i_done_62;
          return_value_SPF_i_done_62=SPF_i_done(spf_response, (enum SPF_result_enum)mech->prefix_type, (enum SPF_reason_enum)SPF_REASON_MECH, (enum SPF_errcode_t)SPF_E_SUCCESS);
          return return_value_SPF_i_done_62;
        }

        break;
      }
      case 7:
      {
        do
          spf_response->num_dns_mech = spf_response->num_dns_mech + 1;
        while((_Bool)0);
        return_value_SPF_mech_data_64=SPF_mech_data_link2(mech);
        return_value_SPF_mech_data_len_65=SPF_mech_data_len_link2(mech);
        err=SPF_record_expand_data(SPF_record_interpret__1__spf_server, spf_request, spf_response, return_value_SPF_mech_data_64, return_value_SPF_mech_data_len_65, &buf, &buf_len);
        if(!((signed int)err == SPF_E_SUCCESS))
        {
          do
            if(!(buf == ((char *)NULL)))
            {
              free((void *)buf);
              buf = (char *)(void *)0;
            }

          while((_Bool)0);
          enum SPF_errcode_t return_value_SPF_i_done_66;
          return_value_SPF_i_done_66=SPF_i_done(spf_response, (enum SPF_result_enum)SPF_RESULT_TEMPERROR, (enum SPF_reason_enum)SPF_REASON_NONE, err);
          return return_value_SPF_i_done_66;
        }

        lookup = buf;
        rr_a=SPF_dns_lookup(resolver, lookup, (enum __ns_type)ns_t_a, 0);
        if(!(SPF_record_interpret__1__spf_server->debug == 0))
          SPF_debugx("spf_interpret.c", 1231, "found %d A records for %s  (herrno: %d)", rr_a->num_rr, lookup, rr_a->herrno);

        if(rr_a->herrno == 2)
        {
          SPF_dns_rr_free(rr_a);
          do
            if(!(buf == ((char *)NULL)))
            {
              free((void *)buf);
              buf = (char *)(void *)0;
            }

          while((_Bool)0);
          enum SPF_errcode_t return_value_SPF_i_done_67;
          return_value_SPF_i_done_67=SPF_i_done(spf_response, (enum SPF_result_enum)SPF_RESULT_TEMPERROR, (enum SPF_reason_enum)SPF_REASON_NONE, (enum SPF_errcode_t)SPF_E_DNS_ERROR);
          return return_value_SPF_i_done_67;
        }

        if(rr_a->num_rr >= 1)
        {
          SPF_dns_rr_free(rr_a);
          do
            if(!(buf == ((char *)NULL)))
            {
              free((void *)buf);
              buf = (char *)(void *)0;
            }

          while((_Bool)0);
          enum SPF_errcode_t return_value_SPF_i_done_68;
          return_value_SPF_i_done_68=SPF_i_done(spf_response, (enum SPF_result_enum)mech->prefix_type, (enum SPF_reason_enum)SPF_REASON_MECH, (enum SPF_errcode_t)SPF_E_SUCCESS);
          return return_value_SPF_i_done_68;
        }

        SPF_dns_rr_free(rr_a);
        break;
      }
      case 8:
      {
        do
          if(!(buf == ((char *)NULL)))
          {
            free((void *)buf);
            buf = (char *)(void *)0;
          }

        while((_Bool)0);
        if((signed int)mech->prefix_type == SPF_RESULT_PERMERROR)
        {
          return_value_SPF_i_done_69=SPF_i_done(spf_response, (enum SPF_result_enum)SPF_RESULT_PERMERROR, (enum SPF_reason_enum)SPF_REASON_NONE, (enum SPF_errcode_t)SPF_E_UNKNOWN_MECH);
          return return_value_SPF_i_done_69;
        }

        return_value_SPF_i_done_70=SPF_i_done(spf_response, (enum SPF_result_enum)mech->prefix_type, (enum SPF_reason_enum)SPF_REASON_MECH, (enum SPF_errcode_t)SPF_E_SUCCESS);
        return return_value_SPF_i_done_70;
      }
      default:
      {
        do
          if(!(buf == ((char *)NULL)))
          {
            free((void *)buf);
            buf = (char *)(void *)0;
          }

        while((_Bool)0);
        return_value_SPF_i_done_71=SPF_i_done(spf_response, (enum SPF_result_enum)SPF_RESULT_PERMERROR, (enum SPF_reason_enum)SPF_REASON_NONE, (enum SPF_errcode_t)SPF_E_UNKNOWN_MECH);
        return return_value_SPF_i_done_71;
      }
    }
    if(mech == local_policy)
    {
      err=SPF_record_interpret(SPF_record_interpret__1__spf_server->local_policy, spf_request, spf_response, depth + 1);
      if(SPF_record_interpret__1__spf_server->debug >= 1)
      {
        return_value_SPF_strerror_72=SPF_strerror(err);
        return_value_SPF_strresult_73=SPF_strresult(spf_response->result);
        return_value_SPF_strreason_74=SPF_strreason(spf_response->reason);
        SPF_debugx("spf_interpret.c", 1272, "local_policy:  executed SPF record:  %s  result: %s  reason: %s", return_value_SPF_strerror_72, return_value_SPF_strresult_73, return_value_SPF_strreason_74);
      }

      if(!((signed int)spf_response->result == SPF_RESULT_INVALID))
      {
        do
          if(!(buf == ((char *)NULL)))
          {
            free((void *)buf);
            buf = (char *)(void *)0;
          }

        while((_Bool)0);
        return err;
      }

    }

    mech=SPF_mech_next_link2(mech);
  }
  do
    if(!(buf == ((char *)NULL)))
    {
      free((void *)buf);
      buf = (char *)(void *)0;
    }

  while((_Bool)0);
  enum SPF_errcode_t return_value_SPF_i_done_75;
  return_value_SPF_i_done_75=SPF_i_done(spf_response, (enum SPF_result_enum)SPF_RESULT_NEUTRAL, (enum SPF_reason_enum)SPF_REASON_DEFAULT, (enum SPF_errcode_t)SPF_E_SUCCESS);
  return return_value_SPF_i_done_75;
}

// SPF_record_lint
// file spf_compile.c line 1055
static void SPF_record_lint(struct SPF_server_struct *spf_server, struct SPF_response_struct *spf_response, struct SPF_record_struct *spf_record)
{
  union SPF_data_union *d;
  union SPF_data_union *data_end;
  char *s;
  char *s_end;
  signed int found_non_ip;
  signed int found_valid_tld;
  struct SPF_mech_struct *mech;
  union SPF_data_union *data;
  signed int i;
  mech = spf_record->mech_first;
  i = 0;
  const unsigned short int **return_value___ctype_b_loc_4;
  while(!(i >= (signed int)spf_record->num_mech))
  {
    _Bool tmp_if_expr_1;
    if((signed int)mech->mech_type == 8)
      tmp_if_expr_1 = (_Bool)1;

    else
      tmp_if_expr_1 = (signed int)mech->mech_type == 9 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_1)
    {
      if(!(i == (signed int)spf_record->num_mech + -1))
        SPF_response_add_warn(spf_response, (enum SPF_errcode_t)SPF_E_MECH_AFTER_ALL, "Mechanisms found after the \"all:\" mechanism will be ignored.");

    }

    _Bool tmp_if_expr_2;
    if((signed int)mech->mech_type == 5)
      tmp_if_expr_2 = (_Bool)1;

    else
      tmp_if_expr_2 = (signed int)mech->mech_type == 6 ? (_Bool)1 : (_Bool)0;
    if(!tmp_if_expr_2)
    {
      data=SPF_mech_data(mech);
      data_end=SPF_mech_end_data(mech);
      if(!(data == data_end))
      {
        if((signed int)data->dc.parm_type == 11)
        {
          data=SPF_data_next(data);
          if(data == data_end)
            goto __CPROVER_DUMP_L22;

        }

        found_valid_tld = 0;
        found_non_ip = 0;
        d = data;
        while(!(d >= data_end))
        {
          switch((signed int)d->dv.parm_type)
          {
            case 11:
            {
              SPF_errorx("spf_compile.c", 1123, "%s", (const void *)"Multiple CIDR parameters found");
              break;
            }
            case 4:

            case 5:

            case 0:
            {
              found_valid_tld = 0;
              break;
            }
            case 12:
            {
              found_valid_tld = 0;
              s=SPF_data_str(d);
              s_end = s + (signed long int)d->ds.len;
              for( ; !(s >= s_end); s = s + 1l)
              {
                const unsigned short int **return_value___ctype_b_loc_3;
                return_value___ctype_b_loc_3=__ctype_b_loc();
                if((2048 & (signed int)(*return_value___ctype_b_loc_3)[(signed long int)(signed int)(unsigned char)*s]) == 0)
                {
                  if(!((signed int)*s == 46))
                  {
                    if(!((signed int)*s == 58))
                      found_non_ip = 1;

                  }

                }

                if((signed int)*s == 46)
                  found_valid_tld = 1;

                else
                {
                  return_value___ctype_b_loc_4=__ctype_b_loc();
                  if((1024 & (signed int)(*return_value___ctype_b_loc_4)[(signed long int)(signed int)(unsigned char)*s]) == 0)
                    found_valid_tld = 0;

                }
              }
              break;
            }
            default:
            {
              found_non_ip = 1;
              found_valid_tld = 1;
            }
          }
          d=SPF_data_next(d);
        }
        if(found_non_ip == 0 || found_valid_tld == 0)
        {
          if(found_non_ip == 0)
            SPF_response_add_warn(spf_response, (enum SPF_errcode_t)SPF_E_BAD_HOST_IP, "Invalid hostname (an IP address?)");

          else
            if(found_valid_tld == 0)
              SPF_response_add_warn(spf_response, (enum SPF_errcode_t)SPF_E_BAD_HOST_TLD, "Hostname has a missing or invalid TLD");

        }

      }

    }


  __CPROVER_DUMP_L22:
    ;
    i = i + 1;
    mech=SPF_mech_next(mech);
  }
}

// SPF_record_new
// file ../../src/include/spf_record.h line 228
struct SPF_record_struct * SPF_record_new(struct SPF_server_struct *spf_server, const char *text)
{
  struct SPF_record_struct *rp;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct SPF_record_struct) /*64ul*/ );
  rp = (struct SPF_record_struct *)return_value_malloc_1;
  if(rp == ((struct SPF_record_struct *)NULL))
    return rp;

  else
  {
    memset((void *)rp, 0, sizeof(struct SPF_record_struct) /*64ul*/ );
    rp->spf_server = spf_server;
    return rp;
  }
}

// SPF_record_print
// file spf_print.c line 45
enum SPF_errcode_t SPF_record_print(struct SPF_record_struct *spf_record)
{
  char *prt_buf = (char *)(void *)0;
  unsigned long int prt_len = (unsigned long int)0;
  signed int err;
  const char *return_value_SPF_strerror_2;
  if(spf_record == ((struct SPF_record_struct *)NULL))
  {
    SPF_infox("spf_print.c", 52, "%s", (const void *)"SPF header: <null record>");
    SPF_infox("spf_print.c", 53, "%s", (const void *)"Unknown");
    return (enum SPF_errcode_t)SPF_E_SUCCESS;
  }

  else
  {
    SPF_infox("spf_print.c", 63, "SPF header:  version: %d  mech %d/%u  mod %d/%u  len=%u", spf_record->version, (signed int)spf_record->num_mech, (unsigned int)spf_record->mech_len, (signed int)spf_record->num_mod, (unsigned int)spf_record->mod_len, (unsigned int)(sizeof(struct SPF_record_struct) /*64ul*/  + spf_record->mech_len + spf_record->mod_len));
    enum SPF_errcode_t return_value_SPF_record_stringify_1;
    return_value_SPF_record_stringify_1=SPF_record_stringify(spf_record, &prt_buf, &prt_len);
    err = (signed int)return_value_SPF_record_stringify_1;
    if(err == SPF_E_RESULT_UNKNOWN)
      SPF_infox("spf_print.c", 67, "%s", (const void *)"Unknown");

    else
      if(!(err == 0))
      {
        return_value_SPF_strerror_2=SPF_strerror((enum SPF_errcode_t)err);
        SPF_infox("spf_print.c", 69, "SPF_record_stringify error: %s (%d)", return_value_SPF_strerror_2, err);
      }

      else
        SPF_infox("spf_print.c", 71, "SPF record:  %s", prt_buf);
    if(!(prt_buf == ((char *)NULL)))
      free((void *)prt_buf);

    return (enum SPF_errcode_t)SPF_E_SUCCESS;
  }
}

// SPF_record_stringify
// file spf_id2str.c line 245
enum SPF_errcode_t SPF_record_stringify(struct SPF_record_struct *spf_record, char **bufp, unsigned long int *buflenp)
{
  signed int i;
  struct SPF_mech_struct *mech;
  struct SPF_mod_struct *mod;
  union SPF_data_union *data;
  union SPF_data_union *data_end;
  unsigned long int len;
  const char *p_err;
  char *p;
  char *p_end;
  char ip4_buf[16l];
  char ip6_buf[46l];
  signed int cidr_ok;
  enum SPF_errcode_t err;
  do
    if(spf_record == ((struct SPF_record_struct *)NULL))
      SPF_errorx("spf_id2str.c", 265, "%s", (const void *)"spf_record is NULL");

  while((_Bool)0);
  len = sizeof(char [7l]) /*7ul*/  + spf_record->mech_len * (unsigned long int)4 + spf_record->mod_len * (unsigned long int)4 + sizeof(char [2l]) /*2ul*/ ;
  err=SPF_recalloc(bufp, buflenp, len);
  signed int return_value_snprintf_6;
  signed int return_value_snprintf_7;
  signed int return_value_snprintf_8;
  signed int return_value_snprintf_9;
  struct in_addr *return_value_SPF_mech_ip4_data_10;
  signed int return_value_snprintf_11;
  signed int return_value_snprintf_12;
  struct in6_addr *return_value_SPF_mech_ip6_data_13;
  signed int return_value_snprintf_14;
  signed int return_value_snprintf_15;
  signed int return_value_snprintf_16;
  signed int return_value_snprintf_17;
  signed int return_value_snprintf_18;
  union SPF_data_union *return_value_SPF_data_next_20;
  if(!((signed int)err == SPF_E_SUCCESS))
    return err;

  else
  {
    p = *bufp;
    p_end = *bufp + (signed long int)*buflenp;
    if(!(spf_record->spf_server->debug == 0))
      SPF_debugx("spf_id2str.c", 294, "stringify: Buffer length is %lu\n", (unsigned long int)*buflenp);

    signed int return_value_snprintf_1;
    return_value_snprintf_1=snprintf(p, (unsigned long int)(p_end - p), "v=spf%d", spf_record->version);
    len = (unsigned long int)return_value_snprintf_1;
    p = p + (signed long int)len;
    if(!(p_end - p >= 1l))
      return (enum SPF_errcode_t)SPF_E_INTERNAL_ERROR;

    else
    {
      mech = spf_record->mech_first;
      i = 0;
      for( ; !(i >= (signed int)spf_record->num_mech); i = i + 1)
      {
        if(!(spf_record->spf_server->debug == 0))
          SPF_debugx("spf_id2str.c", 314, "stringify: Handling mechanism %d/%d at %p", i, spf_record->num_mech, mech);

        if(!(p_end - p >= 2l))
          return (enum SPF_errcode_t)SPF_E_INTERNAL_ERROR;

        char *tmp_post_2 = p;
        p = p + 1l;
        *tmp_post_2 = (char)32;
        if(!(p_end - p >= 2l))
          return (enum SPF_errcode_t)SPF_E_INTERNAL_ERROR;

        switch((signed int)mech->prefix_type)
        {
          case SPF_RESULT_PASS:
            break;
          case SPF_RESULT_FAIL:
          {
            char *tmp_post_3 = p;
            p = p + 1l;
            *tmp_post_3 = (char)45;
            break;
          }
          case SPF_RESULT_SOFTFAIL:
          {
            char *tmp_post_4 = p;
            p = p + 1l;
            *tmp_post_4 = (char)126;
            break;
          }
          case SPF_RESULT_NEUTRAL:
          {
            char *tmp_post_5 = p;
            p = p + 1l;
            *tmp_post_5 = (char)63;
            break;
          }
          case SPF_RESULT_PERMERROR:
            return (enum SPF_errcode_t)SPF_E_RESULT_UNKNOWN;
          default:
            return (enum SPF_errcode_t)SPF_E_INVALID_PREFIX;
        }
        if(!(spf_record->spf_server->debug == 0))
          SPF_debugx("spf_id2str.c", 348, "Mechanism type is %d", mech->mech_type);

        switch((signed int)mech->mech_type)
        {
          case 1:
          {
            return_value_snprintf_6=snprintf(p, (unsigned long int)(p_end - p), "a");
            len = (unsigned long int)return_value_snprintf_6;
            break;
          }
          case 2:
          {
            return_value_snprintf_7=snprintf(p, (unsigned long int)(p_end - p), "mx");
            len = (unsigned long int)return_value_snprintf_7;
            break;
          }
          case 3:
          {
            return_value_snprintf_8=snprintf(p, (unsigned long int)(p_end - p), "ptr");
            len = (unsigned long int)return_value_snprintf_8;
            break;
          }
          case 4:
          {
            return_value_snprintf_9=snprintf(p, (unsigned long int)(p_end - p), "include");
            len = (unsigned long int)return_value_snprintf_9;
            break;
          }
          case 5:
          {
            return_value_SPF_mech_ip4_data_10=SPF_mech_ip4_data_link1(mech);
            p_err=inet_ntop(2, (const void *)return_value_SPF_mech_ip4_data_10, ip4_buf, (unsigned int)sizeof(char [16l]) /*16ul*/ );
            if(p_err == ((const char *)NULL))
              return (enum SPF_errcode_t)SPF_E_INTERNAL_ERROR;

            if(!(mech->mech_len == 0))
            {
              return_value_snprintf_11=snprintf(p, (unsigned long int)(p_end - p), "ip4:%s/%d", (const void *)ip4_buf, mech->mech_len);
              len = (unsigned long int)return_value_snprintf_11;
            }

            else
            {
              return_value_snprintf_12=snprintf(p, (unsigned long int)(p_end - p), "ip4:%s", (const void *)ip4_buf);
              len = (unsigned long int)return_value_snprintf_12;
            }
            break;
          }
          case 6:
          {
            return_value_SPF_mech_ip6_data_13=SPF_mech_ip6_data_link1(mech);
            p_err=inet_ntop(10, (const void *)return_value_SPF_mech_ip6_data_13, ip6_buf, (unsigned int)sizeof(char [46l]) /*46ul*/ );
            if(p_err == ((const char *)NULL))
              return (enum SPF_errcode_t)SPF_E_INTERNAL_ERROR;

            if(!(mech->mech_len == 0))
            {
              return_value_snprintf_14=snprintf(p, (unsigned long int)(p_end - p), "ip6:%s/%d", (const void *)ip6_buf, mech->mech_len);
              len = (unsigned long int)return_value_snprintf_14;
            }

            else
            {
              return_value_snprintf_15=snprintf(p, (unsigned long int)(p_end - p), "ip6:%s", (const void *)ip6_buf);
              len = (unsigned long int)return_value_snprintf_15;
            }
            break;
          }
          case 7:
          {
            return_value_snprintf_16=snprintf(p, (unsigned long int)(p_end - p), "exists");
            len = (unsigned long int)return_value_snprintf_16;
            break;
          }
          case 8:
          {
            return_value_snprintf_17=snprintf(p, (unsigned long int)(p_end - p), "all");
            len = (unsigned long int)return_value_snprintf_17;
            break;
          }
          case 9:
          {
            return_value_snprintf_18=snprintf(p, (unsigned long int)(p_end - p), "redirect");
            len = (unsigned long int)return_value_snprintf_18;
            break;
          }
          default:
            return (enum SPF_errcode_t)SPF_E_UNKNOWN_MECH;
        }
        p = p + (signed long int)len;
        if(!(p_end - p >= 1l))
          return (enum SPF_errcode_t)SPF_E_INTERNAL_ERROR;

        if(!(spf_record->spf_server->debug == 0))
          SPF_debugx("spf_id2str.c", 412, "stringify: Buffer so far is %s", p);

        if(!((signed int)mech->mech_type == 5))
        {
          if(!((signed int)mech->mech_type == 6))
          {
            data=SPF_mech_data_link1(mech);
            data_end=SPF_mech_end_data_link1(mech);
            unsigned long int return_value_SPF_mech_data_len_22;
            return_value_SPF_mech_data_len_22=SPF_mech_data_len_link1(mech);
            if(return_value_SPF_mech_data_len_22 >= 1ul)
            {
              _Bool tmp_if_expr_21;
              if(!((signed int)data->dc.parm_type == 11))
                tmp_if_expr_21 = (_Bool)1;

              else
              {
                return_value_SPF_data_next_20=SPF_data_next_link2(data);
                tmp_if_expr_21 = return_value_SPF_data_next_20 < data_end ? (_Bool)1 : (_Bool)0;
              }
              if(tmp_if_expr_21)
              {
                char *tmp_post_19 = p;
                p = p + 1l;
                *tmp_post_19 = (char)58;
              }

            }

            _Bool tmp_if_expr_23;
            if((signed int)mech->mech_type == 1)
              tmp_if_expr_23 = (_Bool)1;

            else
              tmp_if_expr_23 = (signed int)mech->mech_type == 2 ? (_Bool)1 : (_Bool)0;
            cidr_ok = (signed int)tmp_if_expr_23;
            err=SPF_record_stringify_data(data, data_end, &p, p_end, 0, cidr_ok, spf_record->spf_server->debug);
            if(!((signed int)err == SPF_E_SUCCESS))
              return err;

          }

        }

        mech=SPF_mech_next_link1(mech);
      }
      mod = spf_record->mod_first;
      i = 0;
      for( ; !(i >= (signed int)spf_record->num_mod); i = i + 1)
      {
        if(!(spf_record->spf_server->debug == 0))
          SPF_debugx("spf_id2str.c", 451, "stringify: Handling modifier %d/%d at %p", i, spf_record->num_mod, mod);

        if(!(p_end - p >= 2l))
          return (enum SPF_errcode_t)SPF_E_INTERNAL_ERROR;

        char *tmp_post_24 = p;
        p = p + 1l;
        *tmp_post_24 = (char)32;
        char *return_value_SPF_mod_name_25;
        return_value_SPF_mod_name_25=SPF_mod_name_link1(mod);
        signed int return_value_snprintf_26;
        return_value_snprintf_26=snprintf(p, (unsigned long int)(p_end - p), "%.*s=", mod->name_len, return_value_SPF_mod_name_25);
        len = (unsigned long int)return_value_snprintf_26;
        p = p + (signed long int)len;
        if(!(p_end - p >= 1l))
          return (enum SPF_errcode_t)SPF_E_INTERNAL_ERROR;

        data=SPF_mod_data_link1(mod);
        data_end=SPF_mod_end_data(mod);
        err=SPF_record_stringify_data(data, data_end, &p, p_end, 1, 1, spf_record->spf_server->debug);
        if(!((signed int)err == SPF_E_SUCCESS))
          return err;

        mod=SPF_mod_next(mod);
      }
      char *tmp_post_27 = p;
      p = p + 1l;
      *tmp_post_27 = (char)0;
      return (enum SPF_errcode_t)SPF_E_SUCCESS;
    }
  }
}

// SPF_record_stringify_data
// file spf_id2str.c line 44
static enum SPF_errcode_t SPF_record_stringify_data(union SPF_data_union *data, union SPF_data_union *data_end, char **p_p, char *p_end, signed int is_mod, signed int cidr_ok, signed int debug)
{
  char *p = *p_p;
  unsigned long int len;
  union SPF_data_union *cidr_data;
  if(!(debug == 0))
    SPF_debugx("spf_id2str.c", 55, " string data: Building");

  signed int return_value_toupper_10;
  if(!(p_end - p >= 1l))
    return (enum SPF_errcode_t)SPF_E_INTERNAL_ERROR;

  else
  {
    cidr_data = (union SPF_data_union *)(void *)0;
    if(!(data >= data_end))
    {
      if((signed int)data->dc.parm_type == 11)
      {
        if(!(debug == 0))
          SPF_debugx("spf_id2str.c", 64, " string data: Found a CIDR at %p", data);

        if(cidr_ok == 0)
          return (enum SPF_errcode_t)SPF_E_INTERNAL_ERROR;

        cidr_data = data;
        data=SPF_data_next_link2(data);
      }

    }

    while(!(data >= data_end))
    {
      if(!(debug == 0))
        SPF_debugx("spf_id2str.c", 77, " string data: Handling data type %d at %p", data->ds.parm_type, data);

      if((signed int)data->ds.parm_type == 12)
      {
        char *s;
        s=SPF_data_str_link2(data);
        char *s_end = s + (signed long int)data->ds.len;
        if(!(debug == 0))
          SPF_debugx("spf_id2str.c", 84, " string data: String is [%d] '%*.*s'", data->ds.len, data->ds.len, data->ds.len, s);

        if(!(p_end - (p + (signed long int)data->ds.len) >= 1l))
          return (enum SPF_errcode_t)SPF_E_INTERNAL_ERROR;

        while(!(s >= s_end))
          if((signed int)*s == 32)
          {
            char *tmp_post_1 = p;
            p = p + 1l;
            *tmp_post_1 = (char)37;
            char *tmp_post_2 = p;
            p = p + 1l;
            *tmp_post_2 = (char)95;
            s = s + 1l;
          }

          else
            if((signed int)*s == 37)
            {
              char *tmp_post_3 = p;
              p = p + 1l;
              *tmp_post_3 = (char)37;
              s = s + 1l;
              _Bool tmp_if_expr_6;
              if((signed int)*s == 50)
                tmp_if_expr_6 = (signed int)s[(signed long int)1] == 48 ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr_6 = (_Bool)0;
              if(tmp_if_expr_6)
              {
                char *tmp_post_4 = p;
                p = p + 1l;
                *tmp_post_4 = (char)45;
                s = s + (signed long int)2;
              }

              else
              {
                char *tmp_post_5 = p;
                p = p + 1l;
                *tmp_post_5 = (char)37;
              }
            }

            else
            {
              char *tmp_post_7 = p;
              p = p + 1l;
              char *tmp_post_8 = s;
              s = s + 1l;
              *tmp_post_7 = *tmp_post_8;
            }
        if(!(p_end - p >= 1l))
          return (enum SPF_errcode_t)SPF_E_INTERNAL_ERROR;

      }

      else
        if((signed int)data->dc.parm_type == 11)
          return (enum SPF_errcode_t)SPF_E_INVALID_CIDR;

        else
        {
          signed int return_value_snprintf_9;
          return_value_snprintf_9=snprintf(p, (unsigned long int)(p_end - p), "%%{");
          len = (unsigned long int)return_value_snprintf_9;
          p = p + (signed long int)len;
          if(!(p_end - p >= 1l))
            return (enum SPF_errcode_t)SPF_E_INTERNAL_ERROR;

          if(!(p_end - p >= 2l))
            return (enum SPF_errcode_t)SPF_E_INTERNAL_ERROR;

          switch((signed int)data->dv.parm_type)
          {
            case 0:
            {
              *p = (char)108;
              break;
            }
            case 1:
            {
              *p = (char)115;
              break;
            }
            case 2:
            {
              *p = (char)111;
              break;
            }
            case 3:
            {
              *p = (char)100;
              break;
            }
            case 4:
            {
              *p = (char)105;
              break;
            }
            case 5:
            {
              *p = (char)99;
              break;
            }
            case 6:
            {
              if(is_mod == 0)
                return (enum SPF_errcode_t)SPF_E_INVALID_VAR;

              *p = (char)116;
              break;
            }
            case 7:
            {
              *p = (char)112;
              break;
            }
            case 8:
            {
              *p = (char)118;
              break;
            }
            case 9:
            {
              *p = (char)104;
              break;
            }
            case 10:
            {
              *p = (char)114;
              break;
            }
            default:
              return (enum SPF_errcode_t)SPF_E_INVALID_VAR;
          }
          if(!(data->dv.url_encode == 0))
          {
            return_value_toupper_10=toupper((signed int)*p);
            *p = (char)return_value_toupper_10;
          }

          p = p + 1l;
          if(!(p_end - p >= 1l))
            return (enum SPF_errcode_t)SPF_E_INTERNAL_ERROR;

          if(!(data->dv.num_rhs == 0))
          {
            signed int return_value_snprintf_11;
            return_value_snprintf_11=snprintf(p, (unsigned long int)(p_end - p), "%d", data->dv.num_rhs);
            len = (unsigned long int)return_value_snprintf_11;
            p = p + (signed long int)len;
            if(!(p_end - p >= 1l))
              return (enum SPF_errcode_t)SPF_E_INTERNAL_ERROR;

          }

          if(!(p_end - p >= 9l))
            return (enum SPF_errcode_t)SPF_E_INTERNAL_ERROR;

          if(!(data->dv.rev == 0))
          {
            char *tmp_post_12 = p;
            p = p + 1l;
            *tmp_post_12 = (char)114;
          }

          if(!(data->dv.delim_dot == 0))
          {
            _Bool tmp_if_expr_14;
            if(!(data->dv.delim_dash == 0))
              tmp_if_expr_14 = (_Bool)1;

            else
              tmp_if_expr_14 = data->dv.delim_plus != 0 ? (_Bool)1 : (_Bool)0;
            _Bool tmp_if_expr_15;
            if(tmp_if_expr_14)
              tmp_if_expr_15 = (_Bool)1;

            else
              tmp_if_expr_15 = data->dv.delim_equal != 0 ? (_Bool)1 : (_Bool)0;
            _Bool tmp_if_expr_16;
            if(tmp_if_expr_15)
              tmp_if_expr_16 = (_Bool)1;

            else
              tmp_if_expr_16 = data->dv.delim_bar != 0 ? (_Bool)1 : (_Bool)0;
            _Bool tmp_if_expr_17;
            if(tmp_if_expr_16)
              tmp_if_expr_17 = (_Bool)1;

            else
              tmp_if_expr_17 = data->dv.delim_under != 0 ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr_17)
            {
              char *tmp_post_13 = p;
              p = p + 1l;
              *tmp_post_13 = (char)46;
            }

          }

          if(!(data->dv.delim_dash == 0))
          {
            char *tmp_post_18 = p;
            p = p + 1l;
            *tmp_post_18 = (char)45;
          }

          if(!(data->dv.delim_plus == 0))
          {
            char *tmp_post_19 = p;
            p = p + 1l;
            *tmp_post_19 = (char)43;
          }

          if(!(data->dv.delim_equal == 0))
          {
            char *tmp_post_20 = p;
            p = p + 1l;
            *tmp_post_20 = (char)61;
          }

          if(!(data->dv.delim_bar == 0))
          {
            char *tmp_post_21 = p;
            p = p + 1l;
            *tmp_post_21 = (char)124;
          }

          if(!(data->dv.delim_under == 0))
          {
            char *tmp_post_22 = p;
            p = p + 1l;
            *tmp_post_22 = (char)95;
          }

          char *tmp_post_23 = p;
          p = p + 1l;
          *tmp_post_23 = (char)125;
          if(!(p_end - p >= 1l))
            return (enum SPF_errcode_t)SPF_E_INTERNAL_ERROR;

        }
      data=SPF_data_next_link2(data);
    }
    if(!(cidr_data == ((union SPF_data_union *)NULL)))
    {
      if(!(cidr_data->dc.ipv4 == 0))
      {
        signed int return_value_snprintf_24;
        return_value_snprintf_24=snprintf(p, (unsigned long int)(p_end - p), "/%d", cidr_data->dc.ipv4);
        len = (unsigned long int)return_value_snprintf_24;
        p = p + (signed long int)len;
        if(!(p_end - p >= 1l))
          return (enum SPF_errcode_t)SPF_E_INTERNAL_ERROR;

      }

      if(!(cidr_data->dc.ipv6 == 0))
      {
        signed int return_value_snprintf_25;
        return_value_snprintf_25=snprintf(p, (unsigned long int)(p_end - p), "//%d", cidr_data->dc.ipv6);
        len = (unsigned long int)return_value_snprintf_25;
        p = p + (signed long int)len;
        if(!(p_end - p >= 1l))
          return (enum SPF_errcode_t)SPF_E_INTERNAL_ERROR;

      }

    }

    *p_p = p;
    return (enum SPF_errcode_t)SPF_E_SUCCESS;
  }
}

// SPF_request_free
// file ../../src/include/spf_request.h line 54
void SPF_request_free(struct SPF_request_struct *sr)
{
  do
    if(sr == ((struct SPF_request_struct *)NULL))
      SPF_errorx("spf_request.c", 61, "%s", (const void *)"sr is NULL");

  while((_Bool)0);
  do
  {
    if(!(sr->client_dom == ((char *)NULL)))
      free((void *)sr->client_dom);

    sr->client_dom = (char *)(void *)0;
  }
  while((_Bool)0);
  do
  {
    if(!(sr->helo_dom == ((char *)NULL)))
      free((void *)sr->helo_dom);

    sr->helo_dom = (char *)(void *)0;
  }
  while((_Bool)0);
  do
  {
    if(!(sr->env_from == ((char *)NULL)))
      free((void *)sr->env_from);

    sr->env_from = (char *)(void *)0;
  }
  while((_Bool)0);
  do
  {
    if(!(sr->env_from_lp == ((char *)NULL)))
      free((void *)sr->env_from_lp);

    sr->env_from_lp = (char *)(void *)0;
  }
  while((_Bool)0);
  do
  {
    if(!(sr->env_from_dp == ((char *)NULL)))
      free((void *)sr->env_from_dp);

    sr->env_from_dp = (char *)(void *)0;
  }
  while((_Bool)0);
  free((void *)sr);
}

// SPF_request_get_client_dom
// file ../../src/include/spf_request.h line 69
const char * SPF_request_get_client_dom(struct SPF_request_struct *sr)
{
  struct SPF_server_struct *SPF_request_get_client_dom__1__spf_server;
  do
    if(sr == ((struct SPF_request_struct *)NULL))
      SPF_errorx("spf_request.c", 200, "%s", (const void *)"sr is NULL");

  while((_Bool)0);
  SPF_request_get_client_dom__1__spf_server = sr->spf_server;
  do
    if(SPF_request_get_client_dom__1__spf_server == ((struct SPF_server_struct *)NULL))
      SPF_errorx("spf_request.c", 202, "%s", (const void *)"spf_server is NULL");

  while((_Bool)0);
  if(sr->client_dom == ((char *)NULL))
    sr->client_dom=SPF_dns_get_client_dom(SPF_request_get_client_dom__1__spf_server->resolver, sr);

  return sr->client_dom;
}

// SPF_request_get_exp
// file spf_get_exp.c line 83
enum SPF_errcode_t SPF_request_get_exp(struct SPF_server_struct *spf_server, struct SPF_request_struct *spf_request, struct SPF_response_struct *spf_response, struct SPF_record_struct *spf_record, char **bufp, unsigned long int *buflenp)
{
  struct SPF_macro_struct *spf_macro;
  struct SPF_dns_server_struct *resolver;
  struct SPF_dns_rr_struct *rr_txt;
  enum SPF_errcode_t err;
  const char *domain;
  do
    if(spf_server == ((struct SPF_server_struct *)NULL))
      SPF_errorx("spf_get_exp.c", 101, "%s", (const void *)"spf_server is NULL");

  while((_Bool)0);
  do
    if(spf_request == ((struct SPF_request_struct *)NULL))
      SPF_errorx("spf_get_exp.c", 102, "%s", (const void *)"spf_request is NULL");

  while((_Bool)0);
  do
    if(spf_response == ((struct SPF_response_struct *)NULL))
      SPF_errorx("spf_get_exp.c", 103, "%s", (const void *)"spf_response is NULL");

  while((_Bool)0);
  do
    if(spf_record == ((struct SPF_record_struct *)NULL))
      SPF_errorx("spf_get_exp.c", 104, "%s", (const void *)"spf_record is NULL");

  while((_Bool)0);
  do
    if(bufp == ((char **)NULL))
      SPF_errorx("spf_get_exp.c", 105, "%s", (const void *)"bufp is NULL");

  while((_Bool)0);
  do
    if(buflenp == ((unsigned long int *)NULL))
      SPF_errorx("spf_get_exp.c", 106, "%s", (const void *)"buflenp is NULL");

  while((_Bool)0);
  domain = spf_request->cur_dom;
  enum SPF_errcode_t return_value_SPF_response_add_warn_1;
  if(domain == ((const char *)NULL))
  {
    return_value_SPF_response_add_warn_1=SPF_response_add_warn(spf_response, (enum SPF_errcode_t)SPF_E_NOT_CONFIG, "Could not identify current domain for explanation");
    return return_value_SPF_response_add_warn_1;
  }

  err=SPF_record_find_mod_value(spf_server, spf_request, spf_response, spf_record, "exp-text", bufp, buflenp);
  enum SPF_errcode_t return_value;
  enum SPF_errcode_t return_value_SPF_server_get_default_explanation_6;
  enum SPF_errcode_t return_value_SPF_server_get_default_explanation_7;
  enum SPF_errcode_t return_value_SPF_server_get_default_explanation_8;
  if((signed int)err == SPF_E_SUCCESS)
    return err;

  else
  {
    err=SPF_record_find_mod_value(spf_server, spf_request, spf_response, spf_record, "exp", bufp, buflenp);
    if(!((signed int)err == SPF_E_SUCCESS))
    {
      enum SPF_errcode_t return_value_SPF_server_get_default_explanation_2;
      return_value_SPF_server_get_default_explanation_2=SPF_server_get_default_explanation(spf_server, spf_request, spf_response, bufp, buflenp);
      return return_value_SPF_server_get_default_explanation_2;
    }

    _Bool tmp_if_expr_4;
    if(*bufp == ((char *)NULL))
      tmp_if_expr_4 = (_Bool)1;

    else
      tmp_if_expr_4 = (signed int)(*bufp)[(signed long int)0] == 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_4)
    {
      SPF_response_add_warn(spf_response, (enum SPF_errcode_t)SPF_E_NOT_SPF, "Explanation is blank!");
      enum SPF_errcode_t return_value_SPF_server_get_default_explanation_3;
      return_value_SPF_server_get_default_explanation_3=SPF_server_get_default_explanation(spf_server, spf_request, spf_response, bufp, buflenp);
      return return_value_SPF_server_get_default_explanation_3;
    }

    resolver = spf_server->resolver;
    if(!(resolver->get_exp == ((enum SPF_errcode_t (*)(struct SPF_server_struct *, const char *, char **, unsigned long int *))NULL)))
    {
      return_value=resolver->get_exp(spf_server, *bufp, bufp, buflenp);
      return return_value;
    }

    rr_txt=SPF_dns_lookup(resolver, *bufp, (enum __ns_type)ns_t_txt, 1);
    if(rr_txt == ((struct SPF_dns_rr_struct *)NULL))
    {
      SPF_dns_rr_free(rr_txt);
      enum SPF_errcode_t return_value_SPF_server_get_default_explanation_5;
      return_value_SPF_server_get_default_explanation_5=SPF_server_get_default_explanation(spf_server, spf_request, spf_response, bufp, buflenp);
      return return_value_SPF_server_get_default_explanation_5;
    }

    switch(rr_txt->herrno)
    {
      case 1:

      case 4:
      {
        SPF_dns_rr_free(rr_txt);
        return_value_SPF_server_get_default_explanation_6=SPF_server_get_default_explanation(spf_server, spf_request, spf_response, bufp, buflenp);
        return return_value_SPF_server_get_default_explanation_6;
      }
      case 2:
      {
        SPF_dns_rr_free(rr_txt);
        return_value_SPF_server_get_default_explanation_7=SPF_server_get_default_explanation(spf_server, spf_request, spf_response, bufp, buflenp);
        return return_value_SPF_server_get_default_explanation_7;
      }
      case 0:
        break;
      default:
      {
        SPF_warningx("spf_get_exp.c", 180, "%s", (const void *)"Unknown DNS lookup error code");
        SPF_dns_rr_free(rr_txt);
        return_value_SPF_server_get_default_explanation_8=SPF_server_get_default_explanation(spf_server, spf_request, spf_response, bufp, buflenp);
        return return_value_SPF_server_get_default_explanation_8;
      }
    }
    if(rr_txt->num_rr == 0)
    {
      SPF_response_add_warn(spf_response, (enum SPF_errcode_t)SPF_E_NOT_SPF, "No TXT records returned from DNS lookup");
      enum SPF_errcode_t return_value_SPF_server_get_default_explanation_9;
      return_value_SPF_server_get_default_explanation_9=SPF_server_get_default_explanation(spf_server, spf_request, spf_response, bufp, buflenp);
      return return_value_SPF_server_get_default_explanation_9;
    }

    spf_macro = (struct SPF_macro_struct *)(void *)0;
    err=SPF_record_compile_macro(spf_server, spf_response, &spf_macro, rr_txt->rr[(signed long int)0]->txt);
    if(!((signed int)err == SPF_E_SUCCESS))
    {
      if(!(spf_macro == ((struct SPF_macro_struct *)NULL)))
        SPF_macro_free(spf_macro);

      SPF_dns_rr_free(rr_txt);
      enum SPF_errcode_t return_value_SPF_server_get_default_explanation_10;
      return_value_SPF_server_get_default_explanation_10=SPF_server_get_default_explanation(spf_server, spf_request, spf_response, bufp, buflenp);
      return return_value_SPF_server_get_default_explanation_10;
    }

    union SPF_data_union *return_value_SPF_macro_data_11;
    return_value_SPF_macro_data_11=SPF_macro_data_link1(spf_macro);
    err=SPF_record_expand_data(spf_server, spf_request, spf_response, return_value_SPF_macro_data_11, spf_macro->macro_len, bufp, buflenp);
    SPF_macro_free(spf_macro);
    SPF_dns_rr_free(rr_txt);
    return err;
  }
}

// SPF_request_get_rec_dom
// file ../../src/include/spf_request.h line 67
const char * SPF_request_get_rec_dom(struct SPF_request_struct *sr)
{
  struct SPF_server_struct *SPF_request_get_rec_dom__1__spf_server = sr->spf_server;
  return SPF_request_get_rec_dom__1__spf_server->rec_dom;
}

// SPF_request_is_loopback
// file spf_request.c line 212
signed int SPF_request_is_loopback(struct SPF_request_struct *sr)
{
  unsigned int return_value_htonl_5;
  if(sr->client_ver == 2)
  {
    unsigned int return_value_ntohl_1;
    return_value_ntohl_1=ntohl(sr->ipv4.s_addr);
    if((0xff000000 & return_value_ntohl_1) == 2130706432u)
      return 1;

  }

  else
    if(sr->client_ver == 10)
    {
      _Bool tmp_statement_expression_2;
      struct in6_addr *__a = (struct in6_addr *)&sr->ipv6;
      _Bool tmp_if_expr_3;
      if(__a->__in6_u.__u6_addr32[0l] == 0u)
        tmp_if_expr_3 = __a->__in6_u.__u6_addr32[(signed long int)1] == (unsigned int)0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_3 = (_Bool)0;
      _Bool tmp_if_expr_4;
      if(tmp_if_expr_3)
        tmp_if_expr_4 = __a->__in6_u.__u6_addr32[(signed long int)2] == (unsigned int)0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_4 = (_Bool)0;
      _Bool tmp_if_expr_6;
      if(tmp_if_expr_4)
      {
        return_value_htonl_5=htonl((unsigned int)1);
        tmp_if_expr_6 = __a->__in6_u.__u6_addr32[(signed long int)3] == return_value_htonl_5 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_6 = (_Bool)0;
      tmp_statement_expression_2 = tmp_if_expr_6;
      if(tmp_statement_expression_2)
        return 1;

    }

  return 0;
}

// SPF_request_new
// file ../../src/include/spf_request.h line 53
struct SPF_request_struct * SPF_request_new(struct SPF_server_struct *spf_server)
{
  struct SPF_request_struct *sr;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct SPF_request_struct) /*96ul*/ );
  sr = (struct SPF_request_struct *)return_value_malloc_1;
  if(sr == ((struct SPF_request_struct *)NULL))
    return sr;

  else
  {
    memset((void *)sr, 0, sizeof(struct SPF_request_struct) /*96ul*/ );
    sr->spf_server = spf_server;
    sr->client_ver = 0;
    sr->ipv4.s_addr=htonl((unsigned int)0x00000000);
    sr->ipv6 = in6addr_any;
    return sr;
  }
}

// SPF_request_prepare
// file spf_request.c line 228
static enum SPF_errcode_t SPF_request_prepare(struct SPF_request_struct *sr)
{
  if(!(sr->use_helo == 0))
    sr->cur_dom = sr->helo_dom;

  else
    sr->cur_dom = sr->env_from_dp;
  return (enum SPF_errcode_t)SPF_E_SUCCESS;
}

// SPF_request_query_fallback
// file ../../src/include/spf_request.h line 77
enum SPF_errcode_t SPF_request_query_fallback(struct SPF_request_struct *spf_request, struct SPF_response_struct **spf_responsep, const char *record)
{
  struct SPF_server_struct *SPF_request_query_fallback__1__spf_server;
  struct SPF_record_struct *spf_record;
  enum SPF_errcode_t err;
  do
    if(spf_request == ((struct SPF_request_struct *)NULL))
      SPF_errorx("spf_request.c", 307, "%s", (const void *)"spf_request is NULL");

  while((_Bool)0);
  SPF_request_query_fallback__1__spf_server = spf_request->spf_server;
  do
    if(SPF_request_query_fallback__1__spf_server == ((struct SPF_server_struct *)NULL))
      SPF_errorx("spf_request.c", 309, "%s", (const void *)"spf_server is NULL");

  while((_Bool)0);
  *spf_responsep=SPF_response_new(spf_request);
  enum SPF_errcode_t return_value_SPF_i_done_1;
  if(*spf_responsep == ((struct SPF_response_struct *)NULL))
    return (enum SPF_errcode_t)SPF_E_NO_MEMORY;

  else
  {
    signed int return_value_SPF_request_is_loopback_2;
    return_value_SPF_request_is_loopback_2=SPF_request_is_loopback(spf_request);
    if(!(return_value_SPF_request_is_loopback_2 == 0))
    {
      return_value_SPF_i_done_1=SPF_i_done(*spf_responsep, (enum SPF_result_enum)SPF_RESULT_PASS, (enum SPF_reason_enum)SPF_REASON_LOCALHOST, (enum SPF_errcode_t)SPF_E_SUCCESS);
      return return_value_SPF_i_done_1;
    }

    SPF_request_prepare(spf_request);
    err=SPF_record_compile(SPF_request_query_fallback__1__spf_server, *spf_responsep, &spf_record, record);
    enum SPF_errcode_t return_value_SPF_request_query_record_3;
    return_value_SPF_request_query_record_3=SPF_request_query_record(spf_request, *spf_responsep, spf_record, err);
    return return_value_SPF_request_query_record_3;
  }
}

// SPF_request_query_mailfrom
// file ../../src/include/spf_request.h line 72
enum SPF_errcode_t SPF_request_query_mailfrom(struct SPF_request_struct *spf_request, struct SPF_response_struct **spf_responsep)
{
  struct SPF_server_struct *SPF_request_query_mailfrom__1__spf_server;
  struct SPF_record_struct *spf_record;
  enum SPF_errcode_t err;
  do
    if(spf_request == ((struct SPF_request_struct *)NULL))
      SPF_errorx("spf_request.c", 276, "%s", (const void *)"spf_request is NULL");

  while((_Bool)0);
  SPF_request_query_mailfrom__1__spf_server = spf_request->spf_server;
  do
    if(SPF_request_query_mailfrom__1__spf_server == ((struct SPF_server_struct *)NULL))
      SPF_errorx("spf_request.c", 278, "%s", (const void *)"spf_server is NULL");

  while((_Bool)0);
  *spf_responsep=SPF_response_new(spf_request);
  enum SPF_errcode_t return_value_SPF_i_done_1;
  if(*spf_responsep == ((struct SPF_response_struct *)NULL))
    return (enum SPF_errcode_t)SPF_E_NO_MEMORY;

  else
  {
    signed int return_value_SPF_request_is_loopback_2;
    return_value_SPF_request_is_loopback_2=SPF_request_is_loopback(spf_request);
    if(!(return_value_SPF_request_is_loopback_2 == 0))
    {
      return_value_SPF_i_done_1=SPF_i_done(*spf_responsep, (enum SPF_result_enum)SPF_RESULT_PASS, (enum SPF_reason_enum)SPF_REASON_LOCALHOST, (enum SPF_errcode_t)SPF_E_SUCCESS);
      return return_value_SPF_i_done_1;
    }

    SPF_request_prepare(spf_request);
    err=SPF_server_get_record(SPF_request_query_mailfrom__1__spf_server, spf_request, *spf_responsep, &spf_record);
    enum SPF_errcode_t return_value_SPF_request_query_record_3;
    return_value_SPF_request_query_record_3=SPF_request_query_record(spf_request, *spf_responsep, spf_record, err);
    return return_value_SPF_request_query_record_3;
  }
}

// SPF_request_query_rcptto
// file ../../src/include/spf_request.h line 74
enum SPF_errcode_t SPF_request_query_rcptto(struct SPF_request_struct *spf_request, struct SPF_response_struct **spf_responsep, const char *rcpt_to)
{
  struct SPF_server_struct *SPF_request_query_rcptto__1__spf_server;
  struct SPF_record_struct *spf_record;
  enum SPF_errcode_t err;
  const char *rcpt_to_dom;
  char *record;
  unsigned long int len;
  do
    if(spf_request == ((struct SPF_request_struct *)NULL))
      SPF_errorx("spf_request.c", 350, "%s", (const void *)"spf_request is NULL");

  while((_Bool)0);
  SPF_request_query_rcptto__1__spf_server = spf_request->spf_server;
  do
    if(SPF_request_query_rcptto__1__spf_server == ((struct SPF_server_struct *)NULL))
      SPF_errorx("spf_request.c", 352, "%s", (const void *)"spf_server is NULL");

  while((_Bool)0);
  *spf_responsep=SPF_response_new(spf_request);
  enum SPF_errcode_t return_value_SPF_i_done_1;
  if(*spf_responsep == ((struct SPF_response_struct *)NULL))
    return (enum SPF_errcode_t)SPF_E_NO_MEMORY;

  else
  {
    signed int return_value_SPF_request_is_loopback_2;
    return_value_SPF_request_is_loopback_2=SPF_request_is_loopback(spf_request);
    if(!(return_value_SPF_request_is_loopback_2 == 0))
    {
      return_value_SPF_i_done_1=SPF_i_done(*spf_responsep, (enum SPF_result_enum)SPF_RESULT_PASS, (enum SPF_reason_enum)SPF_REASON_LOCALHOST, (enum SPF_errcode_t)SPF_E_SUCCESS);
      return return_value_SPF_i_done_1;
    }

    rcpt_to_dom=strchr(rcpt_to, 64);
    if(rcpt_to_dom == ((const char *)NULL))
      rcpt_to_dom = rcpt_to;

    spf_request->cur_dom = rcpt_to_dom;
    unsigned long int return_value_strlen_3;
    return_value_strlen_3=strlen(rcpt_to_dom);
    len = sizeof(char [7l]) /*7ul*/  + (unsigned long int)64 + return_value_strlen_3;
    void *return_value_malloc_4;
    return_value_malloc_4=malloc(len);
    record = (char *)return_value_malloc_4;
    if(record == ((char *)NULL))
      return (enum SPF_errcode_t)SPF_E_NO_MEMORY;

    else
    {
      snprintf(record, len, "v=spf1 mx:%s", rcpt_to_dom);
      err=SPF_record_compile(SPF_request_query_rcptto__1__spf_server, *spf_responsep, &spf_record, record);
      free((void *)record);
      enum SPF_errcode_t return_value_SPF_request_query_record_5;
      return_value_SPF_request_query_record_5=SPF_request_query_record(spf_request, *spf_responsep, spf_record, err);
      return return_value_SPF_request_query_record_5;
    }
  }
}

// SPF_request_query_record
// file spf_request.c line 241
static enum SPF_errcode_t SPF_request_query_record(struct SPF_request_struct *spf_request, struct SPF_response_struct *spf_response, struct SPF_record_struct *spf_record, enum SPF_errcode_t err)
{
  signed int return_value_SPF_response_errors_1;
  if(!((signed int)err == SPF_E_SUCCESS))
  {
    if(!(spf_record == ((struct SPF_record_struct *)NULL)))
      SPF_record_free(spf_record);

    return err;
  }

  else
  {
    signed int return_value_SPF_response_errors_2;
    return_value_SPF_response_errors_2=SPF_response_errors(spf_response);
    if(return_value_SPF_response_errors_2 >= 1)
    {
      return_value_SPF_response_errors_1=SPF_response_errors(spf_response);
      SPF_infox("spf_request.c", 255, "Warning: %d errors in response, but no error code. Evaluating.", return_value_SPF_response_errors_1);
    }

    spf_response->spf_record_exp = spf_record;
    err=SPF_record_interpret(spf_record, spf_request, spf_response, 0);
    SPF_record_free(spf_record);
    return err;
  }
}

// SPF_request_set_env_from
// file ../../src/include/spf_request.h line 65
signed int SPF_request_set_env_from(struct SPF_request_struct *sr, const char *from)
{
  char *cp;
  unsigned long int len;
  do
    if(from == ((const char *)NULL))
      SPF_errorx("spf_request.c", 144, "%s", (const void *)"from is NULL");

  while((_Bool)0);
  do
  {
    if(!(sr->env_from == ((char *)NULL)))
      free((void *)sr->env_from);

    sr->env_from = (char *)(void *)0;
  }
  while((_Bool)0);
  do
  {
    if(!(sr->env_from_lp == ((char *)NULL)))
      free((void *)sr->env_from_lp);

    sr->env_from_lp = (char *)(void *)0;
  }
  while((_Bool)0);
  do
  {
    if(!(sr->env_from_dp == ((char *)NULL)))
      free((void *)sr->env_from_dp);

    sr->env_from_dp = (char *)(void *)0;
  }
  while((_Bool)0);
  if((signed int)*from == 0)
  {
    if(!(sr->helo_dom == ((char *)NULL)))
      from = sr->helo_dom;

  }

  cp=strrchr(from, 64);
  if(!(cp == ((char *)NULL)) && !(cp == from))
  {
    sr->env_from=strdup(from);
    if(sr->env_from == ((char *)NULL))
      return SPF_E_NO_MEMORY;

    len = (unsigned long int)(cp - from);
    void *return_value_malloc_1;
    return_value_malloc_1=malloc(len + (unsigned long int)1);
    sr->env_from_lp = (char *)return_value_malloc_1;
    if(sr->env_from_lp == ((char *)NULL))
    {
      do
      {
        if(!(sr->env_from == ((char *)NULL)))
          free((void *)sr->env_from);

        sr->env_from = (char *)(void *)0;
      }
      while((_Bool)0);
      return SPF_E_NO_MEMORY;
    }

    strncpy(sr->env_from_lp, from, len);
    sr->env_from_lp[(signed long int)len] = (char)0;
    sr->env_from_dp=strdup(cp + (signed long int)1);
    if(sr->env_from_dp == ((char *)NULL))
    {
      do
      {
        if(!(sr->env_from == ((char *)NULL)))
          free((void *)sr->env_from);

        sr->env_from = (char *)(void *)0;
      }
      while((_Bool)0);
      do
      {
        if(!(sr->env_from_lp == ((char *)NULL)))
          free((void *)sr->env_from_lp);

        sr->env_from_lp = (char *)(void *)0;
      }
      while((_Bool)0);
      return SPF_E_NO_MEMORY;
    }

  }

  else
  {
    if(cp == from)
      from = from + 1l;

    unsigned long int return_value_strlen_2;
    return_value_strlen_2=strlen(from);
    len = sizeof(char [12l]) /*12ul*/  + return_value_strlen_2;
    void *return_value_malloc_3;
    return_value_malloc_3=malloc(len + (unsigned long int)1);
    sr->env_from = (char *)return_value_malloc_3;
    if(sr->env_from == ((char *)NULL))
      return SPF_E_NO_MEMORY;

    sprintf(sr->env_from, "postmaster@%s", from);
    sr->env_from_lp=strdup("postmaster");
    if(sr->env_from_lp == ((char *)NULL))
    {
      do
      {
        if(!(sr->env_from == ((char *)NULL)))
          free((void *)sr->env_from);

        sr->env_from = (char *)(void *)0;
      }
      while((_Bool)0);
      return SPF_E_NO_MEMORY;
    }

    sr->env_from_dp=strdup(from);
    if(sr->env_from_dp == ((char *)NULL))
    {
      do
      {
        if(!(sr->env_from == ((char *)NULL)))
          free((void *)sr->env_from);

        sr->env_from = (char *)(void *)0;
      }
      while((_Bool)0);
      do
      {
        if(!(sr->env_from_lp == ((char *)NULL)))
          free((void *)sr->env_from_lp);

        sr->env_from_lp = (char *)(void *)0;
      }
      while((_Bool)0);
      return SPF_E_NO_MEMORY;
    }

  }
  return 0;
}

// SPF_request_set_helo_dom
// file ../../src/include/spf_request.h line 63
enum SPF_errcode_t SPF_request_set_helo_dom(struct SPF_request_struct *sr, const char *dom)
{
  do
    if(dom == ((const char *)NULL))
      SPF_errorx("spf_request.c", 119, "%s", (const void *)"dom is NULL");

  while((_Bool)0);
  do
  {
    if(!(sr->helo_dom == ((char *)NULL)))
      free((void *)sr->helo_dom);

    sr->helo_dom = (char *)(void *)0;
  }
  while((_Bool)0);
  sr->helo_dom=strdup(dom);
  signed int return_value_SPF_request_set_env_from_1;
  if(sr->helo_dom == ((char *)NULL))
    return (enum SPF_errcode_t)SPF_E_NO_MEMORY;

  else
  {
    if(sr->env_from == ((char *)NULL))
    {
      return_value_SPF_request_set_env_from_1=SPF_request_set_env_from(sr, dom);
      return (enum SPF_errcode_t)return_value_SPF_request_set_env_from_1;
    }

    return (enum SPF_errcode_t)SPF_E_SUCCESS;
  }
}

// SPF_request_set_ipv4
// file spf_request.c line 71
enum SPF_errcode_t SPF_request_set_ipv4(struct SPF_request_struct *sr, struct in_addr addr)
{
  if(!(sr->client_dom == ((char *)NULL)))
  {
    free((void *)sr->client_dom);
    sr->client_dom = (char *)(void *)0;
  }

  sr->client_ver = 2;
  sr->ipv4 = addr;
  return (enum SPF_errcode_t)SPF_E_SUCCESS;
}

// SPF_request_set_ipv4_str
// file ../../src/include/spf_request.h line 59
enum SPF_errcode_t SPF_request_set_ipv4_str(struct SPF_request_struct *sr, const char *astr)
{
  struct in_addr addr;
  if(astr == ((const char *)NULL))
    astr = "0.0.0.0";

  signed int return_value_inet_pton_1;
  return_value_inet_pton_1=inet_pton(2, astr, (void *)&addr);
  if(!(return_value_inet_pton_1 >= 1))
    return (enum SPF_errcode_t)SPF_E_INVALID_IP4;

  else
  {
    enum SPF_errcode_t return_value_SPF_request_set_ipv4_2;
    return_value_SPF_request_set_ipv4_2=SPF_request_set_ipv4(sr, addr);
    return return_value_SPF_request_set_ipv4_2;
  }
}

// SPF_request_set_ipv6
// file spf_request.c line 83
enum SPF_errcode_t SPF_request_set_ipv6(struct SPF_request_struct *sr, struct in6_addr addr)
{
  if(!(sr->client_dom == ((char *)NULL)))
  {
    free((void *)sr->client_dom);
    sr->client_dom = (char *)(void *)0;
  }

  sr->client_ver = 10;
  sr->ipv6 = addr;
  return (enum SPF_errcode_t)SPF_E_SUCCESS;
}

// SPF_request_set_ipv6_str
// file ../../src/include/spf_request.h line 61
enum SPF_errcode_t SPF_request_set_ipv6_str(struct SPF_request_struct *sr, const char *astr)
{
  struct in6_addr addr;
  if(astr == ((const char *)NULL))
    astr = "::";

  signed int return_value_inet_pton_1;
  return_value_inet_pton_1=inet_pton(10, astr, (void *)&addr);
  if(!(return_value_inet_pton_1 >= 1))
    return (enum SPF_errcode_t)SPF_E_INVALID_IP6;

  else
  {
    enum SPF_errcode_t return_value_SPF_request_set_ipv6_2;
    return_value_SPF_request_set_ipv6_2=SPF_request_set_ipv6(sr, addr);
    return return_value_SPF_request_set_ipv6_2;
  }
}

// SPF_response_add_error
// file ../../src/include/spf_response.h line 234
enum SPF_errcode_t SPF_response_add_error(struct SPF_response_struct *rp, enum SPF_errcode_t code, const char *format, ...)
{
  void **ap = (void **)&format;
  SPF_response_add_error_v(rp, code, 1, (const char *)(void *)0, 0, format, ap);
  rp->num_errors = rp->num_errors + 1;
  ap = ((void **)NULL);
  return code;
}

// SPF_response_add_error_idx
// file spf_response.c line 247
enum SPF_errcode_t SPF_response_add_error_idx(struct SPF_response_struct *rp, enum SPF_errcode_t code, const char *text, signed int idx, const char *format, ...)
{
  void **ap = (void **)&format;
  SPF_response_add_error_v(rp, code, 1, text, idx, format, ap);
  rp->num_errors = rp->num_errors + 1;
  ap = ((void **)NULL);
  return code;
}

// SPF_response_add_error_ptr
// file ../../src/include/spf_response.h line 226
enum SPF_errcode_t SPF_response_add_error_ptr(struct SPF_response_struct *rp, enum SPF_errcode_t code, const char *text, const char *tptr, const char *format, ...)
{
  void **ap = (void **)&format;
  SPF_response_add_error_v(rp, code, 1, text != ((const char *)NULL) ? text : tptr, (signed int)(text != ((const char *)NULL) ? tptr - text : (signed long int)0), format, ap);
  rp->num_errors = rp->num_errors + 1;
  ap = ((void **)NULL);
  return code;
}

// SPF_response_add_error_v
// file spf_response.c line 187
static enum SPF_errcode_t SPF_response_add_error_v(struct SPF_response_struct *rp, enum SPF_errcode_t code, signed int is_error, const char *text, signed int idx, const char *format, void **ap)
{
  struct SPF_error_struct *tmp;
  char buf[4096l];
  signed int size;
  if(format == ((const char *)NULL))
    format=SPF_strerror(code);

  size=vsnprintf(buf, sizeof(char [4096l]) /*4096ul*/ , format, ap);
  if(!(text == ((const char *)NULL)))
    snprintf(&buf[(signed long int)size], sizeof(char [4096l]) /*4096ul*/  - (unsigned long int)size, " near '%.12s'", &text[(signed long int)idx]);

  buf[(signed long int)(4096 - 1)] = (char)0;
  if(rp->errors_length == rp->errors_size)
  {
    size = (signed int)rp->errors_size + (signed int)rp->errors_size / 4 + 4;
    void *return_value_realloc_1;
    return_value_realloc_1=realloc((void *)rp->errors, (unsigned long int)size * sizeof(struct SPF_error_struct) /*24ul*/ );
    tmp = (struct SPF_error_struct *)return_value_realloc_1;
    if(tmp == ((struct SPF_error_struct *)NULL))
    {
      SPF_errorx("spf_response.c", 211, "%s", (const void *)"Failed to allocate memory for extra response error");
      return code;
    }

    rp->errors = tmp;
    rp->errors_size = (unsigned short int)size;
  }

  (rp->errors + (signed long int)rp->errors_length)->code = code;
  (rp->errors + (signed long int)rp->errors_length)->is_error = (char)is_error;
  (rp->errors + (signed long int)rp->errors_length)->message=strdup(buf);
  rp->errors_length = rp->errors_length + 1;
  return code;
}

// SPF_response_add_warn
// file ../../src/include/spf_response.h line 245
enum SPF_errcode_t SPF_response_add_warn(struct SPF_response_struct *rp, enum SPF_errcode_t code, const char *format, ...)
{
  void **ap = (void **)&format;
  SPF_response_add_error_v(rp, code, 0, (const char *)(void *)0, 0, format, ap);
  ap = ((void **)NULL);
  return code;
}

// SPF_response_add_warn_idx
// file spf_response.c line 273
enum SPF_errcode_t SPF_response_add_warn_idx(struct SPF_response_struct *rp, enum SPF_errcode_t code, const char *text, signed int idx, const char *format, ...)
{
  void **ap = (void **)&format;
  SPF_response_add_error_v(rp, code, 0, text, idx, format, ap);
  ap = ((void **)NULL);
  return code;
}

// SPF_response_add_warn_ptr
// file spf_response.c line 264
enum SPF_errcode_t SPF_response_add_warn_ptr(struct SPF_response_struct *rp, enum SPF_errcode_t code, const char *text, const char *tptr, const char *format, ...)
{
  void **ap = (void **)&format;
  SPF_response_add_error_v(rp, code, 0, text != ((const char *)NULL) ? text : tptr, (signed int)(text != ((const char *)NULL) ? tptr - text : (signed long int)0), format, ap);
  ap = ((void **)NULL);
  return code;
}

// SPF_response_choose
// file spf_response.c line 78
static struct SPF_response_struct * SPF_response_choose(struct SPF_response_struct *yes, struct SPF_response_struct *no)
{
  SPF_response_free(no);
  return yes;
}

// SPF_response_combine
// file ../../src/include/spf_response.h line 198
struct SPF_response_struct * SPF_response_combine(struct SPF_response_struct *main, struct SPF_response_struct *r2mx)
{
  enum SPF_result_enum return_value_SPF_response_result_1;
  return_value_SPF_response_result_1=SPF_response_result(main);
  struct SPF_response_struct *return_value_SPF_response_choose_2;
  struct SPF_response_struct *return_value_SPF_response_choose_3;
  enum SPF_result_enum return_value_SPF_response_result_4;
  struct SPF_response_struct *return_value_SPF_response_choose_5;
  struct SPF_response_struct *return_value_SPF_response_choose_6;
  struct SPF_response_struct *return_value_SPF_response_choose_7;
  enum SPF_result_enum return_value_SPF_response_result_8;
  struct SPF_response_struct *return_value_SPF_response_choose_9;
  struct SPF_response_struct *return_value_SPF_response_choose_10;
  switch((signed int)return_value_SPF_response_result_1)
  {
    case SPF_RESULT_INVALID:
    {
      return_value_SPF_response_choose_2=SPF_response_choose(r2mx, main);
      return return_value_SPF_response_choose_2;
    }
    case SPF_RESULT_PASS:
    {
      return_value_SPF_response_choose_3=SPF_response_choose(main, r2mx);
      return return_value_SPF_response_choose_3;
    }
    case SPF_RESULT_NEUTRAL:
    {
      return_value_SPF_response_result_4=SPF_response_result(r2mx);
      if((signed int)return_value_SPF_response_result_4 == SPF_RESULT_PASS)
      {
        return_value_SPF_response_choose_5=SPF_response_choose(r2mx, main);
        return return_value_SPF_response_choose_5;
      }

      return_value_SPF_response_choose_6=SPF_response_choose(main, r2mx);
      return return_value_SPF_response_choose_6;
    }
    case SPF_RESULT_FAIL:
    {
      return_value_SPF_response_choose_7=SPF_response_choose(r2mx, main);
      return return_value_SPF_response_choose_7;
    }
    case SPF_RESULT_TEMPERROR:

    case SPF_RESULT_PERMERROR:

    case SPF_RESULT_SOFTFAIL:

    default:
    {
      return_value_SPF_response_result_8=SPF_response_result(r2mx);
      if((signed int)return_value_SPF_response_result_8 == SPF_RESULT_NEUTRAL || (signed int)return_value_SPF_response_result_8 == SPF_RESULT_PASS || (signed int)return_value_SPF_response_result_8 == SPF_RESULT_SOFTFAIL)
      {
        return_value_SPF_response_choose_9=SPF_response_choose(r2mx, main);
        return return_value_SPF_response_choose_9;
      }

      return_value_SPF_response_choose_10=SPF_response_choose(main, r2mx);
      return return_value_SPF_response_choose_10;
    }
  }
}

// SPF_response_errcode
// file ../../src/include/spf_response.h line 204
enum SPF_errcode_t SPF_response_errcode(struct SPF_response_struct *rp)
{
  return rp->err;
}

// SPF_response_errors
// file ../../src/include/spf_response.h line 214
signed int SPF_response_errors(struct SPF_response_struct *rp)
{
  return (signed int)rp->num_errors;
}

// SPF_response_free
// file ../../src/include/spf_response.h line 197
void SPF_response_free(struct SPF_response_struct *rp)
{
  signed int i;
  if(!(rp->received_spf == ((char *)NULL)))
    free((void *)rp->received_spf);

  if(!(rp->header_comment == ((char *)NULL)))
    free((void *)rp->header_comment);

  if(!(rp->smtp_comment == ((char *)NULL)))
    free((void *)rp->smtp_comment);

  if(!(rp->explanation == ((char *)NULL)))
    free((void *)rp->explanation);

  if(!(rp->errors == ((struct SPF_error_struct *)NULL)))
  {
    i = 0;
    for( ; !(i >= (signed int)rp->errors_length); i = i + 1)
      free((void *)(rp->errors + (signed long int)i)->message);
    free((void *)rp->errors);
  }

  free((void *)rp);
}

// SPF_response_get_explanation
// file spf_response.c line 177
const char * SPF_response_get_explanation(struct SPF_response_struct *rp)
{
  return rp->explanation;
}

// SPF_response_get_header_comment
// file ../../src/include/spf_response.h line 207
const char * SPF_response_get_header_comment(struct SPF_response_struct *rp)
{
  return rp->header_comment;
}

// SPF_response_get_received_spf
// file spf_response.c line 153
const char * SPF_response_get_received_spf(struct SPF_response_struct *rp)
{
  return rp->received_spf;
}

// SPF_response_get_received_spf_value
// file spf_response.c line 159
const char * SPF_response_get_received_spf_value(struct SPF_response_struct *rp)
{
  return rp->received_spf_value;
}

// SPF_response_get_smtp_comment
// file ../../src/include/spf_response.h line 208
const char * SPF_response_get_smtp_comment(struct SPF_response_struct *rp)
{
  return rp->smtp_comment;
}

// SPF_response_message
// file ../../src/include/spf_response.h line 218
struct SPF_error_struct * SPF_response_message(struct SPF_response_struct *rp, signed int idx)
{
  return &rp->errors[(signed long int)idx];
}

// SPF_response_messages
// file ../../src/include/spf_response.h line 212
signed int SPF_response_messages(struct SPF_response_struct *rp)
{
  return (signed int)rp->errors_length;
}

// SPF_response_new
// file ../../src/include/spf_response.h line 196
struct SPF_response_struct * SPF_response_new(struct SPF_request_struct *spf_request)
{
  struct SPF_response_struct *rp;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct SPF_response_struct) /*96ul*/ );
  rp = (struct SPF_response_struct *)return_value_malloc_1;
  if(rp == ((struct SPF_response_struct *)NULL))
    return rp;

  else
  {
    memset((void *)rp, 0, sizeof(struct SPF_response_struct) /*96ul*/ );
    rp->spf_request = spf_request;
    rp->result = (enum SPF_result_enum)SPF_RESULT_INVALID;
    return rp;
  }
}

// SPF_response_reason
// file ../../src/include/spf_response.h line 203
enum SPF_reason_enum SPF_response_reason(struct SPF_response_struct *rp)
{
  return rp->reason;
}

// SPF_response_result
// file ../../src/include/spf_response.h line 202
enum SPF_result_enum SPF_response_result(struct SPF_response_struct *rp)
{
  return rp->result;
}

// SPF_response_warnings
// file spf_response.c line 302
signed int SPF_response_warnings(struct SPF_response_struct *rp)
{
  return (signed int)rp->errors_length - (signed int)rp->num_errors;
}

// SPF_sanitize
// file ../../src/include/spf_internal.h line 138
char * SPF_sanitize(struct SPF_server_struct *spf_server, char *str)
{
  char *p;
  do
    if(spf_server == ((struct SPF_server_struct *)NULL))
      SPF_errorx("spf_utils.c", 58, "%s", (const void *)"spf_server is NULL");

  while((_Bool)0);
  const unsigned short int **return_value___ctype_b_loc_1;
  if(spf_server->sanitize == 0)
    return str;

  else
    if(str == ((char *)NULL))
      return str;

    else
    {
      p = str;
      for( ; !((signed int)*p == 0); p = p + 1l)
      {
        return_value___ctype_b_loc_1=__ctype_b_loc();
        if((16384 & (signed int)(*return_value___ctype_b_loc_1)[(signed long int)(signed int)(unsigned char)*p]) == 0)
          *p = (char)63;

      }
      return str;
    }
}

// SPF_server_free
// file spf_server.c line 200
void SPF_server_free(struct SPF_server_struct *sp)
{
  if(!(sp->resolver == ((struct SPF_dns_server_struct *)NULL)))
  {
    if(!(sp->destroy_resolver == 0))
      SPF_dns_free(sp->resolver);

  }

  if(!(sp->local_policy == ((struct SPF_record_struct *)NULL)))
    SPF_record_free(sp->local_policy);

  if(!(sp->explanation == ((struct SPF_macro_struct *)NULL)))
    SPF_macro_free(sp->explanation);

  if(!(sp->rec_dom == ((char *)NULL)))
    free((void *)sp->rec_dom);

  free((void *)sp);
}

// SPF_server_get_default_explanation
// file spf_get_exp.c line 47
static enum SPF_errcode_t SPF_server_get_default_explanation(struct SPF_server_struct *spf_server, struct SPF_request_struct *spf_request, struct SPF_response_struct *spf_response, char **bufp, unsigned long int *buflenp)
{
  enum SPF_errcode_t err;
  struct SPF_macro_struct *spf_macro = spf_server->explanation;
  if(!(spf_macro == ((struct SPF_macro_struct *)NULL)))
  {
    union SPF_data_union *return_value_SPF_macro_data_1;
    return_value_SPF_macro_data_1=SPF_macro_data_link1(spf_macro);
    err=SPF_record_expand_data(spf_server, spf_request, spf_response, return_value_SPF_macro_data_1, spf_macro->macro_len, bufp, buflenp);
    return err;
  }

  else
  {
    unsigned long int len = sizeof(char [38l]) /*38ul*/  + (unsigned long int)1;
    if(!(*buflenp >= len))
    {
      char *tmp;
      void *return_value_realloc_2;
      return_value_realloc_2=realloc((void *)*bufp, len);
      tmp = (char *)return_value_realloc_2;
      if(tmp == ((char *)NULL))
        return (enum SPF_errcode_t)SPF_E_NO_MEMORY;

      *bufp = tmp;
      *buflenp = len;
    }

    strcpy(*bufp, "SPF failure: no explanation available");
    return (enum SPF_errcode_t)SPF_E_SUCCESS;
  }
}

// SPF_server_get_max_dns_mech
// file spf_server.c line 504
signed int SPF_server_get_max_dns_mech(struct SPF_server_struct *s)
{
  return s->max_dns_mech;
}

// SPF_server_get_max_dns_mx
// file ../../src/include/spf_server.h line 105
signed int SPF_server_get_max_dns_mx(struct SPF_server_struct *s)
{
  return s->max_dns_mx;
}

// SPF_server_get_max_dns_ptr
// file ../../src/include/spf_server.h line 104
signed int SPF_server_get_max_dns_ptr(struct SPF_server_struct *s)
{
  return s->max_dns_ptr;
}

// SPF_server_get_record
// file ../../src/include/spf_server.h line 89
enum SPF_errcode_t SPF_server_get_record(struct SPF_server_struct *spf_server, struct SPF_request_struct *spf_request, struct SPF_response_struct *spf_response, struct SPF_record_struct **spf_recordp)
{
  struct SPF_dns_server_struct *resolver;
  struct SPF_dns_rr_struct *rr_txt;
  enum SPF_errcode_t err;
  signed int herrno;
  const char *domain;
  enum __ns_type rr_type;
  signed int num_found;
  signed int idx_found;
  signed int i;
  do
    if(spf_server == ((struct SPF_server_struct *)NULL))
      SPF_errorx("spf_server.c", 332, "%s", (const void *)"spf_server is NULL");

  while((_Bool)0);
  do
    if(spf_request == ((struct SPF_request_struct *)NULL))
      SPF_errorx("spf_server.c", 333, "%s", (const void *)"spf_request is NULL");

  while((_Bool)0);
  do
    if(spf_server->resolver == ((struct SPF_dns_server_struct *)NULL))
      SPF_errorx("spf_server.c", 334, "%s", (const void *)"spf_server->resolver is NULL");

  while((_Bool)0);
  do
    if(spf_recordp == ((struct SPF_record_struct **)NULL))
      SPF_errorx("spf_server.c", 335, "%s", (const void *)"spf_recordp is NULL");

  while((_Bool)0);
  domain = spf_request->cur_dom;
  do
    if(domain == ((const char *)NULL))
      SPF_errorx("spf_server.c", 338, "%s", (const void *)"domain is NULL");

  while((_Bool)0);
  *spf_recordp = (struct SPF_record_struct *)(void *)0;
  resolver = spf_server->resolver;
  enum SPF_errcode_t return_value;
  if(!(resolver->get_spf == ((enum SPF_errcode_t (*)(struct SPF_server_struct *, struct SPF_request_struct *, struct SPF_response_struct *, struct SPF_record_struct **))NULL)))
  {
    return_value=resolver->get_spf(spf_server, spf_request, spf_response, spf_recordp);
    return return_value;
  }

  rr_type = (enum __ns_type)ns_t_txt;
  enum SPF_errcode_t return_value_SPF_response_add_error_1;
  enum SPF_errcode_t return_value_SPF_i_done_2;
  enum SPF_errcode_t return_value_SPF_response_add_error_3;
  enum SPF_errcode_t return_value_SPF_i_done_4;
  enum SPF_errcode_t return_value_SPF_response_add_error_5;
  enum SPF_errcode_t return_value_SPF_response_add_error_6;
  enum SPF_errcode_t return_value_SPF_response_add_error_7;
  do
  {

  retry:
    ;
    rr_txt=SPF_dns_lookup(resolver, domain, rr_type, 1);
    switch(rr_txt->herrno)
    {
      case 1:
      {
        if(spf_server->debug >= 1)
          SPF_debugx("spf_server.c", 356, "get_record(%s): HOST_NOT_FOUND", domain);

        SPF_dns_rr_free(rr_txt);
        if((signed int)rr_type == 99)
        {
          rr_type = (enum __ns_type)ns_t_txt;
          goto retry;
        }

        spf_response->result = (enum SPF_result_enum)SPF_RESULT_NONE;
        spf_response->reason = (enum SPF_reason_enum)SPF_REASON_FAILURE;
        return_value_SPF_response_add_error_1=SPF_response_add_error(spf_response, (enum SPF_errcode_t)SPF_E_NOT_SPF, "Host '%s' not found.", domain);
        return_value_SPF_i_done_2=SPF_i_done(spf_response, (enum SPF_result_enum)SPF_RESULT_NONE, (enum SPF_reason_enum)SPF_REASON_FAILURE, return_value_SPF_response_add_error_1);
        return return_value_SPF_i_done_2;
      }
      case 4:
      {
        if(spf_server->debug >= 1)
          SPF_debugx("spf_server.c", 371, "get_record(%s): NO_DATA", domain);

        SPF_dns_rr_free(rr_txt);
        if((signed int)rr_type == 99)
        {
          rr_type = (enum __ns_type)ns_t_txt;
          goto retry;
        }

        spf_response->result = (enum SPF_result_enum)SPF_RESULT_NONE;
        spf_response->reason = (enum SPF_reason_enum)SPF_REASON_FAILURE;
        return_value_SPF_response_add_error_3=SPF_response_add_error(spf_response, (enum SPF_errcode_t)SPF_E_NOT_SPF, "No DNS data for '%s'.", domain);
        return_value_SPF_i_done_4=SPF_i_done(spf_response, (enum SPF_result_enum)SPF_RESULT_NONE, (enum SPF_reason_enum)SPF_REASON_FAILURE, return_value_SPF_response_add_error_3);
        return return_value_SPF_i_done_4;
      }
      case 2:
      {
        if(spf_server->debug >= 1)
          SPF_debugx("spf_server.c", 386, "get_record(%s): TRY_AGAIN", domain);

        SPF_dns_rr_free(rr_txt);
        return_value_SPF_response_add_error_5=SPF_response_add_error(spf_response, (enum SPF_errcode_t)SPF_E_DNS_ERROR, "Temporary DNS failure for '%s'.", domain);
        return return_value_SPF_response_add_error_5;
      }
      case 3:
      {
        if(spf_server->debug >= 1)
          SPF_debugx("spf_server.c", 394, "get_record(%s): NO_RECOERY", domain);

        SPF_dns_rr_free(rr_txt);
        return_value_SPF_response_add_error_6=SPF_response_add_error(spf_response, (enum SPF_errcode_t)SPF_E_DNS_ERROR, "Unrecoverable DNS failure for '%s'.", domain);
        return return_value_SPF_response_add_error_6;
      }
      case 0:
      {
        if(spf_server->debug >= 1)
          SPF_debugx("spf_server.c", 402, "get_record(%s): NETDB_SUCCESS", domain);

        break;
      }
      default:
      {
        if(spf_server->debug >= 1)
          SPF_debugx("spf_server.c", 407, "get_record(%s): UNKNOWN_ERROR", domain);

        herrno = rr_txt->herrno;
        SPF_dns_rr_free(rr_txt);
        return_value_SPF_response_add_error_7=SPF_response_add_error(spf_response, (enum SPF_errcode_t)SPF_E_DNS_ERROR, "Unknown DNS failure for '%s': %d.", domain, herrno);
        return return_value_SPF_response_add_error_7;
      }
    }
    if(rr_txt->num_rr == 0)
    {
      SPF_dns_rr_free(rr_txt);
      if((signed int)rr_type == 99)
      {
        rr_type = (enum __ns_type)ns_t_txt;
        goto retry;
      }

      enum SPF_errcode_t return_value_SPF_response_add_error_8;
      return_value_SPF_response_add_error_8=SPF_response_add_error(spf_response, (enum SPF_errcode_t)SPF_E_NOT_SPF, "No TXT records returned from DNS lookup for '%s'", domain);
      return return_value_SPF_response_add_error_8;
    }

    idx_found = 0;
    num_found = 0;
    i = 0;
    for( ; !(i >= rr_txt->num_rr); i = i + 1)
    {
      signed int return_value_strncasecmp_9;
      return_value_strncasecmp_9=strncasecmp(rr_txt->rr[(signed long int)i]->txt, "v=spf1", sizeof(char [7l]) /*7ul*/  - (unsigned long int)1);
      if(return_value_strncasecmp_9 == 0)
      {
        char e = rr_txt->rr[(signed long int)i]->txt[(signed long int)(sizeof(char [7l]) /*7ul*/  - (unsigned long int)1)];
        if((signed int)e == 0 || (signed int)e == 32)
        {
          if(spf_server->debug >= 1)
            SPF_debugx("spf_server.c", 443, "found SPF record: %s", (const void *)rr_txt->rr[(signed long int)i]->txt);

          num_found = num_found + 1;
          idx_found = i;
        }

      }

    }
    if(!(num_found == 0))
      goto __CPROVER_DUMP_L36;

    SPF_dns_rr_free(rr_txt);
    if(!((signed int)rr_type == 99))
      break;

    rr_type = (enum __ns_type)ns_t_txt;
  }
  while((_Bool)1);
  spf_response->result = (enum SPF_result_enum)SPF_RESULT_NONE;
  spf_response->reason = (enum SPF_reason_enum)SPF_REASON_FAILURE;
  enum SPF_errcode_t return_value_SPF_response_add_error_10;
  return_value_SPF_response_add_error_10=SPF_response_add_error(spf_response, (enum SPF_errcode_t)SPF_E_NOT_SPF, "No SPF records for '%s'", domain);
  enum SPF_errcode_t return_value_SPF_i_done_11;
  return_value_SPF_i_done_11=SPF_i_done(spf_response, (enum SPF_result_enum)SPF_RESULT_NONE, (enum SPF_reason_enum)SPF_REASON_FAILURE, return_value_SPF_response_add_error_10);
  return return_value_SPF_i_done_11;

__CPROVER_DUMP_L36:
  ;
  if(num_found >= 2)
  {
    SPF_dns_rr_free(rr_txt);
    spf_response->result = (enum SPF_result_enum)SPF_RESULT_PERMERROR;
    spf_response->reason = (enum SPF_reason_enum)SPF_REASON_FAILURE;
    enum SPF_errcode_t return_value_SPF_response_add_error_12;
    return_value_SPF_response_add_error_12=SPF_response_add_error(spf_response, (enum SPF_errcode_t)SPF_E_MULTIPLE_RECORDS, "Multiple SPF records for '%s'", domain);
    enum SPF_errcode_t return_value_SPF_i_done_13;
    return_value_SPF_i_done_13=SPF_i_done(spf_response, (enum SPF_result_enum)SPF_RESULT_PERMERROR, (enum SPF_reason_enum)SPF_REASON_FAILURE, return_value_SPF_response_add_error_12);
    return return_value_SPF_i_done_13;
  }

  err=SPF_record_compile(spf_server, spf_response, spf_recordp, rr_txt->rr[(signed long int)idx_found]->txt);
  SPF_dns_rr_free(rr_txt);
  enum SPF_errcode_t return_value_SPF_response_add_error_14;
  if(!((signed int)err == SPF_E_SUCCESS))
  {
    return_value_SPF_response_add_error_14=SPF_response_add_error(spf_response, (enum SPF_errcode_t)SPF_E_NOT_SPF, "Failed to compile SPF record for '%s'", domain);
    return return_value_SPF_response_add_error_14;
  }

  return (enum SPF_errcode_t)SPF_E_SUCCESS;
}

// SPF_server_new
// file ../../src/include/spf_server.h line 76
struct SPF_server_struct * SPF_server_new(enum SPF_server_dnstype_enum dnstype, signed int debug)
{
  struct SPF_dns_server_struct *dc_r;
  struct SPF_dns_server_struct *dc_c;
  struct SPF_dns_server_struct *dc_z;
  struct SPF_server_struct *sp;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct SPF_server_struct) /*56ul*/ );
  sp = (struct SPF_server_struct *)return_value_malloc_1;
  if(sp == ((struct SPF_server_struct *)NULL))
    return sp;

  else
  {
    SPF_server_new_common_pre(sp, debug);
    sp->destroy_resolver = 1;
    switch((signed int)dnstype)
    {
      case SPF_DNS_RESOLV:
      {
        dc_r=SPF_dns_resolv_new((struct SPF_dns_server_struct *)(void *)0, (const char *)(void *)0, debug);
        if(dc_r == ((struct SPF_dns_server_struct *)NULL))
          SPF_errorx("spf_server.c", 149, "%s", (const void *)"Failed to create DNS resolver");

        sp->resolver = dc_r;
        break;
      }
      case SPF_DNS_CACHE:
      {
        dc_r=SPF_dns_resolv_new((struct SPF_dns_server_struct *)(void *)0, (const char *)(void *)0, debug);
        if(dc_r == ((struct SPF_dns_server_struct *)NULL))
          SPF_errorx("spf_server.c", 156, "%s", (const void *)"Failed to create DNS resolver");

        dc_c=SPF_dns_cache_new(dc_r, (const char *)(void *)0, debug, 8);
        if(dc_c == ((struct SPF_dns_server_struct *)NULL))
          SPF_errorx("spf_server.c", 159, "%s", (const void *)"Failed to create DNS cache");

        sp->resolver = dc_c;
        break;
      }
      case SPF_DNS_ZONE:
      {
        dc_z=SPF_dns_zone_new((struct SPF_dns_server_struct *)(void *)0, (const char *)(void *)0, debug);
        if(dc_z == ((struct SPF_dns_server_struct *)NULL))
          SPF_errorx("spf_server.c", 166, "%s", (const void *)"Failed to create DNS zone");

        sp->resolver = dc_z;
        break;
      }
      default:
        SPF_errorx("spf_server.c", 171, "Unknown DNS type %d", dnstype);
    }
    SPF_server_new_common_post(sp);
    return sp;
  }
}

// SPF_server_new_common_post
// file spf_server.c line 102
static void SPF_server_new_common_post(struct SPF_server_struct *sp)
{
  struct SPF_response_struct *spf_response;
  enum SPF_errcode_t err;
  spf_response = (struct SPF_response_struct *)(void *)0;
  err=SPF_server_set_explanation(sp, "Please%_see%_http://www.openspf.org/Why?id=%{S}&ip=%{C}&receiver=%{R}", &spf_response);
  if(!((signed int)err == SPF_E_SUCCESS))
    SPF_errorx("spf_server.c", 111, "Error code %d compiling default explanation", err);

  if(!(spf_response == ((struct SPF_response_struct *)NULL)))
  {
    signed int return_value_SPF_response_messages_1;
    return_value_SPF_response_messages_1=SPF_response_messages(spf_response);
    if(return_value_SPF_response_messages_1 >= 1)
      SPF_errorx("spf_server.c", 115, "%s", (const void *)"Response errors compiling default explanation");

    SPF_response_free(spf_response);
  }

  spf_response = (struct SPF_response_struct *)(void *)0;
  err=SPF_server_set_localpolicy(sp, "", 0, &spf_response);
  if(!((signed int)err == SPF_E_SUCCESS))
    SPF_errorx("spf_server.c", 122, "Error code %d compiling default whitelist", err);

  if(!(spf_response == ((struct SPF_response_struct *)NULL)))
  {
    signed int return_value_SPF_response_messages_2;
    return_value_SPF_response_messages_2=SPF_response_messages(spf_response);
    if(return_value_SPF_response_messages_2 >= 1)
      SPF_errorx("spf_server.c", 126, "%s", (const void *)"Response errors compiling default whitelist");

    SPF_response_free(spf_response);
  }

}

// SPF_server_new_common_pre
// file spf_server.c line 85
static void SPF_server_new_common_pre(struct SPF_server_struct *sp, signed int debug)
{
  enum SPF_errcode_t err;
  memset((void *)sp, 0, sizeof(struct SPF_server_struct) /*56ul*/ );
  sp->max_dns_mech = 10;
  sp->max_dns_ptr = 10;
  sp->max_dns_mx = 10;
  sp->debug = debug;
  err=SPF_server_set_rec_dom_ghbn(sp);
  if(!((signed int)err == SPF_E_SUCCESS))
    SPF_errorx("spf_server.c", 98, "%s", (const void *)"Failed to set rec_dom using gethostname()");

}

// SPF_server_new_dns
// file spf_server.c line 180
struct SPF_server_struct * SPF_server_new_dns(struct SPF_dns_server_struct *dns, signed int debug)
{
  struct SPF_server_struct *sp;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct SPF_server_struct) /*56ul*/ );
  sp = (struct SPF_server_struct *)return_value_malloc_1;
  if(sp == ((struct SPF_server_struct *)NULL))
    return sp;

  else
  {
    SPF_server_new_common_pre(sp, debug);
    sp->destroy_resolver = 0;
    sp->resolver = dns;
    SPF_server_new_common_post(sp);
    return sp;
  }
}

// SPF_server_set_explanation
// file ../../src/include/spf_server.h line 83
enum SPF_errcode_t SPF_server_set_explanation(struct SPF_server_struct *sp, const char *exp, struct SPF_response_struct **spf_responsep)
{
  struct SPF_macro_struct *spf_macro = (struct SPF_macro_struct *)(void *)0;
  enum SPF_errcode_t err;
  do
    if(exp == ((const char *)NULL))
      SPF_errorx("spf_server.c", 241, "%s", (const void *)"exp is NULL");

  while((_Bool)0);
  if(*spf_responsep == ((struct SPF_response_struct *)NULL))
  {
    *spf_responsep=SPF_response_new((struct SPF_request_struct *)(void *)0);
    if(!(*spf_responsep == ((struct SPF_response_struct *)NULL)))
      goto __CPROVER_DUMP_L3;

    return (enum SPF_errcode_t)SPF_E_NO_MEMORY;
  }

  else
  {

  __CPROVER_DUMP_L3:
    ;
    err=SPF_record_compile_macro(sp, *spf_responsep, &spf_macro, exp);
    if((signed int)err == SPF_E_SUCCESS)
    {
      if(!(sp->explanation == ((struct SPF_macro_struct *)NULL)))
        SPF_macro_free(sp->explanation);

      sp->explanation = spf_macro;
    }

    else
    {
      SPF_response_add_error(*spf_responsep, err, "Failed to compile explanation '%s'", exp);
      if(!(spf_macro == ((struct SPF_macro_struct *)NULL)))
        SPF_macro_free(spf_macro);

    }
    return err;
  }
}

// SPF_server_set_localpolicy
// file ../../src/include/spf_server.h line 85
enum SPF_errcode_t SPF_server_set_localpolicy(struct SPF_server_struct *sp, const char *policy, signed int use_default_whitelist, struct SPF_response_struct **spf_responsep)
{
  struct SPF_record_struct *spf_record = (struct SPF_record_struct *)(void *)0;
  enum SPF_errcode_t err;
  char *record;
  unsigned long int len;
  do
    if(policy == ((const char *)NULL))
      SPF_errorx("spf_server.c", 276, "%s", (const void *)"policy is NULL");

  while((_Bool)0);
  if(*spf_responsep == ((struct SPF_response_struct *)NULL))
  {
    *spf_responsep=SPF_response_new((struct SPF_request_struct *)(void *)0);
    if(!(*spf_responsep == ((struct SPF_response_struct *)NULL)))
      goto __CPROVER_DUMP_L3;

    return (enum SPF_errcode_t)SPF_E_NO_MEMORY;
  }

  else
  {

  __CPROVER_DUMP_L3:
    ;
    unsigned long int return_value_strlen_1;
    return_value_strlen_1=strlen(policy);
    len = sizeof(char [7l]) /*7ul*/  + return_value_strlen_1 + (unsigned long int)20;
    if(!(use_default_whitelist == 0))
      len = len + sizeof(char [34l]) /*34ul*/ ;

    void *return_value_malloc_2;
    return_value_malloc_2=malloc(len);
    record = (char *)return_value_malloc_2;
    if(record == ((char *)NULL))
      return (enum SPF_errcode_t)SPF_E_NO_MEMORY;

    else
    {
      if(!(use_default_whitelist == 0))
        snprintf(record, len, "%s %s %s", (const void *)"v=spf1", policy, (const void *)"include:spf.trusted-forwarder.org");

      else
        snprintf(record, len, "%s %s", (const void *)"v=spf1", policy);
      err=SPF_record_compile(sp, *spf_responsep, &spf_record, record);
      if((signed int)err == SPF_E_SUCCESS)
      {
        if(!(sp->local_policy == ((struct SPF_record_struct *)NULL)))
          SPF_record_free(sp->local_policy);

        sp->local_policy = spf_record;
      }

      else
      {
        SPF_response_add_error(*spf_responsep, err, "Failed to compile local policy '%s'", policy);
        if(!(spf_record == ((struct SPF_record_struct *)NULL)))
          SPF_record_free(spf_record);

      }
      free((void *)record);
      return err;
    }
  }
}

// SPF_server_set_max_dns_mech
// file ../../src/include/spf_server.h line 103
enum SPF_errcode_t SPF_server_set_max_dns_mech(struct SPF_server_struct *s, signed int n)
{
  s->max_dns_mech = n;
  return (enum SPF_errcode_t)SPF_E_SUCCESS;
}

// SPF_server_set_max_dns_mx
// file spf_server.c line 506
enum SPF_errcode_t SPF_server_set_max_dns_mx(struct SPF_server_struct *s, signed int n)
{
  s->max_dns_mx = n;
  return (enum SPF_errcode_t)SPF_E_SUCCESS;
}

// SPF_server_set_max_dns_ptr
// file spf_server.c line 505
enum SPF_errcode_t SPF_server_set_max_dns_ptr(struct SPF_server_struct *s, signed int n)
{
  s->max_dns_ptr = n;
  return (enum SPF_errcode_t)SPF_E_SUCCESS;
}

// SPF_server_set_rec_dom
// file ../../src/include/spf_server.h line 79
enum SPF_errcode_t SPF_server_set_rec_dom(struct SPF_server_struct *sp, const char *dom)
{
  if(!(sp->rec_dom == ((char *)NULL)))
    free((void *)sp->rec_dom);

  enum SPF_errcode_t return_value_SPF_server_set_rec_dom_ghbn_1;
  if(dom == ((const char *)NULL))
  {
    return_value_SPF_server_set_rec_dom_ghbn_1=SPF_server_set_rec_dom_ghbn(sp);
    return return_value_SPF_server_set_rec_dom_ghbn_1;
  }

  sp->rec_dom=strdup(dom);
  if(sp->rec_dom == ((char *)NULL))
    return (enum SPF_errcode_t)SPF_E_NO_MEMORY;

  else
    return (enum SPF_errcode_t)SPF_E_SUCCESS;
}

// SPF_server_set_rec_dom_ghbn
// file spf_server.c line 68
static enum SPF_errcode_t SPF_server_set_rec_dom_ghbn(struct SPF_server_struct *sp)
{
  void *return_value_malloc_1;
  return_value_malloc_1=malloc((unsigned long int)64);
  sp->rec_dom = (char *)return_value_malloc_1;
  if(sp->rec_dom == ((char *)NULL))
    return (enum SPF_errcode_t)SPF_E_NO_MEMORY;

  else
  {
    signed int return_value_gethostname_2;
    return_value_gethostname_2=gethostname(sp->rec_dom, (unsigned long int)64);
    if(!(return_value_gethostname_2 >= 0))
      return (enum SPF_errcode_t)SPF_E_INTERNAL_ERROR;

    else
      return (enum SPF_errcode_t)SPF_E_SUCCESS;
  }
}

// SPF_server_set_sanitize
// file ../../src/include/spf_server.h line 81
enum SPF_errcode_t SPF_server_set_sanitize(struct SPF_server_struct *sp, signed int sanitize)
{
  sp->sanitize = sanitize;
  return (enum SPF_errcode_t)SPF_E_SUCCESS;
}

// SPF_strerror
// file ../../src/include/spf.h line 74
const char * SPF_strerror(enum SPF_errcode_t spf_c_err)
{
  switch((signed int)spf_c_err)
  {
    case SPF_E_SUCCESS:
      return "No errors";
    case SPF_E_NO_MEMORY:
      return "Out of memory";
    case SPF_E_NOT_SPF:
      return "Could not find a valid SPF record";
    case SPF_E_SYNTAX:
      return "Syntax error";
    case SPF_E_MOD_W_PREF:
      return "Modifiers can not have prefixes";
    case SPF_E_INVALID_CHAR:
      return "Invalid character found";
    case SPF_E_UNKNOWN_MECH:
      return "Unknown mechanism found";
    case SPF_E_INVALID_OPT:
      return "Invalid option found";
    case SPF_E_INVALID_CIDR:
      return "Invalid CIDR length";
    case SPF_E_MISSING_OPT:
      return "Required option is missing";
    case SPF_E_INTERNAL_ERROR:
      return "Internal programming error";
    case SPF_E_INVALID_ESC:
      return "Invalid %-escape character";
    case SPF_E_INVALID_VAR:
      return "Invalid macro variable";
    case SPF_E_BIG_SUBDOM:
      return "Subdomain truncation depth too large";
    case SPF_E_INVALID_DELIM:
      return "Invalid delimiter character";
    case SPF_E_BIG_STRING:
      return "Option string too long";
    case SPF_E_BIG_MECH:
      return "Too many mechanisms";
    case SPF_E_BIG_MOD:
      return "Too many modifiers";
    case SPF_E_BIG_DNS:
      return "Mechanisms used too many DNS lookups";
    case SPF_E_INVALID_IP4:
      return "Invalid IPv4 address literal";
    case SPF_E_INVALID_IP6:
      return "Invalid IPv6 address literal";
    case SPF_E_INVALID_PREFIX:
      return "Invalid mechanism prefix";
    case SPF_E_RESULT_UNKNOWN:
      return "SPF result is \"unknown\"";
    case SPF_E_UNINIT_VAR:
      return "Uninitialized variable";
    case SPF_E_MOD_NOT_FOUND:
      return "Modifier not found";
    case SPF_E_NOT_CONFIG:
      return "Not configured";
    case SPF_E_DNS_ERROR:
      return "DNS lookup failure";
    case SPF_E_BAD_HOST_IP:
      return "Invalid hostname (possibly an IP address?)";
    case SPF_E_BAD_HOST_TLD:
      return "Hostname has a missing or invalid TLD";
    case SPF_E_MECH_AFTER_ALL:
      return "Mechanisms found after the \"all:\" mechanism will be ignored";
    case SPF_E_INCLUDE_RETURNED_NONE:
      return "include: mechanism returned 'none'";
    case SPF_E_RECURSIVE:
      return "include: or redirect= caused unlimited recursion";
    case SPF_E_MULTIPLE_RECORDS:
      return "Multiple SPF or TXT records for domain.";
    default:
      return "Unknown SPF error code";
  }
  return ((const char *)NULL);
}

// SPF_strreason
// file ../../src/include/spf.h line 80
const char * SPF_strreason(enum SPF_reason_enum reason)
{
  switch((signed int)reason)
  {
    case SPF_REASON_NONE:
      return "none";
    case SPF_REASON_LOCALHOST:
      return "localhost";
    case SPF_REASON_LOCAL_POLICY:
      return "local policy";
    case SPF_REASON_MECH:
      return "mechanism";
    case SPF_REASON_DEFAULT:
      return "default";
    case SPF_REASON_2MX:
      return "secondary MX";
    default:
      return "(invalid reason)";
  }
}

// SPF_strresult
// file ../../src/include/spf.h line 78
const char * SPF_strresult(enum SPF_result_enum result)
{
  switch((signed int)result)
  {
    case SPF_RESULT_INVALID:
      return "(invalid)";
    case SPF_RESULT_PASS:
      return "pass";
    case SPF_RESULT_FAIL:
      return "fail";
    case SPF_RESULT_SOFTFAIL:
      return "softfail";
    case SPF_RESULT_NEUTRAL:
      return "neutral";
    case SPF_RESULT_PERMERROR:
      return "permerror";
    case SPF_RESULT_TEMPERROR:
      return "temperror";
    case SPF_RESULT_NONE:
      return "none";
    default:
      return "(error: unknown result)";
  }
}

// SPF_strrrtype
// file ../../src/include/spf.h line 89
const char * SPF_strrrtype(enum __ns_type rr_type)
{
  switch((signed int)rr_type)
  {
    case ns_t_a:
      return "A";
    case ns_t_aaaa:
      return "AAAA";
    case ns_t_any:
      return "ANY";
    case ns_t_invalid:
      return "BAD";
    case ns_t_mx:
      return "MX";
    case ns_t_ptr:
      return "PTR";
    case 99:
      return "SPF";
    case ns_t_txt:
      return "TXT";
    default:
      return "??";
  }
}

// SPF_voidp2spfhook
// file spf_dns_cache.c line 113
static inline struct anonymous_1 * SPF_voidp2spfhook(void *hook)
{
  return (struct anonymous_1 *)hook;
}

// SPF_voidp2spfhook_link1
// file spf_dns_zone.c line 83
static inline struct anonymous_9 * SPF_voidp2spfhook_link1(void *hook_link1)
{
  return (struct anonymous_9 *)hook_link1;
}

// SPF_warning_stdio
// file ../../src/include/spf_log.h line 88
void SPF_warning_stdio(const char *file, signed int line, const char *errmsg)
{
  char buf[128l];
  if(!(file == ((const char *)NULL)))
  {
    snprintf(buf, sizeof(char [128l]) /*128ul*/ , "%s:%d", file, line);
    fprintf(stderr, "%-20s Warning: %s\n", (const void *)buf, errmsg);
  }

  else
    fprintf(stderr, "Warning: %s\n", errmsg);
}

// SPF_warning_syslog
// file spf_log_syslog.c line 52
void SPF_warning_syslog(const char *file, signed int line, const char *errmsg)
{
  char buf[128l];
  if(!(file == ((const char *)NULL)))
  {
    snprintf(buf, sizeof(char [128l]) /*128ul*/ , "%s:%d", file, line);
    syslog(2 << 3 | 4, "%-20s %s", (const void *)buf, errmsg);
  }

  else
    syslog(2 << 3 | 4, "%s", errmsg);
}

// SPF_warningv
// file spf_log.c line 124
void SPF_warningv(const char *file, signed int line, const char *format, void **ap)
{
  char errmsg[800l];
  if(!(SPF_warning_handler == ((void (*)(const char *, signed int, const char *))NULL)))
  {
    vsnprintf(errmsg, sizeof(char [800l]) /*800ul*/ , format, ap);
    SPF_warning_handler(file, line, errmsg);
  }

}

// SPF_warningx
// file ../../src/include/spf_log.h line 46
void SPF_warningx(const char *file, signed int line, const char *format, ...)
{
  char errmsg[800l];
  void **ap;
  if(!(SPF_warning_handler == ((void (*)(const char *, signed int, const char *))NULL)))
  {
    ap = (void **)&format;
    vsnprintf(errmsg, sizeof(char [800l]) /*800ul*/ , format, ap);
    ap = ((void **)NULL);
    SPF_warning_handler(file, line, errmsg);
  }

}

// SPF_warningx2
// file spf_log.c line 176
void SPF_warningx2(const char *format, ...)
{
  void **ap = (void **)&format;
  SPF_warningv((const char *)(void *)0, 0, format, ap);
  ap = ((void **)NULL);
}

// W
// file spfd.c line 364
static inline const char * W(const char *c)
{
  if(!(c == ((const char *)NULL)))
    return c;

  else
    return "(null)";
}

// __ns_get16
// file __ns_get16.c line 15
unsigned int __ns_get16(const unsigned char *src)
{
  unsigned int dst;
  do
  {
    const unsigned char *t_cp = (const unsigned char *)src;
    dst = (unsigned int)((signed int)(unsigned short int)t_cp[(signed long int)0] << 8 | (signed int)(unsigned short int)t_cp[(signed long int)1]);
    src = src + (signed long int)2;
  }
  while((_Bool)0);
  return dst;
}

// __ns_initparse
// file __ns_initparse.c line 100
signed int __ns_initparse(const unsigned char *msg, signed int msglen, struct __ns_msg *handle)
{
  const unsigned char *eom = msg + (signed long int)msglen;
  signed int i;
  memset((void *)handle, 0x5e, sizeof(struct __ns_msg) /*80ul*/ );
  handle->_msg = msg;
  handle->_eom = eom;
  if(!(eom >= msg + 2l))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    *return_value___errno_location_1 = 90;
    return -1;
  }

  do
  {
    const unsigned char *__ns_initparse__1__2__t_cp = (const unsigned char *)msg;
    handle->_id = (unsigned short int)((signed int)(unsigned short int)__ns_initparse__1__2__t_cp[(signed long int)0] << 8 | (signed int)(unsigned short int)__ns_initparse__1__2__t_cp[(signed long int)1]);
    msg = msg + (signed long int)2;
  }
  while((_Bool)0);
  if(!(eom >= msg + 2l))
  {
    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    *return_value___errno_location_2 = 90;
    return -1;
  }

  do
  {
    const unsigned char *t_cp = (const unsigned char *)msg;
    handle->_flags = (unsigned short int)((signed int)(unsigned short int)t_cp[(signed long int)0] << 8 | (signed int)(unsigned short int)t_cp[(signed long int)1]);
    msg = msg + (signed long int)2;
  }
  while((_Bool)0);
  i = 0;
  for( ; !(i >= ns_s_max); i = i + 1)
  {
    if(!(eom >= msg + 2l))
    {
      signed int *return_value___errno_location_3;
      return_value___errno_location_3=__errno_location();
      *return_value___errno_location_3 = 90;
      return -1;
    }

    do
    {
      const unsigned char *__ns_initparse__1__5__1__2__t_cp = (const unsigned char *)msg;
      handle->_counts[(signed long int)i] = (unsigned short int)((signed int)(unsigned short int)__ns_initparse__1__5__1__2__t_cp[(signed long int)0] << 8 | (signed int)(unsigned short int)__ns_initparse__1__5__1__2__t_cp[(signed long int)1]);
      msg = msg + (signed long int)2;
    }
    while((_Bool)0);
  }
  i = 0;
  for( ; !(i >= ns_s_max); i = i + 1)
    if((signed int)handle->_counts[(signed long int)i] == 0)
      handle->_sections[(signed long int)i] = (const unsigned char *)(void *)0;

    else
    {
      signed int b;
      b=__ns_skiprr(msg, eom, (enum __ns_sect)i, (signed int)handle->_counts[(signed long int)i]);
      if(!(b >= 0))
        return -1;

      handle->_sections[(signed long int)i] = msg;
      msg = msg + (signed long int)b;
    }
  if(!(msg == eom))
  {
    signed int *return_value___errno_location_4;
    return_value___errno_location_4=__errno_location();
    *return_value___errno_location_4 = 90;
    return -1;
  }

  setsection(handle, (enum __ns_sect)ns_s_max);
  return 0;
}

// __ns_msg_getflag
// file __ns_msg_getflag.c line 15
signed int __ns_msg_getflag(struct __ns_msg handle, signed int flag)
{
  return ((signed int)handle._flags & _ns_flagdata[(signed long int)flag].mask) >> _ns_flagdata[(signed long int)flag].shift;
}

// __ns_name_compress
// file __ns_name_uncompress.c line 613
signed int __ns_name_compress(const char *src, unsigned char *dst, unsigned long int dstsiz, const unsigned char **dnptrs, const unsigned char **lastdnptr)
{
  unsigned char tmp[255l];
  signed int return_value___ns_name_pton_1;
  return_value___ns_name_pton_1=__ns_name_pton(src, tmp, sizeof(unsigned char [255l]) /*255ul*/ );
  if(return_value___ns_name_pton_1 == -1)
    return -1;

  else
  {
    signed int return_value___ns_name_pack_2;
    return_value___ns_name_pack_2=__ns_name_pack(tmp, dst, (signed int)dstsiz, dnptrs, lastdnptr);
    return return_value___ns_name_pack_2;
  }
}

// __ns_name_ntol
// file __ns_name_uncompress.c line 344
signed int __ns_name_ntol(const unsigned char *src, unsigned char *dst, unsigned long int dstsiz)
{
  const unsigned char *cp;
  unsigned char *dn;
  unsigned char *eom;
  unsigned char c;
  unsigned int n;
  signed int l;
  cp = src;
  dn = dst;
  eom = dst + (signed long int)dstsiz;
  if(dn >= eom)
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    *return_value___errno_location_1 = 90;
    return -1;
  }

  const unsigned char *tmp_post_2;
  signed int return_value_tolower_9;
  do
  {
    tmp_post_2 = cp;
    cp = cp + 1l;
    n = (unsigned int)*tmp_post_2;
    if(n == 0u)
      break;

    if((192u & n) == 192u)
    {
      signed int *return_value___errno_location_3;
      return_value___errno_location_3=__errno_location();
      *return_value___errno_location_3 = 90;
      return -1;
    }

    unsigned char *tmp_post_4 = dn;
    dn = dn + 1l;
    *tmp_post_4 = (unsigned char)n;
    l=labellen(cp - (signed long int)1);
    if(!(l >= 0))
    {
      signed int *return_value___errno_location_5;
      return_value___errno_location_5=__errno_location();
      *return_value___errno_location_5 = 90;
      return -1;
    }

    if(dn + (signed long int)l >= eom)
    {
      signed int *return_value___errno_location_6;
      return_value___errno_location_6=__errno_location();
      *return_value___errno_location_6 = 90;
      return -1;
    }

    (void)(void *)0;
    for( ; l >= 1; l = l - 1)
    {
      const unsigned char *tmp_post_7 = cp;
      cp = cp + 1l;
      c = *tmp_post_7;
      const unsigned short int **return_value___ctype_b_loc_11;
      return_value___ctype_b_loc_11=__ctype_b_loc();
      if(!((256 & (signed int)(*return_value___ctype_b_loc_11)[(signed long int)(signed int)c]) == 0))
      {
        unsigned char *tmp_post_8 = dn;
        dn = dn + 1l;
        return_value_tolower_9=tolower((signed int)c);
        *tmp_post_8 = (unsigned char)return_value_tolower_9;
      }

      else
      {
        unsigned char *tmp_post_10 = dn;
        dn = dn + 1l;
        *tmp_post_10 = c;
      }
    }
  }
  while((_Bool)1);
  unsigned char *tmp_post_12 = dn;
  dn = dn + 1l;
  *tmp_post_12 = (unsigned char)0;
  return (signed int)(dn - dst);
}

// __ns_name_ntop
// file __ns_name_uncompress.c line 106
signed int __ns_name_ntop(const unsigned char *src, char *dst, unsigned long int dstsiz)
{
  const unsigned char *cp;
  char *dn;
  char *eom;
  unsigned char c;
  unsigned int n;
  signed int l;
  cp = src;
  dn = dst;
  eom = dst + (signed long int)dstsiz;
  const unsigned char *tmp_post_1;
  signed int return_value_printable_20;
  do
  {
    tmp_post_1 = cp;
    cp = cp + 1l;
    n = (unsigned int)*tmp_post_1;
    if(n == 0u)
      break;

    if((192u & n) == 192u)
    {
      signed int *return_value___errno_location_2;
      return_value___errno_location_2=__errno_location();
      *return_value___errno_location_2 = 90;
      return -1;
    }

    if(!(dn == dst))
    {
      if(dn >= eom)
      {
        signed int *return_value___errno_location_3;
        return_value___errno_location_3=__errno_location();
        *return_value___errno_location_3 = 90;
        return -1;
      }

      char *tmp_post_4 = dn;
      dn = dn + 1l;
      *tmp_post_4 = (char)46;
    }

    l=labellen(cp - (signed long int)1);
    if(!(l >= 0))
    {
      signed int *return_value___errno_location_5;
      return_value___errno_location_5=__errno_location();
      *return_value___errno_location_5 = 90;
      return -1;
    }

    if(dn + (signed long int)l >= eom)
    {
      signed int *return_value___errno_location_6;
      return_value___errno_location_6=__errno_location();
      *return_value___errno_location_6 = 90;
      return -1;
    }

    if((192u & n) == 64u)
    {
      signed int m;
      if(!(n == 65u))
      {
        signed int *return_value___errno_location_7;
        return_value___errno_location_7=__errno_location();
        *return_value___errno_location_7 = 22;
        return -1;
      }

      m=decode_bitstring((const char **)&cp, dn, eom);
      if(!(m >= 0))
      {
        signed int *return_value___errno_location_8;
        return_value___errno_location_8=__errno_location();
        *return_value___errno_location_8 = 90;
        return -1;
      }

      dn = dn + (signed long int)m;
      continue;
    }

    (void)(void *)0;
    for( ; l >= 1; l = l - 1)
    {
      const unsigned char *tmp_post_9 = cp;
      cp = cp + 1l;
      c = *tmp_post_9;
      signed int return_value_special_21;
      return_value_special_21=special((signed int)c);
      if(!(return_value_special_21 == 0))
      {
        if(dn + 1l >= eom)
        {
          signed int *return_value___errno_location_10;
          return_value___errno_location_10=__errno_location();
          *return_value___errno_location_10 = 90;
          return -1;
        }

        char *tmp_post_11 = dn;
        dn = dn + 1l;
        *tmp_post_11 = (char)92;
        char *tmp_post_12 = dn;
        dn = dn + 1l;
        *tmp_post_12 = (char)c;
      }

      else
      {
        return_value_printable_20=printable((signed int)c);
        if(return_value_printable_20 == 0)
        {
          if(dn + 3l >= eom)
          {
            signed int *return_value___errno_location_13;
            return_value___errno_location_13=__errno_location();
            *return_value___errno_location_13 = 90;
            return -1;
          }

          char *tmp_post_14 = dn;
          dn = dn + 1l;
          *tmp_post_14 = (char)92;
          char *tmp_post_15 = dn;
          dn = dn + 1l;
          *tmp_post_15 = digits[(signed long int)((signed int)c / 100)];
          char *tmp_post_16 = dn;
          dn = dn + 1l;
          *tmp_post_16 = digits[(signed long int)(((signed int)c % 100) / 10)];
          char *tmp_post_17 = dn;
          dn = dn + 1l;
          *tmp_post_17 = digits[(signed long int)((signed int)c % 10)];
        }

        else
        {
          if(dn >= eom)
          {
            signed int *return_value___errno_location_18;
            return_value___errno_location_18=__errno_location();
            *return_value___errno_location_18 = 90;
            return -1;
          }

          char *tmp_post_19 = dn;
          dn = dn + 1l;
          *tmp_post_19 = (char)c;
        }
      }
    }
  }
  while((_Bool)1);
  if(dn == dst)
  {
    if(dn >= eom)
    {
      signed int *return_value___errno_location_22;
      return_value___errno_location_22=__errno_location();
      *return_value___errno_location_22 = 90;
      return -1;
    }

    char *tmp_post_23 = dn;
    dn = dn + 1l;
    *tmp_post_23 = (char)46;
  }

  if(dn >= eom)
  {
    signed int *return_value___errno_location_24;
    return_value___errno_location_24=__errno_location();
    *return_value___errno_location_24 = 90;
    return -1;
  }

  char *tmp_post_25 = dn;
  dn = dn + 1l;
  *tmp_post_25 = (char)0;
  return (signed int)(dn - dst);
}

// __ns_name_pack
// file __ns_name_uncompress.c line 485
signed int __ns_name_pack(const unsigned char *src, unsigned char *dst, signed int dstsiz, const unsigned char **dnptrs, const unsigned char **lastdnptr)
{
  unsigned char *dstp;
  const unsigned char **cpp;
  const unsigned char **lpp;
  const unsigned char *eob;
  const unsigned char *msg;
  const unsigned char *srcp;
  signed int n;
  signed int l;
  signed int first = 1;
  srcp = src;
  dstp = dst;
  eob = dstp + (signed long int)dstsiz;
  cpp = (const unsigned char **)(void *)0;
  lpp = cpp;
  if(!(dnptrs == ((const unsigned char **)NULL)))
  {
    const unsigned char **tmp_post_1 = dnptrs;
    dnptrs = dnptrs + 1l;
    msg = *tmp_post_1;
    if(!(msg == ((const unsigned char *)NULL)))
    {
      cpp = dnptrs;
      for( ; !(*cpp == ((const unsigned char *)NULL)); cpp = cpp + 1l)
        (void)(void *)0;
      lpp = cpp;
    }

  }

  else
    msg = (const unsigned char *)(void *)0;
  l = 0;
  do
  {
    signed int l0;
    n = (signed int)*srcp;
    if((0xc0 & n) == 0xc0)
    {
      signed int *return_value___errno_location_2;
      return_value___errno_location_2=__errno_location();
      *return_value___errno_location_2 = 90;
      return -1;
    }

    l0=labellen(srcp);
    if(!(l0 >= 0))
    {
      signed int *return_value___errno_location_3;
      return_value___errno_location_3=__errno_location();
      *return_value___errno_location_3 = 22;
      return -1;
    }

    l = l + l0 + 1;
    if(l >= 256)
    {
      signed int *return_value___errno_location_4;
      return_value___errno_location_4=__errno_location();
      *return_value___errno_location_4 = 90;
      return -1;
    }

    srcp = srcp + (signed long int)(l0 + 1);
  }
  while(!(n == 0));
  srcp = src;
  do
  {
    n = (signed int)*srcp;
    if(!(msg == ((const unsigned char *)NULL)) && !(n == 0))
    {
      l=dn_find(srcp, msg, (const unsigned char * const *)dnptrs, (const unsigned char * const *)lpp);
      if(l >= 0)
      {
        if(dstp + 1l >= eob)
          goto cleanup;

        unsigned char *tmp_post_5 = dstp;
        dstp = dstp + 1l;
        *tmp_post_5 = (unsigned char)(l >> 8 | 0xc0);
        unsigned char *tmp_post_6 = dstp;
        dstp = dstp + 1l;
        *tmp_post_6 = (unsigned char)(l % 256);
        return (signed int)(dstp - dst);
      }

      if(!(lastdnptr == ((const unsigned char **)NULL)) && !(first == 0) && !(dstp - msg >= 16384l) && !(cpp >= lastdnptr + -1l))
      {
        const unsigned char **tmp_post_7 = cpp;
        cpp = cpp + 1l;
        *tmp_post_7 = dstp;
        *cpp = (const unsigned char *)(void *)0;
        first = 0;
      }

    }

    if((0xc0 & n) == 0xc0)
      goto cleanup;

    n=labellen(srcp);
    if(dstp + 1l + (signed long int)n >= eob)
      goto cleanup;

    memcpy((void *)dstp, (const void *)srcp, (unsigned long int)(n + 1));
    srcp = srcp + (signed long int)(n + 1);
    dstp = dstp + (signed long int)(n + 1);
  }
  while(!(n == 0));
  if(!(eob >= dstp))
  {

  cleanup:
    ;
    if(!(msg == ((const unsigned char *)NULL)))
      *lpp = (const unsigned char *)(void *)0;

    signed int *return_value___errno_location_8;
    return_value___errno_location_8=__errno_location();
    *return_value___errno_location_8 = 90;
    return -1;
  }

  return (signed int)(dstp - dst);
}

// __ns_name_pton
// file __ns_name_uncompress.c line 209
signed int __ns_name_pton(const char *src, unsigned char *dst, unsigned long int dstsiz)
{
  unsigned char *label;
  unsigned char *bp;
  unsigned char *eom;
  signed int c;
  signed int n;
  signed int escaped;
  signed int e = 0;
  char *cp;
  escaped = 0;
  bp = dst;
  eom = dst + (signed long int)dstsiz;
  unsigned char *tmp_post_1 = bp;
  bp = bp + 1l;
  label = tmp_post_1;
  const char *tmp_post_2;
  do
  {
    tmp_post_2 = src;
    src = src + 1l;
    c = (signed int)*tmp_post_2;
    if(c == 0)
      break;

    if(!(escaped == 0))
    {
      if(c == 91)
      {
        cp=strchr(src, 93);
        if(cp == ((char *)NULL))
        {
          signed int *return_value___errno_location_3;
          return_value___errno_location_3=__errno_location();
          *return_value___errno_location_3 = 22;
          return -1;
        }

        e=encode_bitsring(&src, cp + (signed long int)2, (char **)&label, (char **)&bp, (const char *)eom);
        if(!(e == 0))
        {
          signed int *return_value___errno_location_4;
          return_value___errno_location_4=__errno_location();
          *return_value___errno_location_4 = e;
          return -1;
        }

        escaped = 0;
        unsigned char *tmp_post_5 = bp;
        bp = bp + 1l;
        label = tmp_post_5;
        const char *tmp_post_7 = src;
        src = src + 1l;
        c = (signed int)*tmp_post_7;
        if(c == 0)
          goto done;

        else
          if(!(c == 46))
          {
            signed int *return_value___errno_location_6;
            return_value___errno_location_6=__errno_location();
            *return_value___errno_location_6 = 22;
            return -1;
          }

        continue;
      }

      else
      {
        cp=strchr(digits, c);
        if(!(cp == ((char *)NULL)))
        {
          n = (signed int)((cp - digits) * (signed long int)100);
          const char *tmp_post_9 = src;
          src = src + 1l;
          c = (signed int)*tmp_post_9;
          _Bool tmp_if_expr_10;
          if(c == 0)
            tmp_if_expr_10 = (_Bool)1;

          else
          {
            cp=strchr(digits, c);
            tmp_if_expr_10 = cp == (char *)(void *)0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_10)
          {
            signed int *return_value___errno_location_8;
            return_value___errno_location_8=__errno_location();
            *return_value___errno_location_8 = 90;
            return -1;
          }

          n = n + (signed int)((cp - digits) * (signed long int)10);
          const char *tmp_post_12 = src;
          src = src + 1l;
          c = (signed int)*tmp_post_12;
          _Bool tmp_if_expr_13;
          if(c == 0)
            tmp_if_expr_13 = (_Bool)1;

          else
          {
            cp=strchr(digits, c);
            tmp_if_expr_13 = cp == (char *)(void *)0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_13)
          {
            signed int *return_value___errno_location_11;
            return_value___errno_location_11=__errno_location();
            *return_value___errno_location_11 = 90;
            return -1;
          }

          n = n + (signed int)(cp - digits);
          if(n >= 256)
          {
            signed int *return_value___errno_location_14;
            return_value___errno_location_14=__errno_location();
            *return_value___errno_location_14 = 90;
            return -1;
          }

          c = n;
        }

      }
      escaped = 0;
    }

    else
      if(c == 92)
      {
        escaped = 1;
        continue;
      }

      else
        if(c == 46)
        {
          c = (signed int)((bp - label) - (signed long int)1);
          if(!((0xc0 & c) == 0))
          {
            signed int *return_value___errno_location_15;
            return_value___errno_location_15=__errno_location();
            *return_value___errno_location_15 = 90;
            return -1;
          }

          if(label >= eom)
          {
            signed int *return_value___errno_location_16;
            return_value___errno_location_16=__errno_location();
            *return_value___errno_location_16 = 90;
            return -1;
          }

          *label = (unsigned char)c;
          if((signed int)*src == 0)
          {
            if(!(c == 0))
            {
              if(bp >= eom)
              {
                signed int *return_value___errno_location_17;
                return_value___errno_location_17=__errno_location();
                *return_value___errno_location_17 = 90;
                return -1;
              }

              unsigned char *tmp_post_18 = bp;
              bp = bp + 1l;
              *tmp_post_18 = (unsigned char)0;
            }

            if(bp - dst >= 256l)
            {
              signed int *return_value___errno_location_19;
              return_value___errno_location_19=__errno_location();
              *return_value___errno_location_19 = 90;
              return -1;
            }

            return 1;
          }

          _Bool tmp_if_expr_21;
          if(c == 0)
            tmp_if_expr_21 = (_Bool)1;

          else
            tmp_if_expr_21 = (signed int)*src == 46 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr_21)
          {
            signed int *return_value___errno_location_20;
            return_value___errno_location_20=__errno_location();
            *return_value___errno_location_20 = 90;
            return -1;
          }

          unsigned char *tmp_post_22 = bp;
          bp = bp + 1l;
          label = tmp_post_22;
          continue;
        }

    if(bp >= eom)
    {
      signed int *return_value___errno_location_23;
      return_value___errno_location_23=__errno_location();
      *return_value___errno_location_23 = 90;
      return -1;
    }

    unsigned char *tmp_post_24 = bp;
    bp = bp + 1l;
    *tmp_post_24 = (unsigned char)c;
  }
  while((_Bool)1);
  c = (signed int)((bp - label) - (signed long int)1);
  if(!((0xc0 & c) == 0))
  {
    signed int *return_value___errno_location_25;
    return_value___errno_location_25=__errno_location();
    *return_value___errno_location_25 = 90;
    return -1;
  }


done:
  ;
  if(label >= eom)
  {
    signed int *return_value___errno_location_26;
    return_value___errno_location_26=__errno_location();
    *return_value___errno_location_26 = 90;
    return -1;
  }

  *label = (unsigned char)c;
  if(!(c == 0))
  {
    if(bp >= eom)
    {
      signed int *return_value___errno_location_27;
      return_value___errno_location_27=__errno_location();
      *return_value___errno_location_27 = 90;
      return -1;
    }

    unsigned char *tmp_post_28 = bp;
    bp = bp + 1l;
    *tmp_post_28 = (unsigned char)0;
  }

  if(bp - dst >= 256l)
  {
    signed int *return_value___errno_location_29;
    return_value___errno_location_29=__errno_location();
    *return_value___errno_location_29 = 90;
    return -1;
  }

  return 0;
}

// __ns_name_rollback
// file __ns_name_uncompress.c line 628
void __ns_name_rollback(const unsigned char *src, const unsigned char **dnptrs, const unsigned char **lastdnptr)
{
  for( ; !(dnptrs >= lastdnptr); dnptrs = dnptrs + 1l)
  {
    if(*dnptrs == ((const unsigned char *)NULL))
      break;

    if(*dnptrs >= src)
    {
      *dnptrs = (const unsigned char *)(void *)0;
      break;
    }

  }
}

// __ns_name_skip
// file __ns_name_uncompress.c line 647
signed int __ns_name_skip(const unsigned char **ptrptr, const unsigned char *eom)
{
  const unsigned char *cp;
  unsigned int n;
  signed int l;
  cp = *ptrptr;
  const unsigned char *tmp_post_1;
  signed int *return_value___errno_location_3;
  while(!(cp >= eom))
  {
    tmp_post_1 = cp;
    cp = cp + 1l;
    n = (unsigned int)*tmp_post_1;
    if(n == 0u)
      break;

    switch(n & (unsigned int)0xc0)
    {
      case (unsigned int)0:
      {
        cp = cp + (signed long int)n;
        goto __CPROVER_DUMP_L8;
      }
      case (unsigned int)0x40:
      {
        l=labellen(cp - (signed long int)1);
        if(!(l >= 0))
        {
          signed int *return_value___errno_location_2;
          return_value___errno_location_2=__errno_location();
          *return_value___errno_location_2 = 90;
          return -1;
        }

        cp = cp + (signed long int)l;
        goto __CPROVER_DUMP_L8;
      }
      case (unsigned int)0xc0:
      {
        cp = cp + 1l;
        break;
      }
      default:
      {
        return_value___errno_location_3=__errno_location();
        *return_value___errno_location_3 = 90;
        return -1;
      }
    }
    break;

  __CPROVER_DUMP_L8:
    ;
  }
  if(!(eom >= cp))
  {
    signed int *return_value___errno_location_4;
    return_value___errno_location_4=__errno_location();
    *return_value___errno_location_4 = 90;
    return -1;
  }

  *ptrptr = cp;
  return 0;
}

// __ns_name_uncompress
// file __ns_name_uncompress.c line 585
signed int __ns_name_uncompress(const unsigned char *msg, const unsigned char *eom, const unsigned char *src, char *dst, unsigned long int dstsiz)
{
  unsigned char tmp[255l];
  signed int n;
  n=__ns_name_unpack(msg, eom, src, tmp, sizeof(unsigned char [255l]) /*255ul*/ );
  if(n == -1)
    return -1;

  else
  {
    signed int return_value___ns_name_ntop_1;
    return_value___ns_name_ntop_1=__ns_name_ntop(tmp, dst, dstsiz);
    if(return_value___ns_name_ntop_1 == -1)
      return -1;

    else
      return n;
  }
}

// __ns_name_unpack
// file __ns_name_uncompress.c line 394
signed int __ns_name_unpack(const unsigned char *msg, const unsigned char *eom, const unsigned char *src, unsigned char *dst, unsigned long int dstsiz)
{
  const unsigned char *srcp;
  const unsigned char *dstlim;
  unsigned char *dstp;
  signed int n;
  signed int len;
  signed int checked;
  signed int l;
  len = -1;
  checked = 0;
  dstp = dst;
  srcp = src;
  dstlim = dst + (signed long int)dstsiz;
  if(srcp >= eom || !(srcp >= msg))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    *return_value___errno_location_1 = 90;
    return -1;
  }

  const unsigned char *tmp_post_2;
  signed int *return_value___errno_location_9;
  do
  {
    tmp_post_2 = srcp;
    srcp = srcp + 1l;
    n = (signed int)*tmp_post_2;
    if(n == 0)
      break;

    switch(n & 0xc0)
    {
      case 0:

      case 0x40:
      {
        l=labellen(srcp - (signed long int)1);
        if(!(l >= 0))
        {
          signed int *return_value___errno_location_3;
          return_value___errno_location_3=__errno_location();
          *return_value___errno_location_3 = 90;
          return -1;
        }

        if(dstp + (signed long int)l + 1l >= dstlim || srcp + (signed long int)l >= eom)
        {
          signed int *return_value___errno_location_4;
          return_value___errno_location_4=__errno_location();
          *return_value___errno_location_4 = 90;
          return -1;
        }

        checked = checked + l + 1;
        unsigned char *tmp_post_5 = dstp;
        dstp = dstp + 1l;
        *tmp_post_5 = (unsigned char)n;
        memcpy((void *)dstp, (const void *)srcp, (unsigned long int)l);
        dstp = dstp + (signed long int)l;
        srcp = srcp + (signed long int)l;
        break;
      }
      case 0xc0:
      {
        if(srcp >= eom)
        {
          signed int *return_value___errno_location_6;
          return_value___errno_location_6=__errno_location();
          *return_value___errno_location_6 = 90;
          return -1;
        }

        if(!(len >= 0))
          len = (signed int)((srcp - src) + (signed long int)1);

        srcp = msg + (signed long int)((n & 0x3f) << 8 | (signed int)*srcp & 0xff);
        if(srcp >= eom || !(srcp >= msg))
        {
          signed int *return_value___errno_location_7;
          return_value___errno_location_7=__errno_location();
          *return_value___errno_location_7 = 90;
          return -1;
        }

        checked = checked + 2;
        if((signed long int)checked >= eom - msg)
        {
          signed int *return_value___errno_location_8;
          return_value___errno_location_8=__errno_location();
          *return_value___errno_location_8 = 90;
          return -1;
        }

        break;
      }
      default:
      {
        return_value___errno_location_9=__errno_location();
        *return_value___errno_location_9 = 90;
        return -1;
      }
    }
  }
  while((_Bool)1);
  *dstp = (unsigned char)0;
  if(!(len >= 0))
    len = (signed int)(srcp - src);

  return len;
}

// __ns_parserr
// file __ns_initparse.c line 137
signed int __ns_parserr(struct __ns_msg *handle, enum __ns_sect section, signed int rrnum, struct __ns_rr *rr)
{
  signed int b;
  signed int tmp = (signed int)section;
  if((signed int)section >= ns_s_max || !(tmp >= 0))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    *return_value___errno_location_1 = 19;
    return -1;
  }

  if(!(section == handle->_sect))
    setsection(handle, section);

  if(rrnum == -1)
    rrnum = handle->_rrnum;

  _Bool tmp_if_expr_3;
  if(!(rrnum >= 0))
    tmp_if_expr_3 = (_Bool)1;

  else
    tmp_if_expr_3 = rrnum >= (signed int)handle->_counts[(signed long int)(signed int)section] ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_3)
  {
    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    *return_value___errno_location_2 = 19;
    return -1;
  }

  if(!(rrnum >= handle->_rrnum))
    setsection(handle, section);

  if(!(handle->_rrnum >= rrnum))
  {
    b=__ns_skiprr(handle->_msg_ptr, handle->_eom, section, rrnum - handle->_rrnum);
    if(!(b >= 0))
      return -1;

    handle->_msg_ptr = handle->_msg_ptr + (signed long int)b;
    handle->_rrnum = rrnum;
  }

  b=__dn_expand(handle->_msg, handle->_eom, handle->_msg_ptr, rr->name, 1025);
  if(!(b >= 0))
    return -1;

  else
  {
    handle->_msg_ptr = handle->_msg_ptr + (signed long int)b;
    if(!(handle->_eom >= handle->_msg_ptr + 4l))
    {
      signed int *return_value___errno_location_4;
      return_value___errno_location_4=__errno_location();
      *return_value___errno_location_4 = 90;
      return -1;
    }

    do
    {
      const unsigned char *__ns_parserr__1__5__t_cp = (const unsigned char *)handle->_msg_ptr;
      rr->type = (unsigned short int)((signed int)(unsigned short int)__ns_parserr__1__5__t_cp[(signed long int)0] << 8 | (signed int)(unsigned short int)__ns_parserr__1__5__t_cp[(signed long int)1]);
      handle->_msg_ptr = handle->_msg_ptr + (signed long int)2;
    }
    while((_Bool)0);
    do
    {
      const unsigned char *__ns_parserr__1__6__t_cp = (const unsigned char *)handle->_msg_ptr;
      rr->rr_class = (unsigned short int)((signed int)(unsigned short int)__ns_parserr__1__6__t_cp[(signed long int)0] << 8 | (signed int)(unsigned short int)__ns_parserr__1__6__t_cp[(signed long int)1]);
      handle->_msg_ptr = handle->_msg_ptr + (signed long int)2;
    }
    while((_Bool)0);
    if((signed int)section == ns_s_qd)
    {
      rr->ttl = (unsigned int)0;
      rr->rdlength = (unsigned short int)0;
      rr->rdata = (const unsigned char *)(void *)0;
    }

    else
    {
      if(!(handle->_eom >= handle->_msg_ptr + 6l))
      {
        signed int *return_value___errno_location_5;
        return_value___errno_location_5=__errno_location();
        *return_value___errno_location_5 = 90;
        return -1;
      }

      do
      {
        const unsigned char *t_cp = (const unsigned char *)handle->_msg_ptr;
        rr->ttl = (unsigned int)t_cp[(signed long int)0] << 24 | (unsigned int)t_cp[(signed long int)1] << 16 | (unsigned int)t_cp[(signed long int)2] << 8 | (unsigned int)t_cp[(signed long int)3];
        handle->_msg_ptr = handle->_msg_ptr + (signed long int)4;
      }
      while((_Bool)0);
      do
      {
        const unsigned char *__ns_parserr__1__8__3__t_cp = (const unsigned char *)handle->_msg_ptr;
        rr->rdlength = (unsigned short int)((signed int)(unsigned short int)__ns_parserr__1__8__3__t_cp[(signed long int)0] << 8 | (signed int)(unsigned short int)__ns_parserr__1__8__3__t_cp[(signed long int)1]);
        handle->_msg_ptr = handle->_msg_ptr + (signed long int)2;
      }
      while((_Bool)0);
      if(!(handle->_eom >= handle->_msg_ptr + (signed long int)rr->rdlength))
      {
        signed int *return_value___errno_location_6;
        return_value___errno_location_6=__errno_location();
        *return_value___errno_location_6 = 90;
        return -1;
      }

      rr->rdata = handle->_msg_ptr;
      handle->_msg_ptr = handle->_msg_ptr + (signed long int)rr->rdlength;
    }
    handle->_rrnum = handle->_rrnum + 1;
    if(!((signed int)handle->_counts[(signed long int)(signed int)section] >= handle->_rrnum))
      setsection(handle, (enum __ns_sect)((signed int)section + 1));

    return 0;
  }
}

// __ns_skiprr
// file __ns_initparse.c line 76
signed int __ns_skiprr(const unsigned char *ptr, const unsigned char *eom, enum __ns_sect section, signed int count)
{
  const unsigned char *optr = ptr;
  (void)(void *)0;
  for( ; count >= 1; count = count - 1)
  {
    signed int b;
    signed int rdlength;
    b=__dn_skipname(ptr, eom);
    if(!(b >= 0))
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      *return_value___errno_location_1 = 90;
      return -1;
    }

    ptr = ptr + (signed long int)(b + 2 + 2);
    if(!((signed int)section == ns_s_qd))
    {
      if(!(eom >= ptr + 6l))
      {
        signed int *return_value___errno_location_2;
        return_value___errno_location_2=__errno_location();
        *return_value___errno_location_2 = 90;
        return -1;
      }

      ptr = ptr + (signed long int)4;
      do
      {
        const unsigned char *t_cp = (const unsigned char *)ptr;
        rdlength = (signed int)(unsigned short int)t_cp[(signed long int)0] << 8 | (signed int)(unsigned short int)t_cp[(signed long int)1];
        ptr = ptr + (signed long int)2;
      }
      while((_Bool)0);
      ptr = ptr + (signed long int)rdlength;
    }

  }
  if(!(eom >= ptr))
  {
    signed int *return_value___errno_location_3;
    return_value___errno_location_3=__errno_location();
    *return_value___errno_location_3 = 90;
    return -1;
  }

  return (signed int)(ptr - optr);
}

// _align_ptr
// file ../../src/include/spf_internal.h line 76
static inline char * _align_ptr(char *s)
{
  return s + (signed long int)((unsigned long int)(4 - 1) - ((unsigned long int)s - (unsigned long int)1 & (unsigned long int)(4 - 1)));
}

// _align_ptr_link1
// file ../../src/include/spf_internal.h line 76
static inline char * _align_ptr_link1(char *s_link1)
{
  return s_link1 + (signed long int)((unsigned long int)(4 - 1) - ((unsigned long int)s_link1 - (unsigned long int)1 & (unsigned long int)(4 - 1)));
}

// _align_ptr_link2
// file ../../src/include/spf_internal.h line 76
static inline char * _align_ptr_link2(char *s_link2)
{
  return s_link2 + (signed long int)((unsigned long int)(4 - 1) - ((unsigned long int)s_link2 - (unsigned long int)1 & (unsigned long int)(4 - 1)));
}

// _align_ptr_link3
// file ../../src/include/spf_internal.h line 76
static inline char * _align_ptr_link3(char *s_link3)
{
  return s_link3 + (signed long int)((unsigned long int)(4 - 1) - ((unsigned long int)s_link3 - (unsigned long int)1 & (unsigned long int)(4 - 1)));
}

// _align_ptr_link4
// file ../../src/include/spf_internal.h line 76
static inline char * _align_ptr_link4(char *s_link4)
{
  return s_link4 + (signed long int)((unsigned long int)(4 - 1) - ((unsigned long int)s_link4 - (unsigned long int)1 & (unsigned long int)(4 - 1)));
}

// _align_sz
// file ../../src/include/spf_internal.h line 74
static inline unsigned long int _align_sz(unsigned long int s)
{
  return s + ((unsigned long int)(4 - 1) - (s - (unsigned long int)1 & (unsigned long int)(4 - 1)));
}

// _align_sz_link1
// file ../../src/include/spf_internal.h line 74
static inline unsigned long int _align_sz_link1(unsigned long int s_link1)
{
  return s_link1 + ((unsigned long int)(4 - 1) - (s_link1 - (unsigned long int)1 & (unsigned long int)(4 - 1)));
}

// _align_sz_link2
// file ../../src/include/spf_internal.h line 74
static inline unsigned long int _align_sz_link2(unsigned long int s_link2)
{
  return s_link2 + ((unsigned long int)(4 - 1) - (s_link2 - (unsigned long int)1 & (unsigned long int)(4 - 1)));
}

// crc32str
// file spf_dns_cache.c line 218
static inline signed int crc32str(unsigned int accum, const char *str, signed int max_hash_len)
{
  for( ; max_hash_len >= 1 && !((signed int)*str == 0); str = str + 1l)
    if(!((signed int)*str == 46))
    {
      accum = crc_32_tab[(signed long int)((signed int)(unsigned char)accum ^ (signed int)(unsigned char)*str)] ^ (unsigned int)(unsigned char)(accum >> 8);
      max_hash_len = max_hash_len - 1;
    }

  return (signed int)accum;
}

// daemon_bind_inet_tcp
// file spfd.c line 595
static signed int daemon_bind_inet_tcp()
{
  struct sockaddr_in addr;
  signed int sock;
  signed int optval;
  unsigned long int optlen;
  sock=socket(2, 1, 0);
  if(!(sock >= 0))
  {
    perror("socket");
    do
    {
      fprintf(stderr, "%s\n", (const void *)"Failed to create socket");
      exit(1);
    }
    while((_Bool)0);
  }

  optval = 1;
  optlen = sizeof(signed int) /*4ul*/ ;
  setsockopt(sock, 1, 2, (const void *)&optval, (unsigned int)optlen);
  memset((void *)&addr, 0, sizeof(struct sockaddr_in) /*16ul*/ );
  addr.sin_family = (unsigned short int)2;
  addr.sin_port=htons((unsigned short int)spfd_config.tcpport);
  addr.sin_addr.s_addr = (unsigned int)0x00000000;
  signed int return_value_bind_1;
  return_value_bind_1=bind(sock, (struct sockaddr *)&addr, (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ );
  if(!(return_value_bind_1 >= 0))
  {
    perror("bind");
    do
    {
      fprintf(stderr, "%s\n", (const void *)"Failed to bind socket");
      exit(1);
    }
    while((_Bool)0);
  }

  signed int return_value_listen_2;
  return_value_listen_2=listen(sock, 5);
  if(!(return_value_listen_2 >= 0))
  {
    perror("listen");
    do
    {
      fprintf(stderr, "%s\n", (const void *)"Failed to listen on socket");
      exit(1);
    }
    while((_Bool)0);
  }

  fprintf(stderr, "Accepting connections on %d\n", spfd_config.tcpport);
  return sock;
}

// daemon_bind_inet_udp
// file spfd.c line 571
static signed int daemon_bind_inet_udp()
{
  struct sockaddr_in addr;
  signed int sock;
  sock=socket(2, 2, 0);
  if(!(sock >= 0))
  {
    perror("socket");
    do
    {
      fprintf(stderr, "%s\n", (const void *)"Failed to create socket");
      exit(1);
    }
    while((_Bool)0);
  }

  memset((void *)&addr, 0, sizeof(struct sockaddr_in) /*16ul*/ );
  addr.sin_family = (unsigned short int)2;
  addr.sin_port=htons((unsigned short int)spfd_config.udpport);
  addr.sin_addr.s_addr = (unsigned int)0x00000000;
  signed int return_value_bind_1;
  return_value_bind_1=bind(sock, (struct sockaddr *)&addr, (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ );
  if(!(return_value_bind_1 >= 0))
  {
    perror("bind");
    do
    {
      fprintf(stderr, "%s\n", (const void *)"Failed to bind socket");
      exit(1);
    }
    while((_Bool)0);
  }

  fprintf(stderr, "Accepting datagrams on %d\n", spfd_config.udpport);
  return sock;
}

// daemon_bind_unix
// file spfd.c line 632
static signed int daemon_bind_unix()
{
  struct sockaddr_un addr;
  signed int sock;
  sock=socket(1, 1, 0);
  if(!(sock >= 0))
  {
    perror("socket");
    do
    {
      fprintf(stderr, "%s\n", (const void *)"Failed to create socket");
      exit(1);
    }
    while((_Bool)0);
  }

  memset((void *)&addr, 0, sizeof(struct sockaddr_un) /*110ul*/ );
  addr.sun_family = (unsigned short int)1;
  strncpy(addr.sun_path, spfd_config.path, sizeof(char [108l]) /*108ul*/  - (unsigned long int)1);
  signed int return_value_unlink_2;
  return_value_unlink_2=unlink(spfd_config.path);
  if(!(return_value_unlink_2 >= 0))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    if(!(*return_value___errno_location_1 == 2))
    {
      perror("unlink");
      do
      {
        fprintf(stderr, "%s\n", (const void *)"Failed to unlink socket");
        exit(1);
      }
      while((_Bool)0);
    }

  }

  signed int return_value_bind_3;
  return_value_bind_3=bind(sock, (struct sockaddr *)&addr, (unsigned int)sizeof(struct sockaddr_un) /*110ul*/ );
  if(!(return_value_bind_3 >= 0))
  {
    perror("bind");
    do
    {
      fprintf(stderr, "%s\n", (const void *)"Failed to bind socket");
      exit(1);
    }
    while((_Bool)0);
  }

  signed int return_value_listen_4;
  return_value_listen_4=listen(sock, 5);
  if(!(return_value_listen_4 >= 0))
  {
    perror("listen");
    do
    {
      fprintf(stderr, "%s\n", (const void *)"Failed to listen on socket");
      exit(1);
    }
    while((_Bool)0);
  }

  fprintf(stderr, "Accepting connections on %s\n", spfd_config.path);
  return sock;
}

// daemon_config
// file spfd.c line 502
static void daemon_config(signed int argc, char **argv)
{
  signed int idx;
  char c;
  memset((void *)&spfd_config, 0, sizeof(struct _config_t) /*96ul*/ );
  signed int return_value_getopt_long_1;
  signed long int return_value_atol_2;
  signed long int return_value_atol_3;
  signed long int return_value_atol_4;
  signed long int return_value_atol_5;
  do
  {
    return_value_getopt_long_1=getopt_long(argc, argv, shortopts, longopts, &idx);
    c = (char)return_value_getopt_long_1;
    if((signed int)c == -1)
      break;

    switch((signed int)c)
    {
      case 116:
      {
        return_value_atol_2=atol(optarg);
        spfd_config.tcpport = (signed int)return_value_atol_2;
        break;
      }
      case 112:
      {
        return_value_atol_3=atol(optarg);
        spfd_config.udpport = (signed int)return_value_atol_3;
        break;
      }
      case 102:
      {
        spfd_config.path = optarg;
        break;
      }
      case 100:
      {
        return_value_atol_4=atol(optarg);
        spfd_config.debug = (signed int)return_value_atol_4;
        break;
      }
      case 120:
      {
        spfd_config.pathuser=daemon_get_user(optarg);
        break;
      }
      case 121:
      {
        spfd_config.pathgroup=daemon_get_group(optarg);
        break;
      }
      case 109:
      {
        return_value_atol_5=atol(optarg);
        spfd_config.pathmode = (signed int)return_value_atol_5;
        break;
      }
      case 117:
      {
        spfd_config.setuser=daemon_get_user(optarg);
        break;
      }
      case 103:
      {
        spfd_config.setgroup=daemon_get_group(optarg);
        break;
      }
      case 0:

      case 63:
      {
        usage();
        do
        {
          fprintf(stderr, "%s\n", (const void *)"Invalid argument");
          exit(1);
        }
        while((_Bool)0);
        break;
      }
      case 104:
      {
        usage();
        do
        {
          fprintf(stderr, "%s\n", (const void *)"");
          exit(1);
        }
        while((_Bool)0);
        break;
      }
      default:
      {
        fprintf(stderr, "Error: getopt returned character code 0%o ??\n", c);
        do
        {
          fprintf(stderr, "%s\n", (const void *)"WHAT?");
          exit(1);
        }
        while((_Bool)0);
      }
    }
  }
  while((_Bool)1);
}

// daemon_get_group
// file spfd.c line 486
static unsigned int daemon_get_group(const char *arg)
{
  struct group *grp;
  const unsigned short int **return_value___ctype_b_loc_2;
  return_value___ctype_b_loc_2=__ctype_b_loc();
  signed long int return_value_atol_1;
  if(!((2048 & (signed int)(*return_value___ctype_b_loc_2)[(signed long int)(signed int)*arg]) == 0))
  {
    return_value_atol_1=atol(arg);
    grp=getgrgid((unsigned int)return_value_atol_1);
  }

  else
    grp=getgrnam(arg);
  if(grp == ((struct group *)NULL))
  {
    fprintf(stderr, "Failed to find user %s\n", arg);
    do
    {
      fprintf(stderr, "%s\n", (const void *)"Unknown group");
      exit(1);
    }
    while((_Bool)0);
  }

  return grp->gr_gid;
}

// daemon_get_user
// file spfd.c line 469
static unsigned int daemon_get_user(const char *arg)
{
  struct passwd *pwd;
  const unsigned short int **return_value___ctype_b_loc_2;
  return_value___ctype_b_loc_2=__ctype_b_loc();
  signed long int return_value_atol_1;
  if(!((2048 & (signed int)(*return_value___ctype_b_loc_2)[(signed long int)(signed int)*arg]) == 0))
  {
    return_value_atol_1=atol(arg);
    pwd=getpwuid((unsigned int)return_value_atol_1);
  }

  else
    pwd=getpwnam(arg);
  if(pwd == ((struct passwd *)NULL))
  {
    fprintf(stderr, "Failed to find user %s\n", arg);
    do
    {
      fprintf(stderr, "%s\n", (const void *)"Unknown user");
      exit(1);
    }
    while((_Bool)0);
  }

  return pwd->pw_uid;
}

// daemon_init
// file spfd.c line 665
static void daemon_init()
{
  struct SPF_response_struct *spf_response = (struct SPF_response_struct *)(void *)0;
  enum SPF_errcode_t err;
  memset((void *)&spfd_state, 0, sizeof(struct _state_t) /*12ul*/ );
  spf_server=SPF_server_new((enum SPF_server_dnstype_enum)SPF_DNS_CACHE, spfd_config.debug);
  if(!(spfd_config.rec_dom == ((char *)NULL)))
  {
    err=SPF_server_set_rec_dom(spf_server, spfd_config.rec_dom);
    if(!(err == /*enum*/SPF_E_SUCCESS))
      do
      {
        fprintf(stderr, "%s\n", (const void *)"Failed to set receiving domain name");
        exit(1);
      }
      while((_Bool)0);

  }

  if(!(spfd_config.sanitize == 0))
  {
    err=SPF_server_set_sanitize(spf_server, spfd_config.sanitize);
    if(!(err == /*enum*/SPF_E_SUCCESS))
      do
      {
        fprintf(stderr, "%s\n", (const void *)"Failed to set server sanitize flag");
        exit(1);
      }
      while((_Bool)0);

  }

  if(!(spfd_config.max_lookup == 0))
  {
    err=SPF_server_set_max_dns_mech(spf_server, spfd_config.max_lookup);
    if(!(err == /*enum*/SPF_E_SUCCESS))
      do
      {
        fprintf(stderr, "%s\n", (const void *)"Failed to set maximum DNS requests");
        exit(1);
      }
      while((_Bool)0);

  }

  if(!(spfd_config.localpolicy == ((char *)NULL)))
  {
    err=SPF_server_set_localpolicy(spf_server, spfd_config.localpolicy, spfd_config.use_trusted, &spf_response);
    if(!(err == /*enum*/SPF_E_SUCCESS))
    {
      response_print_errors("Compiling local policy", spf_response, err);
      do
      {
        fprintf(stderr, "%s\n", (const void *)"Failed to set local policy");
        exit(1);
      }
      while((_Bool)0);
    }

    do
    {
      if(!(spf_response == ((struct SPF_response_struct *)NULL)))
        SPF_response_free(spf_response);

      spf_response = (struct SPF_response_struct *)(void *)0;
    }
    while((_Bool)0);
  }

  if(!(spfd_config.explanation == ((char *)NULL)))
  {
    err=SPF_server_set_explanation(spf_server, spfd_config.explanation, &spf_response);
    if(!(err == /*enum*/SPF_E_SUCCESS))
    {
      response_print_errors("Setting default explanation", spf_response, err);
      do
      {
        fprintf(stderr, "%s\n", (const void *)"Failed to set default explanation");
        exit(1);
      }
      while((_Bool)0);
    }

    do
    {
      if(!(spf_response == ((struct SPF_response_struct *)NULL)))
        SPF_response_free(spf_response);

      spf_response = (struct SPF_response_struct *)(void *)0;
    }
    while((_Bool)0);
  }

  if(!(spfd_config.udpport == 0))
    spfd_state.sock_udp=daemon_bind_inet_udp();

  if(!(spfd_config.tcpport == 0))
    spfd_state.sock_tcp=daemon_bind_inet_tcp();

  if(!(spfd_config.path == ((char *)NULL)))
    spfd_state.sock_unix=daemon_bind_unix();

}

// daemon_main
// file spfd.c line 862
static void daemon_main()
{
  union pthread_attr_t attr;
  unsigned long int th;
  struct _request_t *req;
  char buf[4096l];
  struct anonymous_10 rfd;
  struct anonymous_10 sfd;
  signed int maxfd;
  pthread_attr_init(&attr);
  pthread_attr_setdetachstate(&attr, 1);
  do
  {
    signed int __d0;
    signed int __d1;
    asm("cld; rep; stosq" : "=c"(__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous_10) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&rfd)->fds_bits[(signed long int)0]) : "memory");
  }
  while((_Bool)0);
  maxfd = 0;
  if(!(spfd_state.sock_udp == 0))
  {
    (&rfd)->fds_bits[(signed long int)(spfd_state.sock_udp / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&rfd)->fds_bits[(signed long int)(spfd_state.sock_udp / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << spfd_state.sock_udp % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
    if(!(maxfd >= spfd_state.sock_udp))
      maxfd = spfd_state.sock_udp;

  }

  if(!(spfd_state.sock_tcp == 0))
  {
    (&rfd)->fds_bits[(signed long int)(spfd_state.sock_tcp / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&rfd)->fds_bits[(signed long int)(spfd_state.sock_tcp / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << spfd_state.sock_tcp % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
    if(!(maxfd >= spfd_state.sock_tcp))
      maxfd = spfd_state.sock_tcp;

  }

  if(!(spfd_state.sock_unix == 0))
  {
    (&rfd)->fds_bits[(signed long int)(spfd_state.sock_unix / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&rfd)->fds_bits[(signed long int)(spfd_state.sock_unix / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << spfd_state.sock_unix % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
    if(!(maxfd >= spfd_state.sock_unix))
      maxfd = spfd_state.sock_unix;

  }

  do
  {
    memcpy((void *)&sfd, (const void *)&rfd, sizeof(struct anonymous_10) /*128ul*/ );
    signed int return_value_select_1;
    return_value_select_1=select(maxfd + 1, &sfd, (struct anonymous_10 *)(void *)0, (struct anonymous_10 *)(void *)0, (struct timeval *)(void *)0);
    if(return_value_select_1 == -1)
      break;

    if(!(spfd_state.sock_udp == 0))
    {
      if(!((sfd.fds_bits[(signed long int)(spfd_state.sock_udp / 8)] & (signed long int)(1UL << spfd_state.sock_udp % 8)) == 0l))
      {
        void *return_value_calloc_2;
        return_value_calloc_2=calloc((unsigned long int)1, sizeof(struct _request_t) /*4480ul*/ );
        req = (struct _request_t *)return_value_calloc_2;
        req->addrlen = (unsigned int)sizeof(union anonymous_14) /*112ul*/ ;
        req->sock = spfd_state.sock_udp;
        signed long int return_value_recvfrom_3;
        return_value_recvfrom_3=recvfrom(spfd_state.sock_udp, (void *)buf, (unsigned long int)4095, 0, (struct sockaddr *)&req->addr.in, &req->addrlen);
        req->datalen = (signed int)return_value_recvfrom_3;
        if(req->datalen >= 0)
        {
          buf[(signed long int)req->datalen] = (char)0;
          req->data=strdup(buf);
          pthread_create(&th, &attr, handle_datagram, (void *)req);
        }

        else
          free((void *)req);
      }

    }

    if(!(spfd_state.sock_tcp == 0))
    {
      if(!((sfd.fds_bits[(signed long int)(spfd_state.sock_tcp / 8)] & (signed long int)(1UL << spfd_state.sock_tcp % 8)) == 0l))
      {
        void *return_value_calloc_4;
        return_value_calloc_4=calloc((unsigned long int)1, sizeof(struct _request_t) /*4480ul*/ );
        req = (struct _request_t *)return_value_calloc_4;
        req->addrlen = (unsigned int)sizeof(union anonymous_14) /*112ul*/ ;
        req->sock=accept(spfd_state.sock_tcp, (struct sockaddr *)&req->addr.in, &req->addrlen);
        if(req->sock >= 0)
          pthread_create(&th, &attr, handle_stream, (void *)req);

        else
          free((void *)req);
      }

    }

    if(!(spfd_state.sock_unix == 0))
    {
      if(!((sfd.fds_bits[(signed long int)(spfd_state.sock_unix / 8)] & (signed long int)(1UL << spfd_state.sock_unix % 8)) == 0l))
      {
        void *return_value_calloc_5;
        return_value_calloc_5=calloc((unsigned long int)1, sizeof(struct _request_t) /*4480ul*/ );
        req = (struct _request_t *)return_value_calloc_5;
        req->addrlen = (unsigned int)sizeof(union anonymous_14) /*112ul*/ ;
        req->sock=accept(spfd_state.sock_unix, (struct sockaddr *)&req->addr.un, &req->addrlen);
        if(req->sock >= 0)
          pthread_create(&th, &attr, handle_stream, (void *)req);

        else
          free((void *)req);
      }

    }

  }
  while((_Bool)1);
  pthread_attr_destroy(&attr);
}

// decode_bitstring
// file __ns_name_uncompress.c line 803
static signed int decode_bitstring(const char **cpp, char *dn, const char *eom)
{
  const char *cp = *cpp;
  char *beg = dn;
  char tc;
  signed int b;
  signed int blen;
  signed int plen;
  signed int i;
  blen = (signed int)*cp & 0xff;
  if(blen == 0)
    blen = 256;

  plen = (blen + 3) / 4;
  plen = plen + (signed int)(sizeof(char [6l]) /*6ul*/  + (unsigned long int)(blen > 99 ? 3 : (blen > 9 ? 2 : 1)));
  if(dn + (signed long int)plen >= eom)
    return -1;

  else
  {
    cp = cp + 1l;
    signed int return_value_sprintf_1;
    return_value_sprintf_1=sprintf(dn, "\\[x");
    i = (signed int)(unsigned long int)return_value_sprintf_1;
    if(!(i >= 0))
      return -1;

    else
    {
      dn = dn + (signed long int)i;
      b = blen;
      for( ; b >= 8; cp = cp + 1l)
      {
        signed int return_value_sprintf_2;
        return_value_sprintf_2=sprintf(dn, "%02x", (signed int)*cp & 0xff);
        i = (signed int)(unsigned long int)return_value_sprintf_2;
        if(!(i >= 0))
          return -1;

        dn = dn + (signed long int)i;
        b = b - 8;
      }
      if(b >= 5)
      {
        const char *tmp_post_3 = cp;
        cp = cp + 1l;
        tc = *tmp_post_3;
        signed int return_value_sprintf_4;
        return_value_sprintf_4=sprintf(dn, "%02x", (signed int)tc & 0xff << 8 - b);
        i = (signed int)(unsigned long int)return_value_sprintf_4;
        if(!(i >= 0))
          return -1;

        dn = dn + (signed long int)i;
      }

      else
        if(b >= 1)
        {
          const char *tmp_post_5 = cp;
          cp = cp + 1l;
          tc = *tmp_post_5;
          signed int return_value_sprintf_6;
          return_value_sprintf_6=sprintf(dn, "%1x", (signed int)tc >> 4 & 0x0f & 0x0f << 4 - b);
          i = (signed int)(unsigned long int)return_value_sprintf_6;
          if(!(i >= 0))
            return -1;

          dn = dn + (signed long int)i;
        }

      signed int return_value_sprintf_7;
      return_value_sprintf_7=sprintf(dn, "/%d]", blen);
      i = (signed int)(unsigned long int)return_value_sprintf_7;
      if(!(i >= 0))
        return -1;

      else
      {
        dn = dn + (signed long int)i;
        *cpp = cp;
        return (signed int)(dn - beg);
      }
    }
  }
}

// dn_find
// file __ns_name_uncompress.c line 744
static signed int dn_find(const unsigned char *domain, const unsigned char *msg, const unsigned char * const *dnptrs, const unsigned char * const *lastdnptr)
{
  const unsigned char *dn;
  const unsigned char *cp;
  const unsigned char *sp;
  const unsigned char * const *cpp;
  unsigned int n;
  cpp = dnptrs;
  const unsigned char *tmp_post_1;
  signed int return_value_labellen_2;
  signed int return_value_mklower_5;
  signed int return_value_mklower_7;
  signed int *return_value___errno_location_8;
  for( ; !(cpp >= lastdnptr); cpp = cpp + 1l)
  {
    sp = *cpp;
    for( ; !((signed int)*sp == 0); sp = sp + (signed long int)((signed int)*sp + 1))
    {
      if(!((0xc0 & (signed int)*sp) == 0))
        break;

      if(sp - msg >= 16384l)
        break;

      dn = domain;
      cp = sp;
      do
      {
        tmp_post_1 = cp;
        cp = cp + 1l;
        n = (unsigned int)*tmp_post_1;
        if(n == 0u)
          break;

        switch(n & (unsigned int)0xc0)
        {
          case (unsigned int)0:
          {
            return_value_labellen_2=labellen(cp - (signed long int)1);
            n = (unsigned int)return_value_labellen_2;
            const unsigned char *tmp_post_3 = dn;
            dn = dn + 1l;
            if(!(n == (unsigned int)*tmp_post_3))
              goto next;

            (void)(void *)0;
            for( ; n >= 1u; n = n - 1u)
            {
              const unsigned char *tmp_post_4 = dn;
              dn = dn + 1l;
              return_value_mklower_5=mklower((signed int)*tmp_post_4);
              const unsigned char *tmp_post_6 = cp;
              cp = cp + 1l;
              return_value_mklower_7=mklower((signed int)*tmp_post_6);
              if(!(return_value_mklower_5 == return_value_mklower_7))
                goto next;

            }
            if((signed int)*dn == 0)
            {
              if((signed int)*cp == 0)
                return (signed int)(sp - msg);

            }

            if(!(*dn == 0))
              break;

            goto next;
          }
          case (unsigned int)0xc0:
          {
            cp = msg + (signed long int)((n & (unsigned int)0x3f) << 8 | (unsigned int)*cp);
            break;
          }
          default:
          {
            return_value___errno_location_8=__errno_location();
            *return_value___errno_location_8 = 90;
            return -1;
          }
        }
      }
      while((_Bool)1);

    next:
      ;
    }
  }
  signed int *return_value___errno_location_9;
  return_value___errno_location_9=__errno_location();
  *return_value___errno_location_9 = 2;
  return -1;
}

// encode_bitsring
// file __ns_name_uncompress.c line 851
static signed int encode_bitsring(const char **bp, const char *end, char **labelp, char **dst, const char *eom)
{
  signed int afterslash = 0;
  const char *cp = *bp;
  char *tp;
  char c;
  const char *beg_blen;
  char *end_blen = (char *)(void *)0;
  signed int value = 0;
  signed int count = 0;
  signed int tbcount = 0;
  signed int blen = 0;
  end_blen = (char *)(void *)0;
  beg_blen = end_blen;
  if(!(end - cp >= 2l))
    return 22;

  else
  {
    const char *tmp_post_1 = cp;
    cp = cp + 1l;
    if(!((signed int)*tmp_post_1 == 120))
      return 22;

    else
    {
      const unsigned short int **return_value___ctype_b_loc_2;
      return_value___ctype_b_loc_2=__ctype_b_loc();
      if((4096 & (signed int)(*return_value___ctype_b_loc_2)[(signed long int)(0xff & (signed int)*cp)]) == 0)
        return 22;

      else
      {
        tp = *dst + (signed long int)1;
        for( ; !(cp >= end) && !(tp >= eom); cp = cp + 1l)
        {
          c = *cp;
          switch((signed int)c)
          {
            case 93:
            {
              if(!(afterslash == 0))
              {
                if(beg_blen == ((const char *)NULL))
                  return 22;

                signed long int return_value_strtol_3;
                return_value_strtol_3=strtol(beg_blen, &end_blen, 10);
                blen = (signed int)return_value_strtol_3;
                if(!((signed int)*end_blen == 93))
                  return 22;

              }

              if(!(count == 0))
              {
                char *tmp_post_4 = tp;
                tp = tp + 1l;
                *tmp_post_4 = (char)(value << 4 & 0xff);
              }

              cp = cp + 1l;
              goto done;
            }
            case 47:
            {
              afterslash = 1;
              break;
            }
            default:
              if(!(afterslash == 0))
              {
                const unsigned short int **return_value___ctype_b_loc_5;
                return_value___ctype_b_loc_5=__ctype_b_loc();
                if((2048 & (signed int)(*return_value___ctype_b_loc_5)[(signed long int)(0xff & (signed int)c)]) == 0)
                  return 22;

                if(beg_blen == ((const char *)NULL))
                {
                  if((signed int)c == 48)
                    return 22;

                  beg_blen = cp;
                }

              }

              else
              {
                const unsigned short int **return_value___ctype_b_loc_6;
                return_value___ctype_b_loc_6=__ctype_b_loc();
                if((4096 & (signed int)(*return_value___ctype_b_loc_6)[(signed long int)(0xff & (signed int)c)]) == 0)
                  return 22;

                value = value << 4;
                value = value + (signed int)digitvalue[(signed long int)(signed int)c];
                count = count + 4;
                tbcount = tbcount + 4;
                if(tbcount >= 257)
                  return 22;

                if(count == 8)
                {
                  char *tmp_post_7 = tp;
                  tp = tp + 1l;
                  *tmp_post_7 = (char)value;
                  count = 0;
                }

              }
          }
        }

      done:
        ;
        if(cp >= end || tp >= eom)
          return 90;

        else
        {
          if(blen >= 1)
          {
            signed int traillen;
            if(!((3 + blen & -4) == tbcount))
              return 22;

            traillen = tbcount - blen;
            if(!((0xff & value << 8 + -traillen) == 0))
              return 22;

          }

          else
            blen = tbcount;
          if(blen == 256)
            blen = 0;

          *(*labelp) = (char)0x41;
          *(*dst) = (char)blen;
          *bp = cp;
          *dst = tp;
          return 0;
        }
      }
    }
  }
}

// find_field
// file spfd.c line 730
static char ** find_field(struct _request_t *req, const char *key)
{
  signed int return_value_strcmp_1;
  return_value_strcmp_1=strcmp(key, "ip");
  if(return_value_strcmp_1 == 0)
    return &req->ip;

  else
  {
    signed int return_value_strcmp_2;
    return_value_strcmp_2=strcmp(key, "helo");
    if(return_value_strcmp_2 == 0)
      return &req->helo;

    else
    {
      signed int return_value_strcmp_3;
      return_value_strcmp_3=strcmp(key, "sender");
      if(return_value_strcmp_3 == 0)
        return &req->sender;

      else
      {
        signed int return_value_strcmp_4;
        return_value_strcmp_4=strcmp(key, "rcpt");
        if(return_value_strcmp_4 == 0)
          return &req->rcpt_to;

        else
        {
          fprintf(stderr, "Invalid key %s\n", key);
          return (char **)(void *)0;
        }
      }
    }
  }
}

// handle_datagram
// file spfd.c line 748
static void * handle_datagram(void *arg)
{
  struct _request_t *req;
  char **fp;
  char *key;
  char *value;
  char *end;
  signed int err;
  req = (struct _request_t *)arg;
  key = req->data;
  while(!(key >= req->data + (signed long int)req->datalen))
  {
    unsigned long int return_value_strcspn_1;
    return_value_strcspn_1=strcspn(key, "\r\n");
    end = key + (signed long int)return_value_strcspn_1;
    *end = (char)0;
    value=strchr(key, 61);
    if(!(value == ((char *)NULL)))
    {
      char *tmp_post_2 = value;
      value = value + 1l;
      *tmp_post_2 = (char)0;
      fp=find_field(req, key);
      if(!(fp == ((char **)NULL)))
        *fp = value;

      key = end + (signed long int)1;
      while(!(key >= req->data + (signed long int)req->datalen))
      {
        char *return_value_strchr_3;
        return_value_strchr_3=strchr("\r\n", (signed int)*key);
        if(!(return_value_strchr_3 == ((char *)NULL)))
          key = key + 1l;

        else
          break;
      }
    }

  }
  request_handle(req);
  printf("- %s\n", req->sender);
  fflush(stdout);
  signed long int return_value_sendto_4;
  return_value_sendto_4=sendto(req->sock, (const void *)req->fmt, (unsigned long int)req->fmtlen, 0, (struct sockaddr *)&req->addr.in, req->addrlen);
  err = (signed int)return_value_sendto_4;
  if(err == -1)
    perror("sendto");

  do
  {
    if(!(req->spf_response == ((struct SPF_response_struct *)NULL)))
      SPF_response_free(req->spf_response);

    req->spf_response = (struct SPF_response_struct *)(void *)0;
  }
  while((_Bool)0);
  do
  {
    if(!(req->spf_request == ((struct SPF_request_struct *)NULL)))
      SPF_request_free(req->spf_request);

    req->spf_request = (struct SPF_request_struct *)(void *)0;
  }
  while((_Bool)0);
  do
  {
    if(!(req->data == ((char *)NULL)))
      free((void *)req->data);

    req->data = (char *)(void *)0;
  }
  while((_Bool)0);
  free(arg);
  return (void *)0;
}

// handle_stream
// file spfd.c line 811
static void * handle_stream(void *arg)
{
  struct _request_t *req;
  char **fp;
  struct _IO_FILE *stream;
  char key[8192l];
  char *value;
  char *end;
  req = (struct _request_t *)arg;
  stream=fdopen(req->sock, "r");
  signed int return_value_feof_1;
  do
  {

  __CPROVER_DUMP_L1:
    ;
    char *return_value_fgets_2;
    return_value_fgets_2=fgets(key, 8192, stream);
    if(!(return_value_fgets_2 == ((char *)NULL)))
    {
      unsigned long int return_value_strcspn_3;
      return_value_strcspn_3=strcspn(key, "\r\n");
      key[(signed long int)return_value_strcspn_3] = (char)0;
      if(!((signed int)key[0l] == 0))
      {
        unsigned long int return_value_strcspn_4;
        return_value_strcspn_4=strcspn(key, "\r\n");
        end = key + (signed long int)return_value_strcspn_4;
        *end = (char)0;
        value=strchr(key, 61);
        if(!(value == ((char *)NULL)))
        {
          char *tmp_post_5 = value;
          value = value + 1l;
          *tmp_post_5 = (char)0;
          fp=find_field(req, key);
          if(!(fp == ((char **)NULL)))
            *fp=strdup(value);

        }

        goto __CPROVER_DUMP_L1;
      }

    }

    request_handle(req);
    printf("- %s\n", req->sender);
    fflush(stdout);
    send(req->sock, (const void *)req->fmt, (unsigned long int)req->fmtlen, 0);
    do
    {
      if(!(req->ip == ((char *)NULL)))
        free((void *)req->ip);

      req->ip = (char *)(void *)0;
    }
    while((_Bool)0);
    do
    {
      if(!(req->helo == ((char *)NULL)))
        free((void *)req->helo);

      req->helo = (char *)(void *)0;
    }
    while((_Bool)0);
    do
    {
      if(!(req->sender == ((char *)NULL)))
        free((void *)req->sender);

      req->sender = (char *)(void *)0;
    }
    while((_Bool)0);
    do
    {
      if(!(req->rcpt_to == ((char *)NULL)))
        free((void *)req->rcpt_to);

      req->rcpt_to = (char *)(void *)0;
    }
    while((_Bool)0);
    return_value_feof_1=feof(stream);
  }
  while(return_value_feof_1 == 0);
  free(arg);
  return (void *)0;
}

// labellen
// file __ns_name_uncompress.c line 956
static signed int labellen(const unsigned char *lp)
{
  signed int bitlen;
  unsigned char l = *lp;
  if((0xc0 & (signed int)l) == 0xc0)
    return -1;

  else
    if((0xc0 & (signed int)l) == 0x40)
    {
      if((signed int)l == 0x41)
      {
        bitlen = (signed int)lp[(signed long int)1];
        if(bitlen == 0)
          bitlen = 256;

        return (bitlen + 7) / 8 + 1;
      }

      return -1;
    }

    else
      return (signed int)l;
}

// main
// file spfd.c line 957
signed int main(signed int argc, char **argv)
{
  daemon_config(argc, argv);
  daemon_init();
  daemon_main();
  return 0;
}

// mklower
// file __ns_name_uncompress.c line 728
static signed int mklower(signed int ch)
{
  if(ch >= 0x41 && !(ch >= 91))
    return ch + 0x20;

  else
    return ch;
}

// printable
// file __ns_name_uncompress.c line 719
static signed int printable(signed int ch)
{
  return (signed int)(ch > 0x20 && ch < 0x7f);
}

// request_check
// file spfd.c line 249
static const char * request_check(struct _request_t *req)
{
  const char *msg = (const char *)(void *)0;
  if(req->ip == ((char *)NULL))
    msg = "No IP address given";

  else
    if(req->sender == ((char *)NULL))
      msg = "No sender address given";

    else
      return (const char *)(void *)0;
  snprintf(req->fmt, (unsigned long int)4095, "result=unknown\nreason=%s\n", msg);
  return msg;
}

// request_format
// file spfd.c line 372
static void request_format(struct _request_t *req)
{
  struct SPF_response_struct *spf_response = req->spf_response;
  if(!(spf_response == ((struct SPF_response_struct *)NULL)))
  {
    enum SPF_result_enum return_value_SPF_response_result_1;
    return_value_SPF_response_result_1=SPF_response_result(spf_response);
    const char *return_value_SPF_strresult_2;
    return_value_SPF_strresult_2=SPF_strresult(return_value_SPF_response_result_1);
    const char *return_value_W_3;
    return_value_W_3=W(return_value_SPF_strresult_2);
    enum SPF_reason_enum return_value_SPF_response_reason_4;
    return_value_SPF_response_reason_4=SPF_response_reason(spf_response);
    const char *return_value_SPF_strreason_5;
    return_value_SPF_strreason_5=SPF_strreason(return_value_SPF_response_reason_4);
    const char *return_value_W_6;
    return_value_W_6=W(return_value_SPF_strreason_5);
    const char *return_value_SPF_response_get_smtp_comment_7;
    return_value_SPF_response_get_smtp_comment_7=SPF_response_get_smtp_comment(spf_response);
    const char *return_value_W_8;
    return_value_W_8=W(return_value_SPF_response_get_smtp_comment_7);
    const char *return_value_SPF_response_get_header_comment_9;
    return_value_SPF_response_get_header_comment_9=SPF_response_get_header_comment(spf_response);
    const char *return_value_W_10;
    return_value_W_10=W(return_value_SPF_response_get_header_comment_9);
    enum SPF_errcode_t return_value_SPF_response_errcode_11;
    return_value_SPF_response_errcode_11=SPF_response_errcode(spf_response);
    const char *return_value_SPF_strerror_12;
    return_value_SPF_strerror_12=SPF_strerror(return_value_SPF_response_errcode_11);
    const char *return_value_W_13;
    return_value_W_13=W(return_value_SPF_strerror_12);
    req->fmtlen=snprintf(req->fmt, (unsigned long int)4095, "ip=%s\nsender=%s\nresult=%s\nreason=%s\nsmtp_comment=%s\nheader_comment=%s\nerror=%s\n", req->ip, req->sender, return_value_W_3, return_value_W_6, return_value_W_8, return_value_W_10, return_value_W_13);
  }

  else
  {
    const char *return_value_SPF_strerror_14;
    return_value_SPF_strerror_14=SPF_strerror(req->spf_err);
    req->fmtlen=snprintf(req->fmt, (unsigned long int)4095, "ip=%s\nsender=%s\nresult=unknown\nerror=%s\n", req->ip, req->sender, return_value_SPF_strerror_14);
  }
  req->fmt[(signed long int)4095] = (char)0;
}

// request_handle
// file spfd.c line 410
static void request_handle(struct _request_t *req)
{
  printf("| %s\n", req->sender);
  fflush(stdout);
  const char *return_value_request_check_1;
  return_value_request_check_1=request_check(req);
  if(return_value_request_check_1 == ((const char *)NULL))
  {
    request_query(req);
    request_format(req);
  }

}

// request_query
// file spfd.c line 266
static void request_query(struct _request_t *req)
{
  struct SPF_request_struct *spf_request = (struct SPF_request_struct *)(void *)0;
  struct SPF_response_struct *spf_response = (struct SPF_response_struct *)(void *)0;
  struct SPF_response_struct *spf_response_2mx = (struct SPF_response_struct *)(void *)0;
  enum SPF_errcode_t err;
  char *p;
  char *p_end;
  spf_request=SPF_request_new(spf_server);
  char *return_value_strchr_1;
  return_value_strchr_1=strchr(req->ip, 58);
  if(!(return_value_strchr_1 == ((char *)NULL)))
  {
    err=SPF_request_set_ipv6_str(spf_request, req->ip);
    if(!(err == /*enum*/SPF_E_SUCCESS))
      goto fail;

  }

  else
  {
    err=SPF_request_set_ipv4_str(spf_request, req->ip);
    if(!(err == /*enum*/SPF_E_SUCCESS))
      goto fail;

  }
  if(!(req->helo == ((char *)NULL)))
  {
    err=SPF_request_set_helo_dom(spf_request, req->helo);
    if(!(err == /*enum*/SPF_E_SUCCESS))
      goto fail;

  }

  if(!(req->sender == ((char *)NULL)))
  {
    signed int return_value_SPF_request_set_env_from_2;
    return_value_SPF_request_set_env_from_2=SPF_request_set_env_from(spf_request, req->sender);
    err = (enum SPF_errcode_t)return_value_SPF_request_set_env_from_2;
    if(!(err == /*enum*/SPF_E_SUCCESS))
      goto fail;

  }

  err=SPF_request_query_mailfrom(spf_request, &spf_response);
  if(!(err == /*enum*/SPF_E_SUCCESS))
    goto fail;

  enum SPF_result_enum return_value_SPF_response_result_4;
  if(!(spfd_config.sec_mx == 0))
  {
    if(!(req->rcpt_to == ((char *)NULL)))
    {
      if(!(*req->rcpt_to == 0))
      {
        p = req->rcpt_to;
        unsigned long int return_value_strcspn_3;
        return_value_strcspn_3=strcspn(p, " ,;");
        p_end = p + (signed long int)return_value_strcspn_3;
        do
        {
          return_value_SPF_response_result_4=SPF_response_result(spf_response);
          if((signed int)return_value_SPF_response_result_4 == SPF_RESULT_PASS)
            break;

          if(!(*p_end == 0))
            *p_end = (char)0;

          else
            p_end = (char *)(void *)0;
          err=SPF_request_query_rcptto(spf_request, &spf_response_2mx, p);
          if(!(err == /*enum*/SPF_E_SUCCESS))
          {
            response_print_errors("Failed to query based on 2mx recipient", spf_response_2mx, err);
            do
            {
              if(!(spf_response_2mx == ((struct SPF_response_struct *)NULL)))
                SPF_response_free(spf_response_2mx);

              spf_response_2mx = (struct SPF_response_struct *)(void *)0;
            }
            while((_Bool)0);
          }

          else
          {
            spf_response=SPF_response_combine(spf_response, spf_response_2mx);
            spf_response_2mx = (struct SPF_response_struct *)(void *)0;
          }
          if(p_end == ((char *)NULL))
            break;

          p = p_end + (signed long int)1;
        }
        while((_Bool)1);
      }

    }

  }

  if(!(spfd_config.fallback == ((char *)NULL)))
  {
    err=SPF_request_query_fallback(spf_request, &spf_response, spfd_config.fallback);
    if(!(err == /*enum*/SPF_E_SUCCESS))
      goto fail;

  }

  goto ok;

fail:
  ;
  req->spf_err = err;
  do
  {
    if(!(spf_response == ((struct SPF_response_struct *)NULL)))
      SPF_response_free(spf_response);

    spf_response = (struct SPF_response_struct *)(void *)0;
  }
  while((_Bool)0);
  do
  {
    if(!(spf_request == ((struct SPF_request_struct *)NULL)))
      SPF_request_free(spf_request);

    spf_request = (struct SPF_request_struct *)(void *)0;
  }
  while((_Bool)0);

ok:
  ;
  (void)response_print;
  req->spf_response = spf_response;
  req->spf_request = spf_request;
}

// response_print
// file spfd.c line 228
static void response_print(const char *context, struct SPF_response_struct *spf_response)
{
  printf("--vv--\n");
  printf("Context: %s\n", context);
  if(spf_response == ((struct SPF_response_struct *)NULL))
    printf("NULL RESPONSE!\n");

  else
  {
    enum SPF_result_enum return_value_SPF_response_result_1;
    return_value_SPF_response_result_1=SPF_response_result(spf_response);
    const char *return_value_SPF_strresult_2;
    return_value_SPF_strresult_2=SPF_strresult(return_value_SPF_response_result_1);
    printf("Response result: %s\n", return_value_SPF_strresult_2);
    enum SPF_reason_enum return_value_SPF_response_reason_3;
    return_value_SPF_response_reason_3=SPF_response_reason(spf_response);
    const char *return_value_SPF_strreason_4;
    return_value_SPF_strreason_4=SPF_strreason(return_value_SPF_response_reason_3);
    printf("Response reason: %s\n", return_value_SPF_strreason_4);
    enum SPF_errcode_t return_value_SPF_response_errcode_5;
    return_value_SPF_response_errcode_5=SPF_response_errcode(spf_response);
    const char *return_value_SPF_strerror_6;
    return_value_SPF_strerror_6=SPF_strerror(return_value_SPF_response_errcode_5);
    printf("Response err: %s\n", return_value_SPF_strerror_6);
    enum SPF_errcode_t return_value_SPF_response_errcode_7;
    return_value_SPF_response_errcode_7=SPF_response_errcode(spf_response);
    response_print_errors((const char *)(void *)0, spf_response, return_value_SPF_response_errcode_7);
  }
  printf("--^^--\n");
}

// response_print_errors
// file spfd.c line 200
static void response_print_errors(const char *context, struct SPF_response_struct *spf_response, enum SPF_errcode_t err)
{
  struct SPF_error_struct *spf_error;
  signed int i;
  if(!(context == ((const char *)NULL)))
    printf("Context: %s\n", context);

  const char *return_value_SPF_strerror_1;
  if(!((signed int)err == SPF_E_SUCCESS))
  {
    return_value_SPF_strerror_1=SPF_strerror(err);
    printf("ErrorCode: (%d) %s\n", err, return_value_SPF_strerror_1);
  }

  signed int return_value_SPF_response_messages_2;
  if(!(spf_response == ((struct SPF_response_struct *)NULL)))
  {
    i = 0;
    do
    {
      return_value_SPF_response_messages_2=SPF_response_messages(spf_response);
      if(i >= return_value_SPF_response_messages_2)
        break;

      spf_error=SPF_response_message(spf_response, i);
      char return_value_SPF_error_errorp_3;
      return_value_SPF_error_errorp_3=SPF_error_errorp(spf_error);
      char return_value_SPF_error_errorp_4;
      return_value_SPF_error_errorp_4=SPF_error_errorp(spf_error);
      const char *return_value_SPF_error_message_5;
      return_value_SPF_error_message_5=SPF_error_message(spf_error);
      printf("%s: %s%s\n", return_value_SPF_error_errorp_3 != 0 ? "Error" : "Warning", (return_value_SPF_error_errorp_4 != 0 ? (!(err != (enum SPF_errcode_t)0) ? (_Bool)1 : (_Bool)0) : (_Bool)0) ? "[UNRETURNED] " : "", return_value_SPF_error_message_5);
      i = i + 1;
    }
    while((_Bool)1);
  }

  else
    printf("Error: libspf2 gave a NULL spf_response");
}

// setsection
// file __ns_initparse.c line 198
static void setsection(struct __ns_msg *msg, enum __ns_sect sect)
{
  msg->_sect = sect;
  if((signed int)sect == ns_s_max)
  {
    msg->_rrnum = -1;
    msg->_msg_ptr = (const unsigned char *)(void *)0;
  }

  else
  {
    msg->_rrnum = 0;
    msg->_msg_ptr = msg->_sections[(signed long int)(signed int)sect];
  }
}

// special
// file __ns_name_uncompress.c line 694
static signed int special(signed int ch)
{
  if(ch == 0x22 || ch == 0x24 || ch == 0x28 || ch == 0x29 || ch == 0x2E || ch == 0x3B || ch == 0x40 || ch == 0x5C)
    return 1;

  return 0;
}

// usage
// file spfd.c line 443
void usage(void)
{
  fprintf(stdout, "Flags\n");
  fprintf(stdout, "\t-tcpport\n");
  fprintf(stdout, "\t-udpport\n");
  fprintf(stdout, "\t-path\n");
  fprintf(stdout, "\t-pathuser\n");
  fprintf(stdout, "\t-pathgroup\n");
  fprintf(stdout, "\t-pathmode\n");
  fprintf(stdout, "\t-setuser\n");
  fprintf(stdout, "\t-setgroup\n");
  fprintf(stdout, "\t-help\n");
}

